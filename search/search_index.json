{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p><code>requests_oauth2client</code> is an OAuth 2.x client for Python, able to obtain, refresh and revoke tokens from any OAuth2.x/OIDC compliant Authorization Server. It sits upon and extends the famous requests HTTP client module.</p> <p>It can act as an OAuth 2.0 / 2.1 client, to automatically get and renew Access Tokens, based on the Client Credentials, Authorization Code, Refresh token, Token Exchange, JWT Bearer, Device Authorization, Resource Owner Password or CIBA grants. Additional grant types are easy to add if needed.</p> <p>It also supports OpenID Connect 1.0, PKCE, Client Assertions, Token Revocation and Introspection, Resource Indicators, JWT-secured Authorization Requests, Pushed Authorization Requests, Authorization Server Issuer Identification, Demonstrating Proof of Possession, as well as using custom params to any endpoint, and other important features that are often overlooked or needlessly complex in other client libraries.</p> <p>And it also includes a wrapper around requests.Session that makes it super easy to use REST-style APIs, with or without OAuth 2.x.</p> <p>Please note that despite the name, this library has no relationship with Google oauth2client library.</p> <p> </p>"},{"location":"#documentation","title":"Documentation","text":"<p>Full module documentation is available at https://guillp.github.io/requests_oauth2client/.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>requests_oauth2client</code> is available from PyPi, so installing it is as easy as:</p> <pre><code>pip install requests_oauth2client\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Everything from <code>requests_oauth2client</code> is available from the root module, so you can import it like this:</p> <pre><code>from requests_oauth2client import *\n</code></pre> <p>Or you can import individual objects from this package as usual. Note that importing <code>*</code> automatically imports <code>requests</code>, so no need to import it yourself.</p>"},{"location":"#calling-apis-with-access-tokens","title":"Calling APIs with Access Tokens","text":"<p>If you have already obtained an access token for the API you want to call, you can convert it to an instance of BearerToken. Instances of this class work as a <code>requests</code> compatible auth handler.</p> <pre><code>import requests\nfrom requests_oauth2client import BearerToken\n\ntoken = BearerToken(\"my_access_token\")\nresp = requests.get(\"https://my.protected.api/endpoint\", auth=token)\n</code></pre> <p>This authentication handler will add a <code>Authorization: Bearer &lt;my_access_token&gt;</code> header in the request, with your access token value, properly formatted according to RFC6750.</p>"},{"location":"#using-an-oauth2client","title":"Using an OAuth2Client","text":"<p>OAuth2Client offers several methods that implement the communication to the various endpoints that are standardised by OAuth 2.0 and its extensions. These endpoints include the Token Endpoint, Revocation, Introspection, UserInfo, BackChannel Authentication and Device Authorization Endpoints.</p> <p>You must provide the URLs for these endpoints if you intend to use them. Otherwise, only the Token Endpoint is mandatory to initialize an <code>OAuth2Client</code>.</p> <p>To initialize an instance of <code>OAuth2Client</code>, you only need the Token Endpoint URI from your Authorization Server (AS), and the credentials for your application, typically a <code>client_id</code> and a <code>client_secret</code>, usually also provided by the AS:</p> <pre><code>from requests_oauth2client import OAuth2Client\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    client_id=\"my_client_id\",\n    client_secret=\"my_client_secret\",\n)\n</code></pre> <p>The Token Endpoint is the only endpoint that is mandatory to obtain tokens. Credentials are used to authenticate the client everytime it sends a request to its Authorization Server. Usually, these are a static Client ID and Secret, which are the equivalent of a username and a password, but meant for an application instead of for a human user. The default authentication method used by <code>OAuth2Client</code> is Client Secret Post, but other standardized methods such as Client Secret Basic, Client Secret JWT or Private Key JWT are supported as well. See more about client authentication methods below.</p> <p>Instead of providing each endpoint URL yourself, you may also use the AS metadata endpoint URI, or the document data itself, to initialize your OAuth 2.0 client with the appropriate endpoints.</p>"},{"location":"#obtaining-tokens","title":"Obtaining tokens","text":"<p>OAuth2Client has dedicated methods to send requests to the Token Endpoint using different standardized grants. Since the Token Endpoint URL and Client Authentication Method are already declared for the client at initialization, the only required parameters for these methods are those that will be sent in the request to the Token Endpoint.</p> <p>These methods directly return a BearerToken if the request is successful, or raise an exception if it fails. BearerToken contains all the data returned by the Token Endpoint, including the Access Token. It will also:</p> <ul> <li>Keep track of the Access Token expiration date (based on the <code>expires_in</code> hint as returned by the AS). This date is   accessible with the <code>expires_at</code> attribute.</li> <li>Contain the Refresh Token, if returned by the AS, accessible with the <code>refresh_token</code> attribute.</li> <li>Contain the ID Token, if returned by the AS, accessible with the <code>id_token</code> attribute (typically available when using   the Authorization Code flow).</li> <li>Keep track of other associated metadata as well, also accessible as attributes with the same name:   <code>token.custom_attr</code>, or with subscription syntax <code>token[\"my.custom.attr\"]</code>.</li> </ul> <p>You can create such a BearerToken yourself if needed:</p> <pre><code>from requests_oauth2client import BearerToken\n\nbearer_token = BearerToken(access_token=\"an_access_token\", expires_in=60)\nprint(bearer_token)\n# {'access_token': 'an_access_token',\n#  'expires_in': 55,\n#  'token_type': 'Bearer'}\nprint(bearer_token.expires_at)\n# datetime.datetime(2021, 8, 20, 9, 56, 59, 498793)\nassert not bearer_token.is_expired()\n\nprint(bearer_token.expires_in)\n# 40\n</code></pre> <p>Note that the <code>expires_in</code> indicator here is not static. It keeps track of the token lifetime, in seconds, and is calculated as the time flies. The actual static expiration date is accessible with the <code>expires_at</code> property. You can check if a token is expired with bearer_token.is_expired().</p> <p>You can use a BearerToken instance anywhere you can use an access_token as string.</p>"},{"location":"#using-oauth2client-as-a-requests-auth-handler","title":"Using OAuth2Client as a requests Auth Handler","text":"<p>Using OAuth2Client directly is useful for testing or debugging OAuth2.x flows, but it may not be suitable for actual applications where tokens must be obtained, used during their lifetime, then obtained again or refreshed once they are expired. <code>requests_oauth2client</code> contains several requests compatible Auth Handlers (as subclasses of requests.auth.AuthBase), that will take care of obtaining tokens when required, then will cache those tokens until they are expired, and will obtain new ones (or refresh them, when possible), once the initial token is expired. Those are best used with a requests.Session, or an ApiClient, which is a wrapper around <code>Session</code> with a few enhancements as described below.</p>"},{"location":"#client-credentials-grant","title":"Client Credentials grant","text":"<p>To send a request using the Client Credentials grant, use the .client_credentials() method, providing the necessary parameters as keyword arguments in the token request.</p> <pre><code>from requests_oauth2client import OAuth2Client\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\ntoken = oauth2client.client_credentials(scope=\"myscope\")\n# or, if your AS uses resource indicator:\ntoken = oauth2client.client_credentials(scope=\"myscope\", resource=\"https://myapi.local\")\n# or, if your AS uses 'audience' as parameter to identify the requested API (Auth0 style):\ntoken = oauth2client.client_credentials(audience=\"https://myapi.local\")\n# or, if your AS uses custom parameters:\ntoken = oauth2client.client_credentials(scope=\"myscope\", custom_param=\"custom_value\")\n</code></pre> <p>Parameters such as <code>scope</code>, <code>resource</code>, or <code>audience</code>, as well as any other required parameters by the Authorization Server (AS), can be passed as keyword parameters. These parameters will be included in the token request sent to the AS. Please note that none of those parameters are mandatory at the client level, but some might be required by your AS to fulfill your request.</p>"},{"location":"#as-auth-handler","title":"As Auth Handler","text":"<p>You can use the OAuth2ClientCredentialsAuth auth handler. It takes an <code>OAuth2Client</code> as parameter, and the additional kwargs to pass to the token endpoint:</p> <pre><code>import requests\nfrom requests_oauth2client import OAuth2Client, OAuth2ClientCredentialsAuth\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\nauth = OAuth2ClientCredentialsAuth(\n    oauth2client, scope=\"myscope\", resource=\"https://myapi.local\"\n)\n\n# use it like this:\nrequests.get(\"https://myapi.local/resource\", auth=auth)\n\n# or like this:\nsession = requests.Session()\nsession.auth = auth\n\nresp = session.get(\"https://myapi.local/resource\")\n</code></pre> <p>Once again, extra parameters such as <code>scope</code>, <code>resource</code> or <code>audience</code> are allowed if required.</p> <p>When you send your first request, OAuth2ClientCredentialsAuth will automatically retrieve an access token from the AS using the Client Credentials grant, then will include it in the request. Next requests will use the same token, as long as it is valid. A new token will be automatically retrieved once the previous one is expired.</p> <p>You can configure a leeway, which is a period of time before the actual expiration, in seconds, when a new token will be obtained. This may help getting continuous access to the API when the client and API clocks are slightly out of sync. Use the parameter <code>leeway</code> to <code>OAuth2ClientCredentialsAuth</code>:</p> <pre><code>from requests_oauth2client import OAuth2ClientCredentialsAuth\n\nauth = OAuth2ClientCredentialsAuth(\n    oauth2client,\n    scope=\"myscope\",\n    leeway=30,\n)\n</code></pre>"},{"location":"#authorization-code-grant","title":"Authorization Code Grant","text":"<p>Obtaining tokens using the Authorization code grant is made in 3 steps:</p> <ol> <li>your application must open a specific url called the Authentication Request in a browser.</li> <li>your application must obtain and validate the Authorization Response, which is a redirection back to your    application that contains an Authorization Code as parameter. This redirect back (often called \"callback\") is    initiated by the Authorization Server after any necessary interaction with the user is complete (Registration, Login,    Profile completion, Multi-Factor Authentication, Authorization, Consent, etc.)</li> <li>your application must then exchange this Authorization Code for an Access Token, with a request to the Token    Endpoint.</li> </ol> <p>Using an <code>OAuth2Client</code> will help you with all those steps, as described below.</p>"},{"location":"#generating-authorization-requests","title":"Generating Authorization Requests","text":"<p>To be able to use the Authorization Code grant, you need 2 (optionally 3) URIs:</p> <ul> <li>the URL for Authorization Endpoint, which is the url where you must send your Authorization Requests</li> <li>the Redirect URI, which is the url pointing to your application, where the Authorization Server will reply with   Authorization Response</li> <li>optionally, the issuer identifier, if your AS uses   Issuer Identification.</li> </ul> <p>You can declare those URIs when initializing your <code>OAuth2Client</code> instance, or you can use the AS discovery endpoint to initialize those URLs automatically. Then you can generate valid Authorization Requests by calling the method <code>.authorization_request()</code>, with the request specific parameters, such as <code>scope</code>, <code>state</code>, <code>nonce</code> as parameter:</p> <pre><code>from requests_oauth2client import OAuth2Client\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endoint\",\n    authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n    redirect_uri=\"https://url.to.my.application/redirect_uri\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\naz_request = client.authorization_request(scope=\"openid email profile\")\n\nprint(az_request)\n# this will look like this, with line feeds for display purposes only:\n# https://url.to.the.as/authorization_endpoint\n# ?client_id=client_id\n# &amp;redirect_uri=https%3A%2F%2Furl.to.my.application%2Fredirect_uri\n# &amp;response_type=code\n# &amp;scope=openid+email+profile\n# &amp;state=FBx9mWeLwoKGgG76vhi6v61-4mgxmgZhtWIa7aTffdY\n# &amp;nonce=iHZJokhkGOAojff1tdknRyz9mPZyy5vq9JDlVaUHyqk\n# &amp;code_challenge=TG7qgdyKnwUPuoQ6NNJRlLMoHbeVmJlB8g0VOcfQEkc\n# &amp;code_challenge_method=S256\n\n# you can send the user to that url with:\nimport webbrowser\n\nwebbrowser.open(az_request.uri)\n</code></pre> <p>Note that the <code>state</code>, <code>nonce</code> and <code>code_challenge</code> parameters are generated with secure random values by default. Should you wish to use your own values, you can pass them as parameters to <code>OAuth2Client.authorization_request()</code>. For PKCE, you need to pass your generated <code>code_verifier</code>, and the <code>code_challenge</code> will automatically be derived from it. If you want to disable PKCE, you can pass <code>code_challenge_method=None</code> when initializing your <code>OAuth2Client</code>.</p>"},{"location":"#validating-the-authorization-response","title":"Validating the Authorization Response","text":"<p>Once you have redirected the user browser to the Authorization Request URI, and after the user is successfully authenticated and authorized, plus any other extra interactive step is complete, the AS will respond with a redirection to your redirect_uri. That is the Authorization Response. It contains several parameters that must be retrieved by your client. The Authorization Code is one of those parameters, but you must also validate that the state matches your request; if using AS Issuer Identification, you must also validate that the issuer matches what is expected. You can do this with:</p> <pre><code># using the `az_request` as defined above\n\nresponse_uri = input(\n    \"Please enter the full url and/or params obtained on the redirect_uri: \"\n)\n# say the callback url is https://url.to.my.application/redirect_uri?code=an_az_code&amp;state=FBx9mWeLwoKGgG76vhi6v61-4mgxmgZhtWIa7aTffdY&amp;issuer=https://url.to.the.as\naz_response = az_request.validate_callback(response_uri)\n</code></pre> <p>This <code>auth_response</code> is an <code>AuthorizationResponse</code> instance and contains everything that is needed for your application to complete the authentication and get its tokens from the AS.</p>"},{"location":"#exchanging-code-for-tokens","title":"Exchanging code for tokens","text":"<p>Once you have obtained the AS response, containing an authorization code, your application must exchange it for actual Token(s).</p> <p>To exchange a code for Access and/or ID tokens, use the OAuth2Client.authorization_code() method. If you have obtained an AuthorizationResponse as described above, you can simply do:</p> <pre><code>token = oauth2client.authorization_code(az_response)\n</code></pre> <p>This will automatically include the <code>code</code>, <code>redirect_uri</code> and <code>code_verifier</code> parameters in the Token Request, as expected by the AS. You may include extra parameters if required, or you may pass your own parameters, without using an <code>AuthorizationResponse</code> instance, like this:</p> <pre><code>token = oauth2client.authorization_code(\n    code=code,\n    code_verifier=code_verifier,\n    redirect_uri=redirect_uri,\n    custom_param=custom_value,\n)\n</code></pre>"},{"location":"#as-auth-handler_1","title":"As Auth Handler","text":"<p>The OAuth2AuthorizationCodeAuth handler takes an OAuth2Client and an authorization code as parameter, plus whatever additional keyword parameters are required by your Authorization Server:</p> <pre><code>from requests_oauth2client import OAuth2Client, ApiClient, OAuth2AuthorizationCodeAuth\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\napi_client = ApiClient(\n    \"https://your.protected.api/endpoint\",\n    auth=OAuth2AuthorizationCodeAuth(\n        oauth2client,\n        \"my_authorization_code\",\n    ),\n)\n\n# any request using api_client will trigger exchanging the code for an access_token, which is then cached, and refreshed later if needed\nresp = api_client.post(data={...})\n</code></pre> <p>OAuth2AuthorizationCodeAuth will take care of refreshing the token automatically once it is expired, using the refresh token, if available.</p>"},{"location":"#note-on-authorizationrequest","title":"Note on AuthorizationRequest","text":"<p>Authorization Requests generated by <code>OAuth2Client.authorization_request()</code> are instance of the class <code>AuthorizationRequest</code>. You can also use that class directly to generate your requests, but in that case you need to supply your Authorization Endpoint URI, your <code>client_id</code>, <code>redirect_uri</code>, etc. You can access every parameter from an <code>AuthorizationRequest</code> instance, as well as the generated <code>code_verifier</code>, as attributes of this instance. Once an Authorization Request URL is generated, it your application responsibility to redirect or otherwise send the user to that URL. You may use the <code>webbrowser</code> module from Python standard library to do so. Here is an example for generating Authorization Requests:</p> <pre><code>from requests_oauth2client import AuthorizationRequest\n\naz_request = AuthorizationRequest(\n    \"https://url.to.the/authorization_endpoint\",\n    client_id=\"my_client_id\",\n    redirect_uri=\"http://localhost/callback\",  # this redirect_uri is specific to your app\n    scope=\"openid email profile\",\n    # extra parameters such as `resource` can be included as well if required by your AS\n    resource=\"https://my.resource.local/api\",\n)\nprint(\n    az_request\n)  # this request will look like this, with line breaks for display purposes only\n# https://url.to.the/authorization_endpoint\n# ?client_id=my_client_id\n# &amp;redirect_uri=http%3A%2F%2Flocalhost%callback\n# &amp;response_type=code\n# &amp;state=kHWL4VwcbUbtPR4mtht6yMAGG_S-ZcBh5RxI_IGDmJc\n# &amp;nonce=mSGOS1M3LYU9ncTvvutoqUR4n1EtmaC_sQ3db4dyMAc\n# &amp;scope=openid+email+profile\n# &amp;code_challenge=W3n02f6xUKoDVbmhWEWz3h780b-Ci6ucnBS_d7nogmQ\n# &amp;code_challenge_method=S256\n# &amp;resource=https%3A%2F%2Fmy.resource.local%2Fapi\n\nprint(az_request.code_verifier)\n# 'gYK-ZnQfoat2bghwed7oEz--wvn4D70ksJ5GuWO9sXXygZ7PMnUlSpBmMCcNRHxdgTS9m_roYwGxF6HQxIqZVwXmxRJUziFHUFxDrNuUIjCJCx6gBhPlpFbUXulB1fo2'\n</code></pre>"},{"location":"#device-authorization-grant","title":"Device Authorization Grant","text":"<p>Helpers for the Device Authorization Grant are also included. To get device and user codes, read the response attributes (including Device Code, User Code, Verification URI, etc.), then pooling the Token Endpoint:</p> <pre><code>from requests_oauth2client import (\n    OAuth2Client,\n    DeviceAuthorizationPoolingJob,\n    BearerToken,\n)\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    device_authorization_endpoint=\"https://url.to.the/device_authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\nda_resp = client.authorize_device()\n\n# `da_resp` contains the Device Code, User Code, Verification URI, and other info returned by the AS:\nda_resp.device_code\nda_resp.user_code\nda_resp.verification_uri\nda_resp.verification_uri_complete\nda_resp.expires_at\nda_resp.interval\n\n# Send/show the Verification Uri and User Code to the user. They must use a browser to visit that URL, authenticate, and input the User Code.\n\n# You can then request the Token endpoint to check if the user successfully authorized your device like this:\npool_job = DeviceAuthorizationPoolingJob(client, da_resp)\n\nresp = None\nwhile resp is None:\n    resp = pool_job()\n\nassert isinstance(resp, BearerToken)\n</code></pre> <p>DeviceAuthorizationPoolingJob will automatically obey the pooling period. Everytime you call <code>pool_job()</code>, it will wait the appropriate number of seconds as indicated by the AS, and will apply slow-down requests.</p>"},{"location":"#as-auth-handler_2","title":"As Auth Handler","text":"<p>Use OAuth2DeviceCodeAuth as auth handler to exchange a device code for an access token:</p> <pre><code>from requests_oauth2client import ApiClient, OAuth2DeviceCodeAuth, OAuth2Client\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    device_authorization_endpoint=\"https://url.to.the/device_authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\ndevice_auth_resp = client.authorize_device()\n\n# expose user_code and verification_uri or verification_uri_complete to the user\ndevice_auth_resp.user_code\ndevice_auth_resp.verification_uri\ndevice_auth_resp.verification_uri_complete\n\n# then try to send your request with an OAuth2DeviceCodeAuth handler\n# this will pool the token endpoint until the user authorizes the device\napi_client = ApiClient(\n    \"https://your.protected.api/endpoint\",\n    auth=OAuth2DeviceCodeAuth(client, device_auth_resp),\n)\n\nresp = api_client.post(\n    data={...}\n)  # the first call will hang until the user authorizes your app and the token endpoint returns a token.\n</code></pre>"},{"location":"#client-initiated-backchannel-authentication-ciba","title":"Client-Initiated BackChannel Authentication (CIBA)","text":"<p>To initiate a BackChannel Authentication against the dedicated endpoint, read the response attributes and pool the Token Endpoint until the end-user successfully authenticates:</p> <pre><code>from requests_oauth2client import (\n    OAuth2Client,\n    BearerToken,\n    BackChannelAuthenticationPoolingJob,\n)\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    backchannel_authentication_endpoint=\"https://url.to.the/backchannel_authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\nba_resp = client.backchannel_authentication_request(\n    scope=\"openid email profile\",\n    login_hint=\"user@example.net\",\n)\n\n# `ba_resp` will contain the response attributes as returned by the AS, including an `auth_req_id`:\nba_resp.auth_req_id\nba_resp.expires_in  # decreases with time\nba_resp.expires_at  # a static `datetime` to keep track of the expiration date, based on the \"expires_in\" returned by the AS\nba_resp.interval  # the pooling interval indicated by the AS\nba_resp.custom  # if the AS respond with additional attributes, they are also accessible\n\npool_job = BackChannelAuthenticationPoolingJob(client, ba_resp)\n\nresp = None\nwhile resp is None:\n    resp = pool_job()\n\nassert isinstance(resp, BearerToken)\n</code></pre> <p>Hints by the AS to slow down pooling will automatically be obeyed.</p>"},{"location":"#token-exchange","title":"Token Exchange","text":"<p>To send a token exchange request, use the OAuth2Client.token_exchange() method:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\ntoken = client.token_exchange(\n    subject_token=\"your_token_value\",\n    subject_token_type=\"urn:ietf:params:oauth:token-type:access_token\",\n)\n</code></pre> <p>As with the other grant-type specific methods, you may specify additional keyword parameters, that will be passed to the token endpoint, including any standardised attribute like <code>actor_token</code> or <code>actor_token_type</code>, or any custom parameter. There are short names for token types, that will be automatically translated to standardised types:</p> <pre><code>token = client.token_exchange(\n    subject_token=\"your_token_value\",\n    subject_token_type=\"access_token\",  # will be automatically replaced by \"urn:ietf:params:oauth:token-type:access_token\"\n    actor_token=\"your_actor_token\",\n    actor_token_type=\"id_token\",  # will be automatically replaced by \"urn:ietf:params:oauth:token-type:id_token\"\n)\n</code></pre> <p>Or to make it even easier, types can be guessed based on the supplied subject or actor token:</p> <pre><code>from requests_oauth2client import BearerToken, ClientSecretJwt, IdToken, OAuth2Client\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\ntoken = client.token_exchange(\n    subject_token=BearerToken(\n        \"your_token_value\"\n    ),  # subject_token_type will be \"urn:ietf:params:oauth:token-type:access_token\"\n    actor_token=IdToken(\n        \"your_actor_token\"\n    ),  # actor_token_type will be \"urn:ietf:params:oauth:token-type:id_token\"\n)\n</code></pre>"},{"location":"#supported-client-authentication-methods","title":"Supported Client Authentication Methods","text":"<p><code>requests_oauth2client</code> supports several client authentication methods, as defined in multiple OAuth2.x standards. You select the appropriate method to use when initializing your OAuth2Client, with the <code>auth</code> parameter. Once initialized, a client will automatically use the configured authentication method every time it sends a requested to an endpoint that requires client authentication. You don't have anything else to do afterwards.</p>"},{"location":"#client-secret-basic","title":"Client Secret Basic","text":"<p>With client_secret_basic, <code>client_id</code> and <code>client_secret</code> are included in clear-text in the <code>Authorization</code> header when sending requests to the Token Endpoint. To use it, just pass a <code>ClientSecretBasic(client_id, client_secret)</code> as <code>auth</code> parameter:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretBasic\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretBasic(\"client_id\", \"client_secret\"),\n)\n</code></pre>"},{"location":"#client-secret-post","title":"Client Secret Post","text":"<p>With client_secret_post, <code>client_id</code> and <code>client_secret</code> are included as part of the body form data. To use it, pass a <code>ClientSecretPost(client_id, client_secret)</code> as <code>auth</code> parameter. This is the default when you pass a tuple <code>(client_id, client_secret)</code> as <code>auth</code> when initializing an <code>OAuth2Client</code>:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretPost\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretPost(\"client_id\", \"client_secret\"),\n)\n# or\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=(\"client_id\", \"client_secret\")\n)\n# or\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    client_id=\"my_client_id\",\n    client_secret=\"my_client_secret\",\n)\n</code></pre>"},{"location":"#client-secret-jwt","title":"Client Secret JWT","text":"<p>With client_secret_jwt, the client generates an ephemeral JWT assertion including information about itself (client_id), the AS (url of the endpoint), and an expiration date a few seconds in the future. To use it, pass a <code>ClientSecretJwt(client_id, client_secret)</code> as <code>auth</code> parameter. Assertion generation is entirely automatic, you don't have anything to do:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n</code></pre> <p>This method is more secure than the 2 previous, because only ephemeral credentials are transmitted, which limits the possibility for interception and replay of the Client Secret. But that Client Secret still needs to be shared between the AS and Client owner(s).</p>"},{"location":"#private-key-jwt","title":"Private Key JWT","text":"<p>With private_key_jwt, client uses a JWT assertion that is just like the one for client_secret_jwt, but it is signed with an asymmetric key. To use it, you need a private signing key, in a <code>dict</code> that matches the JWK format, or as an instance of <code>jwskate.Jwk</code>. The matching public key must be registered for your client on AS side. Once you have that, using this auth method is simple with the <code>PrivateKeyJwt(client_id, private_jwk)</code> auth handler:</p> <pre><code>from requests_oauth2client import OAuth2Client, PrivateKeyJwt\n\nprivate_jwk = {\n    \"kid\": \"mykid\",\n    \"kty\": \"RSA\",\n    \"e\": \"AQAB\",\n    \"n\": \"...\",\n    \"d\": \"...\",\n    \"p\": \"...\",\n    \"q\": \"...\",\n    \"dp\": \"...\",\n    \"dq\": \"...\",\n    \"qi\": \"...\",\n}\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=PrivateKeyJwt(\"client_id\", private_jwk)\n)\n# or\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=(\"client_id\", private_jwk)\n)\n# or\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", client_id=\"client_id\", private_jwk=private_jwk\n)\n</code></pre> <p>This method can be considered more secure than those relying on a client secret, because only ephemeral credentials are sent over the wire, and it uses asymmetric cryptography: the signing key is generated by the client, and only the public key is known by the AS. Transmitting that public key between owner(s) of the client and of the AS is much easier than transmitting the Client Secret, which is a shared key that must be considered as confidential.</p>"},{"location":"#none","title":"None","text":"<p>The latest Client Authentication Method, none, is for Public Clients which do not authenticate to the Token Endpoint. Those clients only include their <code>client_id</code> in body form data, without any authentication credentials. Use <code>PublicApp(client_id)</code>:</p> <pre><code>from requests_oauth2client import OAuth2Client, PublicApp\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=PublicApp(\"app_client_id\")\n)\n</code></pre>"},{"location":"#token-revocation","title":"Token Revocation","text":"<p>The OAuth2Client class provides methods for sending revocation requests to a Revocation Endpoint. To use this feature, you need to provide the Revocation Endpoint URI when creating an instance of OAuth2Client. The available methods for revoking tokens are:</p> <ul> <li>revoke_token(): Revokes a token by providing the token value and an optional token_type_hint.</li> <li>revoke_access_token(): Revokes an access token by providing the token value.</li> <li>revoke_refresh_token(): Revokes a refresh token by providing the token value.</li> </ul> <p>Here is an example of how to use these methods:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    revocation_endpoint=\"https://url.to.the/revocation_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\noauth2client.revoke_token(\"mytoken\", token_type_hint=\"access_token\")\noauth2client.revoke_access_token(\"mytoken\")\noauth2client.revoke_refresh_token(\"mytoken\")\n</code></pre> <p>These methods return a boolean value indicating whether the revocation request was successfully sent and no error was returned. If the Authorization Server returns a non-successful HTTP code without a standard error message, it will return <code>False</code>. If the Authorization Server returns a standard error, an exception will be raised.</p>"},{"location":"#token-introspection","title":"Token Introspection","text":"<p>The OAuth2Client class also supports sending requests to a Token Introspection Endpoint. To use this feature, you need to provide the Introspection Endpoint URI when creating an instance of OAuth2Client. The introspect_token() method is then available for introspecting tokens:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    introspection_endpoint=\"https://url.to.the/introspection_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\nresp = oauth2client.introspect_token(\"mytoken\", token_type_hint=\"access_token\")\n</code></pre> <p>The <code>introspect_token()</code> method returns the data returned by the introspection endpoint, decoded if it is in JSON format.</p>"},{"location":"#userinfo-requests","title":"UserInfo Requests","text":"<p>The OAuth2Client class also supports sending requests to a UserInfo Endpoint. To use this feature, you need to provide the UserInfo Endpoint URI when creating an instance of OAuth2Client The userinfo() method is then available for retrieving user information:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    userinfo_endpoint=\"https://url.to.the/userinfo_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\nresp = oauth2client.userinfo(\"mytoken\")\n</code></pre> <p>The <code>userinfo()</code> method returns the data returned by the userinfo endpoint, decoded if it is in JSON format.</p>"},{"location":"#initializing-an-oauth2client-from-a-discovery-document","title":"Initializing an <code>OAuth2Client</code> from a discovery document","text":"<p>You can initialize an OAuth2Client with the endpoint URIs mentioned in a standardised discovery document using the OAuth2Client.from_discovery_endpoint() class method:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client.from_discovery_endpoint(\n    \"https://url.to.the.as/.well-known/openid-configuration\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\n# OR, if you know the issuer value\noauth2client = OAuth2Client.from_discovery_endpoint(\n    issuer=\"https://url.to.the.as\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n</code></pre> <p>This will fetch the document from the specified URI, decode it, and initialize an OAuth2Client pointing to the appropriate endpoint URIs.</p> <p>If you use the <code>issuer</code> keyword argument, the URI to the discovery endpoint will be deduced from that identifier, and a check will be made to ensure that the <code>issuer</code> from the retrieved metadata document matches that value.</p>"},{"location":"#using-dpop","title":"Using DPoP","text":""},{"location":"#basic-usage","title":"Basic usage","text":"<p><code>DPoP</code> (Demonstrating Proof of Possession) is supported out-of-the-box. To obtain a DPoP token, you can either:</p> <ul> <li>pass <code>dpop=True</code> when using any <code>OAuth2Client</code> method that sends a token request,</li> <li>or enable <code>DPoP</code> by default by passing <code>dpop_bound_access_tokens=True</code> when initializing your client.</li> </ul> <pre><code>from requests_oauth2client import DPoPToken, OAuth2Client\n\noauth2client = OAuth2Client.from_discovery_endpoint(\n    issuer=\"https://as.local\",\n    client_id=\"client_id\", client_secret=\"client_secret\",\n)\n\ntoken = oauth2client.client_credentials(scope=\"my_scope\", dpop=True)\nassert isinstance(token, DPoPToken)\n\n# or, to enable DPoP by default for every token request\noauth2client = OAuth2Client.from_discovery_endpoint(\n    issuer=\"https://as.local\",\n    client_id=\"client_id\", client_secret=\"client_secret\",\n    dpop_bound_access_tokens=True,\n)\ntoken = oauth2client.client_credentials(scope=\"my_scope\")\nassert isinstance(token, DPoPToken)\n</code></pre>"},{"location":"#about-dpoptoken","title":"About <code>DPoPToken</code>","text":"<p><code>DPoPToken</code> is actually a <code>BearerToken</code> subclass. If you use it as a <code>requests</code> Auth Handler, it will take care of adding a <code>DPoP</code> proof to the request headers, in addition to the access token.</p> <p>Since it is a <code>BearerToken</code> subclass, it is fully compatible with the <code>requests</code> compatible auth handlers provided by <code>requests_oauth2client</code>, such as <code>OAuth2ClientCredentialsAuth</code>, <code>OAuth2AccessTokenAuth</code>, etc. So you may use DPoP with those auth handlers like this:</p> <pre><code>import requests\nfrom requests_oauth2client import OAuth2Client, OAuth2ClientCredentialsAuth, PrivateKeyJwt\n\nclient = OAuth2Client.from_discovery_endpoint(\n    issuer=\"https://my.issuer.local\",\n    auth=PrivateKeyJwt(\"client_id\", \"client_secret\"),\n    dpop_bound_access_tokens=True, # enable DPoP by default\n)\n\nsession = requests.Session()\nsession.auth = OAuth2ClientCredentialsAuth(\n    client=client,\n    scope=\"my_scope\"\n)\n\nresp = session.get(\"https://my.api.local/endpoint\")  # this will automatically obtain a DPoP token and use it\nassert \"DPoP\" in resp.requests.headers  # the appropriate DPoP proof will be included in the request\n</code></pre> <p>Since DPoP is enabled by default with <code>dpop_bound_access_tokens=True</code>, then the <code>OAuth2ClientCredentialsAuth</code> will obtain and use <code>DPoPToken</code> instances. You could also leave it disabled by default and pass <code>dpop=True</code> when initializing you auth handler instance: <code>OAuth2ClientCredentialsAuth(client=client, scope=\"my_scope\", dpop=True)</code>.</p>"},{"location":"#choosing-your-own-proof-signature-keys","title":"Choosing your own proof signature keys","text":"<p>By default, the private key used for signing <code>DPoP</code> proofs is auto-generated by <code>OAuth2Client</code> whenever a new token is obtained. By default, generated keys are of type Elliptic Curve (<code>EC</code>), and use the <code>ES256</code> signature alg (as in Elliptic-Curve with a SHA256 hash). Should you, for testing purposes, wish to generate or use your own key, you may use the parameter <code>dpop_key</code> to provide a key of your choice. It takes a <code>DPoPKey</code> instance, which you can generate using <code>DPoPKey.generate()</code>, or by initializing an instance with a key that you previously generated:</p> <pre><code>from cryptography.hazmat.primitives.asymmetric import rsa\nimport jwskate\nfrom requests_oauth2client import DPoPKey, DPoPToken, OAuth2Client\n\noauth2client = OAuth2Client.from_discovery_endpoint(\n    issuer=\"https://as.local\",\n    client_id=\"client_id\", client_secret=\"client_secret\",\n    dpop_bound_access_tokens=True,\n)\n\ndpop_key = DPoPKey.generate(alg=\"RS512\")  # generate a new DPoP key with an alg of your choice\n# or, for testing purposes only, your can load your own key\ndpop_key = DPoPKey(private_key=jwskate.Jwk({\"kty\": \"EC\", \"crv\": \"P-256\", \"alg\": \"ES256\", \"x\": \"...\", \"y\": \"...\", \"d\": \"...\"}))\n# or, any key material supported by `jwskate` is supported, so you can also use `cryptography` keys directly,\n# but you need to specify the signature `alg` since it is not part of the key itself\ndpop_key = DPoPKey(private_key=rsa.generate_private_key(public_exponent=65537, key_size=2048), alg=\"RS256\")\n\ntoken = oauth2client.client_credentials(scope=\"my_scope\", dpop_key=dpop_key)\nassert isinstance(token, DPoPToken)\nassert token.dpop_key == dpop_key\n</code></pre>"},{"location":"#hooking-into-dpop-key-and-proof-generation","title":"Hooking into DPoP key and proof generation","text":"<p>Instead of generating your own keys everytime, you may also control how <code>DPoPKey</code>s are automatically generated. This can be useful for fuzz-testing, pen-testing or feature-testing the Authorization Server. To choose the signing alg, use the parameter <code>dpop_alg</code> when initializing your client. This will accordingly determine the key type to generate. You may also pass a custom <code>dpop_key_generator</code>, which is a callable that accepts a signature <code>alg</code> as parameter, and generates <code>DPoPKey</code> instances.</p> <p>You can also override the <code>DPoPToken</code> class with a custom one, which will be used to represent the DPoP token that is returned by the AS, and then generates proofs and includes those proofs into HTTP requests.</p> <p>You may use <code>DPoPKey.generate</code> as a helper method for that, or implement your own generator:</p> <pre><code>import secrets\nfrom requests_oauth2client import DPoPKey, DPoPToken, OAuth2Client\n\nclass CustomDPoPToken(DPoPToken):\n    \"\"\"A custom DPoP token class that places the DPoP proof and token into a non-standard header.\"\"\"\n    AUTHORIZATION_HEADER = \"X-Custom-Auth\"\n    DPOP_HEADER = \"X-DPoP\"\n\noauth2client = OAuth2Client.from_discovery_endpoint(\n    issuer=\"https://as.local\",\n    client_id=\"client_id\", client_secret=\"client_secret\",\n    dpop_bound_access_tokens=True,  # enable DPoP by default\n    dpop_alg=\"RS256\", # choose the signing alg to use, and it will automatically determine the key type to generate.\n    dpop_key_generator=lambda alg: DPoPKey.generate(\n        alg=alg,\n        # those other parameters are for feature testing the AS, or for workarounding AS bugs:\n        jwt_typ=\"jwt+custom\", # you can customize the `typ` that is included in DPoP proof headers\n        jti_generator=lambda: secrets.token_urlsafe(24), # generate unique jti differently than the default UUIDs\n        iat_generator=lambda: 12532424, # override `iat` generation in DPoP proofs, here it will return a static value\n        dpop_token_class=CustomDPoPToken, # override the class that represents DPoP tokens\n    )\n)\n</code></pre>"},{"location":"#about-dpop-nonces","title":"About DPoP nonces","text":"<p>Authorization Server provided <code>DPoP</code> nonces are automatically and transparently handled by <code>OAuth2Client</code>.</p> <p>Likewise, Resource Server provided <code>DPoP</code> nonces are supported when using the default <code>DPoPToken</code> class. This includes all requests-compatible auth handlers provided by <code>requests_oauth2client</code>, like <code>OAuth2AccessTokenAuth</code>, <code>OAuth2ClientCredentialsAuth</code>, <code>OAuth2AuthorizationCodeAuth</code>, etc.</p> <p>As an example, see the sample below:</p> <pre><code>from requests_oauth2client import OAuth2Client, OAuth2ClientCredentialsAuth\n\nimport requests\n\noauth2client = OAuth2Client.from_discovery_endpoint(\n    issuer=\"https://as.local\",\n    client_id=\"client_id\", client_secret=\"client_secret\",\n)\n\nresponse = requests.get(\n    \"https://my.api.local/endpoint\",\n    auth=OAuth2ClientCredentialsAuth(oauth2client, scope=\"my_scope\", dpop=True),\n)\n</code></pre> <p>Assuming that both the Authorization Server (at https://as.local) and the Resource Server (at https://my.api.local) require the use of <code>DPoP</code> nonces, then at least 4 different requests are sent as a result of the <code>requests.get()</code> call above:</p> <ol> <li>The first request is to get a token from the Authorization Server, here using a Client Credentials grant and including a DPoP proof. DPoP also works with all other grant types. That first requests does not include a nonce. Since the AS requires a DPoP nonce, it replies to that request with an <code>error=use_dpop_nonce</code> flag and a generated DPoP nonce.</li> <li>Second request is automatically sent to the AS, this time with a DPoP proof that contains the nonce provided by the AS. As a result, the AS returns a DPoP token.</li> <li> <p>Third request is sent to the target API, with the DPoP token obtained at step 2, and a DPoP proof that does not yet contain a <code>nonce</code>.    The response from this call is a <code>401</code> with at least these 2 response headers:</p> </li> <li> <p>a <code>WWW-Authenticate: DPoP error=\"use_dpop_nonce\"</code> header, indicating that a DPoP <code>nonce</code> is requested,</p> </li> <li>and a <code>DPoP-Nonce</code> header containing the <code>nonce</code> to use.</li> <li>a request is sent again to the target API, this time with a DPoP proof that contains the RS provided <code>nonce</code>    obtained at step 3. Target API then should accept that request, do its own business and return a <code>200</code> response.</li> </ol> <p>If you send multiple requests to the same API, instead of using individual calls to <code>requests.get()</code>, <code>requests.post()</code> etc., you should use a <code>requests.Session</code> or an <code>ApiClient</code>. It will make sure that the obtained access token and DPoP nonce(s) are reused as long as they are valid, which avoid repeating calls 1 and 2 unnecessarily and consuming more tokens and nonces than necessary:</p> <pre><code>from requests_oauth2client import ApiClient, OAuth2Client, OAuth2ClientCredentialsAuth\n\noauth2client = OAuth2Client.from_discovery_endpoint(\n    issuer=\"https://as.local\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\napi = ApiClient(\"https://my.api.local/\", auth=OAuth2ClientCredentialsAuth(oauth2client, scope=\"my_scope\", dpop=True))\nresponse1 = api.get(\"endpoint\") # the first call will trigger requests 1. 2. 3. 4. like above\nresponse2 = api.post(\"other_endpoint\") # next calls will reuse the same token and DPoP nonces as long as they are valid.\n# some time later\nresponse3 = api.get(\"other_endpoint\") # new tokens and DPoP nonces will automatically be obtained when the first ones are expired\n</code></pre> <p>AS and RS provided nonces are memoized independently by the <code>DPoPToken</code> instance, so the amount of \"extra\" requests to obtain new DPoP nonces should be minimal.</p>"},{"location":"#specialized-api-client","title":"Specialized API Client","text":"<p>Using APIs usually involves multiple endpoints under the same root url, with a common authentication method. To make it easier, <code>requests_oauth2client</code> includes a requests.Session wrapper called ApiClient, which takes the root API url as parameter on initialization. You can then send requests to different endpoints by passing their relative path instead of the full url. ApiClient also accepts an <code>auth</code> parameter with an AuthHandler. You can pass any of the OAuth2 Auth Handler from this module, or any requests-compatible Authentication Handler. Which makes it very easy to call APIs that are protected with an OAuth2 Client Credentials Grant:</p> <pre><code>from requests_oauth2client import OAuth2Client, ApiClient, OAuth2ClientCredentialsAuth\n\noauth2client = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", client_id=\"client_id\", client_secret=\"client_secret\"\n)\napi = ApiClient(\n    \"https://myapi.local/root\", auth=OAuth2ClientCredentialsAuth(oauth2client)\n)\n\n# will actually send a GET to https://myapi.local/root/resource/foo\nresp = api.get(\"/resource/foo\")\n</code></pre> <p>Note that ApiClient will never send requests \"outside\" its configured root url. The leading <code>/</code> in <code>/resource</code> above is optional. A leading <code>/</code> will not \"reset\" the url path to root, which means that you can also write the relative path without the <code>/</code> and it will automatically be included:</p> <pre><code>api.get(\"resource/foo\")  # will also send a GET to https://myapi.local/root/resource/foo\n</code></pre> <p>You may also pass the path as an iterable of strings (or string-able objects), in which case they will be joined with a <code>/</code> and appended to the url path:</p> <pre><code># will send a GET to https://myapi.local/root/resource/foo\napi.get([\"resource\", \"foo\"])\n# will send a GET to https://myapi.local/root/users/1234/details\napi.get([\"users\", 1234, \"details\"])\n</code></pre> <p>You can also use a syntax based on <code>__getattr__</code> or <code>__getitem__</code>:</p> <pre><code>api.resource.get()  # will send a GET to https://myapi.local/root/resource\napi[\"my-resource\"].get()  # will send a GET to https://myapi.local/root/my-resource\n</code></pre> <p>Both <code>__getattr__</code> and <code>__getitem__</code> return a new <code>ApiClient</code> initialised on the new base_url. So you can easily call multiple sub-resources on the same API this way:</p> <pre><code>from requests_oauth2client import ApiClient\n\napi = ApiClient(\"https://myapi.local\")\nusers_api = api.users\nuser = users_api.get(\"userid\")  # GET https://myapi.local/users/userid\nother_user = users_api.get(\"other_userid\")  # GET https://myapi.local/users/other_userid\nresources_api = api.resources\nresources = resources_api.get()  # GET https://myapi.local/resources\n</code></pre> <p>ApiClient will, by default, raise exceptions whenever a request returns an error status. You can disable that by passing <code>raise_for_status=False</code> when initializing your ApiClient:</p> <pre><code>from requests_oauth2client import ApiClient\n\napi = ApiClient(\n    \"http://httpstat.us\", raise_for_status=False\n)  # raise_for_status defaults to True\nresp = api.get(\"500\")\nassert resp is not None\n# without raise_for_status=False, a requests.exceptions.HTTPError exception would be raised instead\n</code></pre> <p>You may override this at request time:</p> <pre><code># raise_for_status at request-time overrides the value defined at init-time\nresp = api.get(\"500\", raise_for_status=True)\n</code></pre> <p>You can access the underlying <code>requests.Session</code> with the session attribute, and you can provide an already existing and configured <code>Session</code> instance at init time:</p> <pre><code>import requests\nfrom requests_oauth2client import ApiClient\n\nsession = requests.Session()\nsession.proxies = {\"https\": \"http://localhost:3128\"}\napi = ApiClient(\"https://myapi.local/resource\", session=session)\nassert api.session == session\n</code></pre>"},{"location":"#vendor-specific-clients","title":"Vendor-Specific clients","text":"<p><code>requests_oauth2client</code> is flexible enough to handle most use cases, so you should be able to use any AS by any vendor as long as it supports OAuth 2.0.</p> <p>You can however create a subclass of OAuth2Client or ApiClient to make it easier to use with specific Authorization Servers or APIs. OAuth2Client has several extensibility points in the form of methods like <code>OAuth2Client.parse_token_response()</code>, <code>OAuth2Client.on_token_error()</code> that implement response parsing, error handling, etc.</p> <pre><code>from requests_oauth2client.vendor_specific import Auth0\n\na0client = Auth0.client(\n    \"mytenant.eu\", client_id=\"client_id\", client_secret=\"client_secret\"\n)\n# this will automatically initialize the token endpoint to https://mytenant.eu.auth0.com/oauth/token\n# and other endpoints accordingly\ntoken = a0client.client_credentials(audience=\"audience\")\n\n# this is a wrapper around Auth0 Management API\na0mgmt = Auth0.management_api_client(\n    \"mytenant.eu\", client_id=\"client_id\", client_secret=\"client_secret\"\n)\nmyusers = a0mgmt.get(\"users\")\n</code></pre>"},{"location":"api/","title":"API","text":""},{"location":"api/#requests_oauth2client","title":"<code>requests_oauth2client</code>","text":"<p>Main module for <code>requests_oauth2client</code>.</p> <p>You can import any class from any submodule directly from this main module.</p>"},{"location":"api/#requests_oauth2client.ApiClient","title":"<code>ApiClient</code>","text":"<p>A Wrapper around requests.Session with extra features for REST API calls.</p> <p>Additional features compared to using a requests.Session directly:</p> <ul> <li>You must set a root url at creation time, which then allows passing relative urls at request time.</li> <li>It may also raise exceptions instead of returning error responses.</li> <li>You can also pass additional kwargs at init time, which will be used to configure the Session, instead of setting them later.</li> <li>for parameters passed as <code>json</code>, <code>params</code> or <code>data</code>, values that are <code>None</code> can be automatically discarded from the request</li> <li>boolean values in <code>data</code> or <code>params</code> fields can be serialized to values that are suitable for the target API, like <code>\"true\"</code>  or <code>\"false\"</code>, or <code>\"1\"</code> / <code>\"0\"</code>, instead of the default values <code>\"True\"</code> or <code>\"False\"</code>,</li> <li>you may pass <code>cookies</code> and <code>headers</code>, which will be added to the session cookie handler or request headers respectively.</li> <li>you may use the <code>user_agent</code> parameter to change the <code>User-Agent</code> header easily. Set it to   <code>None</code> to remove that header.</li> </ul> <p><code>base_url</code> will serve as root for relative urls passed to ApiClient.request(), ApiClient.get(), etc.</p> <p>A requests.HTTPError will be raised everytime an API call returns an error code (&gt;= 400), unless you set <code>raise_for_status</code> to <code>False</code>. Additional parameters passed at init time, including <code>auth</code> will be used to configure the Session.</p> Example <pre><code>from requests_oauth2client import ApiClient\n\napi = ApiClient(\"https://myapi.local/resource\", timeout=10)\nresp = api.get(\"/myid\")  # this will send a GET request\n# to https://myapi.local/resource/myid\n\n# you can pass an underlying requests.Session at init time\nsession = requests.Session()\nsession.proxies = {\"https\": \"https://localhost:3128\"}\napi = ApiClient(\"https://myapi.local/resource\", session=session)\n\n# or you can let ApiClient init its own session and provide additional configuration\n# parameters:\napi = ApiClient(\n    \"https://myapi.local/resource\",\n    proxies={\"https\": \"https://localhost:3128\"},\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>the base api url, that is the root for all the target API endpoints.</p> required <code>auth</code> <code>AuthBase | None</code> <p>the requests.auth.AuthBase to use as authentication handler.</p> <code>None</code> <code>timeout</code> <code>int | None</code> <p>the default timeout, in seconds, to use for each request from this <code>ApiClient</code>. Can be set to <code>None</code> to disable timeout.</p> <code>60</code> <code>raise_for_status</code> <code>bool</code> <p>if <code>True</code>, exceptions will be raised everytime a request returns an error code (&gt;= 400).</p> <code>True</code> <code>none_fields</code> <code>Literal['include', 'exclude', 'empty']</code> <p>defines what to do with parameters with value <code>None</code> in <code>data</code> or <code>json</code> fields.</p> <ul> <li>if <code>\"exclude\"</code> (default), fields whose values are <code>None</code> are not included in the request.</li> <li>if <code>\"include\"</code>, they are included with string value <code>None</code>. This is the default behavior of <code>requests</code>. Note that they will be serialized to <code>null</code> in JSON.</li> <li>if <code>\"empty\"</code>, they are included with an empty value (as an empty string).</li> </ul> <code>'exclude'</code> <code>bool_fields</code> <code>tuple[Any, Any] | None</code> <p>a tuple of <code>(true_value, false_value)</code>. Fields from <code>data</code> or <code>params</code> with a boolean value (<code>True</code> or <code>False</code>) will be serialized to the corresponding value. This can be useful since some APIs expect a <code>'true'</code> or <code>'false'</code> value as boolean, and <code>requests</code> serializes <code>True</code> to <code>'True'</code> and <code>False</code> to <code>'False'</code>. Set it to <code>None</code> to restore default requests behavior.</p> <code>('true', 'false')</code> <code>cookies</code> <code>Mapping[str, Any] | None</code> <p>a mapping of cookies to set in the underlying <code>requests.Session</code>.</p> <code>None</code> <code>headers</code> <code>Mapping[str, Any] | None</code> <p>a mapping of headers to set in the underlying <code>requests.Session</code>.</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>a preconfigured <code>requests.Session</code> to use with this <code>ApiClient</code>.</p> <code>None</code> <code>**session_kwargs</code> <code>Any</code> <p>additional kwargs to configure the underlying <code>requests.Session</code>.</p> <code>{}</code> <p>Raises:</p> Type Description <code>InvalidBoolFieldsParam</code> <p>if the provided <code>bool_fields</code> parameter is invalid.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>@frozen(init=False)\nclass ApiClient:\n    \"\"\"A Wrapper around [requests.Session][] with extra features for REST API calls.\n\n    Additional features compared to using a [requests.Session][] directly:\n\n    - You must set a root url at creation time, which then allows passing relative urls at request time.\n    - It may also raise exceptions instead of returning error responses.\n    - You can also pass additional kwargs at init time, which will be used to configure the\n    [Session][requests.Session], instead of setting them later.\n    - for parameters passed as `json`, `params` or `data`, values that are `None` can be\n    automatically discarded from the request\n    - boolean values in `data` or `params` fields can be serialized to values that are suitable\n    for the target API, like `\"true\"`  or `\"false\"`, or `\"1\"` / `\"0\"`, instead of the default\n    values `\"True\"` or `\"False\"`,\n    - you may pass `cookies` and `headers`, which will be added to the session cookie handler or\n    request headers respectively.\n    - you may use the `user_agent` parameter to change the `User-Agent` header easily. Set it to\n      `None` to remove that header.\n\n    `base_url` will serve as root for relative urls passed to\n    [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request],\n    [ApiClient.get()][requests_oauth2client.api_client.ApiClient.get], etc.\n\n    A [requests.HTTPError][] will be raised everytime an API call returns an error code (&gt;= 400), unless\n    you set `raise_for_status` to `False`. Additional parameters passed at init time, including\n    `auth` will be used to configure the [Session][requests.Session].\n\n    Example:\n        ```python\n        from requests_oauth2client import ApiClient\n\n        api = ApiClient(\"https://myapi.local/resource\", timeout=10)\n        resp = api.get(\"/myid\")  # this will send a GET request\n        # to https://myapi.local/resource/myid\n\n        # you can pass an underlying requests.Session at init time\n        session = requests.Session()\n        session.proxies = {\"https\": \"https://localhost:3128\"}\n        api = ApiClient(\"https://myapi.local/resource\", session=session)\n\n        # or you can let ApiClient init its own session and provide additional configuration\n        # parameters:\n        api = ApiClient(\n            \"https://myapi.local/resource\",\n            proxies={\"https\": \"https://localhost:3128\"},\n        )\n        ```\n\n    Args:\n        base_url: the base api url, that is the root for all the target API endpoints.\n        auth: the [requests.auth.AuthBase][] to use as authentication handler.\n        timeout: the default timeout, in seconds, to use for each request from this `ApiClient`.\n            Can be set to `None` to disable timeout.\n        raise_for_status: if `True`, exceptions will be raised everytime a request returns an\n            error code (&gt;= 400).\n        none_fields: defines what to do with parameters with value `None` in `data` or `json` fields.\n\n            - if `\"exclude\"` (default), fields whose values are `None` are not included in the request.\n            - if `\"include\"`, they are included with string value `None`. This is\n            the default behavior of `requests`. Note that they will be serialized to `null` in JSON.\n            - if `\"empty\"`, they are included with an empty value (as an empty string).\n        bool_fields: a tuple of `(true_value, false_value)`. Fields from `data` or `params` with\n            a boolean value (`True` or `False`) will be serialized to the corresponding value.\n            This can be useful since some APIs expect a `'true'` or `'false'` value as boolean,\n            and `requests` serializes `True` to `'True'` and `False` to `'False'`.\n            Set it to `None` to restore default requests behavior.\n        cookies: a mapping of cookies to set in the underlying `requests.Session`.\n        headers: a mapping of headers to set in the underlying `requests.Session`.\n        session: a preconfigured `requests.Session` to use with this `ApiClient`.\n        **session_kwargs: additional kwargs to configure the underlying `requests.Session`.\n\n    Raises:\n        InvalidBoolFieldsParam: if the provided `bool_fields` parameter is invalid.\n\n    \"\"\"\n\n    base_url: str\n    auth: requests.auth.AuthBase | None\n    timeout: int | None\n    raise_for_status: bool\n    none_fields: Literal[\"include\", \"exclude\", \"empty\"]\n    bool_fields: tuple[Any, Any] | None\n    session: requests.Session\n\n    def __init__(\n        self,\n        base_url: str,\n        *,\n        auth: requests.auth.AuthBase | None = None,\n        timeout: int | None = 60,\n        raise_for_status: bool = True,\n        none_fields: Literal[\"include\", \"exclude\", \"empty\"] = \"exclude\",\n        bool_fields: tuple[Any, Any] | None = (\"true\", \"false\"),\n        cookies: Mapping[str, Any] | None = None,\n        headers: Mapping[str, Any] | None = None,\n        user_agent: str | None = requests.utils.default_user_agent(),\n        session: requests.Session | None = None,\n        **session_kwargs: Any,\n    ) -&gt; None:\n        session = session or requests.Session()\n\n        if cookies:\n            for key, val in cookies.items():\n                session.cookies[key] = str(val)\n\n        if headers:\n            for key, val in headers.items():\n                session.headers[key] = str(val)\n\n        if user_agent is None:\n            session.headers.pop(\"User-Agent\", None)\n        else:\n            session.headers[\"User-Agent\"] = str(user_agent)\n\n        for key, val in session_kwargs.items():\n            setattr(session, key, val)\n\n        if bool_fields is None:\n            bool_fields = (\"True\", \"False\")\n        else:\n            validate_bool_fields(bool_fields)\n\n        self.__attrs_init__(\n            base_url=base_url,\n            auth=auth,\n            raise_for_status=raise_for_status,\n            none_fields=none_fields,\n            bool_fields=bool_fields,\n            timeout=timeout,\n            session=session,\n        )\n\n    def request(  # noqa: C901, PLR0913, D417\n        self,\n        method: str,\n        path: None | str | bytes | Iterable[str | bytes | int] = None,\n        *,\n        params: None | bytes | MutableMapping[str, str] = None,\n        data: (\n            Iterable[bytes]\n            | str\n            | bytes\n            | list[tuple[Any, Any]]\n            | tuple[tuple[Any, Any], ...]\n            | Mapping[Any, Any]\n            | None\n        ) = None,\n        headers: MutableMapping[str, str] | None = None,\n        cookies: None | RequestsCookieJar | MutableMapping[str, str] = None,\n        files: MutableMapping[str, IO[Any]] | None = None,\n        auth: (\n            None\n            | tuple[str, str]\n            | requests.auth.AuthBase\n            | Callable[[requests.PreparedRequest], requests.PreparedRequest]\n        ) = None,\n        timeout: None | float | tuple[float, float] | tuple[float, None] = None,\n        allow_redirects: bool = False,\n        proxies: MutableMapping[str, str] | None = None,\n        hooks: None\n        | (\n            MutableMapping[\n                str,\n                (Iterable[Callable[[requests.Response], Any]] | Callable[[requests.Response], Any]),\n            ]\n        ) = None,\n        stream: bool | None = None,\n        verify: str | bool | None = None,\n        cert: str | tuple[str, str] | None = None,\n        json: Mapping[str, Any] | None = None,\n        raise_for_status: bool | None = None,\n        none_fields: Literal[\"include\", \"exclude\", \"empty\"] | None = None,\n        bool_fields: tuple[Any, Any] | None = None,\n    ) -&gt; requests.Response:\n        \"\"\"A wrapper around [requests.Session.request][] method with extra features.\n\n        Additional features are described in\n        [ApiClient][requests_oauth2client.api_client.ApiClient] documentation.\n\n        All parameters will be passed as-is to [requests.Session.request][], expected those\n        described below which have a special behavior.\n\n        Args:\n          path: the url where the request will be sent to. Can be:\n\n            - a path, as `str`: that path will be joined to the configured API url,\n            - an iterable of path segments: that will be joined to the root url.\n          raise_for_status: like the parameter of the same name from\n            [ApiClient][requests_oauth2client.api_client.ApiClient],\n            but this will be applied for this request only.\n          none_fields: like the parameter of the same name from\n            [ApiClient][requests_oauth2client.api_client.ApiClient],\n            but this will be applied for this request only.\n          bool_fields: like the parameter of the same name from\n            [ApiClient][requests_oauth2client.api_client.ApiClient],\n            but this will be applied for this request only.\n\n        Returns:\n          a Response as returned by requests\n\n        Raises:\n            InvalidBoolFieldsParam: if the provided `bool_fields` parameter is invalid.\n\n        \"\"\"\n        path = self.to_absolute_url(path)\n\n        if none_fields is None:\n            none_fields = self.none_fields\n\n        if none_fields == \"exclude\":\n            if isinstance(data, Mapping):\n                data = {key: val for key, val in data.items() if val is not None}\n            if isinstance(json, Mapping):\n                json = {key: val for key, val in json.items() if val is not None}\n        elif none_fields == \"empty\":\n            if isinstance(data, Mapping):\n                data = {key: val if val is not None else \"\" for key, val in data.items()}\n            if isinstance(json, Mapping):\n                json = {key: val if val is not None else \"\" for key, val in json.items()}\n\n        if bool_fields is None:\n            bool_fields = self.bool_fields\n\n        if bool_fields:\n            true_value, false_value = validate_bool_fields(bool_fields)\n            if isinstance(data, MutableMapping):\n                for key, val in data.items():\n                    if val is True:\n                        data[key] = true_value\n                    elif val is False:\n                        data[key] = false_value\n            if isinstance(params, MutableMapping):\n                for key, val in params.items():\n                    if val is True:\n                        params[key] = true_value\n                    elif val is False:\n                        params[key] = false_value\n\n        timeout = timeout or self.timeout\n\n        response = self.session.request(\n            method,\n            path,\n            params=params,\n            data=data,\n            headers=headers,\n            cookies=cookies,\n            files=files,\n            auth=auth or self.auth,\n            timeout=timeout,\n            allow_redirects=allow_redirects,\n            proxies=proxies,\n            hooks=hooks,\n            stream=stream,\n            verify=verify,\n            cert=cert,\n            json=json,\n        )\n\n        if raise_for_status is None:\n            raise_for_status = self.raise_for_status\n        if raise_for_status:\n            response.raise_for_status()\n        return response\n\n    def to_absolute_url(self, path: None | str | bytes | Iterable[str | bytes | int] = None) -&gt; str:\n        \"\"\"Convert a relative url to an absolute url.\n\n        Given a `path`, return the matching absolute url, based on the `base_url` that is\n        configured for this API.\n\n        The result of this method is different from a standard `urljoin()`, because a relative_url\n        that starts with a \"/\" will not override the path from the base url. You can also pass an\n        iterable of path parts as relative url, which will be properly joined with \"/\". Those parts\n        may be `str` (which will be urlencoded) or `bytes` (which will be decoded as UTF-8 first) or\n        any other type (which will be converted to `str` first, using the `str() function`). See the\n        table below for example results which would exhibit most cases:\n\n        | base_url | relative_url | result_url |\n        |---------------------------|-----------------------------|-------------------------------------------|\n        | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `b\"/path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `\"path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `None` | `\"https://myhost.com/root\"` |\n        | `\"https://myhost.com/root\"` |  `(\"user\", 1, \"resource\")` | `\"https://myhost.com/root/user/1/resource\"` |\n        | `\"https://myhost.com/root\"` | `\"https://otherhost.org/foo\"` | `ValueError` |\n\n        Args:\n          path: a relative url\n\n        Returns:\n          the resulting absolute url\n\n        Raises:\n            InvalidPathParam: if the provided path does not allow constructing a valid url\n\n        \"\"\"\n        url = path\n\n        if url is None:\n            url = self.base_url\n        else:\n            if not isinstance(url, (str, bytes)):\n                try:\n                    url = \"/\".join(\n                        [urlencode(part.decode() if isinstance(part, bytes) else str(part)) for part in url if part],\n                    )\n                except Exception as exc:\n                    raise InvalidPathParam(url) from exc\n\n            if isinstance(url, bytes):\n                url = url.decode()\n\n            if \"://\" in url:\n                raise InvalidPathParam(url)\n\n            url = urljoin(self.base_url + \"/\", url.lstrip(\"/\"))\n\n        if url is None or not isinstance(url, str):\n            raise InvalidPathParam(url)  # pragma: no cover\n\n        return url\n\n    def get(\n        self,\n        path: None | str | bytes | Iterable[str | bytes | int] = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a GET request and return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n            path: the path where the request will be sent.\n            raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n            **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n            a response object.\n\n        Raises:\n            requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"GET\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def post(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a POST request and return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n          a response object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"POST\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def patch(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a PATCH request. Return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"PATCH\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def put(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a PUT request. Return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"PUT\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def delete(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a DELETE request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time. It takes the same\n        parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`.\n\n        Returns:\n          a response object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"DELETE\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def __getattr__(self, item: str) -&gt; ApiClient:\n        \"\"\"Allow access sub resources with an attribute-based syntax.\n\n        Args:\n            item: a subpath\n\n        Returns:\n            a new `ApiClient` initialized on the new base url\n\n        Example:\n            ```python\n            from requests_oauth2client import ApiClient\n\n            api = ApiClient(\"https://myapi.local\")\n            resource1 = api.resource1.get()  # GET https://myapi.local/resource1\n            resource2 = api.resource2.get()  # GET https://myapi.local/resource2\n            ```\n\n        \"\"\"\n        return self[item]\n\n    def __getitem__(self, item: str) -&gt; ApiClient:\n        \"\"\"Allow access to sub resources with a subscription-based syntax.\n\n        Args:\n            item: a subpath\n\n        Returns:\n            a new `ApiClient` initialized on the new base url\n\n        Example:\n            ```python\n            from requests_oauth2client import ApiClient\n\n            api = ApiClient(\"https://myapi.local\")\n            resource1 = api[\"resource1\"].get()  # GET https://myapi.local/resource1\n            resource2 = api[\"resource2\"].get()  # GET https://myapi.local/resource2\n            ```\n\n        \"\"\"\n        new_base_uri = self.to_absolute_url(item)\n        return ApiClient(\n            new_base_uri,\n            session=self.session,\n            none_fields=self.none_fields,\n            bool_fields=self.bool_fields,\n            timeout=self.timeout,\n            raise_for_status=self.raise_for_status,\n        )\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Allow `ApiClient` to act as a context manager.\n\n        You can then use an `ApiClient` instance in a `with` clause, the same way as\n        `requests.Session`. The underlying request.Session will be closed on exit.\n\n        Example:\n            ```python\n            with ApiClient(\"https://myapi.com/path\") as client:\n                resp = client.get(\"resource\")\n            ```\n\n        \"\"\"\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Close the underlying requests.Session on exit.\"\"\"\n        self.session.close()\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.request","title":"<code>request(method, path=None, *, params=None, data=None, headers=None, cookies=None, files=None, auth=None, timeout=None, allow_redirects=False, proxies=None, hooks=None, stream=None, verify=None, cert=None, json=None, raise_for_status=None, none_fields=None, bool_fields=None)</code>","text":"<p>A wrapper around requests.Session.request method with extra features.</p> <p>Additional features are described in ApiClient documentation.</p> <p>All parameters will be passed as-is to requests.Session.request, expected those described below which have a special behavior.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>the url where the request will be sent to. Can be:</p> <ul> <li>a path, as <code>str</code>: that path will be joined to the configured API url,</li> <li>an iterable of path segments: that will be joined to the root url.</li> </ul> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>like the parameter of the same name from ApiClient, but this will be applied for this request only.</p> <code>None</code> <code>none_fields</code> <code>Literal['include', 'exclude', 'empty'] | None</code> <p>like the parameter of the same name from ApiClient, but this will be applied for this request only.</p> <code>None</code> <code>bool_fields</code> <code>tuple[Any, Any] | None</code> <p>like the parameter of the same name from ApiClient, but this will be applied for this request only.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response as returned by requests</p> <p>Raises:</p> Type Description <code>InvalidBoolFieldsParam</code> <p>if the provided <code>bool_fields</code> parameter is invalid.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def request(  # noqa: C901, PLR0913, D417\n    self,\n    method: str,\n    path: None | str | bytes | Iterable[str | bytes | int] = None,\n    *,\n    params: None | bytes | MutableMapping[str, str] = None,\n    data: (\n        Iterable[bytes]\n        | str\n        | bytes\n        | list[tuple[Any, Any]]\n        | tuple[tuple[Any, Any], ...]\n        | Mapping[Any, Any]\n        | None\n    ) = None,\n    headers: MutableMapping[str, str] | None = None,\n    cookies: None | RequestsCookieJar | MutableMapping[str, str] = None,\n    files: MutableMapping[str, IO[Any]] | None = None,\n    auth: (\n        None\n        | tuple[str, str]\n        | requests.auth.AuthBase\n        | Callable[[requests.PreparedRequest], requests.PreparedRequest]\n    ) = None,\n    timeout: None | float | tuple[float, float] | tuple[float, None] = None,\n    allow_redirects: bool = False,\n    proxies: MutableMapping[str, str] | None = None,\n    hooks: None\n    | (\n        MutableMapping[\n            str,\n            (Iterable[Callable[[requests.Response], Any]] | Callable[[requests.Response], Any]),\n        ]\n    ) = None,\n    stream: bool | None = None,\n    verify: str | bool | None = None,\n    cert: str | tuple[str, str] | None = None,\n    json: Mapping[str, Any] | None = None,\n    raise_for_status: bool | None = None,\n    none_fields: Literal[\"include\", \"exclude\", \"empty\"] | None = None,\n    bool_fields: tuple[Any, Any] | None = None,\n) -&gt; requests.Response:\n    \"\"\"A wrapper around [requests.Session.request][] method with extra features.\n\n    Additional features are described in\n    [ApiClient][requests_oauth2client.api_client.ApiClient] documentation.\n\n    All parameters will be passed as-is to [requests.Session.request][], expected those\n    described below which have a special behavior.\n\n    Args:\n      path: the url where the request will be sent to. Can be:\n\n        - a path, as `str`: that path will be joined to the configured API url,\n        - an iterable of path segments: that will be joined to the root url.\n      raise_for_status: like the parameter of the same name from\n        [ApiClient][requests_oauth2client.api_client.ApiClient],\n        but this will be applied for this request only.\n      none_fields: like the parameter of the same name from\n        [ApiClient][requests_oauth2client.api_client.ApiClient],\n        but this will be applied for this request only.\n      bool_fields: like the parameter of the same name from\n        [ApiClient][requests_oauth2client.api_client.ApiClient],\n        but this will be applied for this request only.\n\n    Returns:\n      a Response as returned by requests\n\n    Raises:\n        InvalidBoolFieldsParam: if the provided `bool_fields` parameter is invalid.\n\n    \"\"\"\n    path = self.to_absolute_url(path)\n\n    if none_fields is None:\n        none_fields = self.none_fields\n\n    if none_fields == \"exclude\":\n        if isinstance(data, Mapping):\n            data = {key: val for key, val in data.items() if val is not None}\n        if isinstance(json, Mapping):\n            json = {key: val for key, val in json.items() if val is not None}\n    elif none_fields == \"empty\":\n        if isinstance(data, Mapping):\n            data = {key: val if val is not None else \"\" for key, val in data.items()}\n        if isinstance(json, Mapping):\n            json = {key: val if val is not None else \"\" for key, val in json.items()}\n\n    if bool_fields is None:\n        bool_fields = self.bool_fields\n\n    if bool_fields:\n        true_value, false_value = validate_bool_fields(bool_fields)\n        if isinstance(data, MutableMapping):\n            for key, val in data.items():\n                if val is True:\n                    data[key] = true_value\n                elif val is False:\n                    data[key] = false_value\n        if isinstance(params, MutableMapping):\n            for key, val in params.items():\n                if val is True:\n                    params[key] = true_value\n                elif val is False:\n                    params[key] = false_value\n\n    timeout = timeout or self.timeout\n\n    response = self.session.request(\n        method,\n        path,\n        params=params,\n        data=data,\n        headers=headers,\n        cookies=cookies,\n        files=files,\n        auth=auth or self.auth,\n        timeout=timeout,\n        allow_redirects=allow_redirects,\n        proxies=proxies,\n        hooks=hooks,\n        stream=stream,\n        verify=verify,\n        cert=cert,\n        json=json,\n    )\n\n    if raise_for_status is None:\n        raise_for_status = self.raise_for_status\n    if raise_for_status:\n        response.raise_for_status()\n    return response\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.to_absolute_url","title":"<code>to_absolute_url(path=None)</code>","text":"<p>Convert a relative url to an absolute url.</p> <p>Given a <code>path</code>, return the matching absolute url, based on the <code>base_url</code> that is configured for this API.</p> <p>The result of this method is different from a standard <code>urljoin()</code>, because a relative_url that starts with a \"/\" will not override the path from the base url. You can also pass an iterable of path parts as relative url, which will be properly joined with \"/\". Those parts may be <code>str</code> (which will be urlencoded) or <code>bytes</code> (which will be decoded as UTF-8 first) or any other type (which will be converted to <code>str</code> first, using the <code>str() function</code>). See the table below for example results which would exhibit most cases:</p> base_url relative_url result_url <code>\"https://myhost.com/root\"</code> <code>\"/path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>\"/path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>b\"/path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>\"path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>None</code> <code>\"https://myhost.com/root\"</code> <code>\"https://myhost.com/root\"</code> <code>(\"user\", 1, \"resource\")</code> <code>\"https://myhost.com/root/user/1/resource\"</code> <code>\"https://myhost.com/root\"</code> <code>\"https://otherhost.org/foo\"</code> <code>ValueError</code> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>a relative url</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the resulting absolute url</p> <p>Raises:</p> Type Description <code>InvalidPathParam</code> <p>if the provided path does not allow constructing a valid url</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def to_absolute_url(self, path: None | str | bytes | Iterable[str | bytes | int] = None) -&gt; str:\n    \"\"\"Convert a relative url to an absolute url.\n\n    Given a `path`, return the matching absolute url, based on the `base_url` that is\n    configured for this API.\n\n    The result of this method is different from a standard `urljoin()`, because a relative_url\n    that starts with a \"/\" will not override the path from the base url. You can also pass an\n    iterable of path parts as relative url, which will be properly joined with \"/\". Those parts\n    may be `str` (which will be urlencoded) or `bytes` (which will be decoded as UTF-8 first) or\n    any other type (which will be converted to `str` first, using the `str() function`). See the\n    table below for example results which would exhibit most cases:\n\n    | base_url | relative_url | result_url |\n    |---------------------------|-----------------------------|-------------------------------------------|\n    | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `b\"/path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `\"path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `None` | `\"https://myhost.com/root\"` |\n    | `\"https://myhost.com/root\"` |  `(\"user\", 1, \"resource\")` | `\"https://myhost.com/root/user/1/resource\"` |\n    | `\"https://myhost.com/root\"` | `\"https://otherhost.org/foo\"` | `ValueError` |\n\n    Args:\n      path: a relative url\n\n    Returns:\n      the resulting absolute url\n\n    Raises:\n        InvalidPathParam: if the provided path does not allow constructing a valid url\n\n    \"\"\"\n    url = path\n\n    if url is None:\n        url = self.base_url\n    else:\n        if not isinstance(url, (str, bytes)):\n            try:\n                url = \"/\".join(\n                    [urlencode(part.decode() if isinstance(part, bytes) else str(part)) for part in url if part],\n                )\n            except Exception as exc:\n                raise InvalidPathParam(url) from exc\n\n        if isinstance(url, bytes):\n            url = url.decode()\n\n        if \"://\" in url:\n            raise InvalidPathParam(url)\n\n        url = urljoin(self.base_url + \"/\", url.lstrip(\"/\"))\n\n    if url is None or not isinstance(url, str):\n        raise InvalidPathParam(url)  # pragma: no cover\n\n    return url\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.get","title":"<code>get(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a GET request and return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def get(\n    self,\n    path: None | str | bytes | Iterable[str | bytes | int] = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a GET request and return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n        path: the path where the request will be sent.\n        raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n        **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n        a response object.\n\n    Raises:\n        requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"GET\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.post","title":"<code>post(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a POST request and return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def post(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a POST request and return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n      a response object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"POST\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.patch","title":"<code>patch(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a PATCH request. Return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def patch(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a PATCH request. Return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"PATCH\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.put","title":"<code>put(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a PUT request. Return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def put(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a PUT request. Return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"PUT\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.delete","title":"<code>delete(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a DELETE request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def delete(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a DELETE request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time. It takes the same\n    parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`.\n\n    Returns:\n      a response object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"DELETE\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidBoolFieldsParam","title":"<code>InvalidBoolFieldsParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an invalid value is passed as 'bool_fields' parameter.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>class InvalidBoolFieldsParam(ValueError):\n    \"\"\"Raised when an invalid value is passed as 'bool_fields' parameter.\"\"\"\n\n    def __init__(self, bool_fields: object) -&gt; None:\n        super().__init__(\"\"\"\\\nInvalid value for `bool_fields` parameter. It must be an iterable of 2 `str` values:\n- first one for the `True` value,\n- second one for the `False` value.\nBoolean fields in `data` or `params` with a boolean value (`True` or `False`)\nwill be serialized to the corresponding value.\nDefault is `('true', 'false')`\nUse this parameter when the target API expects some other values, e.g.:\n- ('on', 'off')\n- ('1', '0')\n- ('yes', 'no')\n\"\"\")\n        self.value = bool_fields\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidPathParam","title":"<code>InvalidPathParam</code>","text":"<p>               Bases: <code>TypeError</code>, <code>ValueError</code></p> <p>Raised when an unexpected path is passed as 'url' parameter.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>class InvalidPathParam(TypeError, ValueError):\n    \"\"\"Raised when an unexpected path is passed as 'url' parameter.\"\"\"\n\n    def __init__(self, path: None | str | bytes | Iterable[str | bytes | int]) -&gt; None:\n        super().__init__(\"\"\"\\\nUnexpected path. Please provide a path that is relative to the configured `base_url`:\n- `None` (default) to call the base_url\n- a `str` or `bytes`, that will be joined to the base_url (with a / separator, if required)\n- or an iterable of string-able objects, which will be joined to the base_url with / separators\n\"\"\")\n        self.url = path\n</code></pre>"},{"location":"api/#requests_oauth2client.NonRenewableTokenError","title":"<code>NonRenewableTokenError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when attempting to renew a token non-interactively when missing renewing material.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class NonRenewableTokenError(Exception):\n    \"\"\"Raised when attempting to renew a token non-interactively when missing renewing material.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2AccessTokenAuth","title":"<code>OAuth2AccessTokenAuth</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Authentication Handler for OAuth 2.0 Access Tokens and (optional) Refresh Tokens.</p> <p>This Requests Auth handler implementation uses an access token as Bearer or DPoP token, and can automatically refresh it when expired, if a refresh token is available.</p> <p>Token can be a simple <code>str</code> containing a raw access token value, or a BearerToken that can contain a <code>refresh_token</code>.</p> <p>In addition to adding a properly formatted <code>Authorization</code> header, this will obtain a new token once the current token is expired. Expiration is detected based on the <code>expires_in</code> hint returned by the AS. A configurable <code>leeway</code>, in number of seconds, will make sure that a new token is obtained some seconds before the actual expiration is reached. This may help in situations where the client, AS and RS have slightly offset clocks.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the client to use to refresh tokens.</p> required <code>token</code> <code>str | BearerToken</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> required <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds.</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import BearerToken, OAuth2Client, OAuth2AccessTokenAuth, requests\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n# obtain a BearerToken any way you see fit, optionally including a refresh token\n# for this example, the token value is hardcoded\ntoken = BearerToken(access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\")\nauth = OAuth2AccessTokenAuth(client, token, scope=\"my_scope\")\nresp = requests.post(\"https://my.api.local/resource\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2AccessTokenAuth(requests.auth.AuthBase):\n    \"\"\"Authentication Handler for OAuth 2.0 Access Tokens and (optional) Refresh Tokens.\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation uses an access token as\n    Bearer or DPoP token, and can automatically refresh it when expired, if a refresh token is available.\n\n    Token can be a simple `str` containing a raw access token value, or a\n    [BearerToken][requests_oauth2client.tokens.BearerToken] that can contain a `refresh_token`.\n\n    In addition to adding a properly formatted `Authorization` header, this will obtain a new token\n    once the current token is expired. Expiration is detected based on the `expires_in` hint\n    returned by the AS. A configurable `leeway`, in number of seconds, will make sure that a new\n    token is obtained some seconds before the actual expiration is reached. This may help in\n    situations where the client, AS and RS have slightly offset clocks.\n\n    Args:\n        client: the client to use to refresh tokens.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds.\n        **token_kwargs: additional kwargs to pass to the token endpoint.\n\n    Example:\n        ```python\n        from requests_oauth2client import BearerToken, OAuth2Client, OAuth2AccessTokenAuth, requests\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        # obtain a BearerToken any way you see fit, optionally including a refresh token\n        # for this example, the token value is hardcoded\n        token = BearerToken(access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\")\n        auth = OAuth2AccessTokenAuth(client, token, scope=\"my_scope\")\n        resp = requests.post(\"https://my.api.local/resource\", auth=auth)\n        ```\n\n    \"\"\"\n\n    client: OAuth2Client = field(on_setattr=setters.frozen)\n    token: BearerToken | None\n    leeway: int = field(on_setattr=setters.frozen)\n    token_kwargs: dict[str, Any] = field(on_setattr=setters.frozen)\n\n    def __init__(\n        self, client: OAuth2Client, token: str | BearerToken, *, leeway: int = 20, **token_kwargs: Any\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(client=client, token=token, leeway=leeway, token_kwargs=token_kwargs)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the Access Token to the request.\n\n        If Access Token is not specified or expired, obtain a new one first.\n\n        Raises:\n            NonRenewableTokenError: if the token is not renewable\n\n        \"\"\"\n        if self.token is None or self.token.is_expired(self.leeway):\n            self.renew_token()\n        if self.token is None:\n            raise NonRenewableTokenError  # pragma: no cover\n        return self.token(request)\n\n    def renew_token(self) -&gt; None:\n        \"\"\"Obtain a new Bearer Token.\n\n        This will try to use the `refresh_token`, if there is one.\n\n        \"\"\"\n        if self.token is not None and self.token.refresh_token is not None:\n            self.token = self.client.refresh_token(refresh_token=self.token, **self.token_kwargs)\n\n    def forget_token(self) -&gt; None:\n        \"\"\"Forget the current token, forcing a renewal on the next HTTP request.\"\"\"\n        self.token = None\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2AccessTokenAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new Bearer Token.</p> <p>This will try to use the <code>refresh_token</code>, if there is one.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def renew_token(self) -&gt; None:\n    \"\"\"Obtain a new Bearer Token.\n\n    This will try to use the `refresh_token`, if there is one.\n\n    \"\"\"\n    if self.token is not None and self.token.refresh_token is not None:\n        self.token = self.client.refresh_token(refresh_token=self.token, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2AccessTokenAuth.forget_token","title":"<code>forget_token()</code>","text":"<p>Forget the current token, forcing a renewal on the next HTTP request.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def forget_token(self) -&gt; None:\n    \"\"\"Forget the current token, forcing a renewal on the next HTTP request.\"\"\"\n    self.token = None\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2AuthorizationCodeAuth","title":"<code>OAuth2AuthorizationCodeAuth</code>","text":"<p>               Bases: <code>OAuth2AccessTokenAuth</code></p> <p>Authentication handler for the Authorization Code grant.</p> <p>This Requests Auth handler implementation exchanges an Authorization Code for an access token, then automatically refreshes it once it is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the client to use to obtain Access Tokens.</p> required <code>code</code> <code>str | AuthorizationResponse | None</code> <p>an Authorization Code that has been obtained from the AS.</p> required <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds.</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import ApiClient, OAuth2Client, OAuth2AuthorizationCodeAuth\n\nclient = OAuth2Client(token_endpoint=\"https://myas.local/token\", auth=(\"client_id\", \"client_secret\"))\ncode = \"my_code\"  # you must obtain this code yourself\napi = ApiClient(\"https://my.api.local/resource\", auth=OAuth2AuthorizationCodeAuth(client, code))\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2AuthorizationCodeAuth(OAuth2AccessTokenAuth):  # type: ignore[override]\n    \"\"\"Authentication handler for the [Authorization Code grant](https://www.rfc-editor.org/rfc/rfc6749#section-4.1).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges an Authorization\n    Code for an access token, then automatically refreshes it once it is expired.\n\n    Args:\n        client: the client to use to obtain Access Tokens.\n        code: an Authorization Code that has been obtained from the AS.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds.\n        **token_kwargs: additional kwargs to pass to the token endpoint.\n\n    Example:\n        ```python\n        from requests_oauth2client import ApiClient, OAuth2Client, OAuth2AuthorizationCodeAuth\n\n        client = OAuth2Client(token_endpoint=\"https://myas.local/token\", auth=(\"client_id\", \"client_secret\"))\n        code = \"my_code\"  # you must obtain this code yourself\n        api = ApiClient(\"https://my.api.local/resource\", auth=OAuth2AuthorizationCodeAuth(client, code))\n        ```\n\n    \"\"\"\n\n    code: str | AuthorizationResponse | None\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        code: str | AuthorizationResponse | None,\n        *,\n        leeway: int = 20,\n        token: str | BearerToken | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(\n            client=client,\n            token=token,\n            code=code,\n            leeway=leeway,\n            token_kwargs=token_kwargs,\n        )\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the Authorization Code grant as an Authentication Handler.\n\n        This exchanges an Authorization Code for an access token and adds it in the request.\n\n        Args:\n            request: the request\n\n        Returns:\n            the request, with an Access Token added in Authorization Header\n\n        \"\"\"\n        if self.token is None or self.token.is_expired():\n            self.exchange_code_for_token()\n        return super().__call__(request)\n\n    def exchange_code_for_token(self) -&gt; None:\n        \"\"\"Exchange the authorization code for an access token.\"\"\"\n        if self.code:  # pragma: no branch\n            self.token = self.client.authorization_code(code=self.code, **self.token_kwargs)\n            self.code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2AuthorizationCodeAuth.exchange_code_for_token","title":"<code>exchange_code_for_token()</code>","text":"<p>Exchange the authorization code for an access token.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def exchange_code_for_token(self) -&gt; None:\n    \"\"\"Exchange the authorization code for an access token.\"\"\"\n    if self.code:  # pragma: no branch\n        self.token = self.client.authorization_code(code=self.code, **self.token_kwargs)\n        self.code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2ClientCredentialsAuth","title":"<code>OAuth2ClientCredentialsAuth</code>","text":"<p>               Bases: <code>OAuth2AccessTokenAuth</code></p> <p>An Auth Handler for the Client Credentials grant.</p> <p>This requests AuthBase automatically gets Access Tokens from an OAuth 2.0 Token Endpoint with the Client Credentials grant, and will get a new one once the current one is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>extra kw parameters to pass to the Token Endpoint. May include <code>scope</code>, <code>resource</code>, etc.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import OAuth2Client, OAuth2ClientCredentialsAuth, requests\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\noauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\")\nresp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2ClientCredentialsAuth(OAuth2AccessTokenAuth):\n    \"\"\"An Auth Handler for the [Client Credentials grant](https://www.rfc-editor.org/rfc/rfc6749#section-4.4).\n\n    This [requests AuthBase][requests.auth.AuthBase] automatically gets Access Tokens from an OAuth\n    2.0 Token Endpoint with the Client Credentials grant, and will get a new one once the current\n    one is expired.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds\n        **token_kwargs: extra kw parameters to pass to the Token Endpoint. May include `scope`, `resource`, etc.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, OAuth2ClientCredentialsAuth, requests\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        oauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\")\n        resp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc)\n        ```\n\n    \"\"\"\n\n    def __init__(\n        self, client: OAuth2Client, *, leeway: int = 20, token: str | BearerToken | None = None, **token_kwargs: Any\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(client=client, token=token, leeway=leeway, token_kwargs=token_kwargs)\n\n    @override\n    def renew_token(self) -&gt; None:\n        \"\"\"Obtain a new token for use within this Auth Handler.\"\"\"\n        self.token = self.client.client_credentials(**self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2ClientCredentialsAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new token for use within this Auth Handler.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@override\ndef renew_token(self) -&gt; None:\n    \"\"\"Obtain a new token for use within this Auth Handler.\"\"\"\n    self.token = self.client.client_credentials(**self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2DeviceCodeAuth","title":"<code>OAuth2DeviceCodeAuth</code>","text":"<p>               Bases: <code>OAuth2AccessTokenAuth</code></p> <p>Authentication Handler for the Device Code Flow.</p> <p>This Requests Auth handler implementation exchanges a Device Code for an Access Token, then automatically refreshes it once it is expired.</p> <p>It needs a Device Code and an OAuth2Client to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a Device Code obtained from the AS.</p> required <code>interval</code> <code>int</code> <p>the interval to use to pool the Token Endpoint, in seconds.</p> <code>5</code> <code>expires_in</code> <code>int</code> <p>the lifetime of the token, in seconds.</p> <code>360</code> <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds.</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import OAuth2Client, OAuth2DeviceCodeAuth, requests\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\ndevice_code = client.device_authorization()\nauth = OAuth2DeviceCodeAuth(client, device_code)\nresp = requests.post(\"https://my.api.local/resource\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2DeviceCodeAuth(OAuth2AccessTokenAuth):  # type: ignore[override]\n    \"\"\"Authentication Handler for the [Device Code Flow](https://www.rfc-editor.org/rfc/rfc8628).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges a Device Code for\n    an Access Token, then automatically refreshes it once it is expired.\n\n    It needs a Device Code and an [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be\n    able to get a token from the AS Token Endpoint just before the first request using this Auth\n    Handler is being sent.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        device_code: a Device Code obtained from the AS.\n        interval: the interval to use to pool the Token Endpoint, in seconds.\n        expires_in: the lifetime of the token, in seconds.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds.\n        **token_kwargs: additional kwargs to pass to the token endpoint.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, OAuth2DeviceCodeAuth, requests\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        device_code = client.device_authorization()\n        auth = OAuth2DeviceCodeAuth(client, device_code)\n        resp = requests.post(\"https://my.api.local/resource\", auth=auth)\n        ```\n\n    \"\"\"\n\n    device_code: str | DeviceAuthorizationResponse | None\n    interval: int\n    expires_in: int\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        *,\n        device_code: str | DeviceAuthorizationResponse,\n        leeway: int = 20,\n        interval: int = 5,\n        expires_in: int = 360,\n        token: str | BearerToken | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(\n            client=client,\n            token=token,\n            leeway=leeway,\n            token_kwargs=token_kwargs,\n            device_code=device_code,\n            interval=interval,\n            expires_in=expires_in,\n        )\n\n    @override\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the Device Code grant as a request Authentication Handler.\n\n        This exchanges a Device Code for an access token and adds it in HTTP requests.\n\n        Args:\n            request: a [requests.PreparedRequest][]\n\n        Returns:\n            a [requests.PreparedRequest][] with an Access Token added in Authorization Header\n\n        \"\"\"\n        if self.token is None:\n            self.exchange_device_code_for_token()\n        return super().__call__(request)\n\n    def exchange_device_code_for_token(self) -&gt; None:\n        \"\"\"Exchange the Device Code for an access token.\n\n        This will poll the Token Endpoint until the user finishes the authorization process.\n\n        \"\"\"\n        from .device_authorization import DeviceAuthorizationPoolingJob\n\n        if self.device_code:  # pragma: no branch\n            pooling_job = DeviceAuthorizationPoolingJob(\n                client=self.client,\n                device_code=self.device_code,\n                interval=self.interval,\n            )\n            token = None\n            while token is None:\n                token = pooling_job()\n            self.token = token\n            self.device_code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2DeviceCodeAuth.exchange_device_code_for_token","title":"<code>exchange_device_code_for_token()</code>","text":"<p>Exchange the Device Code for an access token.</p> <p>This will poll the Token Endpoint until the user finishes the authorization process.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def exchange_device_code_for_token(self) -&gt; None:\n    \"\"\"Exchange the Device Code for an access token.\n\n    This will poll the Token Endpoint until the user finishes the authorization process.\n\n    \"\"\"\n    from .device_authorization import DeviceAuthorizationPoolingJob\n\n    if self.device_code:  # pragma: no branch\n        pooling_job = DeviceAuthorizationPoolingJob(\n            client=self.client,\n            device_code=self.device_code,\n            interval=self.interval,\n        )\n        token = None\n        while token is None:\n            token = pooling_job()\n        self.token = token\n        self.device_code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2ResourceOwnerPasswordAuth","title":"<code>OAuth2ResourceOwnerPasswordAuth</code>","text":"<p>               Bases: <code>OAuth2AccessTokenAuth</code></p> <p>Authentication Handler for the Resource Owner Password Credentials Flow.</p> <p>This Requests Auth handler implementation exchanges the user credentials for an Access Token, then automatically repeats the process to get a new one once the current one is expired.</p> <p>Note that this flow is considered deprecated, and the Authorization Code flow should be used whenever possible. Among other bad things, ROPC:</p> <ul> <li>does not support SSO between multiple apps,</li> <li>does not support MFA or risk-based adaptative authentication,</li> <li>depends on the user typing its credentials directly inside the application, instead of on a dedicated, centralized login page managed by the AS, which makes it totally insecure for 3rd party apps.</li> </ul> <p>It needs the username and password and an OAuth2Client to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the client to use to obtain Access Tokens</p> required <code>username</code> <code>str</code> <p>the username</p> required <code>password</code> <code>str</code> <p>the user password</p> required <code>leeway</code> <code>int</code> <p>an amount of time, in seconds</p> <code>20</code> <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint</p> <code>{}</code> Example <pre><code>from requests_oauth2client import ApiClient, OAuth2Client, OAuth2ResourceOwnerPasswordAuth\n\nclient = OAuth2Client(\n    token_endpoint=\"https://myas.local/token\",\n    auth=(\"client_id\", \"client_secret\"),\n)\nusername = \"my_username\"\npassword = \"my_password\"  # you must obtain those credentials from the user\nauth = OAuth2ResourceOwnerPasswordAuth(client, username=username, password=password)\napi = ApiClient(\"https://myapi.local\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2ResourceOwnerPasswordAuth(OAuth2AccessTokenAuth):  # type: ignore[override]\n    \"\"\"Authentication Handler for the [Resource Owner Password Credentials Flow](https://www.rfc-editor.org/rfc/rfc6749#section-4.3).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges the user\n    credentials for an Access Token, then automatically repeats the process to get a new one\n    once the current one is expired.\n\n    Note that this flow is considered *deprecated*, and the Authorization Code flow should be\n    used whenever possible.\n    Among other bad things, ROPC:\n\n    - does not support SSO between multiple apps,\n    - does not support MFA or risk-based adaptative authentication,\n    - depends on the user typing its credentials directly inside the application, instead of on a\n    dedicated, centralized login page managed by the AS, which makes it totally insecure for 3rd party apps.\n\n    It needs the username and password and an\n    [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be able to get a token from\n    the AS Token Endpoint just before the first request using this Auth Handler is being sent.\n\n    Args:\n        client: the client to use to obtain Access Tokens\n        username: the username\n        password: the user password\n        leeway: an amount of time, in seconds\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        **token_kwargs: additional kwargs to pass to the token endpoint\n\n    Example:\n        ```python\n        from requests_oauth2client import ApiClient, OAuth2Client, OAuth2ResourceOwnerPasswordAuth\n\n        client = OAuth2Client(\n            token_endpoint=\"https://myas.local/token\",\n            auth=(\"client_id\", \"client_secret\"),\n        )\n        username = \"my_username\"\n        password = \"my_password\"  # you must obtain those credentials from the user\n        auth = OAuth2ResourceOwnerPasswordAuth(client, username=username, password=password)\n        api = ApiClient(\"https://myapi.local\", auth=auth)\n        ```\n    \"\"\"\n\n    username: str\n    password: str\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        *,\n        username: str,\n        password: str,\n        leeway: int = 20,\n        token: str | BearerToken | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(\n            client=client,\n            token=token,\n            leeway=leeway,\n            token_kwargs=token_kwargs,\n            username=username,\n            password=password,\n        )\n\n    @override\n    def renew_token(self) -&gt; None:\n        \"\"\"Exchange the user credentials for an Access Token.\"\"\"\n        self.token = self.client.resource_owner_password(\n            username=self.username,\n            password=self.password,\n            **self.token_kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2ResourceOwnerPasswordAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Exchange the user credentials for an Access Token.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@override\ndef renew_token(self) -&gt; None:\n    \"\"\"Exchange the user credentials for an Access Token.\"\"\"\n    self.token = self.client.resource_owner_password(\n        username=self.username,\n        password=self.password,\n        **self.token_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest","title":"<code>AuthorizationRequest</code>","text":"<p>Represent an Authorization Request.</p> <p>This class makes it easy to generate valid Authorization Request URI (possibly including a state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization Response.</p> <p>All parameters passed at init time will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour:</p> <ul> <li><code>state</code>: if <code>...</code> (default), a random <code>state</code> parameter will be generated for you.   You may pass your own <code>state</code> as <code>str</code>, or set it to <code>None</code> so that the <code>state</code> parameter   will not be included in the request. You may access that state in the <code>state</code> attribute   from this request.</li> <li><code>nonce</code>: if <code>...</code> (default) and <code>scope</code> includes 'openid', a random <code>nonce</code> will be   generated and included in the request. You may access that <code>nonce</code> in the <code>nonce</code> attribute   from this request.</li> <li><code>code_verifier</code>: if <code>None</code>, and <code>code_challenge_method</code> is <code>'S256'</code> or <code>'plain'</code>,   a valid <code>code_challenge</code> and <code>code_verifier</code> for PKCE will be automatically generated,   and the <code>code_challenge</code> will be included in the request.   You may pass your own <code>code_verifier</code> as a <code>str</code> parameter, in which case the   appropriate <code>code_challenge</code> will be included in the request, according to the   <code>code_challenge_method</code>.</li> <li> <p><code>authorization_response_iss_parameter_supported</code> and <code>issuer</code>:    those are used for Server Issuer Identification. By default:</p> <ul> <li>If <code>\u00ecssuer</code> is set and an issuer is included in the Authorization Response, then the consistency between those 2 values will be checked when using <code>validate_callback()</code>.</li> <li>If issuer is not included in the response, then no issuer check is performed.</li> </ul> <p>Set <code>authorization_response_iss_parameter_supported</code> to <code>True</code> to enforce server identification:</p> <ul> <li>an <code>issuer</code> must also be provided as parameter, and the AS must return that same value for the response to be considered valid by <code>validate_callback()</code>.</li> <li>if no issuer is included in the Authorization Response, then an error will be raised.</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the uri for the authorization endpoint.</p> required <code>client_id</code> <code>str</code> <p>the client_id to include in the request.</p> required <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri to include in the request. This is required in OAuth 2.0 and optional in OAuth 2.1. Pass <code>None</code> if you don't need any redirect_uri in the Authorization Request.</p> <code>None</code> <code>scope</code> <code>None | str | Iterable[str]</code> <p>the scope to include in the request, as an iterable of <code>str</code>, or a single space-separated <code>str</code>.</p> <code>'openid'</code> <code>response_type</code> <code>str</code> <p>the response type to include in the request.</p> <code>CODE</code> <code>state</code> <code>str | ellipsis | None</code> <p>the state to include in the request, or <code>...</code> to autogenerate one (default).</p> <code>...</code> <code>nonce</code> <code>str | ellipsis | None</code> <p>the nonce to include in the request, or <code>...</code> to autogenerate one (default).</p> <code>...</code> <code>code_verifier</code> <code>str | None</code> <p>the code verifier to include in the request. If left as <code>None</code> and <code>code_challenge_method</code> is set, a valid code_verifier will be generated.</p> <code>None</code> <code>code_challenge_method</code> <code>str | None</code> <p>the method to use to derive the <code>code_challenge</code> from the <code>code_verifier</code>.</p> <code>S256</code> <code>acr_values</code> <code>str | Iterable[str] | None</code> <p>requested Authentication Context Class Reference values.</p> <code>None</code> <code>issuer</code> <code>str | None</code> <p>Issuer Identifier value from the OAuth/OIDC Server, if using Server Issuer Identification.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>extra parameters to include in the request, as-is.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import AuthorizationRequest\n\nazr = AuthorizationRequest(\n    authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n    client_id=\"my_client_id\",\n    redirect_uri=\"http://localhost/callback\",\n    scope=\"openid email profile\",\n)\nprint(azr)\n</code></pre> <p>Raises:</p> Type Description <code>InvalidMaxAgeParam</code> <p>if the <code>max_age</code> parameter is invalid.</p> <code>MissingIssuerParam</code> <p>if <code>authorization_response_iss_parameter_supported</code> is set to <code>True</code> but the <code>issuer</code> parameter is not provided.</p> <code>UnsupportedResponseTypeParam</code> <p>if <code>response_type</code> is not supported.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False, repr=False)\nclass AuthorizationRequest:\n    \"\"\"Represent an Authorization Request.\n\n    This class makes it easy to generate valid Authorization Request URI (possibly including a\n    state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization\n    Response.\n\n    All parameters passed at init time will be included in the request query parameters as-is,\n    excepted for a few parameters which have a special behaviour:\n\n    - `state`: if `...` (default), a random `state` parameter will be generated for you.\n      You may pass your own `state` as `str`, or set it to `None` so that the `state` parameter\n      will not be included in the request. You may access that state in the `state` attribute\n      from this request.\n    - `nonce`: if `...` (default) and `scope` includes 'openid', a random `nonce` will be\n      generated and included in the request. You may access that `nonce` in the `nonce` attribute\n      from this request.\n    - `code_verifier`: if `None`, and `code_challenge_method` is `'S256'` or `'plain'`,\n      a valid `code_challenge` and `code_verifier` for PKCE will be automatically generated,\n      and the `code_challenge` will be included in the request.\n      You may pass your own `code_verifier` as a `str` parameter, in which case the\n      appropriate `code_challenge` will be included in the request, according to the\n      `code_challenge_method`.\n    - `authorization_response_iss_parameter_supported` and `issuer`:\n       those are used for Server Issuer Identification. By default:\n\n        - If `\u00ecssuer` is set and an issuer is included in the Authorization Response,\n        then the consistency between those 2 values will be checked when using `validate_callback()`.\n        - If issuer is not included in the response, then no issuer check is performed.\n\n        Set `authorization_response_iss_parameter_supported` to `True` to enforce server identification:\n\n        - an `issuer` must also be provided as parameter, and the AS must return that same value\n        for the response to be considered valid by `validate_callback()`.\n        - if no issuer is included in the Authorization Response, then an error will be raised.\n\n    Args:\n        authorization_endpoint: the uri for the authorization endpoint.\n        client_id: the client_id to include in the request.\n        redirect_uri: the redirect_uri to include in the request. This is required in OAuth 2.0 and optional\n            in OAuth 2.1. Pass `None` if you don't need any redirect_uri in the Authorization\n            Request.\n        scope: the scope to include in the request, as an iterable of `str`, or a single space-separated `str`.\n        response_type: the response type to include in the request.\n        state: the state to include in the request, or `...` to autogenerate one (default).\n        nonce: the nonce to include in the request, or `...` to autogenerate one (default).\n        code_verifier: the code verifier to include in the request.\n            If left as `None` and `code_challenge_method` is set, a valid code_verifier\n            will be generated.\n        code_challenge_method: the method to use to derive the `code_challenge` from the `code_verifier`.\n        acr_values: requested Authentication Context Class Reference values.\n        issuer: Issuer Identifier value from the OAuth/OIDC Server, if using Server Issuer Identification.\n        **kwargs: extra parameters to include in the request, as-is.\n\n    Example:\n        ```python\n        from requests_oauth2client import AuthorizationRequest\n\n        azr = AuthorizationRequest(\n            authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n            client_id=\"my_client_id\",\n            redirect_uri=\"http://localhost/callback\",\n            scope=\"openid email profile\",\n        )\n        print(azr)\n        ```\n\n    Raises:\n        InvalidMaxAgeParam: if the `max_age` parameter is invalid.\n        MissingIssuerParam: if `authorization_response_iss_parameter_supported` is set to `True`\n            but the `issuer` parameter is not provided.\n        UnsupportedResponseTypeParam: if `response_type` is not supported.\n\n    \"\"\"\n\n    authorization_endpoint: str\n\n    client_id: str = field(metadata={\"query\": True})\n    redirect_uri: str | None = field(metadata={\"query\": True})\n    scope: tuple[str, ...] | None = field(metadata={\"query\": True})\n    response_type: str = field(metadata={\"query\": True})\n    state: str | None = field(metadata={\"query\": True})\n    nonce: str | None = field(metadata={\"query\": True})\n    code_challenge_method: str | None = field(metadata={\"query\": True})\n    acr_values: tuple[str, ...] | None = field(metadata={\"query\": True})\n    max_age: int | None = field(metadata={\"query\": True})\n    kwargs: dict[str, Any]\n\n    code_verifier: str | None\n    authorization_response_iss_parameter_supported: bool\n    issuer: str | None\n\n    dpop_key: DPoPKey | None = None\n\n    exception_classes: ClassVar[dict[str, type[AuthorizationResponseError]]] = {\n        \"interaction_required\": InteractionRequired,\n        \"login_required\": LoginRequired,\n        \"session_selection_required\": SessionSelectionRequired,\n        \"consent_required\": ConsentRequired,\n    }\n\n    @classmethod\n    def generate_state(cls) -&gt; str:\n        \"\"\"Generate a random `state` parameter.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    @classmethod\n    def generate_nonce(cls) -&gt; str:\n        \"\"\"Generate a random `nonce`.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    def __init__(  # noqa: PLR0913, C901\n        self,\n        authorization_endpoint: str,\n        *,\n        client_id: str,\n        redirect_uri: str | None = None,\n        scope: None | str | Iterable[str] = \"openid\",\n        response_type: str = ResponseTypes.CODE,\n        state: str | ellipsis | None = ...,  # noqa: F821\n        nonce: str | ellipsis | None = ...,  # noqa: F821\n        code_verifier: str | None = None,\n        code_challenge_method: str | None = CodeChallengeMethods.S256,\n        acr_values: str | Iterable[str] | None = None,\n        max_age: int | None = None,\n        issuer: str | None = None,\n        authorization_response_iss_parameter_supported: bool = False,\n        dpop: bool = False,\n        dpop_alg: str = SignatureAlgs.ES256,\n        dpop_key: DPoPKey | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        if response_type != ResponseTypes.CODE:\n            raise UnsupportedResponseTypeParam(response_type)\n\n        if authorization_response_iss_parameter_supported and not issuer:\n            raise MissingIssuerParam\n\n        if state is ...:\n            state = self.generate_state()\n        if state is not None and not isinstance(state, str):\n            state = str(state)  # pragma: no cover\n\n        if nonce is ...:\n            nonce = self.generate_nonce() if scope is not None and \"openid\" in scope else None\n        if nonce is not None and not isinstance(nonce, str):\n            nonce = str(nonce)  # pragma: no cover\n\n        if not scope:\n            scope = None\n\n        if scope is not None:\n            scope = tuple(scope.split(\" \")) if isinstance(scope, str) else tuple(scope)\n\n        if acr_values is not None:\n            acr_values = tuple(acr_values.split()) if isinstance(acr_values, str) else tuple(acr_values)\n\n        if max_age is not None and max_age &lt; 0:\n            raise InvalidMaxAgeParam\n\n        if \"code_challenge\" in kwargs:\n            msg = (\n                \"A `code_challenge` must not be passed as parameter. Pass the `code_verifier`\"\n                \" instead, and the appropriate `code_challenge` will automatically be derived\"\n                \" from it and included in the request, based on `code_challenge_method`.\"\n            )\n            raise ValueError(msg)\n\n        if code_challenge_method:\n            if not code_verifier:\n                code_verifier = PkceUtils.generate_code_verifier()\n        else:\n            code_verifier = None\n\n        if dpop and not dpop_key:\n            dpop_key = DPoPKey.generate(dpop_alg)\n\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            redirect_uri=redirect_uri,\n            issuer=issuer,\n            response_type=response_type,\n            scope=scope,\n            state=state,\n            nonce=nonce,\n            code_verifier=code_verifier,\n            code_challenge_method=code_challenge_method,\n            acr_values=acr_values,\n            max_age=max_age,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            dpop_key=dpop_key,\n            kwargs=kwargs,\n        )\n\n    @cached_property\n    def code_challenge(self) -&gt; str | None:\n        \"\"\"The `code_challenge` that matches `code_verifier` and `code_challenge_method`.\"\"\"\n        if self.code_verifier and self.code_challenge_method:\n            return PkceUtils.derive_challenge(self.code_verifier, self.code_challenge_method)\n        return None\n\n    @cached_property\n    def dpop_jkt(self) -&gt; str | None:\n        \"\"\"The DPoP JWK thumbprint that matches ``dpop_key`.\"\"\"\n        if self.dpop_key:\n            return self.dpop_key.dpop_jkt\n        return None\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the full argument dict.\n\n        This can be used to serialize this request and/or to initialize a similar request.\n\n        \"\"\"\n        d = asdict(self)\n        d.update(**d.pop(\"kwargs\", {}))\n        return d\n\n    @property\n    def args(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dict with all the query parameters from this AuthorizationRequest.\n\n        Returns:\n            a dict of parameters\n\n        \"\"\"\n        d = {field.name: getattr(self, field.name) for field in fields(type(self)) if field.metadata.get(\"query\")}\n        if d[\"scope\"]:\n            d[\"scope\"] = \" \".join(d[\"scope\"])\n        d[\"code_challenge\"] = self.code_challenge\n        d[\"dpop_jkt\"] = self.dpop_jkt\n        d.update(self.kwargs)\n\n        return {key: val for key, val in d.items() if val is not None}\n\n    def validate_callback(self, response: str) -&gt; AuthorizationResponse:\n        \"\"\"Validate an Authorization Response against this Request.\n\n        Validate a given Authorization Response URI against this Authorization Request, and return\n        an [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse].\n\n        This includes matching the `state` parameter, checking for returned errors, and extracting\n        the returned `code` and other parameters.\n\n        Args:\n            response: the Authorization Response URI. This can be the full URL, or just the\n                query parameters (still encoded as x-www-form-urlencoded).\n\n        Returns:\n            the extracted code, if all checks are successful\n\n        Raises:\n            MissingAuthCode: if the `code` is missing in the response\n            MissingIssuer: if Server Issuer verification is active and the response does\n                not contain an `iss`.\n            MismatchingIssuer: if the 'iss' received from the response does not match the\n                expected value.\n            MismatchingState: if the response `state` does not match the expected value.\n            OAuth2Error: if the response includes an error.\n            MissingAuthCode: if the response does not contain a `code`.\n            UnsupportedResponseTypeParam: if response_type anything else than 'code'.\n\n        \"\"\"\n        try:\n            response_url = furl(response)\n        except ValueError:\n            return self.on_response_error(response)\n\n        # validate 'iss' according to RFC9207\n        received_issuer = response_url.args.get(\"iss\")\n        if self.authorization_response_iss_parameter_supported or received_issuer:\n            if received_issuer is None:\n                raise MissingIssuer(self, response)\n            if self.issuer and received_issuer != self.issuer:\n                raise MismatchingIssuer(self.issuer, received_issuer, self, response)\n\n        # validate state\n        requested_state = self.state\n        if requested_state:\n            received_state = response_url.args.get(\"state\")\n            if requested_state != received_state:\n                raise MismatchingState(requested_state, received_state, self, response)\n\n        error = response_url.args.get(\"error\")\n        if error:\n            return self.on_response_error(response)\n\n        if self.response_type == ResponseTypes.CODE:\n            code: str = response_url.args.get(\"code\")\n            if code is None:\n                raise MissingAuthCode(self, response)\n        else:\n            raise UnsupportedResponseTypeParam(self.response_type)  # pragma: no cover\n\n        return AuthorizationResponse(\n            code_verifier=self.code_verifier,\n            redirect_uri=self.redirect_uri,\n            nonce=self.nonce,\n            acr_values=self.acr_values,\n            max_age=self.max_age,\n            dpop_key=self.dpop_key,\n            **response_url.args,\n        )\n\n    def sign_request_jwt(\n        self,\n        jwk: Jwk | dict[str, Any],\n        alg: str | None = None,\n        lifetime: int | None = None,\n    ) -&gt; SignedJwt:\n        \"\"\"Sign the `request` object that matches this Authorization Request parameters.\n\n        Args:\n            jwk: the JWK to use to sign the request\n            alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n            lifetime: an optional number of seconds of validity for the signed request.\n                If present, `iat` an `exp` claims will be included in the signed JWT.\n\n        Returns:\n            a `Jwt` that contains the signed request object.\n\n        \"\"\"\n        claims = self.args\n        if lifetime:\n            claims[\"iat\"] = Jwt.timestamp()\n            claims[\"exp\"] = Jwt.timestamp(lifetime)\n        return Jwt.sign(\n            claims,\n            key=jwk,\n            alg=alg,\n        )\n\n    def sign(\n        self,\n        jwk: Jwk | dict[str, Any],\n        alg: str | None = None,\n        lifetime: int | None = None,\n        **kwargs: Any,\n    ) -&gt; RequestParameterAuthorizationRequest:\n        \"\"\"Sign this Authorization Request and return a new one.\n\n        This replaces all parameters with a signed `request` JWT.\n\n        Args:\n            jwk: the JWK to use to sign the request\n            alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, don't use an 'exp' claim.\n            kwargs: additional query parameters to include in the signed authorization request\n\n        Returns:\n            the signed Authorization Request\n\n        \"\"\"\n        request_jwt = self.sign_request_jwt(jwk, alg, lifetime)\n        return RequestParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request=str(request_jwt),\n            expires_at=request_jwt.expires_at,\n            **kwargs,\n        )\n\n    def sign_and_encrypt_request_jwt(\n        self,\n        sign_jwk: Jwk | dict[str, Any],\n        enc_jwk: Jwk | dict[str, Any],\n        sign_alg: str | None = None,\n        enc_alg: str | None = None,\n        enc: str = \"A128CBC-HS256\",\n        lifetime: int | None = None,\n    ) -&gt; JweCompact:\n        \"\"\"Sign and encrypt a `request` object for this Authorization Request.\n\n        The signed `request` will contain the same parameters as this AuthorizationRequest.\n\n        Args:\n            sign_jwk: the JWK to use to sign the request\n            enc_jwk: the JWK to use to encrypt the request\n            sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n            enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n            enc: the encoding to use to encrypt the request.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, do not include an 'exp' claim.\n\n        Returns:\n            the signed and encrypted request object, as a `jwskate.Jwt`\n\n        \"\"\"\n        claims = self.args\n        if lifetime:\n            claims[\"iat\"] = Jwt.timestamp()\n            claims[\"exp\"] = Jwt.timestamp(lifetime)\n        return Jwt.sign_and_encrypt(\n            claims=claims,\n            sign_key=sign_jwk,\n            sign_alg=sign_alg,\n            enc_key=enc_jwk,\n            enc_alg=enc_alg,\n            enc=enc,\n        )\n\n    def sign_and_encrypt(\n        self,\n        sign_jwk: Jwk | dict[str, Any],\n        enc_jwk: Jwk | dict[str, Any],\n        sign_alg: str | None = None,\n        enc_alg: str | None = None,\n        enc: str = \"A128CBC-HS256\",\n        lifetime: int | None = None,\n    ) -&gt; RequestParameterAuthorizationRequest:\n        \"\"\"Sign and encrypt the current Authorization Request.\n\n        This replaces all parameters with a matching `request` object.\n\n        Args:\n            sign_jwk: the JWK to use to sign the request\n            enc_jwk: the JWK to use to encrypt the request\n            sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n            enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n            enc: the encoding to use to encrypt the request.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, do not include an 'exp' claim.\n\n        Returns:\n            a `RequestParameterAuthorizationRequest`, with a request object as parameter\n\n        \"\"\"\n        request_jwt = self.sign_and_encrypt_request_jwt(\n            sign_jwk=sign_jwk,\n            enc_jwk=enc_jwk,\n            sign_alg=sign_alg,\n            enc_alg=enc_alg,\n            enc=enc,\n            lifetime=lifetime,\n        )\n        return RequestParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request=str(request_jwt),\n        )\n\n    def on_response_error(self, response: str) -&gt; AuthorizationResponse:\n        \"\"\"Error handler for Authorization Response errors.\n\n        Triggered by\n        [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback]\n        if the response uri contains an error.\n\n        Args:\n            response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n        Returns:\n            may return a default code that will be returned by `validate_callback`. But this method\n            will most likely raise exceptions instead.\n\n        Raises:\n            AuthorizationResponseError: if the response contains an `error`. The raised exception may be a subclass\n\n        \"\"\"\n        response_url = furl(response)\n        error = response_url.args.get(\"error\")\n        error_description = response_url.args.get(\"error_description\")\n        error_uri = response_url.args.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, AuthorizationResponseError)\n        raise exception_class(\n            request=self, response=response, error=error, description=error_description, uri=error_uri\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl`.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args=self.args,\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.code_challenge","title":"<code>code_challenge</code>  <code>cached</code> <code>property</code>","text":"<p>The <code>code_challenge</code> that matches <code>code_verifier</code> and <code>code_challenge_method</code>.</p>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.dpop_jkt","title":"<code>dpop_jkt</code>  <code>cached</code> <code>property</code>","text":"<p>The DPoP JWK thumbprint that matches <code>`dpop_key</code>.</p>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.args","title":"<code>args</code>  <code>property</code>","text":"<p>Return a dict with all the query parameters from this AuthorizationRequest.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>a dict of parameters</p>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.furl","title":"<code>furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code>.</p>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.uri","title":"<code>uri</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.generate_state","title":"<code>generate_state()</code>  <code>classmethod</code>","text":"<p>Generate a random <code>state</code> parameter.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_state(cls) -&gt; str:\n    \"\"\"Generate a random `state` parameter.\"\"\"\n    return secrets.token_urlsafe(32)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.generate_nonce","title":"<code>generate_nonce()</code>  <code>classmethod</code>","text":"<p>Generate a random <code>nonce</code>.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_nonce(cls) -&gt; str:\n    \"\"\"Generate a random `nonce`.\"\"\"\n    return secrets.token_urlsafe(32)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the full argument dict.</p> <p>This can be used to serialize this request and/or to initialize a similar request.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the full argument dict.\n\n    This can be used to serialize this request and/or to initialize a similar request.\n\n    \"\"\"\n    d = asdict(self)\n    d.update(**d.pop(\"kwargs\", {}))\n    return d\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.validate_callback","title":"<code>validate_callback(response)</code>","text":"<p>Validate an Authorization Response against this Request.</p> <p>Validate a given Authorization Response URI against this Authorization Request, and return an AuthorizationResponse.</p> <p>This includes matching the <code>state</code> parameter, checking for returned errors, and extracting the returned <code>code</code> and other parameters.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>the Authorization Response URI. This can be the full URL, or just the query parameters (still encoded as x-www-form-urlencoded).</p> required <p>Returns:</p> Type Description <code>AuthorizationResponse</code> <p>the extracted code, if all checks are successful</p> <p>Raises:</p> Type Description <code>MissingAuthCode</code> <p>if the <code>code</code> is missing in the response</p> <code>MissingIssuer</code> <p>if Server Issuer verification is active and the response does not contain an <code>iss</code>.</p> <code>MismatchingIssuer</code> <p>if the 'iss' received from the response does not match the expected value.</p> <code>MismatchingState</code> <p>if the response <code>state</code> does not match the expected value.</p> <code>OAuth2Error</code> <p>if the response includes an error.</p> <code>MissingAuthCode</code> <p>if the response does not contain a <code>code</code>.</p> <code>UnsupportedResponseTypeParam</code> <p>if response_type anything else than 'code'.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def validate_callback(self, response: str) -&gt; AuthorizationResponse:\n    \"\"\"Validate an Authorization Response against this Request.\n\n    Validate a given Authorization Response URI against this Authorization Request, and return\n    an [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse].\n\n    This includes matching the `state` parameter, checking for returned errors, and extracting\n    the returned `code` and other parameters.\n\n    Args:\n        response: the Authorization Response URI. This can be the full URL, or just the\n            query parameters (still encoded as x-www-form-urlencoded).\n\n    Returns:\n        the extracted code, if all checks are successful\n\n    Raises:\n        MissingAuthCode: if the `code` is missing in the response\n        MissingIssuer: if Server Issuer verification is active and the response does\n            not contain an `iss`.\n        MismatchingIssuer: if the 'iss' received from the response does not match the\n            expected value.\n        MismatchingState: if the response `state` does not match the expected value.\n        OAuth2Error: if the response includes an error.\n        MissingAuthCode: if the response does not contain a `code`.\n        UnsupportedResponseTypeParam: if response_type anything else than 'code'.\n\n    \"\"\"\n    try:\n        response_url = furl(response)\n    except ValueError:\n        return self.on_response_error(response)\n\n    # validate 'iss' according to RFC9207\n    received_issuer = response_url.args.get(\"iss\")\n    if self.authorization_response_iss_parameter_supported or received_issuer:\n        if received_issuer is None:\n            raise MissingIssuer(self, response)\n        if self.issuer and received_issuer != self.issuer:\n            raise MismatchingIssuer(self.issuer, received_issuer, self, response)\n\n    # validate state\n    requested_state = self.state\n    if requested_state:\n        received_state = response_url.args.get(\"state\")\n        if requested_state != received_state:\n            raise MismatchingState(requested_state, received_state, self, response)\n\n    error = response_url.args.get(\"error\")\n    if error:\n        return self.on_response_error(response)\n\n    if self.response_type == ResponseTypes.CODE:\n        code: str = response_url.args.get(\"code\")\n        if code is None:\n            raise MissingAuthCode(self, response)\n    else:\n        raise UnsupportedResponseTypeParam(self.response_type)  # pragma: no cover\n\n    return AuthorizationResponse(\n        code_verifier=self.code_verifier,\n        redirect_uri=self.redirect_uri,\n        nonce=self.nonce,\n        acr_values=self.acr_values,\n        max_age=self.max_age,\n        dpop_key=self.dpop_key,\n        **response_url.args,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.sign_request_jwt","title":"<code>sign_request_jwt(jwk, alg=None, lifetime=None)</code>","text":"<p>Sign the <code>request</code> object that matches this Authorization Request parameters.</p> <p>Parameters:</p> Name Type Description Default <code>jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>lifetime</code> <code>int | None</code> <p>an optional number of seconds of validity for the signed request. If present, <code>iat</code> an <code>exp</code> claims will be included in the signed JWT.</p> <code>None</code> <p>Returns:</p> Type Description <code>SignedJwt</code> <p>a <code>Jwt</code> that contains the signed request object.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_request_jwt(\n    self,\n    jwk: Jwk | dict[str, Any],\n    alg: str | None = None,\n    lifetime: int | None = None,\n) -&gt; SignedJwt:\n    \"\"\"Sign the `request` object that matches this Authorization Request parameters.\n\n    Args:\n        jwk: the JWK to use to sign the request\n        alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n        lifetime: an optional number of seconds of validity for the signed request.\n            If present, `iat` an `exp` claims will be included in the signed JWT.\n\n    Returns:\n        a `Jwt` that contains the signed request object.\n\n    \"\"\"\n    claims = self.args\n    if lifetime:\n        claims[\"iat\"] = Jwt.timestamp()\n        claims[\"exp\"] = Jwt.timestamp(lifetime)\n    return Jwt.sign(\n        claims,\n        key=jwk,\n        alg=alg,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.sign","title":"<code>sign(jwk, alg=None, lifetime=None, **kwargs)</code>","text":"<p>Sign this Authorization Request and return a new one.</p> <p>This replaces all parameters with a signed <code>request</code> JWT.</p> <p>Parameters:</p> Name Type Description Default <code>jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, don't use an 'exp' claim.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>additional query parameters to include in the signed authorization request</p> <code>{}</code> <p>Returns:</p> Type Description <code>RequestParameterAuthorizationRequest</code> <p>the signed Authorization Request</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign(\n    self,\n    jwk: Jwk | dict[str, Any],\n    alg: str | None = None,\n    lifetime: int | None = None,\n    **kwargs: Any,\n) -&gt; RequestParameterAuthorizationRequest:\n    \"\"\"Sign this Authorization Request and return a new one.\n\n    This replaces all parameters with a signed `request` JWT.\n\n    Args:\n        jwk: the JWK to use to sign the request\n        alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, don't use an 'exp' claim.\n        kwargs: additional query parameters to include in the signed authorization request\n\n    Returns:\n        the signed Authorization Request\n\n    \"\"\"\n    request_jwt = self.sign_request_jwt(jwk, alg, lifetime)\n    return RequestParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request=str(request_jwt),\n        expires_at=request_jwt.expires_at,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.sign_and_encrypt_request_jwt","title":"<code>sign_and_encrypt_request_jwt(sign_jwk, enc_jwk, sign_alg=None, enc_alg=None, enc='A128CBC-HS256', lifetime=None)</code>","text":"<p>Sign and encrypt a <code>request</code> object for this Authorization Request.</p> <p>The signed <code>request</code> will contain the same parameters as this AuthorizationRequest.</p> <p>Parameters:</p> Name Type Description Default <code>sign_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>enc_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to encrypt the request</p> required <code>sign_alg</code> <code>str | None</code> <p>the alg to use to sign the request, if <code>sign_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc_alg</code> <code>str | None</code> <p>the alg to use to encrypt the request, if <code>enc_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc</code> <code>str</code> <p>the encoding to use to encrypt the request.</p> <code>'A128CBC-HS256'</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.</p> <code>None</code> <p>Returns:</p> Type Description <code>JweCompact</code> <p>the signed and encrypted request object, as a <code>jwskate.Jwt</code></p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_and_encrypt_request_jwt(\n    self,\n    sign_jwk: Jwk | dict[str, Any],\n    enc_jwk: Jwk | dict[str, Any],\n    sign_alg: str | None = None,\n    enc_alg: str | None = None,\n    enc: str = \"A128CBC-HS256\",\n    lifetime: int | None = None,\n) -&gt; JweCompact:\n    \"\"\"Sign and encrypt a `request` object for this Authorization Request.\n\n    The signed `request` will contain the same parameters as this AuthorizationRequest.\n\n    Args:\n        sign_jwk: the JWK to use to sign the request\n        enc_jwk: the JWK to use to encrypt the request\n        sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n        enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n        enc: the encoding to use to encrypt the request.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, do not include an 'exp' claim.\n\n    Returns:\n        the signed and encrypted request object, as a `jwskate.Jwt`\n\n    \"\"\"\n    claims = self.args\n    if lifetime:\n        claims[\"iat\"] = Jwt.timestamp()\n        claims[\"exp\"] = Jwt.timestamp(lifetime)\n    return Jwt.sign_and_encrypt(\n        claims=claims,\n        sign_key=sign_jwk,\n        sign_alg=sign_alg,\n        enc_key=enc_jwk,\n        enc_alg=enc_alg,\n        enc=enc,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.sign_and_encrypt","title":"<code>sign_and_encrypt(sign_jwk, enc_jwk, sign_alg=None, enc_alg=None, enc='A128CBC-HS256', lifetime=None)</code>","text":"<p>Sign and encrypt the current Authorization Request.</p> <p>This replaces all parameters with a matching <code>request</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>sign_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>enc_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to encrypt the request</p> required <code>sign_alg</code> <code>str | None</code> <p>the alg to use to sign the request, if <code>sign_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc_alg</code> <code>str | None</code> <p>the alg to use to encrypt the request, if <code>enc_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc</code> <code>str</code> <p>the encoding to use to encrypt the request.</p> <code>'A128CBC-HS256'</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.</p> <code>None</code> <p>Returns:</p> Type Description <code>RequestParameterAuthorizationRequest</code> <p>a <code>RequestParameterAuthorizationRequest</code>, with a request object as parameter</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_and_encrypt(\n    self,\n    sign_jwk: Jwk | dict[str, Any],\n    enc_jwk: Jwk | dict[str, Any],\n    sign_alg: str | None = None,\n    enc_alg: str | None = None,\n    enc: str = \"A128CBC-HS256\",\n    lifetime: int | None = None,\n) -&gt; RequestParameterAuthorizationRequest:\n    \"\"\"Sign and encrypt the current Authorization Request.\n\n    This replaces all parameters with a matching `request` object.\n\n    Args:\n        sign_jwk: the JWK to use to sign the request\n        enc_jwk: the JWK to use to encrypt the request\n        sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n        enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n        enc: the encoding to use to encrypt the request.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, do not include an 'exp' claim.\n\n    Returns:\n        a `RequestParameterAuthorizationRequest`, with a request object as parameter\n\n    \"\"\"\n    request_jwt = self.sign_and_encrypt_request_jwt(\n        sign_jwk=sign_jwk,\n        enc_jwk=enc_jwk,\n        sign_alg=sign_alg,\n        enc_alg=enc_alg,\n        enc=enc,\n        lifetime=lifetime,\n    )\n    return RequestParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request=str(request_jwt),\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.on_response_error","title":"<code>on_response_error(response)</code>","text":"<p>Error handler for Authorization Response errors.</p> <p>Triggered by validate_callback() if the response uri contains an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>the Authorization Response URI. This can be the full URL, or just the query parameters.</p> required <p>Returns:</p> Type Description <code>AuthorizationResponse</code> <p>may return a default code that will be returned by <code>validate_callback</code>. But this method</p> <code>AuthorizationResponse</code> <p>will most likely raise exceptions instead.</p> <p>Raises:</p> Type Description <code>AuthorizationResponseError</code> <p>if the response contains an <code>error</code>. The raised exception may be a subclass</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def on_response_error(self, response: str) -&gt; AuthorizationResponse:\n    \"\"\"Error handler for Authorization Response errors.\n\n    Triggered by\n    [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback]\n    if the response uri contains an error.\n\n    Args:\n        response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n    Returns:\n        may return a default code that will be returned by `validate_callback`. But this method\n        will most likely raise exceptions instead.\n\n    Raises:\n        AuthorizationResponseError: if the response contains an `error`. The raised exception may be a subclass\n\n    \"\"\"\n    response_url = furl(response)\n    error = response_url.args.get(\"error\")\n    error_description = response_url.args.get(\"error_description\")\n    error_uri = response_url.args.get(\"error_uri\")\n    exception_class = self.exception_classes.get(error, AuthorizationResponseError)\n    raise exception_class(\n        request=self, response=response, error=error, description=error_description, uri=error_uri\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequestSerializer","title":"<code>AuthorizationRequestSerializer</code>","text":"<p>(De)Serializer for <code>AuthorizationRequest</code> instances.</p> <p>You might need to store pending authorization requests in session, either server-side or client- side. This class is here to help you do that.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class AuthorizationRequestSerializer:\n    \"\"\"(De)Serializer for `AuthorizationRequest` instances.\n\n    You might need to store pending authorization requests in session, either server-side or client- side. This class is\n    here to help you do that.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        dumper: Callable[[AuthorizationRequest], str] | None = None,\n        loader: Callable[[str], AuthorizationRequest] | None = None,\n    ) -&gt; None:\n        self.dumper = dumper or self.default_dumper\n        self.loader = loader or self.default_loader\n\n    @staticmethod\n    def default_dumper(azr: AuthorizationRequest) -&gt; str:\n        \"\"\"Provide a default dumper implementation.\n\n        Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as\n        base64url.\n\n        Args:\n            azr: the `AuthorizationRequest` to serialize\n\n        Returns:\n            the serialized value\n\n        \"\"\"\n        d = asdict(azr)\n        if azr.dpop_key:\n            d[\"dpop_key\"][\"private_key\"] = azr.dpop_key.private_key.to_dict()\n        d.update(**d.pop(\"kwargs\", {}))\n        return BinaPy.serialize_to(\"json\", d).to(\"deflate\").to(\"b64u\").ascii()\n\n    @staticmethod\n    def default_loader(\n        serialized: str,\n        azr_class: type[AuthorizationRequest] = AuthorizationRequest,\n    ) -&gt; AuthorizationRequest:\n        \"\"\"Provide a default deserializer implementation.\n\n        This does the opposite operations than `default_dumper`.\n\n        Args:\n            serialized: the serialized AuthorizationRequest\n            azr_class: the class to deserialize the Authorization Request to\n\n        Returns:\n            an AuthorizationRequest\n\n        \"\"\"\n        args = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n\n        if dpop_key := args.get(\"dpop_key\"):\n            dpop_key[\"private_key\"] = Jwk(dpop_key[\"private_key\"])\n            dpop_key.pop(\"jti_generator\", None)\n            dpop_key.pop(\"iat_generator\", None)\n            dpop_key.pop(\"dpop_token_class\", None)\n            args[\"dpop_key\"] = DPoPKey(**dpop_key)\n\n        return azr_class(**args)\n\n    def dumps(self, azr: AuthorizationRequest) -&gt; str:\n        \"\"\"Serialize and compress a given AuthorizationRequest for easier storage.\n\n        Args:\n            azr: an AuthorizationRequest to serialize\n\n        Returns:\n            the serialized AuthorizationRequest, as a str\n\n        \"\"\"\n        return self.dumper(azr)\n\n    def loads(self, serialized: str) -&gt; AuthorizationRequest:\n        \"\"\"Deserialize a serialized AuthorizationRequest.\n\n        Args:\n            serialized: the serialized AuthorizationRequest\n\n        Returns:\n            the deserialized AuthorizationRequest\n\n        \"\"\"\n        return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequestSerializer.default_dumper","title":"<code>default_dumper(azr)</code>  <code>staticmethod</code>","text":"<p>Provide a default dumper implementation.</p> <p>Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as base64url.</p> <p>Parameters:</p> Name Type Description Default <code>azr</code> <code>AuthorizationRequest</code> <p>the <code>AuthorizationRequest</code> to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized value</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@staticmethod\ndef default_dumper(azr: AuthorizationRequest) -&gt; str:\n    \"\"\"Provide a default dumper implementation.\n\n    Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as\n    base64url.\n\n    Args:\n        azr: the `AuthorizationRequest` to serialize\n\n    Returns:\n        the serialized value\n\n    \"\"\"\n    d = asdict(azr)\n    if azr.dpop_key:\n        d[\"dpop_key\"][\"private_key\"] = azr.dpop_key.private_key.to_dict()\n    d.update(**d.pop(\"kwargs\", {}))\n    return BinaPy.serialize_to(\"json\", d).to(\"deflate\").to(\"b64u\").ascii()\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequestSerializer.default_loader","title":"<code>default_loader(serialized, azr_class=AuthorizationRequest)</code>  <code>staticmethod</code>","text":"<p>Provide a default deserializer implementation.</p> <p>This does the opposite operations than <code>default_dumper</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized AuthorizationRequest</p> required <code>azr_class</code> <code>type[AuthorizationRequest]</code> <p>the class to deserialize the Authorization Request to</p> <code>AuthorizationRequest</code> <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>an AuthorizationRequest</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@staticmethod\ndef default_loader(\n    serialized: str,\n    azr_class: type[AuthorizationRequest] = AuthorizationRequest,\n) -&gt; AuthorizationRequest:\n    \"\"\"Provide a default deserializer implementation.\n\n    This does the opposite operations than `default_dumper`.\n\n    Args:\n        serialized: the serialized AuthorizationRequest\n        azr_class: the class to deserialize the Authorization Request to\n\n    Returns:\n        an AuthorizationRequest\n\n    \"\"\"\n    args = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n\n    if dpop_key := args.get(\"dpop_key\"):\n        dpop_key[\"private_key\"] = Jwk(dpop_key[\"private_key\"])\n        dpop_key.pop(\"jti_generator\", None)\n        dpop_key.pop(\"iat_generator\", None)\n        dpop_key.pop(\"dpop_token_class\", None)\n        args[\"dpop_key\"] = DPoPKey(**dpop_key)\n\n    return azr_class(**args)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequestSerializer.dumps","title":"<code>dumps(azr)</code>","text":"<p>Serialize and compress a given AuthorizationRequest for easier storage.</p> <p>Parameters:</p> Name Type Description Default <code>azr</code> <code>AuthorizationRequest</code> <p>an AuthorizationRequest to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized AuthorizationRequest, as a str</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def dumps(self, azr: AuthorizationRequest) -&gt; str:\n    \"\"\"Serialize and compress a given AuthorizationRequest for easier storage.\n\n    Args:\n        azr: an AuthorizationRequest to serialize\n\n    Returns:\n        the serialized AuthorizationRequest, as a str\n\n    \"\"\"\n    return self.dumper(azr)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequestSerializer.loads","title":"<code>loads(serialized)</code>","text":"<p>Deserialize a serialized AuthorizationRequest.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized AuthorizationRequest</p> required <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>the deserialized AuthorizationRequest</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def loads(self, serialized: str) -&gt; AuthorizationRequest:\n    \"\"\"Deserialize a serialized AuthorizationRequest.\n\n    Args:\n        serialized: the serialized AuthorizationRequest\n\n    Returns:\n        the deserialized AuthorizationRequest\n\n    \"\"\"\n    return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationResponse","title":"<code>AuthorizationResponse</code>","text":"<p>Represent a successful Authorization Response.</p> <p>An Authorization Response is the redirection initiated by the AS to the client's redirection endpoint (redirect_uri), after an Authorization Request. This Response is typically created with a call to <code>AuthorizationRequest.validate_callback()</code> once the call to the client Redirection Endpoint is made. <code>AuthorizationResponse</code> contains the following attributes:</p> <ul> <li>all the parameters that have been returned by the AS, most notably the <code>code</code>, and optional    parameters such as <code>state</code>.</li> <li>the <code>redirect_uri</code> that was used for the Authorization Request</li> <li>the <code>code_verifier</code> matching the <code>code_challenge</code> that was used for the Authorization Request</li> </ul> <p>Parameters <code>redirect_uri</code> and <code>code_verifier</code> must be those from the matching <code>AuthorizationRequest</code>. All other parameters including <code>code</code> and <code>state</code> must be those extracted from the Authorization Response parameters.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>The authorization <code>code</code> returned by the AS.</p> required <code>redirect_uri</code> <code>str | None</code> <p>The <code>redirect_uri</code> that was passed as parameter in the Authorization Request.</p> <code>None</code> <code>code_verifier</code> <code>str | None</code> <p>the <code>code_verifier</code> matching the <code>code_challenge</code> that was passed as parameter in the Authorization Request.</p> <code>None</code> <code>state</code> <code>str | None</code> <p>the <code>state</code> that was was passed as parameter in the Authorization Request and returned by the AS.</p> <code>None</code> <code>nonce</code> <code>str | None</code> <p>the <code>nonce</code> that was was passed as parameter in the Authorization Request.</p> <code>None</code> <code>acr_values</code> <code>str | Sequence[str] | None</code> <p>the <code>acr_values</code> that was passed as parameter in the Authorization Request.</p> <code>None</code> <code>max_age</code> <code>int | None</code> <p>the <code>max_age</code> that was passed as parameter in the Authorization Request.</p> <code>None</code> <code>issuer</code> <code>str | None</code> <p>the expected <code>issuer</code> identifier.</p> <code>None</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used for Authorization Code DPoP binding.</p> <code>None</code> <code>**kwargs</code> <code>str</code> <p>other parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass AuthorizationResponse:\n    \"\"\"Represent a successful Authorization Response.\n\n    An Authorization Response is the redirection initiated by the AS to the client's redirection\n    endpoint (redirect_uri), after an Authorization Request.\n    This Response is typically created with a call to `AuthorizationRequest.validate_callback()`\n    once the call to the client Redirection Endpoint is made.\n    `AuthorizationResponse` contains the following attributes:\n\n     - all the parameters that have been returned by the AS, most notably the `code`, and optional\n       parameters such as `state`.\n     - the `redirect_uri` that was used for the Authorization Request\n     - the `code_verifier` matching the `code_challenge` that was used for the Authorization Request\n\n    Parameters `redirect_uri` and `code_verifier` must be those from the matching\n    `AuthorizationRequest`. All other parameters including `code` and `state` must be those\n    extracted from the Authorization Response parameters.\n\n    Args:\n        code: The authorization `code` returned by the AS.\n        redirect_uri: The `redirect_uri` that was passed as parameter in the Authorization Request.\n        code_verifier: the `code_verifier` matching the `code_challenge` that was passed as\n            parameter in the Authorization Request.\n        state: the `state` that was was passed as parameter in the Authorization Request and returned by the AS.\n        nonce: the `nonce` that was was passed as parameter in the Authorization Request.\n        acr_values: the `acr_values` that was passed as parameter in the Authorization Request.\n        max_age: the `max_age` that was passed as parameter in the Authorization Request.\n        issuer: the expected `issuer` identifier.\n        dpop_key: the `DPoPKey` that was used for Authorization Code DPoP binding.\n        **kwargs: other parameters as returned by the AS.\n\n    \"\"\"\n\n    code: str\n    redirect_uri: str | None\n    code_verifier: str | None\n    state: str | None\n    nonce: str | None\n    acr_values: tuple[str, ...] | None\n    max_age: int | None\n    issuer: str | None\n    dpop_key: DPoPKey | None\n    kwargs: dict[str, Any]\n\n    def __init__(\n        self,\n        *,\n        code: str,\n        redirect_uri: str | None = None,\n        code_verifier: str | None = None,\n        state: str | None = None,\n        nonce: str | None = None,\n        acr_values: str | Sequence[str] | None = None,\n        max_age: int | None = None,\n        issuer: str | None = None,\n        dpop_key: DPoPKey | None = None,\n        **kwargs: str,\n    ) -&gt; None:\n        if not acr_values:\n            acr_values = None\n        elif isinstance(acr_values, str):\n            acr_values = tuple(acr_values.split(\" \"))\n        else:\n            acr_values = tuple(acr_values)\n\n        self.__attrs_init__(\n            code=code,\n            redirect_uri=redirect_uri,\n            code_verifier=code_verifier,\n            state=state,\n            nonce=nonce,\n            acr_values=acr_values,\n            max_age=max_age,\n            issuer=issuer,\n            dpop_key=dpop_key,\n            kwargs=kwargs,\n        )\n\n    def __getattr__(self, item: str) -&gt; str | None:\n        \"\"\"Make additional parameters available as attributes.\n\n        Args:\n            item: the attribute name\n\n        Returns:\n            the attribute value, or None if it isn't part of the returned attributes\n\n        \"\"\"\n        return self.kwargs.get(item)\n</code></pre>"},{"location":"api/#requests_oauth2client.CodeChallengeMethods","title":"<code>CodeChallengeMethods</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>All standardised <code>code_challenge_method</code> values.</p> <p>You should always use <code>S256</code>.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class CodeChallengeMethods(str, Enum):\n    \"\"\"All standardised `code_challenge_method` values.\n\n    You should always use `S256`.\n\n    \"\"\"\n\n    S256 = \"S256\"\n    plain = \"plain\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidCodeVerifierParam","title":"<code>InvalidCodeVerifierParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an invalid code_verifier is supplied.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class InvalidCodeVerifierParam(ValueError):\n    \"\"\"Raised when an invalid code_verifier is supplied.\"\"\"\n\n    def __init__(self, code_verifier: str) -&gt; None:\n        super().__init__(\"\"\"\\\nInvalid 'code_verifier'. It must be a 43 to 128 characters long string, with:\n- lowercase letters\n- uppercase letters\n- digits\n- underscore, dash, tilde, or dot (_-~.)\n\"\"\")\n        self.code_verifier = code_verifier\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidMaxAgeParam","title":"<code>InvalidMaxAgeParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an invalid 'max_age' parameter is provided.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class InvalidMaxAgeParam(ValueError):\n    \"\"\"Raised when an invalid 'max_age' parameter is provided.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"\"\"\\\nInvalid 'max_age' parameter. It must be a positive number of seconds.\nThis specifies the allowable elapsed time in seconds since the last time\nthe End-User was actively authenticated by the OP.\n\"\"\")\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingIssuerParam","title":"<code>MissingIssuerParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when the 'issuer' parameter is required but not provided.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class MissingIssuerParam(ValueError):\n    \"\"\"Raised when the 'issuer' parameter is required but not provided.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"\"\"\\\nWhen 'authorization_response_iss_parameter_supported' is `True`, you must\nprovide the expected `issuer` as parameter.\n\"\"\")\n</code></pre>"},{"location":"api/#requests_oauth2client.PkceUtils","title":"<code>PkceUtils</code>","text":"<p>Contains helper methods for PKCE, as described in RFC7636.</p> <p>See RFC7636.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class PkceUtils:\n    \"\"\"Contains helper methods for PKCE, as described in RFC7636.\n\n    See [RFC7636](https://tools.ietf.org/html/rfc7636).\n\n    \"\"\"\n\n    code_verifier_pattern = re.compile(r\"^[a-zA-Z0-9_\\-~.]{43,128}$\")\n    \"\"\"A regex that matches valid code verifiers.\"\"\"\n\n    @classmethod\n    def generate_code_verifier(cls) -&gt; str:\n        \"\"\"Generate a valid `code_verifier`.\n\n        Returns:\n            a `code_verifier` ready to use for PKCE\n\n        \"\"\"\n        return secrets.token_urlsafe(96)\n\n    @classmethod\n    def derive_challenge(cls, verifier: str | bytes, method: str = CodeChallengeMethods.S256) -&gt; str:\n        \"\"\"Derive the `code_challenge` from a given `code_verifier`.\n\n        Args:\n            verifier: a code verifier\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            a `code_challenge` derived from the given verifier\n\n        Raises:\n            InvalidCodeVerifierParam: if the `verifier` does not match `code_verifier_pattern`\n            UnsupportedCodeChallengeMethod: if the method is not supported\n\n        \"\"\"\n        if isinstance(verifier, bytes):\n            verifier = verifier.decode()\n\n        if not cls.code_verifier_pattern.match(verifier):\n            raise InvalidCodeVerifierParam(verifier)\n\n        if method == CodeChallengeMethods.S256:\n            return BinaPy(verifier).to(\"sha256\").to(\"b64u\").ascii()\n        if method == CodeChallengeMethods.plain:\n            return verifier\n\n        raise UnsupportedCodeChallengeMethod(method)\n\n    @classmethod\n    def generate_code_verifier_and_challenge(cls, method: str = CodeChallengeMethods.S256) -&gt; tuple[str, str]:\n        \"\"\"Generate a valid `code_verifier` and its matching `code_challenge`.\n\n        Args:\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            a `(code_verifier, code_challenge)` tuple.\n\n        \"\"\"\n        verifier = cls.generate_code_verifier()\n        challenge = cls.derive_challenge(verifier, method)\n        return verifier, challenge\n\n    @classmethod\n    def validate_code_verifier(cls, verifier: str, challenge: str, method: str = CodeChallengeMethods.S256) -&gt; bool:\n        \"\"\"Validate a `code_verifier` against a `code_challenge`.\n\n        Args:\n            verifier: the `code_verifier`, exactly as submitted by the client on token request.\n            challenge: the `code_challenge`, exactly as submitted by the client on authorization request.\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            `True` if verifier is valid, or `False` otherwise\n\n        \"\"\"\n        return (\n            cls.code_verifier_pattern.match(verifier) is not None\n            and cls.derive_challenge(verifier, method) == challenge\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.PkceUtils.code_verifier_pattern","title":"<code>code_verifier_pattern = re.compile('^[a-zA-Z0-9_\\\\-~.]{43,128}$')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A regex that matches valid code verifiers.</p>"},{"location":"api/#requests_oauth2client.PkceUtils.generate_code_verifier","title":"<code>generate_code_verifier()</code>  <code>classmethod</code>","text":"<p>Generate a valid <code>code_verifier</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>a <code>code_verifier</code> ready to use for PKCE</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_code_verifier(cls) -&gt; str:\n    \"\"\"Generate a valid `code_verifier`.\n\n    Returns:\n        a `code_verifier` ready to use for PKCE\n\n    \"\"\"\n    return secrets.token_urlsafe(96)\n</code></pre>"},{"location":"api/#requests_oauth2client.PkceUtils.derive_challenge","title":"<code>derive_challenge(verifier, method=CodeChallengeMethods.S256)</code>  <code>classmethod</code>","text":"<p>Derive the <code>code_challenge</code> from a given <code>code_verifier</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>str | bytes</code> <p>a code verifier</p> required <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>S256</code> <p>Returns:</p> Type Description <code>str</code> <p>a <code>code_challenge</code> derived from the given verifier</p> <p>Raises:</p> Type Description <code>InvalidCodeVerifierParam</code> <p>if the <code>verifier</code> does not match <code>code_verifier_pattern</code></p> <code>UnsupportedCodeChallengeMethod</code> <p>if the method is not supported</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef derive_challenge(cls, verifier: str | bytes, method: str = CodeChallengeMethods.S256) -&gt; str:\n    \"\"\"Derive the `code_challenge` from a given `code_verifier`.\n\n    Args:\n        verifier: a code verifier\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        a `code_challenge` derived from the given verifier\n\n    Raises:\n        InvalidCodeVerifierParam: if the `verifier` does not match `code_verifier_pattern`\n        UnsupportedCodeChallengeMethod: if the method is not supported\n\n    \"\"\"\n    if isinstance(verifier, bytes):\n        verifier = verifier.decode()\n\n    if not cls.code_verifier_pattern.match(verifier):\n        raise InvalidCodeVerifierParam(verifier)\n\n    if method == CodeChallengeMethods.S256:\n        return BinaPy(verifier).to(\"sha256\").to(\"b64u\").ascii()\n    if method == CodeChallengeMethods.plain:\n        return verifier\n\n    raise UnsupportedCodeChallengeMethod(method)\n</code></pre>"},{"location":"api/#requests_oauth2client.PkceUtils.generate_code_verifier_and_challenge","title":"<code>generate_code_verifier_and_challenge(method=CodeChallengeMethods.S256)</code>  <code>classmethod</code>","text":"<p>Generate a valid <code>code_verifier</code> and its matching <code>code_challenge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>S256</code> <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>a <code>(code_verifier, code_challenge)</code> tuple.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_code_verifier_and_challenge(cls, method: str = CodeChallengeMethods.S256) -&gt; tuple[str, str]:\n    \"\"\"Generate a valid `code_verifier` and its matching `code_challenge`.\n\n    Args:\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        a `(code_verifier, code_challenge)` tuple.\n\n    \"\"\"\n    verifier = cls.generate_code_verifier()\n    challenge = cls.derive_challenge(verifier, method)\n    return verifier, challenge\n</code></pre>"},{"location":"api/#requests_oauth2client.PkceUtils.validate_code_verifier","title":"<code>validate_code_verifier(verifier, challenge, method=CodeChallengeMethods.S256)</code>  <code>classmethod</code>","text":"<p>Validate a <code>code_verifier</code> against a <code>code_challenge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>str</code> <p>the <code>code_verifier</code>, exactly as submitted by the client on token request.</p> required <code>challenge</code> <code>str</code> <p>the <code>code_challenge</code>, exactly as submitted by the client on authorization request.</p> required <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>S256</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if verifier is valid, or <code>False</code> otherwise</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef validate_code_verifier(cls, verifier: str, challenge: str, method: str = CodeChallengeMethods.S256) -&gt; bool:\n    \"\"\"Validate a `code_verifier` against a `code_challenge`.\n\n    Args:\n        verifier: the `code_verifier`, exactly as submitted by the client on token request.\n        challenge: the `code_challenge`, exactly as submitted by the client on authorization request.\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        `True` if verifier is valid, or `False` otherwise\n\n    \"\"\"\n    return (\n        cls.code_verifier_pattern.match(verifier) is not None\n        and cls.derive_challenge(verifier, method) == challenge\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.RequestParameterAuthorizationRequest","title":"<code>RequestParameterAuthorizationRequest</code>","text":"<p>Represent an Authorization Request that includes a <code>request</code> JWT.</p> <p>To construct such a request yourself, the easiest way is to initialize an <code>AuthorizationRequest</code> then sign it with <code>AuthorizationRequest.sign()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the Authorization Endpoint uri</p> required <code>client_id</code> <code>str</code> <p>the client_id</p> required <code>request</code> <code>Jwt | str</code> <p>the request JWT</p> required <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for this request</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>extra parameters to include in the request</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False, repr=False)\nclass RequestParameterAuthorizationRequest:\n    \"\"\"Represent an Authorization Request that includes a `request` JWT.\n\n    To construct such a request yourself, the easiest way is to initialize\n    an [`AuthorizationRequest`][requests_oauth2client.authorization_request.AuthorizationRequest]\n    then sign it with\n    [`AuthorizationRequest.sign()`][requests_oauth2client.authorization_request.AuthorizationRequest.sign].\n\n    Args:\n        authorization_endpoint: the Authorization Endpoint uri\n        client_id: the client_id\n        request: the request JWT\n        expires_at: the expiration date for this request\n        kwargs: extra parameters to include in the request\n\n    \"\"\"\n\n    authorization_endpoint: str\n    client_id: str\n    request: Jwt\n    expires_at: datetime | None\n    dpop_key: DPoPKey | None\n    kwargs: dict[str, Any]\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        authorization_endpoint: str,\n        client_id: str,\n        request: Jwt | str,\n        expires_at: datetime | None = None,\n        dpop_key: DPoPKey | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        if isinstance(request, str):\n            request = Jwt(request)\n\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            request=request,\n            expires_at=expires_at,\n            dpop_key=dpop_key,\n            kwargs=kwargs,\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl` instance.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args={\"client_id\": self.client_id, \"request\": str(self.request), **self.kwargs},\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\n\n        Returns:\n             the Authorization Request URI\n\n        \"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.RequestParameterAuthorizationRequest.furl","title":"<code>furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code> instance.</p>"},{"location":"api/#requests_oauth2client.RequestParameterAuthorizationRequest.uri","title":"<code>uri</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.RequestUriParameterAuthorizationRequest","title":"<code>RequestUriParameterAuthorizationRequest</code>","text":"<p>Represent an Authorization Request that includes a <code>request_uri</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>The Authorization Endpoint uri.</p> required <code>client_id</code> <code>str</code> <p>The Client ID.</p> required <code>request_uri</code> <code>str</code> <p>The <code>request_uri</code>.</p> required <code>expires_at</code> <code>datetime | None</code> <p>The expiration date for this request.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Extra query parameters to include in the request.</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass RequestUriParameterAuthorizationRequest:\n    \"\"\"Represent an Authorization Request that includes a `request_uri` parameter.\n\n    Args:\n        authorization_endpoint: The Authorization Endpoint uri.\n        client_id: The Client ID.\n        request_uri: The `request_uri`.\n        expires_at: The expiration date for this request.\n        kwargs: Extra query parameters to include in the request.\n\n    \"\"\"\n\n    authorization_endpoint: str\n    client_id: str\n    request_uri: str\n    expires_at: datetime | None\n    dpop_key: DPoPKey | None\n    kwargs: dict[str, Any]\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        authorization_endpoint: str,\n        *,\n        client_id: str,\n        request_uri: str,\n        expires_at: datetime | None = None,\n        dpop_key: DPoPKey | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            request_uri=request_uri,\n            expires_at=expires_at,\n            dpop_key=dpop_key,\n            kwargs=kwargs,\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl` instance.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args={\"client_id\": self.client_id, \"request_uri\": self.request_uri, **self.kwargs},\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.RequestUriParameterAuthorizationRequest.furl","title":"<code>furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code> instance.</p>"},{"location":"api/#requests_oauth2client.RequestUriParameterAuthorizationRequest.uri","title":"<code>uri</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.ResponseTypes","title":"<code>ResponseTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>All standardised <code>response_type</code> values.</p> <p>Note that you should always use <code>code</code>. All other values are deprecated.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class ResponseTypes(str, Enum):\n    \"\"\"All standardised `response_type` values.\n\n    Note that you should always use `code`. All other values are deprecated.\n\n    \"\"\"\n\n    CODE = \"code\"\n    NONE = \"none\"\n    TOKEN = \"token\"\n    IDTOKEN = \"id_token\"\n    CODE_IDTOKEN = \"code id_token\"\n    CODE_TOKEN = \"code token\"\n    CODE_IDTOKEN_TOKEN = \"code id_token token\"\n    IDTOKEN_TOKEN = \"id_token token\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnsupportedCodeChallengeMethod","title":"<code>UnsupportedCodeChallengeMethod</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an unsupported <code>code_challenge_method</code> is provided.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class UnsupportedCodeChallengeMethod(ValueError):\n    \"\"\"Raised when an unsupported `code_challenge_method` is provided.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnsupportedResponseTypeParam","title":"<code>UnsupportedResponseTypeParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an unsupported response_type is passed as parameter.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class UnsupportedResponseTypeParam(ValueError):\n    \"\"\"Raised when an unsupported response_type is passed as parameter.\"\"\"\n\n    def __init__(self, response_type: str) -&gt; None:\n        super().__init__(\"\"\"The only supported response type is 'code'.\"\"\", response_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationPoolingJob","title":"<code>BackChannelAuthenticationPoolingJob</code>","text":"<p>               Bases: <code>BaseTokenEndpointPoolingJob</code></p> <p>A pooling job for the BackChannel Authentication flow.</p> <p>This will poll the Token Endpoint until the user finishes with its authentication.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client that will be used to pool the token endpoint.</p> required <code>auth_req_id</code> <code>str | BackChannelAuthenticationResponse</code> <p>an <code>auth_req_id</code> as <code>str</code> or a <code>BackChannelAuthenticationResponse</code>.</p> required <code>interval</code> <code>int | None</code> <p>The pooling interval, in seconds, to use. This overrides the one in <code>auth_req_id</code> if it is a <code>BackChannelAuthenticationResponse</code>. Defaults to 5 seconds.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>Number of seconds to add to the pooling interval when the AS returns a slow down request.</p> <code>5</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the underlying calls to requests.request.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token request.</p> <code>{}</code> Example <pre><code>client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\npool_job = BackChannelAuthenticationPoolingJob(\n    client=client,\n    auth_req_id=\"my_auth_req_id\",\n)\n\ntoken = None\nwhile token is None:\n    token = pool_job()\n</code></pre> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>@define(init=False)\nclass BackChannelAuthenticationPoolingJob(BaseTokenEndpointPoolingJob):\n    \"\"\"A pooling job for the BackChannel Authentication flow.\n\n    This will poll the Token Endpoint until the user finishes with its authentication.\n\n    Args:\n        client: an OAuth2Client that will be used to pool the token endpoint.\n        auth_req_id: an `auth_req_id` as `str` or a `BackChannelAuthenticationResponse`.\n        interval: The pooling interval, in seconds, to use. This overrides\n            the one in `auth_req_id` if it is a `BackChannelAuthenticationResponse`.\n            Defaults to 5 seconds.\n        slow_down_interval: Number of seconds to add to the pooling interval when the AS returns\n            a slow down request.\n        requests_kwargs: Additional parameters for the underlying calls to [requests.request][].\n        **token_kwargs: Additional parameters for the token request.\n\n    Example:\n        ```python\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        pool_job = BackChannelAuthenticationPoolingJob(\n            client=client,\n            auth_req_id=\"my_auth_req_id\",\n        )\n\n        token = None\n        while token is None:\n            token = pool_job()\n        ```\n\n    \"\"\"\n\n    auth_req_id: str\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        auth_req_id: str | BackChannelAuthenticationResponse,\n        *,\n        interval: int | None = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n            interval = interval or auth_req_id.interval\n            auth_req_id = auth_req_id.auth_req_id\n\n        self.__attrs_init__(\n            client=client,\n            auth_req_id=auth_req_id,\n            interval=interval or 5,\n            slow_down_interval=slow_down_interval,\n            requests_kwargs=requests_kwargs or {},\n            token_kwargs=token_kwargs,\n        )\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Implement the CIBA token request.\n\n        This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        return self.client.ciba(self.auth_req_id, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Implement the CIBA token request.</p> <p>This actually calls [OAuth2Client.ciba(auth_req_id)] on <code>client</code>.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Implement the CIBA token request.\n\n    This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    return self.client.ciba(self.auth_req_id, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationResponse","title":"<code>BackChannelAuthenticationResponse</code>","text":"<p>Represent a BackChannel Authentication Response.</p> <p>This contains all the parameters that are returned by the AS as a result of a BackChannel Authentication Request, such as <code>auth_req_id</code> (required), and the optional <code>expires_at</code>, <code>interval</code>, and/or any custom parameters.</p> <p>Parameters:</p> Name Type Description Default <code>auth_req_id</code> <code>str</code> <p>the <code>auth_req_id</code> as returned by the AS.</p> required <code>expires_at</code> <code>datetime | None</code> <p>the date when the <code>auth_req_id</code> expires. Note that this request also accepts an <code>expires_in</code> parameter, in seconds.</p> <code>None</code> <code>interval</code> <code>int | None</code> <p>the Token Endpoint pooling interval, in seconds, as returned by the AS.</p> <code>20</code> <code>**kwargs</code> <code>Any</code> <p>any additional custom parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>class BackChannelAuthenticationResponse:\n    \"\"\"Represent a BackChannel Authentication Response.\n\n    This contains all the parameters that are returned by the AS as a result of a BackChannel\n    Authentication Request, such as `auth_req_id` (required), and the optional `expires_at`,\n    `interval`, and/or any custom parameters.\n\n    Args:\n        auth_req_id: the `auth_req_id` as returned by the AS.\n        expires_at: the date when the `auth_req_id` expires.\n            Note that this request also accepts an `expires_in` parameter, in seconds.\n        interval: the Token Endpoint pooling interval, in seconds, as returned by the AS.\n        **kwargs: any additional custom parameters as returned by the AS.\n\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        auth_req_id: str,\n        expires_at: datetime | None = None,\n        interval: int | None = 20,\n        **kwargs: Any,\n    ) -&gt; None:\n        self.auth_req_id = auth_req_id\n        self.expires_at = expires_at\n        self.interval = interval\n        self.other = kwargs\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Return `True` if the `auth_req_id` within this response is expired.\n\n        Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is\n        derived from the `expires_in` hint returned by the AS BackChannel Authentication endpoint),\n        this will return `None`.\n\n        Returns:\n            `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is\n            no `expires_in` hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n\n    @property\n    def expires_in(self) -&gt; int | None:\n        \"\"\"Number of seconds until expiration.\"\"\"\n        if self.expires_at:\n            return ceil((self.expires_at - datetime.now(tz=timezone.utc)).total_seconds())\n        return None\n\n    def __getattr__(self, key: str) -&gt; Any:\n        \"\"\"Return attributes from this `BackChannelAuthenticationResponse`.\n\n        Allows accessing response parameters with `token_response.expires_in` or\n        `token_response.any_custom_attribute`.\n\n        Args:\n            key: a key\n\n        Returns:\n            the associated value in this token response\n\n        Raises:\n            AttributeError: if the attribute is not present in the response\n\n        \"\"\"\n        return self.other.get(key) or super().__getattribute__(key)\n</code></pre>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationResponse.expires_in","title":"<code>expires_in</code>  <code>property</code>","text":"<p>Number of seconds until expiration.</p>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationResponse.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Return <code>True</code> if the <code>auth_req_id</code> within this response is expired.</p> <p>Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is derived from the <code>expires_in</code> hint returned by the AS BackChannel Authentication endpoint), this will return <code>None</code>.</p> <p>Returns:</p> Type Description <code>bool | None</code> <p><code>True</code> if the auth_req_id is expired, <code>False</code> if it is still valid, <code>None</code> if there is</p> <code>bool | None</code> <p>no <code>expires_in</code> hint.</p> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Return `True` if the `auth_req_id` within this response is expired.\n\n    Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is\n    derived from the `expires_in` hint returned by the AS BackChannel Authentication endpoint),\n    this will return `None`.\n\n    Returns:\n        `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is\n        no `expires_in` hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.Endpoints","title":"<code>Endpoints</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>All standardised OAuth 2.0 and extensions endpoints.</p> <p>If an endpoint is not mentioned here, then its usage is not supported by OAuth2Client.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class Endpoints(str, Enum):\n    \"\"\"All standardised OAuth 2.0 and extensions endpoints.\n\n    If an endpoint is not mentioned here, then its usage is not supported by OAuth2Client.\n\n    \"\"\"\n\n    TOKEN = \"token_endpoint\"\n    AUTHORIZATION = \"authorization_endpoint\"\n    BACKCHANNEL_AUTHENTICATION = \"backchannel_authentication_endpoint\"\n    DEVICE_AUTHORIZATION = \"device_authorization_endpoint\"\n    INTROSPECTION = \"introspection_endpoint\"\n    REVOCATION = \"revocation_endpoint\"\n    PUSHED_AUTHORIZATION_REQUEST = \"pushed_authorization_request_endpoint\"\n    JWKS = \"jwks_uri\"\n    USER_INFO = \"userinfo_endpoint\"\n</code></pre>"},{"location":"api/#requests_oauth2client.GrantTypes","title":"<code>GrantTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum of standardized <code>grant_type</code> values.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class GrantTypes(str, Enum):\n    \"\"\"An enum of standardized `grant_type` values.\"\"\"\n\n    CLIENT_CREDENTIALS = \"client_credentials\"\n    AUTHORIZATION_CODE = \"authorization_code\"\n    REFRESH_TOKEN = \"refresh_token\"\n    RESOURCE_OWNER_PASSWORD = \"password\"\n    TOKEN_EXCHANGE = \"urn:ietf:params:oauth:grant-type:token-exchange\"\n    JWT_BEARER = \"urn:ietf:params:oauth:grant-type:jwt-bearer\"\n    CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION = \"urn:openid:params:grant-type:ciba\"\n    DEVICE_CODE = \"urn:ietf:params:oauth:grant-type:device_code\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidAcrValuesParam","title":"<code>InvalidAcrValuesParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid 'acr_values' parameter is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidAcrValuesParam(InvalidParam):\n    \"\"\"Raised when an invalid 'acr_values' parameter is provided.\"\"\"\n\n    def __init__(self, acr_values: object) -&gt; None:\n        super().__init__(f\"Invalid 'acr_values' parameter: {acr_values}\")\n        self.acr_values = acr_values\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidBackchannelAuthenticationRequestHintParam","title":"<code>InvalidBackchannelAuthenticationRequestHintParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid hint is provided in a backchannel authentication request.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidBackchannelAuthenticationRequestHintParam(InvalidParam):\n    \"\"\"Raised when an invalid hint is provided in a backchannel authentication request.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidDiscoveryDocument","title":"<code>InvalidDiscoveryDocument</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when handling an invalid Discovery Document.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidDiscoveryDocument(ValueError):\n    \"\"\"Raised when handling an invalid Discovery Document.\"\"\"\n\n    def __init__(self, message: str, discovery_document: dict[str, Any]) -&gt; None:\n        super().__init__(f\"Invalid discovery document: {message}\")\n        self.discovery_document = discovery_document\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidEndpointUri","title":"<code>InvalidEndpointUri</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid endpoint uri is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidEndpointUri(InvalidParam):\n    \"\"\"Raised when an invalid endpoint uri is provided.\"\"\"\n\n    def __init__(self, endpoint: str, uri: str, exc: InvalidUri) -&gt; None:\n        super().__init__(f\"Invalid endpoint uri '{uri}' for '{endpoint}': {exc}\")\n        self.endpoint = endpoint\n        self.uri = uri\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidIssuer","title":"<code>InvalidIssuer</code>","text":"<p>               Bases: <code>InvalidEndpointUri</code></p> <p>Raised when an invalid issuer parameter is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidIssuer(InvalidEndpointUri):\n    \"\"\"Raised when an invalid issuer parameter is provided.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidParam","title":"<code>InvalidParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Base class for invalid parameters errors.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidParam(ValueError):\n    \"\"\"Base class for invalid parameters errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidScopeParam","title":"<code>InvalidScopeParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid scope parameter is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidScopeParam(InvalidParam):\n    \"\"\"Raised when an invalid scope parameter is provided.\"\"\"\n\n    def __init__(self, scope: object) -&gt; None:\n        super().__init__(\"\"\"\\\nUnsupported scope value. It must be one of:\n- a space separated `str` of scopes names\n- an iterable of scope names as `str`\n\"\"\")\n        self.scope = scope\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingAuthRequestId","title":"<code>MissingAuthRequestId</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an 'auth_req_id' is missing in a BackChannelAuthenticationResponse.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingAuthRequestId(ValueError):\n    \"\"\"Raised when an 'auth_req_id' is missing in a BackChannelAuthenticationResponse.\"\"\"\n\n    def __init__(self, bcar: BackChannelAuthenticationResponse) -&gt; None:\n        super().__init__(\"An 'auth_req_id' is required but is missing from this BackChannelAuthenticationResponse.\")\n        self.backchannel_authentication_response = bcar\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingDeviceCode","title":"<code>MissingDeviceCode</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a device_code is required but not provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingDeviceCode(ValueError):\n    \"\"\"Raised when a device_code is required but not provided.\"\"\"\n\n    def __init__(self, dar: DeviceAuthorizationResponse) -&gt; None:\n        super().__init__(\"A device_code is missing in this DeviceAuthorizationResponse\")\n        self.device_authorization_response = dar\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingEndpointUri","title":"<code>MissingEndpointUri</code>","text":"<p>               Bases: <code>AttributeError</code></p> <p>Raised when a required endpoint uri is not known.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingEndpointUri(AttributeError):\n    \"\"\"Raised when a required endpoint uri is not known.\"\"\"\n\n    def __init__(self, endpoint: str) -&gt; None:\n        super().__init__(f\"No '{endpoint}' defined for this client.\")\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingIdTokenEncryptedResponseAlgParam","title":"<code>MissingIdTokenEncryptedResponseAlgParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an ID Token encryption is required but not provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingIdTokenEncryptedResponseAlgParam(InvalidParam):\n    \"\"\"Raised when an ID Token encryption is required but not provided.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"\"\"\\\nAn ID Token decryption key has been provided but no decryption algorithm is defined.\nYou can either pass an `id_token_encrypted_response_alg` parameter with the alg identifier,\nor include an `alg` attribute in the decryption key, if it is in Jwk format.\n\"\"\")\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingRefreshToken","title":"<code>MissingRefreshToken</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a refresh token is required but not present.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingRefreshToken(ValueError):\n    \"\"\"Raised when a refresh token is required but not present.\"\"\"\n\n    def __init__(self, token: TokenResponse) -&gt; None:\n        super().__init__(\"A refresh_token is required but is not present in this Access Token.\")\n        self.token = token\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client","title":"<code>OAuth2Client</code>","text":"<p>An OAuth 2.x Client that can send requests to an OAuth 2.x Authorization Server.</p> <p><code>OAuth2Client</code> is able to obtain tokens from the Token Endpoint using any of the standardised Grant Types, and to communicate with the various backend endpoints like the Revocation, Introspection, and UserInfo Endpoint.</p> <p>To init an OAuth2Client, you only need the url to the Token Endpoint and the Credentials (a client_id and one of a secret or private_key) that will be used to authenticate to that endpoint. Other endpoint urls, such as the Authorization Endpoint, Revocation Endpoint, etc. can be passed as parameter as well if you intend to use them.</p> <p>This class is not intended to help with the end-user authentication or any request that goes in a browser. For authentication requests, see AuthorizationRequest. You may use the method <code>authorization_request()</code> to generate <code>AuthorizationRequest</code>s with the preconfigured <code>authorization_endpoint</code>, <code>client_id</code> and `redirect_uri' from this client.</p> <p>Parameters:</p> Name Type Description Default <code>token_endpoint</code> <code>str</code> <p>the Token Endpoint URI where this client will get access tokens</p> required <code>auth</code> <code>AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None</code> <p>the authentication handler to use for client authentication on the token endpoint. Can be:</p> <ul> <li>a requests.auth.AuthBase instance (which will be used as-is)</li> <li>a tuple of <code>(client_id, client_secret)</code> which will initialize an instance of ClientSecretPost</li> <li>a <code>(client_id, jwk)</code> to initialize a PrivateKeyJwt,</li> <li>or a <code>client_id</code> which will use PublicApp authentication.</li> </ul> <code>None</code> <code>client_id</code> <code>str | None</code> <p>client ID (use either this or <code>auth</code>)</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>client secret (use either this or <code>auth</code>)</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>private_key to use for client authentication (use either this or <code>auth</code>)</p> <code>None</code> <code>revocation_endpoint</code> <code>str | None</code> <p>the Revocation Endpoint URI to use for revoking tokens</p> <code>None</code> <code>introspection_endpoint</code> <code>str | None</code> <p>the Introspection Endpoint URI to use to get info about tokens</p> <code>None</code> <code>userinfo_endpoint</code> <code>str | None</code> <p>the Userinfo Endpoint URI to use to get information about the user</p> <code>None</code> <code>authorization_endpoint</code> <code>str | None</code> <p>the Authorization Endpoint URI, used for initializing Authorization Requests</p> <code>None</code> <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri for this client</p> <code>None</code> <code>backchannel_authentication_endpoint</code> <code>str | None</code> <p>the BackChannel Authentication URI</p> <code>None</code> <code>device_authorization_endpoint</code> <code>str | None</code> <p>the Device Authorization Endpoint URI to use to authorize devices</p> <code>None</code> <code>jwks_uri</code> <code>str | None</code> <p>the JWKS URI to use to obtain the AS public keys</p> <code>None</code> <code>code_challenge_method</code> <code>str</code> <p>challenge method to use for PKCE (should always be 'S256')</p> <code>S256</code> <code>session</code> <code>Session | None</code> <p>a requests Session to use when sending HTTP requests. Useful if some extra parameters such as proxy or client certificate must be used to connect to the AS.</p> <code>None</code> <code>token_class</code> <code>type[BearerToken]</code> <p>a custom BearerToken class, if required</p> <code>BearerToken</code> <code>dpop_bound_access_tokens</code> <code>bool</code> <p>if <code>True</code>, DPoP will be used by default for every token request. otherwise, you can enable DPoP by passing <code>dpop=True</code> when doing a token request.</p> <code>False</code> <code>dpop_key_generator</code> <code>Callable[[str], DPoPKey]</code> <p>a callable that generates a DPoPKey, for whill be called when doing a token request with DPoP enabled.</p> <code>generate</code> <code>testing</code> <code>bool</code> <p>if <code>True</code>, don't verify the validity of the endpoint urls that are passed as parameter.</p> <code>False</code> <code>**extra_metadata</code> <code>Any</code> <p>additional metadata for this client, unused by this class, but may be used by subclasses. Those will be accessible with the <code>extra_metadata</code> attribute.</p> <code>{}</code> Example <pre><code>client = OAuth2Client(\n    token_endpoint=\"https://my.as.local/token\",\n    revocation_endpoint=\"https://my.as.local/revoke\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\n# once initialized, a client can send requests to its configured endpoints\ncc_token = client.client_credentials(scope=\"my_scope\")\nac_token = client.authorization_code(code=\"my_code\")\nclient.revoke_access_token(cc_token)\n</code></pre> <p>Raises:</p> Type Description <code>MissingIDTokenEncryptedResponseAlgParam</code> <p>if an <code>id_token_decryption_key</code> is provided but no decryption alg is provided, either:</p> <ul> <li>using <code>id_token_encrypted_response_alg</code>,</li> <li>or in the <code>alg</code> parameter of the <code>Jwk</code> key</li> </ul> <code>MissingIssuerParam</code> <p>if <code>authorization_response_iss_parameter_supported</code> is set to <code>True</code> but the <code>issuer</code> is not provided.</p> <code>InvalidEndpointUri</code> <p>if a provided endpoint uri is not considered valid. For the rare cases where those checks must be disabled, you can use <code>testing=True</code>.</p> <code>InvalidIssuer</code> <p>if the <code>issuer</code> value is not considered valid.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@frozen(init=False)\nclass OAuth2Client:\n    \"\"\"An OAuth 2.x Client that can send requests to an OAuth 2.x Authorization Server.\n\n    `OAuth2Client` is able to obtain tokens from the Token Endpoint using any of the standardised\n    Grant Types, and to communicate with the various backend endpoints like the Revocation,\n    Introspection, and UserInfo Endpoint.\n\n    To init an OAuth2Client, you only need the url to the Token Endpoint and the Credentials\n    (a client_id and one of a secret or private_key) that will be used to authenticate to that endpoint.\n    Other endpoint urls, such as the Authorization Endpoint, Revocation Endpoint, etc. can be passed as\n    parameter as well if you intend to use them.\n\n\n    This class is not intended to help with the end-user authentication or any request that goes in\n    a browser. For authentication requests, see\n    [AuthorizationRequest][requests_oauth2client.authorization_request.AuthorizationRequest]. You\n    may use the method `authorization_request()` to generate `AuthorizationRequest`s with the\n    preconfigured `authorization_endpoint`, `client_id` and `redirect_uri' from this client.\n\n    Args:\n        token_endpoint: the Token Endpoint URI where this client will get access tokens\n        auth: the authentication handler to use for client authentication on the token endpoint.\n            Can be:\n\n            - a [requests.auth.AuthBase][] instance (which will be used as-is)\n            - a tuple of `(client_id, client_secret)` which will initialize an instance\n            of [ClientSecretPost][requests_oauth2client.client_authentication.ClientSecretPost]\n            - a `(client_id, jwk)` to initialize\n            a [PrivateKeyJwt][requests_oauth2client.client_authentication.PrivateKeyJwt],\n            - or a `client_id` which will\n            use [PublicApp][requests_oauth2client.client_authentication.PublicApp] authentication.\n\n        client_id: client ID (use either this or `auth`)\n        client_secret: client secret (use either this or `auth`)\n        private_key: private_key to use for client authentication (use either this or `auth`)\n        revocation_endpoint: the Revocation Endpoint URI to use for revoking tokens\n        introspection_endpoint: the Introspection Endpoint URI to use to get info about tokens\n        userinfo_endpoint: the Userinfo Endpoint URI to use to get information about the user\n        authorization_endpoint: the Authorization Endpoint URI, used for initializing Authorization Requests\n        redirect_uri: the redirect_uri for this client\n        backchannel_authentication_endpoint: the BackChannel Authentication URI\n        device_authorization_endpoint: the Device Authorization Endpoint URI to use to authorize devices\n        jwks_uri: the JWKS URI to use to obtain the AS public keys\n        code_challenge_method: challenge method to use for PKCE (should always be 'S256')\n        session: a requests Session to use when sending HTTP requests.\n            Useful if some extra parameters such as proxy or client certificate must be used\n            to connect to the AS.\n        token_class: a custom BearerToken class, if required\n        dpop_bound_access_tokens: if `True`, DPoP will be used by default for every token request.\n            otherwise, you can enable DPoP by passing `dpop=True` when doing a token request.\n        dpop_key_generator: a callable that generates a DPoPKey, for whill be called when doing a token request\n            with DPoP enabled.\n        testing: if `True`, don't verify the validity of the endpoint urls that are passed as parameter.\n        **extra_metadata: additional metadata for this client, unused by this class, but may be\n            used by subclasses. Those will be accessible with the `extra_metadata` attribute.\n\n    Example:\n        ```python\n        client = OAuth2Client(\n            token_endpoint=\"https://my.as.local/token\",\n            revocation_endpoint=\"https://my.as.local/revoke\",\n            client_id=\"client_id\",\n            client_secret=\"client_secret\",\n        )\n\n        # once initialized, a client can send requests to its configured endpoints\n        cc_token = client.client_credentials(scope=\"my_scope\")\n        ac_token = client.authorization_code(code=\"my_code\")\n        client.revoke_access_token(cc_token)\n        ```\n\n    Raises:\n        MissingIDTokenEncryptedResponseAlgParam: if an `id_token_decryption_key` is provided\n            but no decryption alg is provided, either:\n\n            - using `id_token_encrypted_response_alg`,\n            - or in the `alg` parameter of the `Jwk` key\n        MissingIssuerParam: if `authorization_response_iss_parameter_supported` is set to `True`\n            but the `issuer` is not provided.\n        InvalidEndpointUri: if a provided endpoint uri is not considered valid. For the rare cases\n            where those checks must be disabled, you can use `testing=True`.\n        InvalidIssuer: if the `issuer` value is not considered valid.\n\n    \"\"\"\n\n    auth: requests.auth.AuthBase\n    token_endpoint: str = field()\n    revocation_endpoint: str | None = field()\n    introspection_endpoint: str | None = field()\n    userinfo_endpoint: str | None = field()\n    authorization_endpoint: str | None = field()\n    redirect_uri: str | None = field()\n    backchannel_authentication_endpoint: str | None = field()\n    device_authorization_endpoint: str | None = field()\n    pushed_authorization_request_endpoint: str | None = field()\n    jwks_uri: str | None = field()\n    authorization_server_jwks: JwkSet\n    issuer: str | None = field()\n    id_token_signed_response_alg: str | None\n    id_token_encrypted_response_alg: str | None\n    id_token_decryption_key: Jwk | None\n    code_challenge_method: str | None\n    authorization_response_iss_parameter_supported: bool\n    session: requests.Session\n    extra_metadata: dict[str, Any]\n    testing: bool\n\n    dpop_bound_access_tokens: bool\n    dpop_key_generator: Callable[[str], DPoPKey]\n    dpop_alg: str\n\n    token_class: type[BearerToken]\n\n    exception_classes: ClassVar[dict[str, type[EndpointError]]] = {\n        \"server_error\": ServerError,\n        \"invalid_request\": InvalidRequest,\n        \"invalid_client\": InvalidClient,\n        \"invalid_scope\": InvalidScope,\n        \"invalid_target\": InvalidTarget,\n        \"invalid_grant\": InvalidGrant,\n        \"access_denied\": AccessDenied,\n        \"unauthorized_client\": UnauthorizedClient,\n        \"authorization_pending\": AuthorizationPending,\n        \"slow_down\": SlowDown,\n        \"expired_token\": ExpiredToken,\n        \"use_dpop_nonce\": UseDPoPNonce,\n        \"unsupported_token_type\": UnsupportedTokenType,\n    }\n\n    def __init__(  # noqa: PLR0913\n        self,\n        token_endpoint: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        revocation_endpoint: str | None = None,\n        introspection_endpoint: str | None = None,\n        userinfo_endpoint: str | None = None,\n        authorization_endpoint: str | None = None,\n        redirect_uri: str | None = None,\n        backchannel_authentication_endpoint: str | None = None,\n        device_authorization_endpoint: str | None = None,\n        pushed_authorization_request_endpoint: str | None = None,\n        jwks_uri: str | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        issuer: str | None = None,\n        id_token_signed_response_alg: str | None = SignatureAlgs.RS256,\n        id_token_encrypted_response_alg: str | None = None,\n        id_token_decryption_key: Jwk | dict[str, Any] | None = None,\n        code_challenge_method: str = CodeChallengeMethods.S256,\n        authorization_response_iss_parameter_supported: bool = False,\n        token_class: type[BearerToken] = BearerToken,\n        session: requests.Session | None = None,\n        dpop_bound_access_tokens: bool = False,\n        dpop_key_generator: Callable[[str], DPoPKey] = DPoPKey.generate,\n        dpop_alg: str = SignatureAlgs.ES256,\n        testing: bool = False,\n        **extra_metadata: Any,\n    ) -&gt; None:\n        if authorization_response_iss_parameter_supported and not issuer:\n            raise MissingIssuerParam\n\n        auth = client_auth_factory(\n            auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            default_auth_handler=ClientSecretPost,\n        )\n\n        if authorization_server_jwks is None:\n            authorization_server_jwks = JwkSet()\n        elif not isinstance(authorization_server_jwks, JwkSet):\n            authorization_server_jwks = JwkSet(authorization_server_jwks)\n\n        if id_token_decryption_key is not None and not isinstance(id_token_decryption_key, Jwk):\n            id_token_decryption_key = Jwk(id_token_decryption_key)\n\n        if id_token_decryption_key is not None and id_token_encrypted_response_alg is None:\n            if id_token_decryption_key.alg:\n                id_token_encrypted_response_alg = id_token_decryption_key.alg\n            else:\n                raise MissingIdTokenEncryptedResponseAlgParam\n\n        if dpop_alg not in SignatureAlgs.ALL_ASYMMETRIC:\n            raise InvalidDPoPAlg(dpop_alg)\n\n        if session is None:\n            session = requests.Session()\n\n        self.__attrs_init__(\n            testing=testing,\n            token_endpoint=token_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            redirect_uri=redirect_uri,\n            backchannel_authentication_endpoint=backchannel_authentication_endpoint,\n            device_authorization_endpoint=device_authorization_endpoint,\n            pushed_authorization_request_endpoint=pushed_authorization_request_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            issuer=issuer,\n            session=session,\n            auth=auth,\n            id_token_signed_response_alg=id_token_signed_response_alg,\n            id_token_encrypted_response_alg=id_token_encrypted_response_alg,\n            id_token_decryption_key=id_token_decryption_key,\n            code_challenge_method=code_challenge_method,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            extra_metadata=extra_metadata,\n            token_class=token_class,\n            dpop_key_generator=dpop_key_generator,\n            dpop_bound_access_tokens=dpop_bound_access_tokens,\n            dpop_alg=dpop_alg,\n        )\n\n    @token_endpoint.validator\n    @revocation_endpoint.validator\n    @introspection_endpoint.validator\n    @userinfo_endpoint.validator\n    @authorization_endpoint.validator\n    @backchannel_authentication_endpoint.validator\n    @device_authorization_endpoint.validator\n    @pushed_authorization_request_endpoint.validator\n    @jwks_uri.validator\n    def validate_endpoint_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n        \"\"\"Validate that an endpoint URI is suitable for use.\n\n        If you need to disable some checks (for AS testing purposes only!), provide a different method here.\n\n        \"\"\"\n        if self.testing or uri is None:\n            return uri\n        try:\n            return validate_endpoint_uri(uri)\n        except InvalidUri as exc:\n            raise InvalidEndpointUri(endpoint=attribute.name, uri=uri, exc=exc) from exc\n\n    @issuer.validator\n    def validate_issuer_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n        \"\"\"Validate that an Issuer identifier is suitable for use.\n\n        This is the same check as an endpoint URI, but the path may be (and usually is) empty.\n\n        \"\"\"\n        if self.testing or uri is None:\n            return uri\n        try:\n            return validate_issuer_uri(uri)\n        except InvalidUri as exc:\n            raise InvalidIssuer(attribute.name, uri, exc) from exc\n\n    @property\n    def client_id(self) -&gt; str:\n        \"\"\"Client ID.\"\"\"\n        if hasattr(self.auth, \"client_id\"):\n            return self.auth.client_id  # type: ignore[no-any-return]\n        msg = \"This client uses a custom authentication method without client_id.\"\n        raise AttributeError(msg)  # pragma: no cover\n\n    @property\n    def client_secret(self) -&gt; str | None:\n        \"\"\"Client Secret.\"\"\"\n        if hasattr(self.auth, \"client_secret\"):\n            return self.auth.client_secret  # type: ignore[no-any-return]\n        return None\n\n    @property\n    def client_jwks(self) -&gt; JwkSet:\n        \"\"\"A `JwkSet` containing the public keys for this client.\n\n        Keys are:\n\n        - the public key for client assertion signature verification (if using private_key_jwt)\n        - the ID Token encryption key\n\n        \"\"\"\n        jwks = JwkSet()\n        if isinstance(self.auth, PrivateKeyJwt):\n            jwks.add_jwk(self.auth.private_jwk.public_jwk().with_usage_parameters())\n        if self.id_token_decryption_key:\n            jwks.add_jwk(self.id_token_decryption_key.public_jwk().with_usage_parameters())\n        return jwks\n\n    def _request(\n        self,\n        endpoint: str,\n        *,\n        on_success: Callable[[requests.Response, DefaultNamedArg(DPoPKey | None, \"dpop_key\")], T],\n        on_failure: Callable[[requests.Response, DefaultNamedArg(DPoPKey | None, \"dpop_key\")], T],\n        dpop_key: DPoPKey | None = None,\n        accept: str = \"application/json\",\n        method: str = \"POST\",\n        **requests_kwargs: Any,\n    ) -&gt; T:\n        \"\"\"Send a request to one of the endpoints.\n\n        This is a helper method that takes care of the following tasks:\n\n        - make sure the endpoint as been configured\n        - set `Accept: application/json` header\n        - send the HTTP POST request, then\n            - apply `on_success` to a successful response\n            - or apply `on_failure` otherwise\n        - return the result\n\n        Args:\n            endpoint: name of the endpoint to use\n            on_success: a callable to apply to successful responses\n            on_failure: a callable to apply to error responses\n            dpop_key: a `DPoPKey` to proof the request. If `None` (default), no DPoP proofing is done.\n            accept: the Accept header to include in the request\n            method: the HTTP method to use\n            **requests_kwargs: keyword arguments for the request\n\n        Raises:\n            InvalidTokenResponse: if the AS response contains a `use_dpop_nonce` error but:\n              - the response comes in reply to a non-DPoP request\n              - the DPoPKey.handle_as_provided_dpop_nonce() method raises an exception. This should happen:\n                    - if the response does not include a DPoP-Nonce HTTP header with the requested nonce value\n                    - or if the requested nonce is the same value that was sent in the request DPoP proof\n              - a new nonce value is requested again for the 3rd time in a row\n\n        \"\"\"\n        endpoint_uri = self._require_endpoint(endpoint)\n        requests_kwargs.setdefault(\"headers\", {})\n        requests_kwargs[\"headers\"][\"Accept\"] = accept\n\n        for _ in range(3):\n            if dpop_key:\n                dpop_proof = dpop_key.proof(htm=\"POST\", htu=endpoint_uri, nonce=dpop_key.as_nonce)\n                requests_kwargs.setdefault(\"headers\", {})\n                requests_kwargs[\"headers\"][\"DPoP\"] = str(dpop_proof)\n\n            response = self.session.request(\n                method,\n                endpoint_uri,\n                **requests_kwargs,\n            )\n            if response.ok:\n                return on_success(response, dpop_key=dpop_key)\n\n            try:\n                return on_failure(response, dpop_key=dpop_key)\n            except UseDPoPNonce as exc:\n                if dpop_key is None:\n                    raise InvalidTokenResponse(\n                        response,\n                        self,\n                        \"\"\"\\\nAuthorization Server requested client to include a DPoP `nonce` in its DPoP proof,\nbut the initial request did not include a DPoP proof.\n\"\"\",\n                    ) from exc\n                try:\n                    dpop_key.handle_as_provided_dpop_nonce(response)\n                except (MissingDPoPNonce, RepeatedDPoPNonce) as exc:\n                    raise InvalidTokenResponse(response, self, str(exc)) from exc\n\n        raise InvalidTokenResponse(\n            response,\n            self,\n            \"\"\"\\\nAuthorization Server requested client to use a different DPoP `nonce` for the third time in row.\nThis should never happen. This exception is raised to avoid a potential endless loop where the client\nkeeps trying to obey the new DPoP `nonce` values as provided by the Authorization Server after each token request.\n\"\"\",\n        )\n\n    def token_request(\n        self,\n        data: dict[str, Any],\n        *,\n        timeout: int = 10,\n        dpop: bool | None = None,\n        dpop_key: DPoPKey | None = None,\n        **requests_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint.\n\n        Authentication will be added automatically based on the defined `auth` for this client.\n\n        Args:\n          data: parameters to send to the token endpoint. Items with a `None`\n               or empty value will not be sent in the request.\n          timeout: a timeout value for the call\n          dpop: toggles DPoP-proofing for the token request:\n\n                - if `False`, disable it,\n                - if `True`, enable it,\n                - if `None`, defaults to `dpop_bound_access_tokens` configuration parameter for the client.\n          dpop_key: a chosen `DPoPKey` for this request. If `None`, a new key will be generated automatically\n                with a call to this client `dpop_key_generator`.\n          **requests_kwargs: additional parameters for requests.post()\n\n        Returns:\n            the token endpoint response\n\n        \"\"\"\n        if dpop is None:\n            dpop = self.dpop_bound_access_tokens\n        if dpop and not dpop_key:\n            dpop_key = self.dpop_key_generator(self.dpop_alg)\n\n        return self._request(\n            Endpoints.TOKEN,\n            auth=self.auth,\n            data=data,\n            timeout=timeout,\n            dpop_key=dpop_key,\n            on_success=self.parse_token_response,\n            on_failure=self.on_token_error,\n            **requests_kwargs,\n        )\n\n    def parse_token_response(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; BearerToken:\n        \"\"\"Parse a Response returned by the Token Endpoint.\n\n        Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse\n        responses returned by the Token Endpoint. Those responses contain an `access_token` and\n        additional attributes.\n\n        Args:\n            response: the `Response` returned by the Token Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            a `BearerToken` based on the response contents.\n\n        \"\"\"\n        token_class = dpop_key.dpop_token_class if dpop_key is not None else self.token_class\n        try:\n            token_response = token_class(**response.json(), _dpop_key=dpop_key)\n        except Exception:  # noqa: BLE001\n            return self.on_token_error(response, dpop_key=dpop_key)\n        else:\n            return token_response\n\n    def on_token_error(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,  # noqa: ARG002\n    ) -&gt; BearerToken:\n        \"\"\"Error handler for `token_request()`.\n\n        Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the\n        Token Endpoint returns an error.\n\n        Args:\n            response: the `Response` returned by the Token Endpoint.\n            dpop_key: the DPoPKey that was used to proof the token request, if any.\n\n        Returns:\n            nothing, and raises an exception instead. But a subclass may return a\n            `BearerToken` to implement a default behaviour if needed.\n\n        Raises:\n            InvalidTokenResponse: if the error response does not contain an OAuth 2.0 standard\n                error response.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidTokenResponse(\n                response=response,\n                client=self,\n                description=f\"An error happened while processing the error response: {exc}\",\n            ) from exc\n        raise exception\n\n    def client_credentials(\n        self,\n        scope: str | Iterable[str] | None = None,\n        *,\n        dpop: bool | None = None,\n        dpop_key: DPoPKey | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint using the `client_credentials` grant.\n\n        Args:\n            scope: the scope to send with the request. Can be a str, or an iterable of str.\n                to pass that way include `scope`, `audience`, `resource`, etc.\n            dpop: toggles DPoP-proofing for the token request:\n\n                - if `False`, disable it,\n                - if `True`, enable it,\n                - if `None`, defaults to `dpop_bound_access_tokens` configuration parameter for the client.\n            dpop_key: a chosen `DPoPKey` for this request. If `None`, a new key will be generated automatically\n                with a call to `dpop_key_generator`.\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters that will be added in the form data for the token endpoint,\n                 alongside `grant_type`.\n\n        Returns:\n            a `BearerToken` or `DPoPToken`, depending on the AS response.\n\n        Raises:\n            InvalidScopeParam: if the `scope` parameter is not suitable\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if scope and not isinstance(scope, str):\n            try:\n                scope = \" \".join(scope)\n            except Exception as exc:\n                raise InvalidScopeParam(scope) from exc\n\n        data = dict(grant_type=GrantTypes.CLIENT_CREDENTIALS, scope=scope, **token_kwargs)\n        return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n\n    def authorization_code(\n        self,\n        code: str | AuthorizationResponse,\n        *,\n        validate: bool = True,\n        dpop: bool = False,\n        dpop_key: DPoPKey | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint with the `authorization_code` grant.\n\n        You can either pass an authorization code, as a `str`, or pass an `AuthorizationResponse` instance as\n        returned by `AuthorizationRequest.validate_callback()` (recommended). If you do the latter, this will\n        automatically:\n\n        - add the appropriate `redirect_uri` value that was initially passed in the Authorization Request parameters.\n        This is no longer mandatory in OAuth 2.1, but a lot of Authorization Servers are still expecting it since it was\n        part of the OAuth 2.0 specifications.\n        - add the appropriate `code_verifier` for PKCE that was generated before sending the AuthorizationRequest.\n        - handle DPoP binding based on the same `DPoPKey` that was used to initialize the `AuthenticationRequest` and\n        whose JWK thumbprint was passed as `dpop_jkt` parameter in the Auth Request.\n\n        Args:\n            code: An authorization code or an `AuthorizationResponse` to exchange for tokens.\n            validate: If `True`, validate the ID Token (this works only if `code` is an `AuthorizationResponse`).\n            dpop: Toggles DPoP binding for the Access Token,\n                 even if Authorization Code DPoP binding was not initially done.\n            dpop_key: A chosen DPoP key. Leave `None` to automatically generate a key, if `dpop` is `True`.\n            requests_kwargs: Additional parameters for the call to the underlying HTTP `requests` call.\n            **token_kwargs: Additional parameters that will be added in the form data for the token endpoint,\n                alongside `grant_type`, `code`, etc.\n\n        Returns:\n            The Token Endpoint Response.\n\n        \"\"\"\n        azr: AuthorizationResponse | None = None\n        if isinstance(code, AuthorizationResponse):\n            token_kwargs.setdefault(\"code_verifier\", code.code_verifier)\n            token_kwargs.setdefault(\"redirect_uri\", code.redirect_uri)\n            azr = code\n            dpop_key = code.dpop_key\n            code = code.code\n\n        requests_kwargs = requests_kwargs or {}\n\n        data = dict(grant_type=GrantTypes.AUTHORIZATION_CODE, code=code, **token_kwargs)\n        token = self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n        if validate and token.id_token and isinstance(azr, AuthorizationResponse):\n            return token.validate_id_token(self, azr)\n        return token\n\n    def refresh_token(\n        self,\n        refresh_token: str | BearerToken,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint with the `refresh_token` grant.\n\n        If `refresh_token` is a `DPoPToken` instance, (which means that DPoP was used to obtain the initial\n        Access/Refresh Tokens), then the same DPoP key will be used to DPoP proof the refresh token request,\n        as defined in RFC9449.\n\n        Args:\n            refresh_token: A refresh_token, as a string, or as a `BearerToken`.\n                That `BearerToken` must have a `refresh_token`.\n            requests_kwargs: Additional parameters for the call to `requests`.\n            **token_kwargs: Additional parameters for the token endpoint,\n                alongside `grant_type`, `refresh_token`, etc.\n\n        Returns:\n            The token endpoint response.\n\n        Raises:\n            MissingRefreshToken: If `refresh_token` is a `BearerToken` instance but does not\n                contain a `refresh_token`.\n\n        \"\"\"\n        dpop_key: DPoPKey | None = None\n        if isinstance(refresh_token, BearerToken):\n            if refresh_token.refresh_token is None or not isinstance(refresh_token.refresh_token, str):\n                raise MissingRefreshToken(refresh_token)\n            if isinstance(refresh_token, DPoPToken):\n                dpop_key = refresh_token.dpop_key\n            refresh_token = refresh_token.refresh_token\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(grant_type=GrantTypes.REFRESH_TOKEN, refresh_token=refresh_token, **token_kwargs)\n        return self.token_request(data, dpop_key=dpop_key, **requests_kwargs)\n\n    def device_code(\n        self,\n        device_code: str | DeviceAuthorizationResponse,\n        *,\n        dpop: bool = False,\n        dpop_key: DPoPKey | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint using the Device Code grant.\n\n        The grant_type is `urn:ietf:params:oauth:grant-type:device_code`. This needs a Device Code,\n        or a `DeviceAuthorizationResponse` as parameter.\n\n        Args:\n            device_code: A device code, or a `DeviceAuthorizationResponse`.\n            dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n            dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n            requests_kwargs: Additional parameters for the call to requests.\n            **token_kwargs: Additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc.\n\n        Returns:\n            The Token Endpoint response.\n\n        Raises:\n            MissingDeviceCode: if `device_code` is a DeviceAuthorizationResponse but does not\n                contain a `device_code`.\n\n        \"\"\"\n        if isinstance(device_code, DeviceAuthorizationResponse):\n            if device_code.device_code is None or not isinstance(device_code.device_code, str):\n                raise MissingDeviceCode(device_code)\n            device_code = device_code.device_code\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantTypes.DEVICE_CODE,\n            device_code=device_code,\n            **token_kwargs,\n        )\n        return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n\n    def ciba(\n        self,\n        auth_req_id: str | BackChannelAuthenticationResponse,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a CIBA request to the Token Endpoint.\n\n        A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant.\n\n        Args:\n            auth_req_id: an authentication request ID, as returned by the AS\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc.\n\n        Returns:\n            The Token Endpoint response.\n\n        Raises:\n            MissingAuthRequestId: if `auth_req_id` is a BackChannelAuthenticationResponse but does not contain\n                an `auth_req_id`.\n\n        \"\"\"\n        if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n            if auth_req_id.auth_req_id is None or not isinstance(auth_req_id.auth_req_id, str):\n                raise MissingAuthRequestId(auth_req_id)\n            auth_req_id = auth_req_id.auth_req_id\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantTypes.CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION,\n            auth_req_id=auth_req_id,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def token_exchange(\n        self,\n        *,\n        subject_token: str | BearerToken | IdToken,\n        subject_token_type: str | None = None,\n        actor_token: None | str | BearerToken | IdToken = None,\n        actor_token_type: str | None = None,\n        requested_token_type: str | None = None,\n        dpop: bool = False,\n        dpop_key: DPoPKey | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a Token Exchange request.\n\n        A Token Exchange request is actually a request to the Token Endpoint with a grant_type\n        `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n        Args:\n            subject_token: The subject token to exchange for a new token.\n            subject_token_type: A token type identifier for the subject_token, mandatory if it cannot be guessed based\n                on `type(subject_token)`.\n            actor_token: The actor token to include in the request, if any.\n            actor_token_type: A token type identifier for the actor_token, mandatory if it cannot be guessed based\n                on `type(actor_token)`.\n            requested_token_type: A token type identifier for the requested token.\n            dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n            dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n            requests_kwargs: Additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: Additional parameters to include in the request body.\n\n        Returns:\n            The Token Endpoint response.\n\n        Raises:\n            UnknownSubjectTokenType: If the type of `subject_token` cannot be determined automatically.\n            UnknownActorTokenType: If the type of `actor_token` cannot be determined automatically.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        try:\n            subject_token_type = self.get_token_type(subject_token_type, subject_token)\n        except ValueError as exc:\n            raise UnknownSubjectTokenType(subject_token, subject_token_type) from exc\n        if actor_token:  # pragma: no branch\n            try:\n                actor_token_type = self.get_token_type(actor_token_type, actor_token)\n            except ValueError as exc:\n                raise UnknownActorTokenType(actor_token, actor_token_type) from exc\n\n        data = dict(\n            grant_type=GrantTypes.TOKEN_EXCHANGE,\n            subject_token=subject_token,\n            subject_token_type=subject_token_type,\n            actor_token=actor_token,\n            actor_token_type=actor_token_type,\n            requested_token_type=requested_token_type,\n            **token_kwargs,\n        )\n        return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n\n    def jwt_bearer(\n        self,\n        assertion: Jwt | str,\n        *,\n        dpop: bool = False,\n        dpop_key: DPoPKey | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request using a JWT as authorization grant.\n\n        This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).\n\n        Args:\n            assertion: A JWT (as an instance of `jwskate.Jwt` or as a `str`) to use as authorization grant.\n            dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n            dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n            requests_kwargs: Additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: Additional parameters to include in the request body.\n\n        Returns:\n            The Token Endpoint response.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if not isinstance(assertion, Jwt):\n            assertion = Jwt(assertion)\n\n        data = dict(\n            grant_type=GrantTypes.JWT_BEARER,\n            assertion=assertion,\n            **token_kwargs,\n        )\n\n        return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n\n    def resource_owner_password(\n        self,\n        username: str,\n        password: str,\n        *,\n        dpop: bool | None = None,\n        dpop_key: DPoPKey | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request using the Resource Owner Password Grant.\n\n        This Grant Type is deprecated and should only be used when there is no other choice.\n\n        Args:\n            username: the resource owner user name\n            password: the resource owner password\n            dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n            dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            The Token Endpoint response.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantTypes.RESOURCE_OWNER_PASSWORD,\n            username=username,\n            password=password,\n            **token_kwargs,\n        )\n\n        return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n\n    def authorization_request(\n        self,\n        *,\n        scope: None | str | Iterable[str] = \"openid\",\n        response_type: str = ResponseTypes.CODE,\n        redirect_uri: str | None = None,\n        state: str | ellipsis | None = ...,  # noqa: F821\n        nonce: str | ellipsis | None = ...,  # noqa: F821\n        code_verifier: str | None = None,\n        dpop: bool | None = None,\n        dpop_key: DPoPKey | None = None,\n        dpop_alg: str | None = None,\n        **kwargs: Any,\n    ) -&gt; AuthorizationRequest:\n        \"\"\"Generate an Authorization Request for this client.\n\n        Args:\n            scope: The `scope` to use.\n            response_type: The `response_type` to use.\n            redirect_uri: The `redirect_uri` to include in the request. By default,\n                the `redirect_uri` defined at init time is used.\n            state: The `state` parameter to use. Leave default to generate a random value.\n            nonce: A `nonce`. Leave default to generate a random value.\n            dpop: Toggles DPoP binding.\n                - if `True`, DPoP binding is used\n                - if `False`, DPoP is not used\n                - if `None`, defaults to `self.dpop_bound_access_tokens`\n            dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for you.\n            dpop_alg: A signature alg to sign the DPoP proof. If `None`, this defaults to `self.dpop_alg`.\n                If DPoP is not used, or a chosen `dpop_key` is provided, this is ignored.\n                This affects the key type if a DPoP key must be generated.\n            code_verifier: The PKCE `code_verifier` to use. Leave default to generate a random value.\n            **kwargs: Additional query parameters to include in the auth request.\n\n        Returns:\n            The Token Endpoint response.\n\n        \"\"\"\n        authorization_endpoint = self._require_endpoint(\"authorization_endpoint\")\n\n        redirect_uri = redirect_uri or self.redirect_uri\n\n        if dpop is None:\n            dpop = self.dpop_bound_access_tokens\n        if dpop_alg is None:\n            dpop_alg = self.dpop_alg\n\n        return AuthorizationRequest(\n            authorization_endpoint=authorization_endpoint,\n            client_id=self.client_id,\n            redirect_uri=redirect_uri,\n            issuer=self.issuer,\n            response_type=response_type,\n            scope=scope,\n            state=state,\n            nonce=nonce,\n            code_verifier=code_verifier,\n            code_challenge_method=self.code_challenge_method,\n            dpop=dpop,\n            dpop_key=dpop_key,\n            dpop_alg=dpop_alg,\n            **kwargs,\n        )\n\n    def pushed_authorization_request(\n        self,\n        authorization_request: AuthorizationRequest,\n        requests_kwargs: dict[str, Any] | None = None,\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Send a Pushed Authorization Request.\n\n        This sends a request to the Pushed Authorization Request Endpoint, and returns a\n        `RequestUriParameterAuthorizationRequest` initialized with the AS response.\n\n        Args:\n            authorization_request: The authorization request to send.\n            requests_kwargs: Additional parameters for `requests.request()`.\n\n        Returns:\n            The `RequestUriParameterAuthorizationRequest` initialized based on the AS response.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n        return self._request(\n            Endpoints.PUSHED_AUTHORIZATION_REQUEST,\n            data=authorization_request.args,\n            auth=self.auth,\n            on_success=self.parse_pushed_authorization_response,\n            on_failure=self.on_pushed_authorization_request_error,\n            dpop_key=authorization_request.dpop_key,\n            **requests_kwargs,\n        )\n\n    def parse_pushed_authorization_response(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Parse the response obtained by `pushed_authorization_request()`.\n\n        Args:\n            response: The `requests.Response` returned by the PAR endpoint.\n            dpop_key: The `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            A `RequestUriParameterAuthorizationRequest` instance initialized based on the PAR endpoint response.\n\n        \"\"\"\n        response_json = response.json()\n        request_uri = response_json.get(\"request_uri\")\n        expires_in = response_json.get(\"expires_in\")\n\n        return RequestUriParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request_uri=request_uri,\n            expires_in=expires_in,\n            dpop_key=dpop_key,\n        )\n\n    def on_pushed_authorization_request_error(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,  # noqa: ARG002\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Error Handler for Pushed Authorization Endpoint errors.\n\n        Args:\n            response: The HTTP response as returned by the AS PAR endpoint.\n            dpop_key: The `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            Should not return anything, but raise an Exception instead. A `RequestUriParameterAuthorizationRequest`\n            may be returned by subclasses for testing purposes.\n\n        Raises:\n            EndpointError: A subclass of this error depending on the error returned by the AS.\n            InvalidPushedAuthorizationResponse: If the returned response is not following the specifications.\n            UnknownTokenEndpointError: For unknown/unhandled errors.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidPushedAuthorizationResponse(response=response, client=self) from exc\n        raise exception\n\n    def userinfo(self, access_token: BearerToken | str) -&gt; Any:\n        \"\"\"Call the UserInfo endpoint.\n\n        This sends a request to the UserInfo endpoint, with the specified access_token, and returns\n        the parsed result.\n\n        Args:\n            access_token: the access token to use\n\n        Returns:\n            the [Response][requests.Response] returned by the userinfo endpoint.\n\n        \"\"\"\n        if isinstance(access_token, str):\n            access_token = BearerToken(access_token)\n        return self._request(\n            Endpoints.USER_INFO,\n            auth=access_token,\n            on_success=self.parse_userinfo_response,\n            on_failure=self.on_userinfo_error,\n        )\n\n    def parse_userinfo_response(self, resp: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; Any:  # noqa: ARG002\n        \"\"\"Parse the response obtained by `userinfo()`.\n\n        Invoked by [userinfo()][requests_oauth2client.client.OAuth2Client.userinfo] to parse the\n        response from the UserInfo endpoint, this will extract and return its JSON content.\n\n        Args:\n            resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            the parsed JSON content from this response.\n\n        \"\"\"\n        return resp.json()\n\n    def on_userinfo_error(self, resp: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; Any:  # noqa: ARG002\n        \"\"\"Parse UserInfo error response.\n\n        Args:\n            resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            nothing, raises exception instead.\n\n        \"\"\"\n        resp.raise_for_status()\n\n    @classmethod\n    def get_token_type(  # noqa: C901\n        cls,\n        token_type: str | None = None,\n        token: None | str | BearerToken | IdToken = None,\n    ) -&gt; str:\n        \"\"\"Get standardized token type identifiers.\n\n        Return a standardized token type identifier, based on a short `token_type` hint and/or a\n        token value.\n\n        Args:\n            token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\"\n                or \"id_token\"\n            token: a token value, as an instance of `BearerToken` or IdToken, or as a `str`.\n\n        Returns:\n            the token_type as defined in the Token Exchange RFC8693.\n\n        Raises:\n            UnknownTokenType: if the type of token cannot be determined\n\n        \"\"\"\n        if not (token_type or token):\n            msg = \"Cannot determine type of an empty token without a token_type hint\"\n            raise UnknownTokenType(msg, token, token_type)\n\n        if token_type is None:\n            if isinstance(token, str):\n                msg = \"\"\"\\\nCannot determine the type of provided token when it is a bare `str`. Please specify a 'token_type'.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            if isinstance(token, BearerToken):\n                return \"urn:ietf:params:oauth:token-type:access_token\"\n            if isinstance(token, IdToken):\n                return \"urn:ietf:params:oauth:token-type:id_token\"\n            msg = f\"Unknown token type {type(token)}\"\n            raise UnknownTokenType(msg, token, token_type)\n        if token_type == TokenType.ACCESS_TOKEN:\n            if token is not None and not isinstance(token, (str, BearerToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nA BearerToken or an access_token as a `str` is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:access_token\"\n        if token_type == TokenType.REFRESH_TOKEN:\n            if token is not None and isinstance(token, BearerToken) and not token.refresh_token:\n                msg = f\"\"\"\\\nThe supplied BearerToken does not contain a refresh_token, which is inconsistent with token_type '{token_type}'.\nA BearerToken containing a refresh_token is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:refresh_token\"\n        if token_type == TokenType.ID_TOKEN:\n            if token is not None and not isinstance(token, (str, IdToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nAn IdToken or a string representation of it is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:id_token\"\n\n        return {\n            \"saml1\": \"urn:ietf:params:oauth:token-type:saml1\",\n            \"saml2\": \"urn:ietf:params:oauth:token-type:saml2\",\n            \"jwt\": \"urn:ietf:params:oauth:token-type:jwt\",\n        }.get(token_type, token_type)\n\n    def revoke_access_token(\n        self,\n        access_token: BearerToken | str,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a request to the Revocation Endpoint to revoke an access token.\n\n        Args:\n            access_token: the access token to revoke\n            requests_kwargs: additional parameters for the underlying requests.post() call\n            **revoke_kwargs: additional parameters to pass to the revocation endpoint\n\n        \"\"\"\n        return self.revoke_token(\n            access_token,\n            token_type_hint=TokenType.ACCESS_TOKEN,\n            requests_kwargs=requests_kwargs,\n            **revoke_kwargs,\n        )\n\n    def revoke_refresh_token(\n        self,\n        refresh_token: str | BearerToken,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a request to the Revocation Endpoint to revoke a refresh token.\n\n        Args:\n            refresh_token: the refresh token to revoke.\n            requests_kwargs: additional parameters to pass to the revocation endpoint.\n            **revoke_kwargs: additional parameters to pass to the revocation endpoint.\n\n        Returns:\n            `True` if the revocation request is successful, `False` if this client has no configured\n            revocation endpoint.\n\n        Raises:\n            MissingRefreshToken: when `refresh_token` is a [BearerToken][requests_oauth2client.tokens.BearerToken]\n                but does not contain a `refresh_token`.\n\n        \"\"\"\n        if isinstance(refresh_token, BearerToken):\n            if refresh_token.refresh_token is None:\n                raise MissingRefreshToken(refresh_token)\n            refresh_token = refresh_token.refresh_token\n\n        return self.revoke_token(\n            refresh_token,\n            token_type_hint=TokenType.REFRESH_TOKEN,\n            requests_kwargs=requests_kwargs,\n            **revoke_kwargs,\n        )\n\n    def revoke_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a Token Revocation request.\n\n        By default, authentication will be the same than the one used for the Token Endpoint.\n\n        Args:\n            token: the token to revoke.\n            token_type_hint: a token_type_hint to send to the revocation endpoint.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **revoke_kwargs: additional parameters to send to the revocation endpoint.\n\n        Returns:\n            the result from `parse_revocation_response` on the returned AS response.\n\n        Raises:\n            MissingEndpointUri: if the Revocation Endpoint URI is not configured.\n            MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n                but does not contain a `refresh_token`.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if token_type_hint == TokenType.REFRESH_TOKEN and isinstance(token, BearerToken):\n            if token.refresh_token is None:\n                raise MissingRefreshToken(token)\n            token = token.refresh_token\n\n        data = dict(revoke_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            Endpoints.REVOCATION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_revocation_response,\n            on_failure=self.on_revocation_error,\n            **requests_kwargs,\n        )\n\n    def parse_revocation_response(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; bool:  # noqa: ARG002\n        \"\"\"Parse reponses from the Revocation Endpoint.\n\n        Since those do not return any meaningful information in a standardised fashion, this just returns `True`.\n\n        Args:\n            response: the `requests.Response` as returned by the Revocation Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            `True` if the revocation succeeds, `False` if no revocation endpoint is present or a\n            non-standardised error is returned.\n\n        \"\"\"\n        return True\n\n    def on_revocation_error(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; bool:  # noqa: ARG002\n        \"\"\"Error handler for `revoke_token()`.\n\n        Invoked by [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token] when the\n        revocation endpoint returns an error.\n\n        Args:\n            response: the `requests.Response` as returned by the Revocation Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            `False` to signal that an error occurred. May raise exceptions instead depending on the\n            revocation response.\n\n        Raises:\n            EndpointError: if the response contains a standardised OAuth 2.0 error.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, RevocationError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception:  # noqa: BLE001\n            return False\n        raise exception\n\n    def introspect_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **introspect_kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"Send a request to the Introspection Endpoint.\n\n        Parameter `token` can be:\n\n        - a `str`\n        - a `BearerToken` instance\n\n        You may pass any arbitrary `token` and `token_type_hint` values as `str`. Those will\n        be included in the request, as-is.\n        If `token` is a `BearerToken`, then `token_type_hint` must be either:\n\n        - `None`: the access_token will be instrospected and no token_type_hint will be included\n        in the request\n        - `access_token`: same as `None`, but the token_type_hint will be included\n        - or `refresh_token`: only available if a Refresh Token is present in the BearerToken.\n\n        Args:\n            token: the token to instrospect\n            token_type_hint: the `token_type_hint` to include in the request.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **introspect_kwargs: additional parameters to send to the introspection endpoint.\n\n        Returns:\n            the response as returned by the Introspection Endpoint.\n\n        Raises:\n            MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n                but does not contain a `refresh_token`.\n            UnknownTokenType: if `token_type_hint` is neither `None`, `\"access_token\"` or `\"refresh_token\"`.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if isinstance(token, BearerToken):\n            if token_type_hint is None or token_type_hint == TokenType.ACCESS_TOKEN:\n                token = token.access_token\n            elif token_type_hint == TokenType.REFRESH_TOKEN:\n                if token.refresh_token is None:\n                    raise MissingRefreshToken(token)\n\n                token = token.refresh_token\n            else:\n                msg = \"\"\"\\\nInvalid `token_type_hint`. To test arbitrary `token_type_hint` values, you must provide `token` as a `str`.\"\"\"\n                raise UnknownTokenType(msg, token, token_type_hint)\n\n        data = dict(introspect_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            Endpoints.INTROSPECTION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_introspection_response,\n            on_failure=self.on_introspection_error,\n            **requests_kwargs,\n        )\n\n    def parse_introspection_response(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,  # noqa: ARG002\n    ) -&gt; Any:\n        \"\"\"Parse Token Introspection Responses received by `introspect_token()`.\n\n        Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n        to parse the returned response. This decodes the JSON content if possible, otherwise it\n        returns the response as a string.\n\n        Args:\n            response: the [Response][requests.Response] as returned by the Introspection Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            the decoded JSON content, or a `str` with the content.\n\n        \"\"\"\n        try:\n            return response.json()\n        except ValueError:\n            return response.text\n\n    def on_introspection_error(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; Any:  # noqa: ARG002\n        \"\"\"Error handler for `introspect_token()`.\n\n        Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n        to parse the returned response in the case an error is returned.\n\n        Args:\n            response: the response as returned by the Introspection Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            usually raises exceptions. A subclass can return a default response instead.\n\n        Raises:\n            EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n            UnknownIntrospectionError: if the response is not a standard error response.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, IntrospectionError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise UnknownIntrospectionError(response=response, client=self) from exc\n        raise exception\n\n    def backchannel_authentication_request(  # noqa: PLR0913\n        self,\n        scope: None | str | Iterable[str] = \"openid\",\n        *,\n        client_notification_token: str | None = None,\n        acr_values: None | str | Iterable[str] = None,\n        login_hint_token: str | None = None,\n        id_token_hint: str | None = None,\n        login_hint: str | None = None,\n        binding_message: str | None = None,\n        user_code: str | None = None,\n        requested_expiry: int | None = None,\n        private_jwk: Jwk | dict[str, Any] | None = None,\n        alg: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **ciba_kwargs: Any,\n    ) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Send a CIBA Authentication Request.\n\n        Args:\n             scope: the scope to include in the request.\n             client_notification_token: the Client Notification Token to include in the request.\n             acr_values: the acr values to include in the request.\n             login_hint_token: the Login Hint Token to include in the request.\n             id_token_hint: the ID Token Hint to include in the request.\n             login_hint: the Login Hint to include in the request.\n             binding_message: the Binding Message to include in the request.\n             user_code: the User Code to include in the request\n             requested_expiry: the Requested Expiry, in seconds, to include in the request.\n             private_jwk: the JWK to use to sign the request (optional)\n             alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.\n             requests_kwargs: additional parameters for\n             **ciba_kwargs: additional parameters to include in the request.\n\n        Returns:\n            a BackChannelAuthenticationResponse as returned by AS\n\n        Raises:\n            InvalidBackchannelAuthenticationRequestHintParam: if none of `login_hint`, `login_hint_token`\n                or `id_token_hint` is provided, or more than one of them is provided.\n            InvalidScopeParam: if the `scope` parameter is invalid.\n            InvalidAcrValuesParam: if the `acr_values` parameter is invalid.\n\n        \"\"\"\n        if not (login_hint or login_hint_token or id_token_hint):\n            msg = \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n            raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n        if (login_hint_token and id_token_hint) or (login_hint and id_token_hint) or (login_hint_token and login_hint):\n            msg = \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n            raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n        requests_kwargs = requests_kwargs or {}\n\n        if scope is not None and not isinstance(scope, str):\n            try:\n                scope = \" \".join(scope)\n            except Exception as exc:\n                raise InvalidScopeParam(scope) from exc\n\n        if acr_values is not None and not isinstance(acr_values, str):\n            try:\n                acr_values = \" \".join(acr_values)\n            except Exception as exc:\n                raise InvalidAcrValuesParam(acr_values) from exc\n\n        data = dict(\n            ciba_kwargs,\n            scope=scope,\n            client_notification_token=client_notification_token,\n            acr_values=acr_values,\n            login_hint_token=login_hint_token,\n            id_token_hint=id_token_hint,\n            login_hint=login_hint,\n            binding_message=binding_message,\n            user_code=user_code,\n            requested_expiry=requested_expiry,\n        )\n\n        if private_jwk is not None:\n            data = {\"request\": str(Jwt.sign(data, key=private_jwk, alg=alg))}\n\n        return self._request(\n            Endpoints.BACKCHANNEL_AUTHENTICATION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_backchannel_authentication_response,\n            on_failure=self.on_backchannel_authentication_error,\n            **requests_kwargs,\n        )\n\n    def parse_backchannel_authentication_response(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,  # noqa: ARG002\n    ) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Parse a response received by `backchannel_authentication_request()`.\n\n        Invoked by\n        [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n        to parse the response returned by the BackChannel Authentication Endpoint.\n\n        Args:\n            response: the response returned by the BackChannel Authentication Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            a `BackChannelAuthenticationResponse`\n\n        Raises:\n            InvalidBackChannelAuthenticationResponse: if the response does not contain a standard\n                BackChannel Authentication response.\n\n        \"\"\"\n        try:\n            return BackChannelAuthenticationResponse(**response.json())\n        except TypeError as exc:\n            raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n\n    def on_backchannel_authentication_error(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,  # noqa: ARG002\n    ) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Error handler for `backchannel_authentication_request()`.\n\n        Invoked by\n        [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n        to parse the response returned by the BackChannel Authentication Endpoint, when it is an\n        error.\n\n        Args:\n            response: the response returned by the BackChannel Authentication Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            usually raises an exception. But a subclass can return a default response instead.\n\n        Raises:\n            EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n            InvalidBackChannelAuthenticationResponse: for non-standard error responses.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, BackChannelAuthenticationError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n        raise exception\n\n    def authorize_device(\n        self,\n        requests_kwargs: dict[str, Any] | None = None,\n        **data: Any,\n    ) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Send a Device Authorization Request.\n\n        Args:\n            **data: additional data to send to the Device Authorization Endpoint\n            requests_kwargs: additional parameters for `requests.request()`\n\n        Returns:\n            a Device Authorization Response\n\n        Raises:\n            MissingEndpointUri: if the Device Authorization URI is not configured\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        return self._request(\n            Endpoints.DEVICE_AUTHORIZATION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_device_authorization_response,\n            on_failure=self.on_device_authorization_error,\n            **requests_kwargs,\n        )\n\n    def parse_device_authorization_response(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,  # noqa: ARG002\n    ) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Parse a Device Authorization Response received by `authorize_device()`.\n\n        Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n        to parse the response returned by the Device Authorization Endpoint.\n\n        Args:\n            response: the response returned by the Device Authorization Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            a `DeviceAuthorizationResponse` as returned by AS\n\n        \"\"\"\n        return DeviceAuthorizationResponse(**response.json())\n\n    def on_device_authorization_error(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,  # noqa: ARG002\n    ) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Error handler for `authorize_device()`.\n\n        Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n        to parse the response returned by the Device Authorization Endpoint, when that response is\n        an error.\n\n        Args:\n            response: the response returned by the Device Authorization Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            usually raises an Exception. But a subclass may return a default response instead.\n\n        Raises:\n            EndpointError: for standard OAuth 2.0 errors\n            InvalidDeviceAuthorizationResponse: for non-standard error responses.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, DeviceAuthorizationError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidDeviceAuthorizationResponse(response=response, client=self) from exc\n        raise exception\n\n    def update_authorization_server_public_keys(self, requests_kwargs: dict[str, Any] | None = None) -&gt; JwkSet:\n        \"\"\"Update the cached AS public keys by retrieving them from its `jwks_uri`.\n\n        Public keys are returned by this method, as a `jwskate.JwkSet`. They are also\n        available in attribute `authorization_server_jwks`.\n\n        Returns:\n            the retrieved public keys\n\n        Raises:\n            ValueError: if no `jwks_uri` is configured\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n        requests_kwargs.setdefault(\"auth\", None)\n\n        jwks_uri = self._require_endpoint(Endpoints.JWKS)\n        resp = self.session.get(jwks_uri, **requests_kwargs)\n        resp.raise_for_status()\n        jwks = resp.json()\n        self.authorization_server_jwks.update(jwks)\n        return self.authorization_server_jwks\n\n    @classmethod\n    def from_discovery_endpoint(\n        cls,\n        url: str | None = None,\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        session: requests.Session | None = None,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an `OAuth2Client` using an AS Discovery Document endpoint.\n\n        If an `url` is provided, an HTTPS request will be done to that URL to obtain the Authorization Server Metadata.\n\n        If an `issuer` is provided, the OpenID Connect Discovery document url will be automatically\n        derived from it, as specified in [OpenID Connect Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationRequest).\n\n        Once the standardized metadata document is obtained, this will extract\n        all Endpoint Uris from that document, will fetch the current public keys from its\n        `jwks_uri`, then will initialize an OAuth2Client based on those endpoints.\n\n        Args:\n          url: The url where the server metadata will be retrieved.\n          issuer: The issuer value that is expected in the discovery document.\n            If not `url` is given, the OpenID Connect Discovery url for this issuer will be retrieved.\n          auth: The authentication handler to use for client authentication.\n          client_id: Client ID.\n          client_secret: Client secret to use to authenticate the client.\n          private_key: Private key to sign client assertions.\n          session: A `requests.Session` to use to retrieve the document and initialise the client with.\n          testing: If `True`, do not try to validate the issuer uri nor the endpoint urls\n            that are part of the document.\n          **kwargs: Additional keyword parameters to pass to `OAuth2Client`.\n\n        Returns:\n          An `OAuth2Client` with endpoints initialized based on the obtained metadata.\n\n        Raises:\n          InvalidIssuer: If `issuer` is not using https, or contains credentials or fragment.\n          InvalidParam: If neither `url` nor `issuer` are suitable urls.\n          requests.HTTPError: If an error happens while fetching the documents.\n\n        Example:\n            ```python\n            from requests_oauth2client import OAuth2Client\n\n            client = OAuth2Client.from_discovery_endpoint(\n                issuer=\"https://myserver.net\",\n                client_id=\"my_client_id,\n                client_secret=\"my_client_secret\",\n            )\n            ```\n\n        \"\"\"\n        if issuer is not None and not testing:\n            try:\n                validate_issuer_uri(issuer)\n            except InvalidUri as exc:\n                raise InvalidIssuer(\"issuer\", issuer, exc) from exc  # noqa: EM101\n        if url is None and issuer is not None:\n            url = oidc_discovery_document_url(issuer)\n        if url is None:\n            msg = \"Please specify at least one of `issuer` or `url`\"\n            raise InvalidParam(msg)\n\n        if not testing:\n            validate_endpoint_uri(url, path=False)\n\n        session = session or requests.Session()\n        discovery = session.get(url).json()\n\n        jwks_uri = discovery.get(\"jwks_uri\")\n        jwks = JwkSet(session.get(jwks_uri).json()) if jwks_uri else None\n\n        return cls.from_discovery_document(\n            discovery,\n            issuer=issuer,\n            auth=auth,\n            session=session,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            authorization_server_jwks=jwks,\n            testing=testing,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_discovery_document(\n        cls,\n        discovery: dict[str, Any],\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        https: bool = True,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an `OAuth2Client`, based on an AS Discovery Document.\n\n        Args:\n          discovery: A `dict` of server metadata, in the same format as retrieved from a discovery endpoint.\n          issuer: If an issuer is given, check that it matches the one mentioned in the document.\n          auth: The authentication handler to use for client authentication.\n          client_id: Client ID.\n          client_secret: Client secret to use to authenticate the client.\n          private_key: Private key to sign client assertions.\n          authorization_server_jwks: The current authorization server JWKS keys.\n          https: (deprecated) If `True`, validates that urls in the discovery document use the https scheme.\n          testing: If `True`, don't try to validate the endpoint urls that are part of the document.\n          **kwargs: Additional args that will be passed to `OAuth2Client`.\n\n        Returns:\n            An `OAuth2Client` initialized with the endpoints from the discovery document.\n\n        Raises:\n            InvalidDiscoveryDocument: If the document does not contain at least a `\"token_endpoint\"`.\n\n        Examples:\n            ```python\n            from requests_oauth2client import OAuth2Client\n\n            client = OAuth2Client.from_discovery_document(\n                {\n                    \"issuer\": \"https://myas.local\",\n                    \"token_endpoint\": \"https://myas.local/token\",\n                },\n                client_id=\"client_id\",\n                client_secret=\"client_secret\",\n            )\n            ```\n\n        \"\"\"\n        if not https:\n            warnings.warn(\n                \"\"\"\\\nThe `https` parameter is deprecated.\nTo disable endpoint uri validation, set `testing=True` when initializing your `OAuth2Client`.\"\"\",\n                stacklevel=1,\n            )\n            testing = True\n        if issuer and discovery.get(\"issuer\") != issuer:\n            msg = f\"\"\"\\\nMismatching `issuer` value in discovery document (received '{discovery.get(\"issuer\")}', expected '{issuer}').\"\"\"\n            raise InvalidParam(\n                msg,\n                issuer,\n                discovery.get(\"issuer\"),\n            )\n        if issuer is None:\n            issuer = discovery.get(\"issuer\")\n\n        token_endpoint = discovery.get(Endpoints.TOKEN)\n        if token_endpoint is None:\n            msg = \"token_endpoint not found in that discovery document\"\n            raise InvalidDiscoveryDocument(msg, discovery)\n        authorization_endpoint = discovery.get(Endpoints.AUTHORIZATION)\n        revocation_endpoint = discovery.get(Endpoints.REVOCATION)\n        introspection_endpoint = discovery.get(Endpoints.INTROSPECTION)\n        userinfo_endpoint = discovery.get(Endpoints.USER_INFO)\n        pushed_authorization_request_endpoint = discovery.get(Endpoints.PUSHED_AUTHORIZATION_REQUEST)\n        jwks_uri = discovery.get(Endpoints.JWKS)\n        if jwks_uri is not None and not testing:\n            validate_endpoint_uri(jwks_uri)\n        authorization_response_iss_parameter_supported = discovery.get(\n            \"authorization_response_iss_parameter_supported\",\n            False,\n        )\n\n        return cls(\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            pushed_authorization_request_endpoint=pushed_authorization_request_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            issuer=issuer,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            testing=testing,\n            **kwargs,\n        )\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Allow using `OAuth2Client` as a context-manager.\n\n        The Authorization Server public keys are retrieved on `__enter__`.\n\n        \"\"\"\n        self.update_authorization_server_public_keys()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; bool:\n        return True\n\n    def _require_endpoint(self, endpoint: str) -&gt; str:\n        \"\"\"Check that a required endpoint url is set.\"\"\"\n        url = getattr(self, endpoint, None)\n        if not url:\n            raise MissingEndpointUri(endpoint)\n\n        return str(url)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.client_id","title":"<code>client_id</code>  <code>property</code>","text":"<p>Client ID.</p>"},{"location":"api/#requests_oauth2client.OAuth2Client.client_secret","title":"<code>client_secret</code>  <code>property</code>","text":"<p>Client Secret.</p>"},{"location":"api/#requests_oauth2client.OAuth2Client.client_jwks","title":"<code>client_jwks</code>  <code>property</code>","text":"<p>A <code>JwkSet</code> containing the public keys for this client.</p> <p>Keys are:</p> <ul> <li>the public key for client assertion signature verification (if using private_key_jwt)</li> <li>the ID Token encryption key</li> </ul>"},{"location":"api/#requests_oauth2client.OAuth2Client.validate_endpoint_uri","title":"<code>validate_endpoint_uri(attribute, uri)</code>","text":"<p>Validate that an endpoint URI is suitable for use.</p> <p>If you need to disable some checks (for AS testing purposes only!), provide a different method here.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@token_endpoint.validator\n@revocation_endpoint.validator\n@introspection_endpoint.validator\n@userinfo_endpoint.validator\n@authorization_endpoint.validator\n@backchannel_authentication_endpoint.validator\n@device_authorization_endpoint.validator\n@pushed_authorization_request_endpoint.validator\n@jwks_uri.validator\ndef validate_endpoint_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n    \"\"\"Validate that an endpoint URI is suitable for use.\n\n    If you need to disable some checks (for AS testing purposes only!), provide a different method here.\n\n    \"\"\"\n    if self.testing or uri is None:\n        return uri\n    try:\n        return validate_endpoint_uri(uri)\n    except InvalidUri as exc:\n        raise InvalidEndpointUri(endpoint=attribute.name, uri=uri, exc=exc) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.validate_issuer_uri","title":"<code>validate_issuer_uri(attribute, uri)</code>","text":"<p>Validate that an Issuer identifier is suitable for use.</p> <p>This is the same check as an endpoint URI, but the path may be (and usually is) empty.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@issuer.validator\ndef validate_issuer_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n    \"\"\"Validate that an Issuer identifier is suitable for use.\n\n    This is the same check as an endpoint URI, but the path may be (and usually is) empty.\n\n    \"\"\"\n    if self.testing or uri is None:\n        return uri\n    try:\n        return validate_issuer_uri(uri)\n    except InvalidUri as exc:\n        raise InvalidIssuer(attribute.name, uri, exc) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.token_request","title":"<code>token_request(data, *, timeout=10, dpop=None, dpop_key=None, **requests_kwargs)</code>","text":"<p>Send a request to the token endpoint.</p> <p>Authentication will be added automatically based on the defined <code>auth</code> for this client.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>parameters to send to the token endpoint. Items with a <code>None</code>    or empty value will not be sent in the request.</p> required <code>timeout</code> <code>int</code> <p>a timeout value for the call</p> <code>10</code> <code>dpop</code> <code>bool | None</code> <p>toggles DPoP-proofing for the token request:</p> <pre><code>- if `False`, disable it,\n- if `True`, enable it,\n- if `None`, defaults to `dpop_bound_access_tokens` configuration parameter for the client.\n</code></pre> <code>None</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>a chosen <code>DPoPKey</code> for this request. If <code>None</code>, a new key will be generated automatically     with a call to this client <code>dpop_key_generator</code>.</p> <code>None</code> <code>**requests_kwargs</code> <code>Any</code> <p>additional parameters for requests.post()</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>the token endpoint response</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def token_request(\n    self,\n    data: dict[str, Any],\n    *,\n    timeout: int = 10,\n    dpop: bool | None = None,\n    dpop_key: DPoPKey | None = None,\n    **requests_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint.\n\n    Authentication will be added automatically based on the defined `auth` for this client.\n\n    Args:\n      data: parameters to send to the token endpoint. Items with a `None`\n           or empty value will not be sent in the request.\n      timeout: a timeout value for the call\n      dpop: toggles DPoP-proofing for the token request:\n\n            - if `False`, disable it,\n            - if `True`, enable it,\n            - if `None`, defaults to `dpop_bound_access_tokens` configuration parameter for the client.\n      dpop_key: a chosen `DPoPKey` for this request. If `None`, a new key will be generated automatically\n            with a call to this client `dpop_key_generator`.\n      **requests_kwargs: additional parameters for requests.post()\n\n    Returns:\n        the token endpoint response\n\n    \"\"\"\n    if dpop is None:\n        dpop = self.dpop_bound_access_tokens\n    if dpop and not dpop_key:\n        dpop_key = self.dpop_key_generator(self.dpop_alg)\n\n    return self._request(\n        Endpoints.TOKEN,\n        auth=self.auth,\n        data=data,\n        timeout=timeout,\n        dpop_key=dpop_key,\n        on_success=self.parse_token_response,\n        on_failure=self.on_token_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_token_response","title":"<code>parse_token_response(response, *, dpop_key=None)</code>","text":"<p>Parse a Response returned by the Token Endpoint.</p> <p>Invoked by token_request to parse responses returned by the Token Endpoint. Those responses contain an <code>access_token</code> and additional attributes.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the <code>Response</code> returned by the Token Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> based on the response contents.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_token_response(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; BearerToken:\n    \"\"\"Parse a Response returned by the Token Endpoint.\n\n    Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse\n    responses returned by the Token Endpoint. Those responses contain an `access_token` and\n    additional attributes.\n\n    Args:\n        response: the `Response` returned by the Token Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        a `BearerToken` based on the response contents.\n\n    \"\"\"\n    token_class = dpop_key.dpop_token_class if dpop_key is not None else self.token_class\n    try:\n        token_response = token_class(**response.json(), _dpop_key=dpop_key)\n    except Exception:  # noqa: BLE001\n        return self.on_token_error(response, dpop_key=dpop_key)\n    else:\n        return token_response\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_token_error","title":"<code>on_token_error(response, *, dpop_key=None)</code>","text":"<p>Error handler for <code>token_request()</code>.</p> <p>Invoked by token_request when the Token Endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the <code>Response</code> returned by the Token Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the DPoPKey that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>nothing, and raises an exception instead. But a subclass may return a</p> <code>BearerToken</code> <p><code>BearerToken</code> to implement a default behaviour if needed.</p> <p>Raises:</p> Type Description <code>InvalidTokenResponse</code> <p>if the error response does not contain an OAuth 2.0 standard error response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_token_error(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,  # noqa: ARG002\n) -&gt; BearerToken:\n    \"\"\"Error handler for `token_request()`.\n\n    Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the\n    Token Endpoint returns an error.\n\n    Args:\n        response: the `Response` returned by the Token Endpoint.\n        dpop_key: the DPoPKey that was used to proof the token request, if any.\n\n    Returns:\n        nothing, and raises an exception instead. But a subclass may return a\n        `BearerToken` to implement a default behaviour if needed.\n\n    Raises:\n        InvalidTokenResponse: if the error response does not contain an OAuth 2.0 standard\n            error response.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidTokenResponse(\n            response=response,\n            client=self,\n            description=f\"An error happened while processing the error response: {exc}\",\n        ) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.client_credentials","title":"<code>client_credentials(scope=None, *, dpop=None, dpop_key=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint using the <code>client_credentials</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>str | Iterable[str] | None</code> <p>the scope to send with the request. Can be a str, or an iterable of str. to pass that way include <code>scope</code>, <code>audience</code>, <code>resource</code>, etc.</p> <code>None</code> <code>dpop</code> <code>bool | None</code> <p>toggles DPoP-proofing for the token request:</p> <ul> <li>if <code>False</code>, disable it,</li> <li>if <code>True</code>, enable it,</li> <li>if <code>None</code>, defaults to <code>dpop_bound_access_tokens</code> configuration parameter for the client.</li> </ul> <code>None</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>a chosen <code>DPoPKey</code> for this request. If <code>None</code>, a new key will be generated automatically with a call to <code>dpop_key_generator</code>.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters that will be added in the form data for the token endpoint,  alongside <code>grant_type</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> or <code>DPoPToken</code>, depending on the AS response.</p> <p>Raises:</p> Type Description <code>InvalidScopeParam</code> <p>if the <code>scope</code> parameter is not suitable</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def client_credentials(\n    self,\n    scope: str | Iterable[str] | None = None,\n    *,\n    dpop: bool | None = None,\n    dpop_key: DPoPKey | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint using the `client_credentials` grant.\n\n    Args:\n        scope: the scope to send with the request. Can be a str, or an iterable of str.\n            to pass that way include `scope`, `audience`, `resource`, etc.\n        dpop: toggles DPoP-proofing for the token request:\n\n            - if `False`, disable it,\n            - if `True`, enable it,\n            - if `None`, defaults to `dpop_bound_access_tokens` configuration parameter for the client.\n        dpop_key: a chosen `DPoPKey` for this request. If `None`, a new key will be generated automatically\n            with a call to `dpop_key_generator`.\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters that will be added in the form data for the token endpoint,\n             alongside `grant_type`.\n\n    Returns:\n        a `BearerToken` or `DPoPToken`, depending on the AS response.\n\n    Raises:\n        InvalidScopeParam: if the `scope` parameter is not suitable\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if scope and not isinstance(scope, str):\n        try:\n            scope = \" \".join(scope)\n        except Exception as exc:\n            raise InvalidScopeParam(scope) from exc\n\n    data = dict(grant_type=GrantTypes.CLIENT_CREDENTIALS, scope=scope, **token_kwargs)\n    return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.authorization_code","title":"<code>authorization_code(code, *, validate=True, dpop=False, dpop_key=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint with the <code>authorization_code</code> grant.</p> <p>You can either pass an authorization code, as a <code>str</code>, or pass an <code>AuthorizationResponse</code> instance as returned by <code>AuthorizationRequest.validate_callback()</code> (recommended). If you do the latter, this will automatically:</p> <ul> <li>add the appropriate <code>redirect_uri</code> value that was initially passed in the Authorization Request parameters. This is no longer mandatory in OAuth 2.1, but a lot of Authorization Servers are still expecting it since it was part of the OAuth 2.0 specifications.</li> <li>add the appropriate <code>code_verifier</code> for PKCE that was generated before sending the AuthorizationRequest.</li> <li>handle DPoP binding based on the same <code>DPoPKey</code> that was used to initialize the <code>AuthenticationRequest</code> and whose JWK thumbprint was passed as <code>dpop_jkt</code> parameter in the Auth Request.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str | AuthorizationResponse</code> <p>An authorization code or an <code>AuthorizationResponse</code> to exchange for tokens.</p> required <code>validate</code> <code>bool</code> <p>If <code>True</code>, validate the ID Token (this works only if <code>code</code> is an <code>AuthorizationResponse</code>).</p> <code>True</code> <code>dpop</code> <code>bool</code> <p>Toggles DPoP binding for the Access Token,  even if Authorization Code DPoP binding was not initially done.</p> <code>False</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>A chosen DPoP key. Leave <code>None</code> to automatically generate a key, if <code>dpop</code> is <code>True</code>.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the call to the underlying HTTP <code>requests</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters that will be added in the form data for the token endpoint, alongside <code>grant_type</code>, <code>code</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>The Token Endpoint Response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorization_code(\n    self,\n    code: str | AuthorizationResponse,\n    *,\n    validate: bool = True,\n    dpop: bool = False,\n    dpop_key: DPoPKey | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint with the `authorization_code` grant.\n\n    You can either pass an authorization code, as a `str`, or pass an `AuthorizationResponse` instance as\n    returned by `AuthorizationRequest.validate_callback()` (recommended). If you do the latter, this will\n    automatically:\n\n    - add the appropriate `redirect_uri` value that was initially passed in the Authorization Request parameters.\n    This is no longer mandatory in OAuth 2.1, but a lot of Authorization Servers are still expecting it since it was\n    part of the OAuth 2.0 specifications.\n    - add the appropriate `code_verifier` for PKCE that was generated before sending the AuthorizationRequest.\n    - handle DPoP binding based on the same `DPoPKey` that was used to initialize the `AuthenticationRequest` and\n    whose JWK thumbprint was passed as `dpop_jkt` parameter in the Auth Request.\n\n    Args:\n        code: An authorization code or an `AuthorizationResponse` to exchange for tokens.\n        validate: If `True`, validate the ID Token (this works only if `code` is an `AuthorizationResponse`).\n        dpop: Toggles DPoP binding for the Access Token,\n             even if Authorization Code DPoP binding was not initially done.\n        dpop_key: A chosen DPoP key. Leave `None` to automatically generate a key, if `dpop` is `True`.\n        requests_kwargs: Additional parameters for the call to the underlying HTTP `requests` call.\n        **token_kwargs: Additional parameters that will be added in the form data for the token endpoint,\n            alongside `grant_type`, `code`, etc.\n\n    Returns:\n        The Token Endpoint Response.\n\n    \"\"\"\n    azr: AuthorizationResponse | None = None\n    if isinstance(code, AuthorizationResponse):\n        token_kwargs.setdefault(\"code_verifier\", code.code_verifier)\n        token_kwargs.setdefault(\"redirect_uri\", code.redirect_uri)\n        azr = code\n        dpop_key = code.dpop_key\n        code = code.code\n\n    requests_kwargs = requests_kwargs or {}\n\n    data = dict(grant_type=GrantTypes.AUTHORIZATION_CODE, code=code, **token_kwargs)\n    token = self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n    if validate and token.id_token and isinstance(azr, AuthorizationResponse):\n        return token.validate_id_token(self, azr)\n    return token\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.refresh_token","title":"<code>refresh_token(refresh_token, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint with the <code>refresh_token</code> grant.</p> <p>If <code>refresh_token</code> is a <code>DPoPToken</code> instance, (which means that DPoP was used to obtain the initial Access/Refresh Tokens), then the same DPoP key will be used to DPoP proof the refresh token request, as defined in RFC9449.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str | BearerToken</code> <p>A refresh_token, as a string, or as a <code>BearerToken</code>. That <code>BearerToken</code> must have a <code>refresh_token</code>.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the call to <code>requests</code>.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>refresh_token</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>The token endpoint response.</p> <p>Raises:</p> Type Description <code>MissingRefreshToken</code> <p>If <code>refresh_token</code> is a <code>BearerToken</code> instance but does not contain a <code>refresh_token</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def refresh_token(\n    self,\n    refresh_token: str | BearerToken,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint with the `refresh_token` grant.\n\n    If `refresh_token` is a `DPoPToken` instance, (which means that DPoP was used to obtain the initial\n    Access/Refresh Tokens), then the same DPoP key will be used to DPoP proof the refresh token request,\n    as defined in RFC9449.\n\n    Args:\n        refresh_token: A refresh_token, as a string, or as a `BearerToken`.\n            That `BearerToken` must have a `refresh_token`.\n        requests_kwargs: Additional parameters for the call to `requests`.\n        **token_kwargs: Additional parameters for the token endpoint,\n            alongside `grant_type`, `refresh_token`, etc.\n\n    Returns:\n        The token endpoint response.\n\n    Raises:\n        MissingRefreshToken: If `refresh_token` is a `BearerToken` instance but does not\n            contain a `refresh_token`.\n\n    \"\"\"\n    dpop_key: DPoPKey | None = None\n    if isinstance(refresh_token, BearerToken):\n        if refresh_token.refresh_token is None or not isinstance(refresh_token.refresh_token, str):\n            raise MissingRefreshToken(refresh_token)\n        if isinstance(refresh_token, DPoPToken):\n            dpop_key = refresh_token.dpop_key\n        refresh_token = refresh_token.refresh_token\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(grant_type=GrantTypes.REFRESH_TOKEN, refresh_token=refresh_token, **token_kwargs)\n    return self.token_request(data, dpop_key=dpop_key, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.device_code","title":"<code>device_code(device_code, *, dpop=False, dpop_key=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint using the Device Code grant.</p> <p>The grant_type is <code>urn:ietf:params:oauth:grant-type:device_code</code>. This needs a Device Code, or a <code>DeviceAuthorizationResponse</code> as parameter.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>A device code, or a <code>DeviceAuthorizationResponse</code>.</p> required <code>dpop</code> <code>bool</code> <p>Toggles DPoP Binding. If <code>None</code>, defaults to <code>self.dpop_bound_access_tokens</code>.</p> <code>False</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>A chosen DPoP key. Leave <code>None</code> to have a new key generated for this request.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the call to requests.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>device_code</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>The Token Endpoint response.</p> <p>Raises:</p> Type Description <code>MissingDeviceCode</code> <p>if <code>device_code</code> is a DeviceAuthorizationResponse but does not contain a <code>device_code</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def device_code(\n    self,\n    device_code: str | DeviceAuthorizationResponse,\n    *,\n    dpop: bool = False,\n    dpop_key: DPoPKey | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint using the Device Code grant.\n\n    The grant_type is `urn:ietf:params:oauth:grant-type:device_code`. This needs a Device Code,\n    or a `DeviceAuthorizationResponse` as parameter.\n\n    Args:\n        device_code: A device code, or a `DeviceAuthorizationResponse`.\n        dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n        dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n        requests_kwargs: Additional parameters for the call to requests.\n        **token_kwargs: Additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc.\n\n    Returns:\n        The Token Endpoint response.\n\n    Raises:\n        MissingDeviceCode: if `device_code` is a DeviceAuthorizationResponse but does not\n            contain a `device_code`.\n\n    \"\"\"\n    if isinstance(device_code, DeviceAuthorizationResponse):\n        if device_code.device_code is None or not isinstance(device_code.device_code, str):\n            raise MissingDeviceCode(device_code)\n        device_code = device_code.device_code\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantTypes.DEVICE_CODE,\n        device_code=device_code,\n        **token_kwargs,\n    )\n    return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.ciba","title":"<code>ciba(auth_req_id, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a CIBA request to the Token Endpoint.</p> <p>A CIBA request is a Token Request using the <code>urn:openid:params:grant-type:ciba</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>auth_req_id</code> <code>str | BackChannelAuthenticationResponse</code> <p>an authentication request ID, as returned by the AS</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>auth_req_id</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>The Token Endpoint response.</p> <p>Raises:</p> Type Description <code>MissingAuthRequestId</code> <p>if <code>auth_req_id</code> is a BackChannelAuthenticationResponse but does not contain an <code>auth_req_id</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def ciba(\n    self,\n    auth_req_id: str | BackChannelAuthenticationResponse,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a CIBA request to the Token Endpoint.\n\n    A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant.\n\n    Args:\n        auth_req_id: an authentication request ID, as returned by the AS\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc.\n\n    Returns:\n        The Token Endpoint response.\n\n    Raises:\n        MissingAuthRequestId: if `auth_req_id` is a BackChannelAuthenticationResponse but does not contain\n            an `auth_req_id`.\n\n    \"\"\"\n    if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n        if auth_req_id.auth_req_id is None or not isinstance(auth_req_id.auth_req_id, str):\n            raise MissingAuthRequestId(auth_req_id)\n        auth_req_id = auth_req_id.auth_req_id\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantTypes.CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION,\n        auth_req_id=auth_req_id,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.token_exchange","title":"<code>token_exchange(*, subject_token, subject_token_type=None, actor_token=None, actor_token_type=None, requested_token_type=None, dpop=False, dpop_key=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a Token Exchange request.</p> <p>A Token Exchange request is actually a request to the Token Endpoint with a grant_type <code>urn:ietf:params:oauth:grant-type:token-exchange</code>.</p> <p>Parameters:</p> Name Type Description Default <code>subject_token</code> <code>str | BearerToken | IdToken</code> <p>The subject token to exchange for a new token.</p> required <code>subject_token_type</code> <code>str | None</code> <p>A token type identifier for the subject_token, mandatory if it cannot be guessed based on <code>type(subject_token)</code>.</p> <code>None</code> <code>actor_token</code> <code>None | str | BearerToken | IdToken</code> <p>The actor token to include in the request, if any.</p> <code>None</code> <code>actor_token_type</code> <code>str | None</code> <p>A token type identifier for the actor_token, mandatory if it cannot be guessed based on <code>type(actor_token)</code>.</p> <code>None</code> <code>requested_token_type</code> <code>str | None</code> <p>A token type identifier for the requested token.</p> <code>None</code> <code>dpop</code> <code>bool</code> <p>Toggles DPoP Binding. If <code>None</code>, defaults to <code>self.dpop_bound_access_tokens</code>.</p> <code>False</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>A chosen DPoP key. Leave <code>None</code> to have a new key generated for this request.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>The Token Endpoint response.</p> <p>Raises:</p> Type Description <code>UnknownSubjectTokenType</code> <p>If the type of <code>subject_token</code> cannot be determined automatically.</p> <code>UnknownActorTokenType</code> <p>If the type of <code>actor_token</code> cannot be determined automatically.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def token_exchange(\n    self,\n    *,\n    subject_token: str | BearerToken | IdToken,\n    subject_token_type: str | None = None,\n    actor_token: None | str | BearerToken | IdToken = None,\n    actor_token_type: str | None = None,\n    requested_token_type: str | None = None,\n    dpop: bool = False,\n    dpop_key: DPoPKey | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a Token Exchange request.\n\n    A Token Exchange request is actually a request to the Token Endpoint with a grant_type\n    `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n    Args:\n        subject_token: The subject token to exchange for a new token.\n        subject_token_type: A token type identifier for the subject_token, mandatory if it cannot be guessed based\n            on `type(subject_token)`.\n        actor_token: The actor token to include in the request, if any.\n        actor_token_type: A token type identifier for the actor_token, mandatory if it cannot be guessed based\n            on `type(actor_token)`.\n        requested_token_type: A token type identifier for the requested token.\n        dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n        dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n        requests_kwargs: Additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: Additional parameters to include in the request body.\n\n    Returns:\n        The Token Endpoint response.\n\n    Raises:\n        UnknownSubjectTokenType: If the type of `subject_token` cannot be determined automatically.\n        UnknownActorTokenType: If the type of `actor_token` cannot be determined automatically.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    try:\n        subject_token_type = self.get_token_type(subject_token_type, subject_token)\n    except ValueError as exc:\n        raise UnknownSubjectTokenType(subject_token, subject_token_type) from exc\n    if actor_token:  # pragma: no branch\n        try:\n            actor_token_type = self.get_token_type(actor_token_type, actor_token)\n        except ValueError as exc:\n            raise UnknownActorTokenType(actor_token, actor_token_type) from exc\n\n    data = dict(\n        grant_type=GrantTypes.TOKEN_EXCHANGE,\n        subject_token=subject_token,\n        subject_token_type=subject_token_type,\n        actor_token=actor_token,\n        actor_token_type=actor_token_type,\n        requested_token_type=requested_token_type,\n        **token_kwargs,\n    )\n    return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.jwt_bearer","title":"<code>jwt_bearer(assertion, *, dpop=False, dpop_key=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request using a JWT as authorization grant.</p> <p>This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).</p> <p>Parameters:</p> Name Type Description Default <code>assertion</code> <code>Jwt | str</code> <p>A JWT (as an instance of <code>jwskate.Jwt</code> or as a <code>str</code>) to use as authorization grant.</p> required <code>dpop</code> <code>bool</code> <p>Toggles DPoP Binding. If <code>None</code>, defaults to <code>self.dpop_bound_access_tokens</code>.</p> <code>False</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>A chosen DPoP key. Leave <code>None</code> to have a new key generated for this request.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>The Token Endpoint response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def jwt_bearer(\n    self,\n    assertion: Jwt | str,\n    *,\n    dpop: bool = False,\n    dpop_key: DPoPKey | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request using a JWT as authorization grant.\n\n    This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).\n\n    Args:\n        assertion: A JWT (as an instance of `jwskate.Jwt` or as a `str`) to use as authorization grant.\n        dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n        dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n        requests_kwargs: Additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: Additional parameters to include in the request body.\n\n    Returns:\n        The Token Endpoint response.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if not isinstance(assertion, Jwt):\n        assertion = Jwt(assertion)\n\n    data = dict(\n        grant_type=GrantTypes.JWT_BEARER,\n        assertion=assertion,\n        **token_kwargs,\n    )\n\n    return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.resource_owner_password","title":"<code>resource_owner_password(username, password, *, dpop=None, dpop_key=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request using the Resource Owner Password Grant.</p> <p>This Grant Type is deprecated and should only be used when there is no other choice.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>the resource owner user name</p> required <code>password</code> <code>str</code> <p>the resource owner password</p> required <code>dpop</code> <code>bool | None</code> <p>Toggles DPoP Binding. If <code>None</code>, defaults to <code>self.dpop_bound_access_tokens</code>.</p> <code>None</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>A chosen DPoP key. Leave <code>None</code> to have a new key generated for this request.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>The Token Endpoint response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def resource_owner_password(\n    self,\n    username: str,\n    password: str,\n    *,\n    dpop: bool | None = None,\n    dpop_key: DPoPKey | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request using the Resource Owner Password Grant.\n\n    This Grant Type is deprecated and should only be used when there is no other choice.\n\n    Args:\n        username: the resource owner user name\n        password: the resource owner password\n        dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n        dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        The Token Endpoint response.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantTypes.RESOURCE_OWNER_PASSWORD,\n        username=username,\n        password=password,\n        **token_kwargs,\n    )\n\n    return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.authorization_request","title":"<code>authorization_request(*, scope='openid', response_type=ResponseTypes.CODE, redirect_uri=None, state=..., nonce=..., code_verifier=None, dpop=None, dpop_key=None, dpop_alg=None, **kwargs)</code>","text":"<p>Generate an Authorization Request for this client.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>None | str | Iterable[str]</code> <p>The <code>scope</code> to use.</p> <code>'openid'</code> <code>response_type</code> <code>str</code> <p>The <code>response_type</code> to use.</p> <code>CODE</code> <code>redirect_uri</code> <code>str | None</code> <p>The <code>redirect_uri</code> to include in the request. By default, the <code>redirect_uri</code> defined at init time is used.</p> <code>None</code> <code>state</code> <code>str | ellipsis | None</code> <p>The <code>state</code> parameter to use. Leave default to generate a random value.</p> <code>...</code> <code>nonce</code> <code>str | ellipsis | None</code> <p>A <code>nonce</code>. Leave default to generate a random value.</p> <code>...</code> <code>dpop</code> <code>bool | None</code> <p>Toggles DPoP binding. - if <code>True</code>, DPoP binding is used - if <code>False</code>, DPoP is not used - if <code>None</code>, defaults to <code>self.dpop_bound_access_tokens</code></p> <code>None</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>A chosen DPoP key. Leave <code>None</code> to have a new key generated for you.</p> <code>None</code> <code>dpop_alg</code> <code>str | None</code> <p>A signature alg to sign the DPoP proof. If <code>None</code>, this defaults to <code>self.dpop_alg</code>. If DPoP is not used, or a chosen <code>dpop_key</code> is provided, this is ignored. This affects the key type if a DPoP key must be generated.</p> <code>None</code> <code>code_verifier</code> <code>str | None</code> <p>The PKCE <code>code_verifier</code> to use. Leave default to generate a random value.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional query parameters to include in the auth request.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>The Token Endpoint response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorization_request(\n    self,\n    *,\n    scope: None | str | Iterable[str] = \"openid\",\n    response_type: str = ResponseTypes.CODE,\n    redirect_uri: str | None = None,\n    state: str | ellipsis | None = ...,  # noqa: F821\n    nonce: str | ellipsis | None = ...,  # noqa: F821\n    code_verifier: str | None = None,\n    dpop: bool | None = None,\n    dpop_key: DPoPKey | None = None,\n    dpop_alg: str | None = None,\n    **kwargs: Any,\n) -&gt; AuthorizationRequest:\n    \"\"\"Generate an Authorization Request for this client.\n\n    Args:\n        scope: The `scope` to use.\n        response_type: The `response_type` to use.\n        redirect_uri: The `redirect_uri` to include in the request. By default,\n            the `redirect_uri` defined at init time is used.\n        state: The `state` parameter to use. Leave default to generate a random value.\n        nonce: A `nonce`. Leave default to generate a random value.\n        dpop: Toggles DPoP binding.\n            - if `True`, DPoP binding is used\n            - if `False`, DPoP is not used\n            - if `None`, defaults to `self.dpop_bound_access_tokens`\n        dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for you.\n        dpop_alg: A signature alg to sign the DPoP proof. If `None`, this defaults to `self.dpop_alg`.\n            If DPoP is not used, or a chosen `dpop_key` is provided, this is ignored.\n            This affects the key type if a DPoP key must be generated.\n        code_verifier: The PKCE `code_verifier` to use. Leave default to generate a random value.\n        **kwargs: Additional query parameters to include in the auth request.\n\n    Returns:\n        The Token Endpoint response.\n\n    \"\"\"\n    authorization_endpoint = self._require_endpoint(\"authorization_endpoint\")\n\n    redirect_uri = redirect_uri or self.redirect_uri\n\n    if dpop is None:\n        dpop = self.dpop_bound_access_tokens\n    if dpop_alg is None:\n        dpop_alg = self.dpop_alg\n\n    return AuthorizationRequest(\n        authorization_endpoint=authorization_endpoint,\n        client_id=self.client_id,\n        redirect_uri=redirect_uri,\n        issuer=self.issuer,\n        response_type=response_type,\n        scope=scope,\n        state=state,\n        nonce=nonce,\n        code_verifier=code_verifier,\n        code_challenge_method=self.code_challenge_method,\n        dpop=dpop,\n        dpop_key=dpop_key,\n        dpop_alg=dpop_alg,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.pushed_authorization_request","title":"<code>pushed_authorization_request(authorization_request, requests_kwargs=None)</code>","text":"<p>Send a Pushed Authorization Request.</p> <p>This sends a request to the Pushed Authorization Request Endpoint, and returns a <code>RequestUriParameterAuthorizationRequest</code> initialized with the AS response.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_request</code> <code>AuthorizationRequest</code> <p>The authorization request to send.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for <code>requests.request()</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>The <code>RequestUriParameterAuthorizationRequest</code> initialized based on the AS response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def pushed_authorization_request(\n    self,\n    authorization_request: AuthorizationRequest,\n    requests_kwargs: dict[str, Any] | None = None,\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Send a Pushed Authorization Request.\n\n    This sends a request to the Pushed Authorization Request Endpoint, and returns a\n    `RequestUriParameterAuthorizationRequest` initialized with the AS response.\n\n    Args:\n        authorization_request: The authorization request to send.\n        requests_kwargs: Additional parameters for `requests.request()`.\n\n    Returns:\n        The `RequestUriParameterAuthorizationRequest` initialized based on the AS response.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n    return self._request(\n        Endpoints.PUSHED_AUTHORIZATION_REQUEST,\n        data=authorization_request.args,\n        auth=self.auth,\n        on_success=self.parse_pushed_authorization_response,\n        on_failure=self.on_pushed_authorization_request_error,\n        dpop_key=authorization_request.dpop_key,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_pushed_authorization_response","title":"<code>parse_pushed_authorization_response(response, *, dpop_key=None)</code>","text":"<p>Parse the response obtained by <code>pushed_authorization_request()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>The <code>requests.Response</code> returned by the PAR endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>The <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>A <code>RequestUriParameterAuthorizationRequest</code> instance initialized based on the PAR endpoint response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_pushed_authorization_response(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Parse the response obtained by `pushed_authorization_request()`.\n\n    Args:\n        response: The `requests.Response` returned by the PAR endpoint.\n        dpop_key: The `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        A `RequestUriParameterAuthorizationRequest` instance initialized based on the PAR endpoint response.\n\n    \"\"\"\n    response_json = response.json()\n    request_uri = response_json.get(\"request_uri\")\n    expires_in = response_json.get(\"expires_in\")\n\n    return RequestUriParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request_uri=request_uri,\n        expires_in=expires_in,\n        dpop_key=dpop_key,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_pushed_authorization_request_error","title":"<code>on_pushed_authorization_request_error(response, *, dpop_key=None)</code>","text":"<p>Error Handler for Pushed Authorization Endpoint errors.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>The HTTP response as returned by the AS PAR endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>The <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>Should not return anything, but raise an Exception instead. A <code>RequestUriParameterAuthorizationRequest</code></p> <code>RequestUriParameterAuthorizationRequest</code> <p>may be returned by subclasses for testing purposes.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>A subclass of this error depending on the error returned by the AS.</p> <code>InvalidPushedAuthorizationResponse</code> <p>If the returned response is not following the specifications.</p> <code>UnknownTokenEndpointError</code> <p>For unknown/unhandled errors.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_pushed_authorization_request_error(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,  # noqa: ARG002\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Error Handler for Pushed Authorization Endpoint errors.\n\n    Args:\n        response: The HTTP response as returned by the AS PAR endpoint.\n        dpop_key: The `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        Should not return anything, but raise an Exception instead. A `RequestUriParameterAuthorizationRequest`\n        may be returned by subclasses for testing purposes.\n\n    Raises:\n        EndpointError: A subclass of this error depending on the error returned by the AS.\n        InvalidPushedAuthorizationResponse: If the returned response is not following the specifications.\n        UnknownTokenEndpointError: For unknown/unhandled errors.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidPushedAuthorizationResponse(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.userinfo","title":"<code>userinfo(access_token)</code>","text":"<p>Call the UserInfo endpoint.</p> <p>This sends a request to the UserInfo endpoint, with the specified access_token, and returns the parsed result.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>BearerToken | str</code> <p>the access token to use</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the Response returned by the userinfo endpoint.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def userinfo(self, access_token: BearerToken | str) -&gt; Any:\n    \"\"\"Call the UserInfo endpoint.\n\n    This sends a request to the UserInfo endpoint, with the specified access_token, and returns\n    the parsed result.\n\n    Args:\n        access_token: the access token to use\n\n    Returns:\n        the [Response][requests.Response] returned by the userinfo endpoint.\n\n    \"\"\"\n    if isinstance(access_token, str):\n        access_token = BearerToken(access_token)\n    return self._request(\n        Endpoints.USER_INFO,\n        auth=access_token,\n        on_success=self.parse_userinfo_response,\n        on_failure=self.on_userinfo_error,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_userinfo_response","title":"<code>parse_userinfo_response(resp, *, dpop_key=None)</code>","text":"<p>Parse the response obtained by <code>userinfo()</code>.</p> <p>Invoked by userinfo() to parse the response from the UserInfo endpoint, this will extract and return its JSON content.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>a Response returned from the UserInfo endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>the parsed JSON content from this response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_userinfo_response(self, resp: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; Any:  # noqa: ARG002\n    \"\"\"Parse the response obtained by `userinfo()`.\n\n    Invoked by [userinfo()][requests_oauth2client.client.OAuth2Client.userinfo] to parse the\n    response from the UserInfo endpoint, this will extract and return its JSON content.\n\n    Args:\n        resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        the parsed JSON content from this response.\n\n    \"\"\"\n    return resp.json()\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_userinfo_error","title":"<code>on_userinfo_error(resp, *, dpop_key=None)</code>","text":"<p>Parse UserInfo error response.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>a Response returned from the UserInfo endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>nothing, raises exception instead.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_userinfo_error(self, resp: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; Any:  # noqa: ARG002\n    \"\"\"Parse UserInfo error response.\n\n    Args:\n        resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        nothing, raises exception instead.\n\n    \"\"\"\n    resp.raise_for_status()\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.get_token_type","title":"<code>get_token_type(token_type=None, token=None)</code>  <code>classmethod</code>","text":"<p>Get standardized token type identifiers.</p> <p>Return a standardized token type identifier, based on a short <code>token_type</code> hint and/or a token value.</p> <p>Parameters:</p> Name Type Description Default <code>token_type</code> <code>str | None</code> <p>a token_type hint, as <code>str</code>. May be \"access_token\", \"refresh_token\" or \"id_token\"</p> <code>None</code> <code>token</code> <code>None | str | BearerToken | IdToken</code> <p>a token value, as an instance of <code>BearerToken</code> or IdToken, or as a <code>str</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the token_type as defined in the Token Exchange RFC8693.</p> <p>Raises:</p> Type Description <code>UnknownTokenType</code> <p>if the type of token cannot be determined</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>    @classmethod\n    def get_token_type(  # noqa: C901\n        cls,\n        token_type: str | None = None,\n        token: None | str | BearerToken | IdToken = None,\n    ) -&gt; str:\n        \"\"\"Get standardized token type identifiers.\n\n        Return a standardized token type identifier, based on a short `token_type` hint and/or a\n        token value.\n\n        Args:\n            token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\"\n                or \"id_token\"\n            token: a token value, as an instance of `BearerToken` or IdToken, or as a `str`.\n\n        Returns:\n            the token_type as defined in the Token Exchange RFC8693.\n\n        Raises:\n            UnknownTokenType: if the type of token cannot be determined\n\n        \"\"\"\n        if not (token_type or token):\n            msg = \"Cannot determine type of an empty token without a token_type hint\"\n            raise UnknownTokenType(msg, token, token_type)\n\n        if token_type is None:\n            if isinstance(token, str):\n                msg = \"\"\"\\\nCannot determine the type of provided token when it is a bare `str`. Please specify a 'token_type'.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            if isinstance(token, BearerToken):\n                return \"urn:ietf:params:oauth:token-type:access_token\"\n            if isinstance(token, IdToken):\n                return \"urn:ietf:params:oauth:token-type:id_token\"\n            msg = f\"Unknown token type {type(token)}\"\n            raise UnknownTokenType(msg, token, token_type)\n        if token_type == TokenType.ACCESS_TOKEN:\n            if token is not None and not isinstance(token, (str, BearerToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nA BearerToken or an access_token as a `str` is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:access_token\"\n        if token_type == TokenType.REFRESH_TOKEN:\n            if token is not None and isinstance(token, BearerToken) and not token.refresh_token:\n                msg = f\"\"\"\\\nThe supplied BearerToken does not contain a refresh_token, which is inconsistent with token_type '{token_type}'.\nA BearerToken containing a refresh_token is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:refresh_token\"\n        if token_type == TokenType.ID_TOKEN:\n            if token is not None and not isinstance(token, (str, IdToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nAn IdToken or a string representation of it is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:id_token\"\n\n        return {\n            \"saml1\": \"urn:ietf:params:oauth:token-type:saml1\",\n            \"saml2\": \"urn:ietf:params:oauth:token-type:saml2\",\n            \"jwt\": \"urn:ietf:params:oauth:token-type:jwt\",\n        }.get(token_type, token_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.revoke_access_token","title":"<code>revoke_access_token(access_token, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a request to the Revocation Endpoint to revoke an access token.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>BearerToken | str</code> <p>the access token to revoke</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the underlying requests.post() call</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to pass to the revocation endpoint</p> <code>{}</code> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_access_token(\n    self,\n    access_token: BearerToken | str,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a request to the Revocation Endpoint to revoke an access token.\n\n    Args:\n        access_token: the access token to revoke\n        requests_kwargs: additional parameters for the underlying requests.post() call\n        **revoke_kwargs: additional parameters to pass to the revocation endpoint\n\n    \"\"\"\n    return self.revoke_token(\n        access_token,\n        token_type_hint=TokenType.ACCESS_TOKEN,\n        requests_kwargs=requests_kwargs,\n        **revoke_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.revoke_refresh_token","title":"<code>revoke_refresh_token(refresh_token, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a request to the Revocation Endpoint to revoke a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str | BearerToken</code> <p>the refresh token to revoke.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the revocation endpoint.</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to pass to the revocation endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the revocation request is successful, <code>False</code> if this client has no configured</p> <code>bool</code> <p>revocation endpoint.</p> <p>Raises:</p> Type Description <code>MissingRefreshToken</code> <p>when <code>refresh_token</code> is a BearerToken but does not contain a <code>refresh_token</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_refresh_token(\n    self,\n    refresh_token: str | BearerToken,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a request to the Revocation Endpoint to revoke a refresh token.\n\n    Args:\n        refresh_token: the refresh token to revoke.\n        requests_kwargs: additional parameters to pass to the revocation endpoint.\n        **revoke_kwargs: additional parameters to pass to the revocation endpoint.\n\n    Returns:\n        `True` if the revocation request is successful, `False` if this client has no configured\n        revocation endpoint.\n\n    Raises:\n        MissingRefreshToken: when `refresh_token` is a [BearerToken][requests_oauth2client.tokens.BearerToken]\n            but does not contain a `refresh_token`.\n\n    \"\"\"\n    if isinstance(refresh_token, BearerToken):\n        if refresh_token.refresh_token is None:\n            raise MissingRefreshToken(refresh_token)\n        refresh_token = refresh_token.refresh_token\n\n    return self.revoke_token(\n        refresh_token,\n        token_type_hint=TokenType.REFRESH_TOKEN,\n        requests_kwargs=requests_kwargs,\n        **revoke_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.revoke_token","title":"<code>revoke_token(token, token_type_hint=None, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a Token Revocation request.</p> <p>By default, authentication will be the same than the one used for the Token Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str | BearerToken</code> <p>the token to revoke.</p> required <code>token_type_hint</code> <code>str | None</code> <p>a token_type_hint to send to the revocation endpoint.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to the underling call to requests.post()</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to send to the revocation endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>the result from <code>parse_revocation_response</code> on the returned AS response.</p> <p>Raises:</p> Type Description <code>MissingEndpointUri</code> <p>if the Revocation Endpoint URI is not configured.</p> <code>MissingRefreshToken</code> <p>if <code>token_type_hint</code> is <code>\"refresh_token\"</code> and <code>token</code> is a BearerToken but does not contain a <code>refresh_token</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_token(\n    self,\n    token: str | BearerToken,\n    token_type_hint: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a Token Revocation request.\n\n    By default, authentication will be the same than the one used for the Token Endpoint.\n\n    Args:\n        token: the token to revoke.\n        token_type_hint: a token_type_hint to send to the revocation endpoint.\n        requests_kwargs: additional parameters to the underling call to requests.post()\n        **revoke_kwargs: additional parameters to send to the revocation endpoint.\n\n    Returns:\n        the result from `parse_revocation_response` on the returned AS response.\n\n    Raises:\n        MissingEndpointUri: if the Revocation Endpoint URI is not configured.\n        MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n            but does not contain a `refresh_token`.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if token_type_hint == TokenType.REFRESH_TOKEN and isinstance(token, BearerToken):\n        if token.refresh_token is None:\n            raise MissingRefreshToken(token)\n        token = token.refresh_token\n\n    data = dict(revoke_kwargs, token=str(token))\n    if token_type_hint:\n        data[\"token_type_hint\"] = token_type_hint\n\n    return self._request(\n        Endpoints.REVOCATION,\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_revocation_response,\n        on_failure=self.on_revocation_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_revocation_response","title":"<code>parse_revocation_response(response, *, dpop_key=None)</code>","text":"<p>Parse reponses from the Revocation Endpoint.</p> <p>Since those do not return any meaningful information in a standardised fashion, this just returns <code>True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the <code>requests.Response</code> as returned by the Revocation Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the revocation succeeds, <code>False</code> if no revocation endpoint is present or a</p> <code>bool</code> <p>non-standardised error is returned.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_revocation_response(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; bool:  # noqa: ARG002\n    \"\"\"Parse reponses from the Revocation Endpoint.\n\n    Since those do not return any meaningful information in a standardised fashion, this just returns `True`.\n\n    Args:\n        response: the `requests.Response` as returned by the Revocation Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        `True` if the revocation succeeds, `False` if no revocation endpoint is present or a\n        non-standardised error is returned.\n\n    \"\"\"\n    return True\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_revocation_error","title":"<code>on_revocation_error(response, *, dpop_key=None)</code>","text":"<p>Error handler for <code>revoke_token()</code>.</p> <p>Invoked by revoke_token() when the revocation endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the <code>requests.Response</code> as returned by the Revocation Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>False</code> to signal that an error occurred. May raise exceptions instead depending on the</p> <code>bool</code> <p>revocation response.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>if the response contains a standardised OAuth 2.0 error.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_revocation_error(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; bool:  # noqa: ARG002\n    \"\"\"Error handler for `revoke_token()`.\n\n    Invoked by [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token] when the\n    revocation endpoint returns an error.\n\n    Args:\n        response: the `requests.Response` as returned by the Revocation Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        `False` to signal that an error occurred. May raise exceptions instead depending on the\n        revocation response.\n\n    Raises:\n        EndpointError: if the response contains a standardised OAuth 2.0 error.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, RevocationError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception:  # noqa: BLE001\n        return False\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.introspect_token","title":"<code>introspect_token(token, token_type_hint=None, requests_kwargs=None, **introspect_kwargs)</code>","text":"<p>Send a request to the Introspection Endpoint.</p> <p>Parameter <code>token</code> can be:</p> <ul> <li>a <code>str</code></li> <li>a <code>BearerToken</code> instance</li> </ul> <p>You may pass any arbitrary <code>token</code> and <code>token_type_hint</code> values as <code>str</code>. Those will be included in the request, as-is. If <code>token</code> is a <code>BearerToken</code>, then <code>token_type_hint</code> must be either:</p> <ul> <li><code>None</code>: the access_token will be instrospected and no token_type_hint will be included in the request</li> <li><code>access_token</code>: same as <code>None</code>, but the token_type_hint will be included</li> <li>or <code>refresh_token</code>: only available if a Refresh Token is present in the BearerToken.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str | BearerToken</code> <p>the token to instrospect</p> required <code>token_type_hint</code> <code>str | None</code> <p>the <code>token_type_hint</code> to include in the request.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to the underling call to requests.post()</p> <code>None</code> <code>**introspect_kwargs</code> <code>Any</code> <p>additional parameters to send to the introspection endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>the response as returned by the Introspection Endpoint.</p> <p>Raises:</p> Type Description <code>MissingRefreshToken</code> <p>if <code>token_type_hint</code> is <code>\"refresh_token\"</code> and <code>token</code> is a BearerToken but does not contain a <code>refresh_token</code>.</p> <code>UnknownTokenType</code> <p>if <code>token_type_hint</code> is neither <code>None</code>, <code>\"access_token\"</code> or <code>\"refresh_token\"</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>    def introspect_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **introspect_kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"Send a request to the Introspection Endpoint.\n\n        Parameter `token` can be:\n\n        - a `str`\n        - a `BearerToken` instance\n\n        You may pass any arbitrary `token` and `token_type_hint` values as `str`. Those will\n        be included in the request, as-is.\n        If `token` is a `BearerToken`, then `token_type_hint` must be either:\n\n        - `None`: the access_token will be instrospected and no token_type_hint will be included\n        in the request\n        - `access_token`: same as `None`, but the token_type_hint will be included\n        - or `refresh_token`: only available if a Refresh Token is present in the BearerToken.\n\n        Args:\n            token: the token to instrospect\n            token_type_hint: the `token_type_hint` to include in the request.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **introspect_kwargs: additional parameters to send to the introspection endpoint.\n\n        Returns:\n            the response as returned by the Introspection Endpoint.\n\n        Raises:\n            MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n                but does not contain a `refresh_token`.\n            UnknownTokenType: if `token_type_hint` is neither `None`, `\"access_token\"` or `\"refresh_token\"`.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if isinstance(token, BearerToken):\n            if token_type_hint is None or token_type_hint == TokenType.ACCESS_TOKEN:\n                token = token.access_token\n            elif token_type_hint == TokenType.REFRESH_TOKEN:\n                if token.refresh_token is None:\n                    raise MissingRefreshToken(token)\n\n                token = token.refresh_token\n            else:\n                msg = \"\"\"\\\nInvalid `token_type_hint`. To test arbitrary `token_type_hint` values, you must provide `token` as a `str`.\"\"\"\n                raise UnknownTokenType(msg, token, token_type_hint)\n\n        data = dict(introspect_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            Endpoints.INTROSPECTION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_introspection_response,\n            on_failure=self.on_introspection_error,\n            **requests_kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_introspection_response","title":"<code>parse_introspection_response(response, *, dpop_key=None)</code>","text":"<p>Parse Token Introspection Responses received by <code>introspect_token()</code>.</p> <p>Invoked by introspect_token() to parse the returned response. This decodes the JSON content if possible, otherwise it returns the response as a string.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response as returned by the Introspection Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>the decoded JSON content, or a <code>str</code> with the content.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_introspection_response(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,  # noqa: ARG002\n) -&gt; Any:\n    \"\"\"Parse Token Introspection Responses received by `introspect_token()`.\n\n    Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n    to parse the returned response. This decodes the JSON content if possible, otherwise it\n    returns the response as a string.\n\n    Args:\n        response: the [Response][requests.Response] as returned by the Introspection Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        the decoded JSON content, or a `str` with the content.\n\n    \"\"\"\n    try:\n        return response.json()\n    except ValueError:\n        return response.text\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_introspection_error","title":"<code>on_introspection_error(response, *, dpop_key=None)</code>","text":"<p>Error handler for <code>introspect_token()</code>.</p> <p>Invoked by introspect_token() to parse the returned response in the case an error is returned.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response as returned by the Introspection Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>usually raises exceptions. A subclass can return a default response instead.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>(or one of its subclasses) if the response contains a standard OAuth 2.0 error.</p> <code>UnknownIntrospectionError</code> <p>if the response is not a standard error response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_introspection_error(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; Any:  # noqa: ARG002\n    \"\"\"Error handler for `introspect_token()`.\n\n    Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n    to parse the returned response in the case an error is returned.\n\n    Args:\n        response: the response as returned by the Introspection Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        usually raises exceptions. A subclass can return a default response instead.\n\n    Raises:\n        EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n        UnknownIntrospectionError: if the response is not a standard error response.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, IntrospectionError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise UnknownIntrospectionError(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.backchannel_authentication_request","title":"<code>backchannel_authentication_request(scope='openid', *, client_notification_token=None, acr_values=None, login_hint_token=None, id_token_hint=None, login_hint=None, binding_message=None, user_code=None, requested_expiry=None, private_jwk=None, alg=None, requests_kwargs=None, **ciba_kwargs)</code>","text":"<p>Send a CIBA Authentication Request.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>None | str | Iterable[str]</code> <p>the scope to include in the request.</p> <code>'openid'</code> <code>client_notification_token</code> <code>str | None</code> <p>the Client Notification Token to include in the request.</p> <code>None</code> <code>acr_values</code> <code>None | str | Iterable[str]</code> <p>the acr values to include in the request.</p> <code>None</code> <code>login_hint_token</code> <code>str | None</code> <p>the Login Hint Token to include in the request.</p> <code>None</code> <code>id_token_hint</code> <code>str | None</code> <p>the ID Token Hint to include in the request.</p> <code>None</code> <code>login_hint</code> <code>str | None</code> <p>the Login Hint to include in the request.</p> <code>None</code> <code>binding_message</code> <code>str | None</code> <p>the Binding Message to include in the request.</p> <code>None</code> <code>user_code</code> <code>str | None</code> <p>the User Code to include in the request</p> <code>None</code> <code>requested_expiry</code> <code>int | None</code> <p>the Requested Expiry, in seconds, to include in the request.</p> <code>None</code> <code>private_jwk</code> <code>Jwk | dict[str, Any] | None</code> <p>the JWK to use to sign the request (optional)</p> <code>None</code> <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for</p> <code>None</code> <code>**ciba_kwargs</code> <code>Any</code> <p>additional parameters to include in the request.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>a BackChannelAuthenticationResponse as returned by AS</p> <p>Raises:</p> Type Description <code>InvalidBackchannelAuthenticationRequestHintParam</code> <p>if none of <code>login_hint</code>, <code>login_hint_token</code> or <code>id_token_hint</code> is provided, or more than one of them is provided.</p> <code>InvalidScopeParam</code> <p>if the <code>scope</code> parameter is invalid.</p> <code>InvalidAcrValuesParam</code> <p>if the <code>acr_values</code> parameter is invalid.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def backchannel_authentication_request(  # noqa: PLR0913\n    self,\n    scope: None | str | Iterable[str] = \"openid\",\n    *,\n    client_notification_token: str | None = None,\n    acr_values: None | str | Iterable[str] = None,\n    login_hint_token: str | None = None,\n    id_token_hint: str | None = None,\n    login_hint: str | None = None,\n    binding_message: str | None = None,\n    user_code: str | None = None,\n    requested_expiry: int | None = None,\n    private_jwk: Jwk | dict[str, Any] | None = None,\n    alg: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **ciba_kwargs: Any,\n) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Send a CIBA Authentication Request.\n\n    Args:\n         scope: the scope to include in the request.\n         client_notification_token: the Client Notification Token to include in the request.\n         acr_values: the acr values to include in the request.\n         login_hint_token: the Login Hint Token to include in the request.\n         id_token_hint: the ID Token Hint to include in the request.\n         login_hint: the Login Hint to include in the request.\n         binding_message: the Binding Message to include in the request.\n         user_code: the User Code to include in the request\n         requested_expiry: the Requested Expiry, in seconds, to include in the request.\n         private_jwk: the JWK to use to sign the request (optional)\n         alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.\n         requests_kwargs: additional parameters for\n         **ciba_kwargs: additional parameters to include in the request.\n\n    Returns:\n        a BackChannelAuthenticationResponse as returned by AS\n\n    Raises:\n        InvalidBackchannelAuthenticationRequestHintParam: if none of `login_hint`, `login_hint_token`\n            or `id_token_hint` is provided, or more than one of them is provided.\n        InvalidScopeParam: if the `scope` parameter is invalid.\n        InvalidAcrValuesParam: if the `acr_values` parameter is invalid.\n\n    \"\"\"\n    if not (login_hint or login_hint_token or id_token_hint):\n        msg = \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n        raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n    if (login_hint_token and id_token_hint) or (login_hint and id_token_hint) or (login_hint_token and login_hint):\n        msg = \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n        raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n    requests_kwargs = requests_kwargs or {}\n\n    if scope is not None and not isinstance(scope, str):\n        try:\n            scope = \" \".join(scope)\n        except Exception as exc:\n            raise InvalidScopeParam(scope) from exc\n\n    if acr_values is not None and not isinstance(acr_values, str):\n        try:\n            acr_values = \" \".join(acr_values)\n        except Exception as exc:\n            raise InvalidAcrValuesParam(acr_values) from exc\n\n    data = dict(\n        ciba_kwargs,\n        scope=scope,\n        client_notification_token=client_notification_token,\n        acr_values=acr_values,\n        login_hint_token=login_hint_token,\n        id_token_hint=id_token_hint,\n        login_hint=login_hint,\n        binding_message=binding_message,\n        user_code=user_code,\n        requested_expiry=requested_expiry,\n    )\n\n    if private_jwk is not None:\n        data = {\"request\": str(Jwt.sign(data, key=private_jwk, alg=alg))}\n\n    return self._request(\n        Endpoints.BACKCHANNEL_AUTHENTICATION,\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_backchannel_authentication_response,\n        on_failure=self.on_backchannel_authentication_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_backchannel_authentication_response","title":"<code>parse_backchannel_authentication_response(response, *, dpop_key=None)</code>","text":"<p>Parse a response received by <code>backchannel_authentication_request()</code>.</p> <p>Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the BackChannel Authentication Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>a <code>BackChannelAuthenticationResponse</code></p> <p>Raises:</p> Type Description <code>InvalidBackChannelAuthenticationResponse</code> <p>if the response does not contain a standard BackChannel Authentication response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_backchannel_authentication_response(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,  # noqa: ARG002\n) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Parse a response received by `backchannel_authentication_request()`.\n\n    Invoked by\n    [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n    to parse the response returned by the BackChannel Authentication Endpoint.\n\n    Args:\n        response: the response returned by the BackChannel Authentication Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        a `BackChannelAuthenticationResponse`\n\n    Raises:\n        InvalidBackChannelAuthenticationResponse: if the response does not contain a standard\n            BackChannel Authentication response.\n\n    \"\"\"\n    try:\n        return BackChannelAuthenticationResponse(**response.json())\n    except TypeError as exc:\n        raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_backchannel_authentication_error","title":"<code>on_backchannel_authentication_error(response, *, dpop_key=None)</code>","text":"<p>Error handler for <code>backchannel_authentication_request()</code>.</p> <p>Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint, when it is an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the BackChannel Authentication Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>usually raises an exception. But a subclass can return a default response instead.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>(or one of its subclasses) if the response contains a standard OAuth 2.0 error.</p> <code>InvalidBackChannelAuthenticationResponse</code> <p>for non-standard error responses.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_backchannel_authentication_error(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,  # noqa: ARG002\n) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Error handler for `backchannel_authentication_request()`.\n\n    Invoked by\n    [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n    to parse the response returned by the BackChannel Authentication Endpoint, when it is an\n    error.\n\n    Args:\n        response: the response returned by the BackChannel Authentication Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        usually raises an exception. But a subclass can return a default response instead.\n\n    Raises:\n        EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n        InvalidBackChannelAuthenticationResponse: for non-standard error responses.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, BackChannelAuthenticationError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.authorize_device","title":"<code>authorize_device(requests_kwargs=None, **data)</code>","text":"<p>Send a Device Authorization Request.</p> <p>Parameters:</p> Name Type Description Default <code>**data</code> <code>Any</code> <p>additional data to send to the Device Authorization Endpoint</p> <code>{}</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for <code>requests.request()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>a Device Authorization Response</p> <p>Raises:</p> Type Description <code>MissingEndpointUri</code> <p>if the Device Authorization URI is not configured</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorize_device(\n    self,\n    requests_kwargs: dict[str, Any] | None = None,\n    **data: Any,\n) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Send a Device Authorization Request.\n\n    Args:\n        **data: additional data to send to the Device Authorization Endpoint\n        requests_kwargs: additional parameters for `requests.request()`\n\n    Returns:\n        a Device Authorization Response\n\n    Raises:\n        MissingEndpointUri: if the Device Authorization URI is not configured\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    return self._request(\n        Endpoints.DEVICE_AUTHORIZATION,\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_device_authorization_response,\n        on_failure=self.on_device_authorization_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_device_authorization_response","title":"<code>parse_device_authorization_response(response, *, dpop_key=None)</code>","text":"<p>Parse a Device Authorization Response received by <code>authorize_device()</code>.</p> <p>Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the Device Authorization Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>a <code>DeviceAuthorizationResponse</code> as returned by AS</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_device_authorization_response(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,  # noqa: ARG002\n) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Parse a Device Authorization Response received by `authorize_device()`.\n\n    Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n    to parse the response returned by the Device Authorization Endpoint.\n\n    Args:\n        response: the response returned by the Device Authorization Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        a `DeviceAuthorizationResponse` as returned by AS\n\n    \"\"\"\n    return DeviceAuthorizationResponse(**response.json())\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_device_authorization_error","title":"<code>on_device_authorization_error(response, *, dpop_key=None)</code>","text":"<p>Error handler for <code>authorize_device()</code>.</p> <p>Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint, when that response is an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the Device Authorization Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>usually raises an Exception. But a subclass may return a default response instead.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>for standard OAuth 2.0 errors</p> <code>InvalidDeviceAuthorizationResponse</code> <p>for non-standard error responses.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_device_authorization_error(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,  # noqa: ARG002\n) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Error handler for `authorize_device()`.\n\n    Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n    to parse the response returned by the Device Authorization Endpoint, when that response is\n    an error.\n\n    Args:\n        response: the response returned by the Device Authorization Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        usually raises an Exception. But a subclass may return a default response instead.\n\n    Raises:\n        EndpointError: for standard OAuth 2.0 errors\n        InvalidDeviceAuthorizationResponse: for non-standard error responses.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, DeviceAuthorizationError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidDeviceAuthorizationResponse(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.update_authorization_server_public_keys","title":"<code>update_authorization_server_public_keys(requests_kwargs=None)</code>","text":"<p>Update the cached AS public keys by retrieving them from its <code>jwks_uri</code>.</p> <p>Public keys are returned by this method, as a <code>jwskate.JwkSet</code>. They are also available in attribute <code>authorization_server_jwks</code>.</p> <p>Returns:</p> Type Description <code>JwkSet</code> <p>the retrieved public keys</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if no <code>jwks_uri</code> is configured</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def update_authorization_server_public_keys(self, requests_kwargs: dict[str, Any] | None = None) -&gt; JwkSet:\n    \"\"\"Update the cached AS public keys by retrieving them from its `jwks_uri`.\n\n    Public keys are returned by this method, as a `jwskate.JwkSet`. They are also\n    available in attribute `authorization_server_jwks`.\n\n    Returns:\n        the retrieved public keys\n\n    Raises:\n        ValueError: if no `jwks_uri` is configured\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n    requests_kwargs.setdefault(\"auth\", None)\n\n    jwks_uri = self._require_endpoint(Endpoints.JWKS)\n    resp = self.session.get(jwks_uri, **requests_kwargs)\n    resp.raise_for_status()\n    jwks = resp.json()\n    self.authorization_server_jwks.update(jwks)\n    return self.authorization_server_jwks\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.from_discovery_endpoint","title":"<code>from_discovery_endpoint(url=None, issuer=None, *, auth=None, client_id=None, client_secret=None, private_key=None, session=None, testing=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize an <code>OAuth2Client</code> using an AS Discovery Document endpoint.</p> <p>If an <code>url</code> is provided, an HTTPS request will be done to that URL to obtain the Authorization Server Metadata.</p> <p>If an <code>issuer</code> is provided, the OpenID Connect Discovery document url will be automatically derived from it, as specified in OpenID Connect Discovery.</p> <p>Once the standardized metadata document is obtained, this will extract all Endpoint Uris from that document, will fetch the current public keys from its <code>jwks_uri</code>, then will initialize an OAuth2Client based on those endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | None</code> <p>The url where the server metadata will be retrieved.</p> <code>None</code> <code>issuer</code> <code>str | None</code> <p>The issuer value that is expected in the discovery document. If not <code>url</code> is given, the OpenID Connect Discovery url for this issuer will be retrieved.</p> <code>None</code> <code>auth</code> <code>AuthBase | tuple[str, str] | str | None</code> <p>The authentication handler to use for client authentication.</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>Client ID.</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>Client secret to use to authenticate the client.</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>Private key to sign client assertions.</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>A <code>requests.Session</code> to use to retrieve the document and initialise the client with.</p> <code>None</code> <code>testing</code> <code>bool</code> <p>If <code>True</code>, do not try to validate the issuer uri nor the endpoint urls that are part of the document.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword parameters to pass to <code>OAuth2Client</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>OAuth2Client</code> <p>An <code>OAuth2Client</code> with endpoints initialized based on the obtained metadata.</p> <p>Raises:</p> Type Description <code>InvalidIssuer</code> <p>If <code>issuer</code> is not using https, or contains credentials or fragment.</p> <code>InvalidParam</code> <p>If neither <code>url</code> nor <code>issuer</code> are suitable urls.</p> <code>HTTPError</code> <p>If an error happens while fetching the documents.</p> Example <pre><code>from requests_oauth2client import OAuth2Client\n\nclient = OAuth2Client.from_discovery_endpoint(\n    issuer=\"https://myserver.net\",\n    client_id=\"my_client_id,\n    client_secret=\"my_client_secret\",\n)\n</code></pre> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@classmethod\ndef from_discovery_endpoint(\n    cls,\n    url: str | None = None,\n    issuer: str | None = None,\n    *,\n    auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_key: Jwk | dict[str, Any] | None = None,\n    session: requests.Session | None = None,\n    testing: bool = False,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n    \"\"\"Initialize an `OAuth2Client` using an AS Discovery Document endpoint.\n\n    If an `url` is provided, an HTTPS request will be done to that URL to obtain the Authorization Server Metadata.\n\n    If an `issuer` is provided, the OpenID Connect Discovery document url will be automatically\n    derived from it, as specified in [OpenID Connect Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationRequest).\n\n    Once the standardized metadata document is obtained, this will extract\n    all Endpoint Uris from that document, will fetch the current public keys from its\n    `jwks_uri`, then will initialize an OAuth2Client based on those endpoints.\n\n    Args:\n      url: The url where the server metadata will be retrieved.\n      issuer: The issuer value that is expected in the discovery document.\n        If not `url` is given, the OpenID Connect Discovery url for this issuer will be retrieved.\n      auth: The authentication handler to use for client authentication.\n      client_id: Client ID.\n      client_secret: Client secret to use to authenticate the client.\n      private_key: Private key to sign client assertions.\n      session: A `requests.Session` to use to retrieve the document and initialise the client with.\n      testing: If `True`, do not try to validate the issuer uri nor the endpoint urls\n        that are part of the document.\n      **kwargs: Additional keyword parameters to pass to `OAuth2Client`.\n\n    Returns:\n      An `OAuth2Client` with endpoints initialized based on the obtained metadata.\n\n    Raises:\n      InvalidIssuer: If `issuer` is not using https, or contains credentials or fragment.\n      InvalidParam: If neither `url` nor `issuer` are suitable urls.\n      requests.HTTPError: If an error happens while fetching the documents.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client\n\n        client = OAuth2Client.from_discovery_endpoint(\n            issuer=\"https://myserver.net\",\n            client_id=\"my_client_id,\n            client_secret=\"my_client_secret\",\n        )\n        ```\n\n    \"\"\"\n    if issuer is not None and not testing:\n        try:\n            validate_issuer_uri(issuer)\n        except InvalidUri as exc:\n            raise InvalidIssuer(\"issuer\", issuer, exc) from exc  # noqa: EM101\n    if url is None and issuer is not None:\n        url = oidc_discovery_document_url(issuer)\n    if url is None:\n        msg = \"Please specify at least one of `issuer` or `url`\"\n        raise InvalidParam(msg)\n\n    if not testing:\n        validate_endpoint_uri(url, path=False)\n\n    session = session or requests.Session()\n    discovery = session.get(url).json()\n\n    jwks_uri = discovery.get(\"jwks_uri\")\n    jwks = JwkSet(session.get(jwks_uri).json()) if jwks_uri else None\n\n    return cls.from_discovery_document(\n        discovery,\n        issuer=issuer,\n        auth=auth,\n        session=session,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_key=private_key,\n        authorization_server_jwks=jwks,\n        testing=testing,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.from_discovery_document","title":"<code>from_discovery_document(discovery, issuer=None, *, auth=None, client_id=None, client_secret=None, private_key=None, authorization_server_jwks=None, https=True, testing=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize an <code>OAuth2Client</code>, based on an AS Discovery Document.</p> <p>Parameters:</p> Name Type Description Default <code>discovery</code> <code>dict[str, Any]</code> <p>A <code>dict</code> of server metadata, in the same format as retrieved from a discovery endpoint.</p> required <code>issuer</code> <code>str | None</code> <p>If an issuer is given, check that it matches the one mentioned in the document.</p> <code>None</code> <code>auth</code> <code>AuthBase | tuple[str, str] | str | None</code> <p>The authentication handler to use for client authentication.</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>Client ID.</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>Client secret to use to authenticate the client.</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>Private key to sign client assertions.</p> <code>None</code> <code>authorization_server_jwks</code> <code>JwkSet | dict[str, Any] | None</code> <p>The current authorization server JWKS keys.</p> <code>None</code> <code>https</code> <code>bool</code> <p>(deprecated) If <code>True</code>, validates that urls in the discovery document use the https scheme.</p> <code>True</code> <code>testing</code> <code>bool</code> <p>If <code>True</code>, don't try to validate the endpoint urls that are part of the document.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional args that will be passed to <code>OAuth2Client</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>OAuth2Client</code> <p>An <code>OAuth2Client</code> initialized with the endpoints from the discovery document.</p> <p>Raises:</p> Type Description <code>InvalidDiscoveryDocument</code> <p>If the document does not contain at least a <code>\"token_endpoint\"</code>.</p> <p>Examples:</p> <pre><code>from requests_oauth2client import OAuth2Client\n\nclient = OAuth2Client.from_discovery_document(\n    {\n        \"issuer\": \"https://myas.local\",\n        \"token_endpoint\": \"https://myas.local/token\",\n    },\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n</code></pre> Source code in <code>requests_oauth2client/client.py</code> <pre><code>    @classmethod\n    def from_discovery_document(\n        cls,\n        discovery: dict[str, Any],\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        https: bool = True,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an `OAuth2Client`, based on an AS Discovery Document.\n\n        Args:\n          discovery: A `dict` of server metadata, in the same format as retrieved from a discovery endpoint.\n          issuer: If an issuer is given, check that it matches the one mentioned in the document.\n          auth: The authentication handler to use for client authentication.\n          client_id: Client ID.\n          client_secret: Client secret to use to authenticate the client.\n          private_key: Private key to sign client assertions.\n          authorization_server_jwks: The current authorization server JWKS keys.\n          https: (deprecated) If `True`, validates that urls in the discovery document use the https scheme.\n          testing: If `True`, don't try to validate the endpoint urls that are part of the document.\n          **kwargs: Additional args that will be passed to `OAuth2Client`.\n\n        Returns:\n            An `OAuth2Client` initialized with the endpoints from the discovery document.\n\n        Raises:\n            InvalidDiscoveryDocument: If the document does not contain at least a `\"token_endpoint\"`.\n\n        Examples:\n            ```python\n            from requests_oauth2client import OAuth2Client\n\n            client = OAuth2Client.from_discovery_document(\n                {\n                    \"issuer\": \"https://myas.local\",\n                    \"token_endpoint\": \"https://myas.local/token\",\n                },\n                client_id=\"client_id\",\n                client_secret=\"client_secret\",\n            )\n            ```\n\n        \"\"\"\n        if not https:\n            warnings.warn(\n                \"\"\"\\\nThe `https` parameter is deprecated.\nTo disable endpoint uri validation, set `testing=True` when initializing your `OAuth2Client`.\"\"\",\n                stacklevel=1,\n            )\n            testing = True\n        if issuer and discovery.get(\"issuer\") != issuer:\n            msg = f\"\"\"\\\nMismatching `issuer` value in discovery document (received '{discovery.get(\"issuer\")}', expected '{issuer}').\"\"\"\n            raise InvalidParam(\n                msg,\n                issuer,\n                discovery.get(\"issuer\"),\n            )\n        if issuer is None:\n            issuer = discovery.get(\"issuer\")\n\n        token_endpoint = discovery.get(Endpoints.TOKEN)\n        if token_endpoint is None:\n            msg = \"token_endpoint not found in that discovery document\"\n            raise InvalidDiscoveryDocument(msg, discovery)\n        authorization_endpoint = discovery.get(Endpoints.AUTHORIZATION)\n        revocation_endpoint = discovery.get(Endpoints.REVOCATION)\n        introspection_endpoint = discovery.get(Endpoints.INTROSPECTION)\n        userinfo_endpoint = discovery.get(Endpoints.USER_INFO)\n        pushed_authorization_request_endpoint = discovery.get(Endpoints.PUSHED_AUTHORIZATION_REQUEST)\n        jwks_uri = discovery.get(Endpoints.JWKS)\n        if jwks_uri is not None and not testing:\n            validate_endpoint_uri(jwks_uri)\n        authorization_response_iss_parameter_supported = discovery.get(\n            \"authorization_response_iss_parameter_supported\",\n            False,\n        )\n\n        return cls(\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            pushed_authorization_request_endpoint=pushed_authorization_request_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            issuer=issuer,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            testing=testing,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.UnknownActorTokenType","title":"<code>UnknownActorTokenType</code>","text":"<p>               Bases: <code>UnknownTokenType</code></p> <p>Raised when the type of actor_token cannot be determined automatically.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class UnknownActorTokenType(UnknownTokenType):\n    \"\"\"Raised when the type of actor_token cannot be determined automatically.\"\"\"\n\n    def __init__(self, actor_token: object, actor_token_type: str | None) -&gt; None:\n        super().__init__(\"actor_token\", token=actor_token, token_type=actor_token_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.UnknownSubjectTokenType","title":"<code>UnknownSubjectTokenType</code>","text":"<p>               Bases: <code>UnknownTokenType</code></p> <p>Raised when the type of subject_token cannot be determined automatically.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class UnknownSubjectTokenType(UnknownTokenType):\n    \"\"\"Raised when the type of subject_token cannot be determined automatically.\"\"\"\n\n    def __init__(self, subject_token: object, subject_token_type: str | None) -&gt; None:\n        super().__init__(\"subject_token\", subject_token, subject_token_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.UnknownTokenType","title":"<code>UnknownTokenType</code>","text":"<p>               Bases: <code>InvalidParam</code>, <code>TypeError</code></p> <p>Raised when the type of a token cannot be determined automatically.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class UnknownTokenType(InvalidParam, TypeError):\n    \"\"\"Raised when the type of a token cannot be determined automatically.\"\"\"\n\n    def __init__(self, message: str, token: object, token_type: str | None) -&gt; None:\n        super().__init__(f\"Unable to determine the type of token provided: {message}\")\n        self.token = token\n        self.token_type = token_type\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseClientAssertionAuthenticationMethod","title":"<code>BaseClientAssertionAuthenticationMethod</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Base class for assertion-based client authentication methods.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen\nclass BaseClientAssertionAuthenticationMethod(BaseClientAuthenticationMethod):\n    \"\"\"Base class for assertion-based client authentication methods.\"\"\"\n\n    lifetime: int\n    jti_gen: Callable[[], str]\n    aud: str | None\n    alg: str | None\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a Client Assertion for a specific audience.\n\n        Args:\n            audience: the audience to use for the `aud` claim of the generated Client Assertion.\n\n        Returns:\n            a Client Assertion, as `str`.\n\n        \"\"\"\n        raise NotImplementedError\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add a `client_assertion` field in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added `client_assertion` field.\n\n        \"\"\"\n        request = super().__call__(request)\n        audience = self.aud or request.url\n        if audience is None:\n            raise InvalidRequestForClientAuthentication(request)  # pragma: no cover\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if request.body\n            else {}\n        )\n        client_assertion = self.client_assertion(audience)\n        params[b\"client_id\"] = [self.client_id.encode()]\n        params[b\"client_assertion\"] = [client_assertion.encode()]\n        params[b\"client_assertion_type\"] = [b\"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseClientAssertionAuthenticationMethod.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a Client Assertion for a specific audience.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the <code>aud</code> claim of the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion, as <code>str</code>.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a Client Assertion for a specific audience.\n\n    Args:\n        audience: the audience to use for the `aud` claim of the generated Client Assertion.\n\n    Returns:\n        a Client Assertion, as `str`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseClientAuthenticationMethod","title":"<code>BaseClientAuthenticationMethod</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Base class for all Client Authentication methods. This extends requests.auth.AuthBase.</p> <p>This base class checks that requests are suitable to add Client Authentication parameters to, and does not modify the request.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen\nclass BaseClientAuthenticationMethod(requests.auth.AuthBase):\n    \"\"\"Base class for all Client Authentication methods. This extends [requests.auth.AuthBase][].\n\n    This base class checks that requests are suitable to add Client Authentication parameters to, and does not modify\n    the request.\n\n    \"\"\"\n\n    client_id: str\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Check that the request is suitable for Client Authentication.\n\n        It checks:\n\n        * that the method is `POST`\n        * that the Content-Type is \"application/x-www-form-urlencoded\" or None\n\n        Args:\n            request: a [requests.PreparedRequest][]\n\n        Returns:\n            a [requests.PreparedRequest][], unmodified\n\n        Raises:\n            RuntimeError: if the request is not suitable for OAuth 2.0 Client Authentication\n\n        \"\"\"\n        if request.method != \"POST\" or request.headers.get(\"Content-Type\") not in (\n            \"application/x-www-form-urlencoded\",\n            None,\n        ):\n            raise InvalidRequestForClientAuthentication(request)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.ClientSecretBasic","title":"<code>ClientSecretBasic</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement <code>client_secret_basic</code> authentication.</p> <p>With this method, the client sends its Client ID and Secret, in the HTTP <code>Authorization</code> header, with the <code>Basic</code> scheme, in each authenticated request to the Authorization Server.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>client_secret</code> <code>str</code> <p>Client Secret</p> required Example <pre><code>from requests_oauth2client import ClientSecretBasic, OAuth2Client\n\nauth = ClientSecretBasic(\"my_client_id\", \"my_client_secret\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass ClientSecretBasic(BaseClientAuthenticationMethod):\n    \"\"\"Implement `client_secret_basic` authentication.\n\n    With this method, the client sends its Client ID and Secret, in the HTTP `Authorization` header, with\n    the `Basic` scheme, in each authenticated request to the Authorization Server.\n\n    Args:\n        client_id: Client ID\n        client_secret: Client Secret\n\n    Example:\n        ```python\n        from requests_oauth2client import ClientSecretBasic, OAuth2Client\n\n        auth = ClientSecretBasic(\"my_client_id\", \"my_client_secret\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    client_secret: str\n\n    def __init__(self, client_id: str, client_secret: str) -&gt; None:\n        self.__attrs_init__(\n            client_id=client_id,\n            client_secret=client_secret,\n        )\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the appropriate `Authorization` header in each request.\n\n        The Authorization header is formatted as such:\n        `Authorization: Basic BASE64('&lt;client_id:client_secret&gt;')`\n\n        Args:\n            request: the request\n\n        Returns:\n            a [requests.PreparedRequest][] with the added Authorization header.\n\n        \"\"\"\n        request = super().__call__(request)\n        b64encoded_credentials = BinaPy(f\"{self.client_id}:{self.client_secret}\").to(\"b64\").ascii()\n        request.headers[\"Authorization\"] = f\"Basic {b64encoded_credentials}\"\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.ClientSecretJwt","title":"<code>ClientSecretJwt</code>","text":"<p>               Bases: <code>BaseClientAssertionAuthenticationMethod</code></p> <p>Implement <code>client_secret_jwt</code> client authentication method.</p> <p>With this method, the client generates a client assertion, then symmetrically signs it with its Client Secret. The assertion is then sent to the AS in a <code>client_assertion</code> field with each authenticated request.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the <code>client_id</code> to use.</p> required <code>client_secret</code> <code>str</code> <p>the <code>client_secret</code> to use to sign generated Client Assertions.</p> required <code>alg</code> <code>str</code> <p>the alg to use to sign generated Client Assertions.</p> <code>HS256</code> <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> <code>60</code> <code>jti_gen</code> <code>Callable[[], str]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> <code>lambda: str(uuid4())</code> <code>aud</code> <code>str | None</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.</p> <code>None</code> Example <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\nauth = ClientSecretJwt(\"my_client_id\", \"my_client_secret\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass ClientSecretJwt(BaseClientAssertionAuthenticationMethod):\n    \"\"\"Implement `client_secret_jwt` client authentication method.\n\n    With this method, the client generates a client assertion, then symmetrically signs it with its Client Secret.\n    The assertion is then sent to the AS in a `client_assertion` field with each authenticated request.\n\n    Args:\n        client_id: the `client_id` to use.\n        client_secret: the `client_secret` to use to sign generated Client Assertions.\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\n        auth = ClientSecretJwt(\"my_client_id\", \"my_client_secret\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    client_secret: str\n\n    def __init__(\n        self,\n        client_id: str,\n        client_secret: str,\n        lifetime: int = 60,\n        alg: str = SignatureAlgs.HS256,\n        jti_gen: Callable[[], str] = lambda: str(uuid4()),\n        aud: str | None = None,\n    ) -&gt; None:\n        self.__attrs_init__(\n            client_id=client_id,\n            client_secret=client_secret,\n            lifetime=lifetime,\n            alg=alg,\n            jti_gen=jti_gen,\n            aud=aud,\n        )\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a symmetrically signed Client Assertion.\n\n        Assertion is signed with the `client_secret` as key and the `alg` passed at init time.\n\n        Args:\n            audience: the audience to use for the generated Client Assertion.\n\n        Returns:\n            a Client Assertion, as `str`.\n\n        \"\"\"\n        iat = int(datetime.now(tz=timezone.utc).timestamp())\n        exp = iat + self.lifetime\n        jti = str(self.jti_gen())\n\n        jwk = SymmetricJwk.from_bytes(self.client_secret.encode())\n\n        jwt = Jwt.sign(\n            claims={\n                \"iss\": self.client_id,\n                \"sub\": self.client_id,\n                \"aud\": audience,\n                \"iat\": iat,\n                \"exp\": exp,\n                \"jti\": jti,\n            },\n            key=jwk,\n            alg=self.alg,\n        )\n        return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.ClientSecretJwt.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a symmetrically signed Client Assertion.</p> <p>Assertion is signed with the <code>client_secret</code> as key and the <code>alg</code> passed at init time.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion, as <code>str</code>.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a symmetrically signed Client Assertion.\n\n    Assertion is signed with the `client_secret` as key and the `alg` passed at init time.\n\n    Args:\n        audience: the audience to use for the generated Client Assertion.\n\n    Returns:\n        a Client Assertion, as `str`.\n\n    \"\"\"\n    iat = int(datetime.now(tz=timezone.utc).timestamp())\n    exp = iat + self.lifetime\n    jti = str(self.jti_gen())\n\n    jwk = SymmetricJwk.from_bytes(self.client_secret.encode())\n\n    jwt = Jwt.sign(\n        claims={\n            \"iss\": self.client_id,\n            \"sub\": self.client_id,\n            \"aud\": audience,\n            \"iat\": iat,\n            \"exp\": exp,\n            \"jti\": jti,\n        },\n        key=jwk,\n        alg=self.alg,\n    )\n    return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.ClientSecretPost","title":"<code>ClientSecretPost</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement <code>client_secret_post</code> client authentication method.</p> <p>With this method, the client inserts its client_id and client_secret in each authenticated request to the AS.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>client_secret</code> <code>str</code> <p>Client Secret</p> required Example <pre><code>from requests_oauth2client import ClientSecretPost, OAuth2Client\n\nauth = ClientSecretPost(\"my_client_id\", \"my_client_secret\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass ClientSecretPost(BaseClientAuthenticationMethod):\n    \"\"\"Implement `client_secret_post` client authentication method.\n\n    With this method, the client inserts its client_id and client_secret in each authenticated\n    request to the AS.\n\n    Args:\n        client_id: Client ID\n        client_secret: Client Secret\n\n    Example:\n        ```python\n        from requests_oauth2client import ClientSecretPost, OAuth2Client\n\n        auth = ClientSecretPost(\"my_client_id\", \"my_client_secret\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    client_secret: str\n\n    def __init__(self, client_id: str, client_secret: str) -&gt; None:\n        self.__attrs_init__(\n            client_id=client_id,\n            client_secret=client_secret,\n        )\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the `client_id` and `client_secret` parameters in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added client credentials fields.\n\n        \"\"\"\n        request = super().__call__(request)\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if isinstance(request.body, (str, bytes))\n            else {}\n        )\n        params[b\"client_id\"] = [self.client_id.encode()]\n        params[b\"client_secret\"] = [self.client_secret.encode()]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidClientAssertionSigningKeyOrAlg","title":"<code>InvalidClientAssertionSigningKeyOrAlg</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when the client assertion signing alg is not specified or invalid.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class InvalidClientAssertionSigningKeyOrAlg(ValueError):\n    \"\"\"Raised when the client assertion signing alg is not specified or invalid.\"\"\"\n\n    def __init__(self, alg: str | None) -&gt; None:\n        super().__init__(\"\"\"\\\nAn asymmetric private signing key, and an alg that is supported by the signing key is required.\nIt can be provided either:\n- as part of the private `Jwk`, in the parameter 'alg'\n- or passed as parameter `alg` when initializing a `PrivateKeyJwt`.\nExamples of valid `alg` values and matching key type:\n- 'RS256', 'RS512' (with a key of type RSA)\n- 'ES256', 'ES512' (with a key of type EC)\nThe private key must include a Key ID (in its 'kid' parameter).\n\"\"\")\n        self.alg = alg\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidRequestForClientAuthentication","title":"<code>InvalidRequestForClientAuthentication</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Raised when a request is not suitable for OAuth 2.0 client authentication.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class InvalidRequestForClientAuthentication(RuntimeError):\n    \"\"\"Raised when a request is not suitable for OAuth 2.0 client authentication.\"\"\"\n\n    def __init__(self, request: requests.PreparedRequest) -&gt; None:\n        super().__init__(\"This request is not suitabe for OAuth 2.0 client authentication.\")\n        self.request = request\n</code></pre>"},{"location":"api/#requests_oauth2client.PrivateKeyJwt","title":"<code>PrivateKeyJwt</code>","text":"<p>               Bases: <code>BaseClientAssertionAuthenticationMethod</code></p> <p>Implement <code>private_key_jwt</code> client authentication method.</p> <p>With this method, the client generates and sends a client_assertion, that is asymmetrically signed with a private key, on each direct request to the Authorization Server.</p> <p>The private key must be supplied as a <code>jwskate.Jwk</code> instance, or any key material that can be used to initialize one.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the <code>client_id</code> to use.</p> required <code>private_jwk</code> <code>Jwk | dict[str, Any] | Any</code> <p>the private key to use to sign generated Client Assertions.</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign generated Client Assertions.</p> <code>None</code> <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> <code>60</code> <code>jti_gen</code> <code>Callable[[], str]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> <code>lambda: str(uuid4())</code> <code>aud</code> <code>str | None</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.k</p> <code>None</code> Example <pre><code>from jwskate import Jwk\nfrom requests_oauth2client import OAuth2Client, PrivateKeyJwt\n\n# load your private key from wherever it is stored:\nwith open(\"my_private_key.pem\") as f:\n    my_private_key = Jwk.from_pem(f.read(), password=\"my_private_key_password\")\n\nauth = PrivateKeyJwt(\"my_client_id\", my_private_key, alg=\"RS256\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass PrivateKeyJwt(BaseClientAssertionAuthenticationMethod):\n    \"\"\"Implement `private_key_jwt` client authentication method.\n\n    With this method, the client generates and sends a client_assertion, that is asymmetrically\n    signed with a private key, on each direct request to the Authorization Server.\n\n    The private key must be supplied as a [`jwskate.Jwk`][jwskate.jwk.Jwk] instance,\n    or any key material that can be used to initialize one.\n\n    Args:\n        client_id: the `client_id` to use.\n        private_jwk: the private key to use to sign generated Client Assertions.\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.k\n\n    Example:\n        ```python\n        from jwskate import Jwk\n        from requests_oauth2client import OAuth2Client, PrivateKeyJwt\n\n        # load your private key from wherever it is stored:\n        with open(\"my_private_key.pem\") as f:\n            my_private_key = Jwk.from_pem(f.read(), password=\"my_private_key_password\")\n\n        auth = PrivateKeyJwt(\"my_client_id\", my_private_key, alg=\"RS256\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    private_jwk: Jwk\n\n    def __init__(\n        self,\n        client_id: str,\n        private_jwk: Jwk | dict[str, Any] | Any,\n        *,\n        alg: str | None = None,\n        lifetime: int = 60,\n        jti_gen: Callable[[], str] = lambda: str(uuid4()),\n        aud: str | None = None,\n    ) -&gt; None:\n        private_jwk = to_jwk(private_jwk)\n\n        alg = private_jwk.alg or alg\n        if not alg:\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n        if alg not in private_jwk.supported_signing_algorithms():\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n        if not private_jwk.is_private or private_jwk.is_symmetric:\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n        kid = private_jwk.get(\"kid\")\n        if not kid:\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n        self.__attrs_init__(\n            client_id=client_id,\n            private_jwk=private_jwk,\n            alg=alg,\n            lifetime=lifetime,\n            jti_gen=jti_gen,\n            aud=aud,\n        )\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a Client Assertion, asymmetrically signed with `private_jwk` as key.\n\n        Args:\n            audience: the audience to use for the generated Client Assertion.\n\n        Returns:\n            a Client Assertion.\n\n        \"\"\"\n        iat = int(datetime.now(tz=timezone.utc).timestamp())\n        exp = iat + self.lifetime\n        jti = str(self.jti_gen())\n\n        jwt = Jwt.sign(\n            claims={\n                \"iss\": self.client_id,\n                \"sub\": self.client_id,\n                \"aud\": audience,\n                \"iat\": iat,\n                \"exp\": exp,\n                \"jti\": jti,\n            },\n            key=self.private_jwk,\n            alg=self.alg,\n        )\n        return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.PrivateKeyJwt.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a Client Assertion, asymmetrically signed with <code>private_jwk</code> as key.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a Client Assertion, asymmetrically signed with `private_jwk` as key.\n\n    Args:\n        audience: the audience to use for the generated Client Assertion.\n\n    Returns:\n        a Client Assertion.\n\n    \"\"\"\n    iat = int(datetime.now(tz=timezone.utc).timestamp())\n    exp = iat + self.lifetime\n    jti = str(self.jti_gen())\n\n    jwt = Jwt.sign(\n        claims={\n            \"iss\": self.client_id,\n            \"sub\": self.client_id,\n            \"aud\": audience,\n            \"iat\": iat,\n            \"exp\": exp,\n            \"jti\": jti,\n        },\n        key=self.private_jwk,\n        alg=self.alg,\n    )\n    return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.PublicApp","title":"<code>PublicApp</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement the <code>none</code> authentication method for public apps.</p> <p>This scheme is used for Public Clients, which do not have any secret credentials. Those only send their client_id to the Authorization Server.</p> Example <pre><code>from requests_oauth2client import OAuth2Client, PublicApp\n\nauth = PublicApp(\"my_client_id\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen\nclass PublicApp(BaseClientAuthenticationMethod):\n    \"\"\"Implement the `none` authentication method for public apps.\n\n    This scheme is used for Public Clients, which do not have any secret credentials. Those only\n    send their client_id to the Authorization Server.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, PublicApp\n\n        auth = PublicApp(\"my_client_id\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the `client_id` field in the request body.\n\n        Args:\n            request: a request.\n\n        Returns:\n            the request with the added `client_id` form field.\n\n        \"\"\"\n        request = super().__call__(request)\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if request.body\n            else {}\n        )\n        params[b\"client_id\"] = [self.client_id.encode()]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.UnsupportedClientCredentials","title":"<code>UnsupportedClientCredentials</code>","text":"<p>               Bases: <code>TypeError</code>, <code>ValueError</code></p> <p>Raised when unsupported client credentials are provided.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class UnsupportedClientCredentials(TypeError, ValueError):\n    \"\"\"Raised when unsupported client credentials are provided.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.DeviceAuthorizationPoolingJob","title":"<code>DeviceAuthorizationPoolingJob</code>","text":"<p>               Bases: <code>BaseTokenEndpointPoolingJob</code></p> <p>A Token Endpoint pooling job for the Device Authorization Flow.</p> <p>This periodically checks if the user has finished with his authorization in a Device Authorization flow.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client that will be used to pool the token endpoint.</p> required <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a <code>device_code</code> as <code>str</code> or a <code>DeviceAuthorizationResponse</code>.</p> required <code>interval</code> <code>int | None</code> <p>The pooling interval to use. This overrides the one in <code>auth_req_id</code> if it is a <code>BackChannelAuthenticationResponse</code>.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>Number of seconds to add to the pooling interval when the AS returns a slow-down request.</p> <code>5</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the underlying calls to requests.request.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token request.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import DeviceAuthorizationPoolingJob, OAuth2Client\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\npooler = DeviceAuthorizationPoolingJob(client=client, device_code=\"my_device_code\")\n\ntoken = None\nwhile token is None:\n    token = pooler()\n</code></pre> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>@define(init=False)\nclass DeviceAuthorizationPoolingJob(BaseTokenEndpointPoolingJob):\n    \"\"\"A Token Endpoint pooling job for the Device Authorization Flow.\n\n    This periodically checks if the user has finished with his authorization in a Device\n    Authorization flow.\n\n    Args:\n        client: an OAuth2Client that will be used to pool the token endpoint.\n        device_code: a `device_code` as `str` or a `DeviceAuthorizationResponse`.\n        interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is\n            a `BackChannelAuthenticationResponse`.\n        slow_down_interval: Number of seconds to add to the pooling interval when the AS returns\n            a slow-down request.\n        requests_kwargs: Additional parameters for the underlying calls to [requests.request][].\n        **token_kwargs: Additional parameters for the token request.\n\n    Example:\n        ```python\n        from requests_oauth2client import DeviceAuthorizationPoolingJob, OAuth2Client\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        pooler = DeviceAuthorizationPoolingJob(client=client, device_code=\"my_device_code\")\n\n        token = None\n        while token is None:\n            token = pooler()\n        ```\n\n    \"\"\"\n\n    device_code: str\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        device_code: str | DeviceAuthorizationResponse,\n        interval: int | None = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(device_code, DeviceAuthorizationResponse):\n            interval = interval or device_code.interval\n            device_code = device_code.device_code\n\n        self.__attrs_init__(\n            client=client,\n            device_code=device_code,\n            interval=interval or 5,\n            slow_down_interval=slow_down_interval,\n            requests_kwargs=requests_kwargs or {},\n            token_kwargs=token_kwargs,\n        )\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Implement the Device Code token request.\n\n        This actually calls [OAuth2Client.device_code(device_code)][requests_oauth2client.OAuth2Client.device_code]\n        on `self.client`.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        return self.client.device_code(self.device_code, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.DeviceAuthorizationPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Implement the Device Code token request.</p> <p>This actually calls OAuth2Client.device_code(device_code) on <code>self.client</code>.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Implement the Device Code token request.\n\n    This actually calls [OAuth2Client.device_code(device_code)][requests_oauth2client.OAuth2Client.device_code]\n    on `self.client`.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    return self.client.device_code(self.device_code, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.DeviceAuthorizationResponse","title":"<code>DeviceAuthorizationResponse</code>","text":"<p>Represent a response returned by the device Authorization Endpoint.</p> <p>All parameters are those returned by the AS as response to a Device Authorization Request.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>user_code</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>verification_uri</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>verification_uri_complete</code> <code>str | None</code> <p>the <code>device_code</code> as returned by the AS.</p> <code>None</code> <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for the device_code. Also accepts an <code>expires_in</code> parameter, as a number of seconds in the future.</p> <code>None</code> <code>interval</code> <code>int | None</code> <p>the pooling <code>interval</code> as returned by the AS.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>class DeviceAuthorizationResponse:\n    \"\"\"Represent a response returned by the device Authorization Endpoint.\n\n    All parameters are those returned by the AS as response to a Device Authorization Request.\n\n    Args:\n        device_code: the `device_code` as returned by the AS.\n        user_code: the `device_code` as returned by the AS.\n        verification_uri: the `device_code` as returned by the AS.\n        verification_uri_complete: the `device_code` as returned by the AS.\n        expires_at: the expiration date for the device_code.\n            Also accepts an `expires_in` parameter, as a number of seconds in the future.\n        interval: the pooling `interval` as returned by the AS.\n        **kwargs: additional parameters as returned by the AS.\n\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        device_code: str,\n        user_code: str,\n        verification_uri: str,\n        verification_uri_complete: str | None = None,\n        expires_at: datetime | None = None,\n        interval: int | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        self.device_code = device_code\n        self.user_code = user_code\n        self.verification_uri = verification_uri\n        self.verification_uri_complete = verification_uri_complete\n        self.expires_at = expires_at\n        self.interval = interval\n        self.other = kwargs\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Check if the `device_code` within this response is expired.\n\n        Returns:\n            `True` if the device_code is expired, `False` if it is still valid, `None` if there is\n            no `expires_in` hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n</code></pre>"},{"location":"api/#requests_oauth2client.DeviceAuthorizationResponse.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Check if the <code>device_code</code> within this response is expired.</p> <p>Returns:</p> Type Description <code>bool | None</code> <p><code>True</code> if the device_code is expired, <code>False</code> if it is still valid, <code>None</code> if there is</p> <code>bool | None</code> <p>no <code>expires_in</code> hint.</p> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Check if the `device_code` within this response is expired.\n\n    Returns:\n        `True` if the device_code is expired, `False` if it is still valid, `None` if there is\n        no `expires_in` hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.DPoPKey","title":"<code>DPoPKey</code>","text":"<p>Wrapper around a DPoP proof signature key.</p> <p>This handles DPoP proof generation. It also keeps track of a nonce, if provided by the Resource Server. Its behavior follows the standard DPoP specifications. You may subclass or otherwise customize this class to implement custom behavior, like adding or modifying claims to the proofs.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>Any</code> <p>the private key to use for DPoP proof signatures.</p> required <code>alg</code> <code>str | None</code> <p>the alg to use for signatures, if not specified of the <code>private_key</code>.</p> <code>None</code> <code>jti_generator</code> <code>Callable[[], str]</code> <p>a callable that generates unique JWT Token ID (jti) values to include in proofs.</p> <code>lambda: str(uuid4())</code> <code>iat_generator</code> <code>Callable[[], int]</code> <p>a callable that generates the Issuer Date (iat) to include in proofs.</p> <code>lambda: timestamp()</code> <code>jwt_typ</code> <code>str</code> <p>the token type (<code>typ</code>) header to include in the generated proofs.</p> <code>'dpop+jwt'</code> <code>dpop_token_class</code> <code>type[DPoPToken]</code> <p>the class to use to represent DPoP tokens.</p> <code>DPoPToken</code> <code>rs_nonce</code> <code>str | None</code> <p>an initial DPoP <code>nonce</code> to include in requests, for testing purposes. You should leave <code>None</code>.</p> <code>None</code> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>@define(init=False)\nclass DPoPKey:\n    \"\"\"Wrapper around a DPoP proof signature key.\n\n    This handles DPoP proof generation. It also keeps track of a nonce, if provided\n    by the Resource Server.\n    Its behavior follows the standard DPoP specifications.\n    You may subclass or otherwise customize this class to implement custom behavior,\n    like adding or modifying claims to the proofs.\n\n    Args:\n        private_key: the private key to use for DPoP proof signatures.\n        alg: the alg to use for signatures, if not specified of the `private_key`.\n        jti_generator: a callable that generates unique JWT Token ID (jti) values to include in proofs.\n        iat_generator: a callable that generates the Issuer Date (iat) to include in proofs.\n        jwt_typ: the token type (`typ`) header to include in the generated proofs.\n        dpop_token_class: the class to use to represent DPoP tokens.\n        rs_nonce: an initial DPoP `nonce` to include in requests, for testing purposes. You should leave `None`.\n\n    \"\"\"\n\n    alg: str = field(on_setattr=setters.frozen)\n    private_key: jwskate.Jwk = field(on_setattr=setters.frozen, repr=False)\n    jti_generator: Callable[[], str] = field(on_setattr=setters.frozen, repr=False)\n    iat_generator: Callable[[], int] = field(on_setattr=setters.frozen, repr=False)\n    jwt_typ: str = field(on_setattr=setters.frozen, repr=False)\n    dpop_token_class: type[DPoPToken] = field(on_setattr=setters.frozen, repr=False)\n    as_nonce: str | None\n    rs_nonce: str | None\n\n    def __init__(\n        self,\n        private_key: Any,\n        alg: str | None = None,\n        jti_generator: Callable[[], str] = lambda: str(uuid4()),\n        iat_generator: Callable[[], int] = lambda: jwskate.Jwt.timestamp(),\n        jwt_typ: str = \"dpop+jwt\",\n        dpop_token_class: type[DPoPToken] = DPoPToken,\n        as_nonce: str | None = None,\n        rs_nonce: str | None = None,\n    ) -&gt; None:\n        try:\n            private_key = jwskate.to_jwk(private_key).check(is_private=True, is_symmetric=False)\n        except ValueError as exc:\n            raise InvalidDPoPKey(private_key) from exc\n\n        alg_name = jwskate.select_alg_class(private_key.SIGNATURE_ALGORITHMS, jwk_alg=private_key.alg, alg=alg).name\n\n        self.__attrs_init__(\n            alg=alg_name,\n            private_key=private_key,\n            jti_generator=jti_generator,\n            iat_generator=iat_generator,\n            jwt_typ=jwt_typ,\n            dpop_token_class=dpop_token_class,\n            as_nonce=as_nonce,\n            rs_nonce=rs_nonce,\n        )\n\n    @classmethod\n    def generate(\n        cls,\n        alg: str = jwskate.SignatureAlgs.ES256,\n        jwt_typ: str = \"dpop+jwt\",\n        jti_generator: Callable[[], str] = lambda: str(uuid4()),\n        iat_generator: Callable[[], int] = lambda: jwskate.Jwt.timestamp(),\n        dpop_token_class: type[DPoPToken] = DPoPToken,\n        as_nonce: str | None = None,\n        rs_nonce: str | None = None,\n    ) -&gt; Self:\n        \"\"\"Generate a new DPoPKey with a new private key that is suitable for the given `alg`.\"\"\"\n        if alg not in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n            raise InvalidDPoPAlg(alg)\n        key = jwskate.Jwk.generate(alg=alg)\n        return cls(\n            private_key=key,\n            jti_generator=jti_generator,\n            iat_generator=iat_generator,\n            jwt_typ=jwt_typ,\n            dpop_token_class=dpop_token_class,\n            as_nonce=as_nonce,\n            rs_nonce=rs_nonce,\n        )\n\n    @cached_property\n    def public_jwk(self) -&gt; jwskate.Jwk:\n        \"\"\"The public JWK key that matches the private key.\"\"\"\n        return self.private_key.public_jwk()\n\n    @cached_property\n    def dpop_jkt(self) -&gt; str:\n        \"\"\"The key thumbprint, used for Authorization Code DPoP binding.\"\"\"\n        return self.private_key.thumbprint()\n\n    def proof(self, htm: str, htu: str, ath: str | None = None, nonce: str | None = None) -&gt; jwskate.SignedJwt:\n        \"\"\"Generate a DPoP proof.\n\n        Proof will contain the following claims:\n\n            - The HTTP method (`htm`), target URI (`htu`), and Access Token hash (`ath`) that are passed as parameters.\n            - The `iat` claim will be generated by the configured `iat_generator`, which defaults to current datetime.\n            - The `jti` claim will be generated by the configured `jti_generator`, which defaults to a random UUID4.\n            - The `nonce` claim will be the value stored in the `nonce` attribute. This attribute is updated\n              automatically when using a `DPoPToken` or one of the provided Authentication handlers as a `requests`\n              auth handler.\n\n        The proof will be signed with the private key of this DPoPKey, using the configured `alg` signature algorithm.\n\n        Args:\n            htm: The HTTP method value of the request to which the proof is attached.\n            htu: The HTTP target URI of the request to which the proof is attached. Query and Fragment parts will\n                be automatically removed before being used as `htu` value in the generated proof.\n            ath: The Access Token hash value.\n            nonce: A recent nonce provided via the DPoP-Nonce HTTP header, from either the AS or RS.  If `None`, the\n                value stored in `rs_nonce` will be used instead.\n                In typical cases, you should never have to use this parameter. It is only used internally when\n                requesting the AS token endpoint.\n\n        Returns:\n            the proof value (as a signed JWT)\n\n        \"\"\"\n        htu = furl(htu).remove(query=True, fragment=True).url\n        proof_claims = {\"jti\": self.jti_generator(), \"htm\": htm, \"htu\": htu, \"iat\": self.iat_generator()}\n        if nonce:\n            proof_claims[\"nonce\"] = nonce\n        elif self.rs_nonce:\n            proof_claims[\"nonce\"] = self.rs_nonce\n        if ath:\n            proof_claims[\"ath\"] = ath\n        return jwskate.SignedJwt.sign(\n            proof_claims,\n            key=self.private_key,\n            alg=self.alg,\n            typ=self.jwt_typ,\n            extra_headers={\"jwk\": self.public_jwk},\n        )\n\n    def handle_as_provided_dpop_nonce(self, response: requests.Response) -&gt; None:\n        \"\"\"Handle an Authorization Server response containing a `use_dpop_nonce` error.\n\n        Args:\n            response: the response from the AS.\n\n        \"\"\"\n        nonce = response.headers.get(\"DPoP-Nonce\")\n        if not nonce:\n            raise MissingDPoPNonce(response)\n        if self.as_nonce == nonce:\n            raise RepeatedDPoPNonce(response)\n        self.as_nonce = nonce\n\n    def handle_rs_provided_dpop_nonce(self, response: requests.Response) -&gt; None:\n        \"\"\"Handle a Resource Server response containing a `use_dpop_nonce` error.\n\n        Args:\n            response: the response from the AS.\n\n        \"\"\"\n        nonce = response.headers.get(\"DPoP-Nonce\")\n        if not nonce:\n            raise MissingDPoPNonce(response)\n        if self.rs_nonce == nonce:\n            raise RepeatedDPoPNonce(response)\n        self.rs_nonce = nonce\n</code></pre>"},{"location":"api/#requests_oauth2client.DPoPKey.public_jwk","title":"<code>public_jwk</code>  <code>cached</code> <code>property</code>","text":"<p>The public JWK key that matches the private key.</p>"},{"location":"api/#requests_oauth2client.DPoPKey.dpop_jkt","title":"<code>dpop_jkt</code>  <code>cached</code> <code>property</code>","text":"<p>The key thumbprint, used for Authorization Code DPoP binding.</p>"},{"location":"api/#requests_oauth2client.DPoPKey.generate","title":"<code>generate(alg=jwskate.SignatureAlgs.ES256, jwt_typ='dpop+jwt', jti_generator=lambda: str(uuid4()), iat_generator=lambda: jwskate.Jwt.timestamp(), dpop_token_class=DPoPToken, as_nonce=None, rs_nonce=None)</code>  <code>classmethod</code>","text":"<p>Generate a new DPoPKey with a new private key that is suitable for the given <code>alg</code>.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>@classmethod\ndef generate(\n    cls,\n    alg: str = jwskate.SignatureAlgs.ES256,\n    jwt_typ: str = \"dpop+jwt\",\n    jti_generator: Callable[[], str] = lambda: str(uuid4()),\n    iat_generator: Callable[[], int] = lambda: jwskate.Jwt.timestamp(),\n    dpop_token_class: type[DPoPToken] = DPoPToken,\n    as_nonce: str | None = None,\n    rs_nonce: str | None = None,\n) -&gt; Self:\n    \"\"\"Generate a new DPoPKey with a new private key that is suitable for the given `alg`.\"\"\"\n    if alg not in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n        raise InvalidDPoPAlg(alg)\n    key = jwskate.Jwk.generate(alg=alg)\n    return cls(\n        private_key=key,\n        jti_generator=jti_generator,\n        iat_generator=iat_generator,\n        jwt_typ=jwt_typ,\n        dpop_token_class=dpop_token_class,\n        as_nonce=as_nonce,\n        rs_nonce=rs_nonce,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.DPoPKey.proof","title":"<code>proof(htm, htu, ath=None, nonce=None)</code>","text":"<p>Generate a DPoP proof.</p> <p>Proof will contain the following claims:</p> <pre><code>- The HTTP method (`htm`), target URI (`htu`), and Access Token hash (`ath`) that are passed as parameters.\n- The `iat` claim will be generated by the configured `iat_generator`, which defaults to current datetime.\n- The `jti` claim will be generated by the configured `jti_generator`, which defaults to a random UUID4.\n- The `nonce` claim will be the value stored in the `nonce` attribute. This attribute is updated\n  automatically when using a `DPoPToken` or one of the provided Authentication handlers as a `requests`\n  auth handler.\n</code></pre> <p>The proof will be signed with the private key of this DPoPKey, using the configured <code>alg</code> signature algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>htm</code> <code>str</code> <p>The HTTP method value of the request to which the proof is attached.</p> required <code>htu</code> <code>str</code> <p>The HTTP target URI of the request to which the proof is attached. Query and Fragment parts will be automatically removed before being used as <code>htu</code> value in the generated proof.</p> required <code>ath</code> <code>str | None</code> <p>The Access Token hash value.</p> <code>None</code> <code>nonce</code> <code>str | None</code> <p>A recent nonce provided via the DPoP-Nonce HTTP header, from either the AS or RS.  If <code>None</code>, the value stored in <code>rs_nonce</code> will be used instead. In typical cases, you should never have to use this parameter. It is only used internally when requesting the AS token endpoint.</p> <code>None</code> <p>Returns:</p> Type Description <code>SignedJwt</code> <p>the proof value (as a signed JWT)</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>def proof(self, htm: str, htu: str, ath: str | None = None, nonce: str | None = None) -&gt; jwskate.SignedJwt:\n    \"\"\"Generate a DPoP proof.\n\n    Proof will contain the following claims:\n\n        - The HTTP method (`htm`), target URI (`htu`), and Access Token hash (`ath`) that are passed as parameters.\n        - The `iat` claim will be generated by the configured `iat_generator`, which defaults to current datetime.\n        - The `jti` claim will be generated by the configured `jti_generator`, which defaults to a random UUID4.\n        - The `nonce` claim will be the value stored in the `nonce` attribute. This attribute is updated\n          automatically when using a `DPoPToken` or one of the provided Authentication handlers as a `requests`\n          auth handler.\n\n    The proof will be signed with the private key of this DPoPKey, using the configured `alg` signature algorithm.\n\n    Args:\n        htm: The HTTP method value of the request to which the proof is attached.\n        htu: The HTTP target URI of the request to which the proof is attached. Query and Fragment parts will\n            be automatically removed before being used as `htu` value in the generated proof.\n        ath: The Access Token hash value.\n        nonce: A recent nonce provided via the DPoP-Nonce HTTP header, from either the AS or RS.  If `None`, the\n            value stored in `rs_nonce` will be used instead.\n            In typical cases, you should never have to use this parameter. It is only used internally when\n            requesting the AS token endpoint.\n\n    Returns:\n        the proof value (as a signed JWT)\n\n    \"\"\"\n    htu = furl(htu).remove(query=True, fragment=True).url\n    proof_claims = {\"jti\": self.jti_generator(), \"htm\": htm, \"htu\": htu, \"iat\": self.iat_generator()}\n    if nonce:\n        proof_claims[\"nonce\"] = nonce\n    elif self.rs_nonce:\n        proof_claims[\"nonce\"] = self.rs_nonce\n    if ath:\n        proof_claims[\"ath\"] = ath\n    return jwskate.SignedJwt.sign(\n        proof_claims,\n        key=self.private_key,\n        alg=self.alg,\n        typ=self.jwt_typ,\n        extra_headers={\"jwk\": self.public_jwk},\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.DPoPKey.handle_as_provided_dpop_nonce","title":"<code>handle_as_provided_dpop_nonce(response)</code>","text":"<p>Handle an Authorization Server response containing a <code>use_dpop_nonce</code> error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response from the AS.</p> required Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>def handle_as_provided_dpop_nonce(self, response: requests.Response) -&gt; None:\n    \"\"\"Handle an Authorization Server response containing a `use_dpop_nonce` error.\n\n    Args:\n        response: the response from the AS.\n\n    \"\"\"\n    nonce = response.headers.get(\"DPoP-Nonce\")\n    if not nonce:\n        raise MissingDPoPNonce(response)\n    if self.as_nonce == nonce:\n        raise RepeatedDPoPNonce(response)\n    self.as_nonce = nonce\n</code></pre>"},{"location":"api/#requests_oauth2client.DPoPKey.handle_rs_provided_dpop_nonce","title":"<code>handle_rs_provided_dpop_nonce(response)</code>","text":"<p>Handle a Resource Server response containing a <code>use_dpop_nonce</code> error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response from the AS.</p> required Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>def handle_rs_provided_dpop_nonce(self, response: requests.Response) -&gt; None:\n    \"\"\"Handle a Resource Server response containing a `use_dpop_nonce` error.\n\n    Args:\n        response: the response from the AS.\n\n    \"\"\"\n    nonce = response.headers.get(\"DPoP-Nonce\")\n    if not nonce:\n        raise MissingDPoPNonce(response)\n    if self.rs_nonce == nonce:\n        raise RepeatedDPoPNonce(response)\n    self.rs_nonce = nonce\n</code></pre>"},{"location":"api/#requests_oauth2client.DPoPToken","title":"<code>DPoPToken</code>","text":"<p>               Bases: <code>BearerToken</code></p> <p>Represent a DPoP token (RFC9449).</p> <p>A DPoP is very much like a BearerToken, with an additional private key bound to it.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>@frozen(init=False)\nclass DPoPToken(BearerToken):  # type: ignore[override]\n    \"\"\"Represent a DPoP token (RFC9449).\n\n    A DPoP is very much like a BearerToken, with an additional private key bound to it.\n\n    \"\"\"\n\n    TOKEN_TYPE = AccessTokenTypes.DPOP.value\n    AUTHORIZATION_SCHEME = AccessTokenTypes.DPOP.value\n    DPOP_HEADER: ClassVar[str] = \"DPoP\"\n\n    dpop_key: DPoPKey = field(kw_only=True)\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        access_token: str,\n        *,\n        _dpop_key: DPoPKey,\n        expires_at: datetime | None = None,\n        scope: str | None = None,\n        refresh_token: str | None = None,\n        token_type: str = TOKEN_TYPE,\n        id_token: str | bytes | IdToken | jwskate.JweCompact | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        if not token68_pattern.match(access_token):\n            raise InvalidDPoPAccessToken(access_token)\n\n        id_token = id_token_converter(id_token)\n\n        self.__attrs_init__(\n            access_token=access_token,\n            expires_at=expires_at,\n            scope=scope,\n            refresh_token=refresh_token,\n            token_type=token_type,\n            id_token=id_token,\n            dpop_key=_dpop_key,\n            kwargs=kwargs,\n        )\n\n    def _response_hook(self, response: requests.Response, **kwargs: Any) -&gt; requests.Response:\n        \"\"\"Handles a Resource Server provided DPoP nonce.\"\"\"\n        if response.status_code == codes.unauthorized and response.headers.get(\"WWW-Authenticate\", \"\").startswith(\n            \"DPoP\"\n        ):\n            self.dpop_key.handle_rs_provided_dpop_nonce(response)\n            new_request = response.request.copy()\n            # remove the previously registered hook to avoid registering it multiple times\n            new_request.deregister_hook(\"response\", self._response_hook)  # type: ignore[no-untyped-call]\n            new_request = self(new_request)  # another hook will be re-registered here in the __call__() method\n\n            return response.connection.send(new_request, **kwargs)\n\n        return response\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add a DPoP proof in each request.\"\"\"\n        request = super().__call__(request)\n        add_dpop_proof(request, dpop_key=self.dpop_key, access_token=self.access_token, header_name=self.DPOP_HEADER)\n        request.register_hook(\"response\", self._response_hook)  # type: ignore[no-untyped-call]\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidDPoPAccessToken","title":"<code>InvalidDPoPAccessToken</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an access token contains invalid characters.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>class InvalidDPoPAccessToken(ValueError):\n    \"\"\"Raised when an access token contains invalid characters.\"\"\"\n\n    def __init__(self, access_token: str) -&gt; None:\n        super().__init__(\"\"\"\\\nThis DPoP token contains invalid characters. DPoP tokens are limited to a set of 68 characters,\nto avoid encoding inconsistencies when doing the token value hashing for the DPoP proof.\"\"\")\n        self.access_token = access_token\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidDPoPAlg","title":"<code>InvalidDPoPAlg</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an invalid or unsupported DPoP alg is given.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>class InvalidDPoPAlg(ValueError):\n    \"\"\"Raised when an invalid or unsupported DPoP alg is given.\"\"\"\n\n    def __init__(self, alg: str) -&gt; None:\n        super().__init__(\"DPoP proofing require an asymmetric signing alg.\")\n        self.alg = alg\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidDPoPKey","title":"<code>InvalidDPoPKey</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a DPoPToken is initialized with a non-suitable key.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>class InvalidDPoPKey(ValueError):\n    \"\"\"Raised when a DPoPToken is initialized with a non-suitable key.\"\"\"\n\n    def __init__(self, key: Any) -&gt; None:\n        super().__init__(\"The key you are trying to use with DPoP is not an asymmetric private key.\")\n        self.key = key\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidDPoPProof","title":"<code>InvalidDPoPProof</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a DPoP proof does not verify.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>class InvalidDPoPProof(ValueError):\n    \"\"\"Raised when a DPoP proof does not verify.\"\"\"\n\n    def __init__(self, proof: bytes, message: str) -&gt; None:\n        super().__init__(f\"Invalid DPoP proof: {message}\")\n        self.proof = proof\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidUseDPoPNonceResponse","title":"<code>InvalidUseDPoPNonceResponse</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for invalid Responses with a <code>use_dpop_nonce</code> error.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>class InvalidUseDPoPNonceResponse(Exception):\n    \"\"\"Base class for invalid Responses with a `use_dpop_nonce` error.\"\"\"\n\n    def __init__(self, response: requests.Response, message: str) -&gt; None:\n        super().__init__(message)\n        self.response = response\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingDPoPNonce","title":"<code>MissingDPoPNonce</code>","text":"<p>               Bases: <code>InvalidUseDPoPNonceResponse</code></p> <p>Raised when a server requests a DPoP nonce but none is provided in its response.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>class MissingDPoPNonce(InvalidUseDPoPNonceResponse):\n    \"\"\"Raised when a server requests a DPoP nonce but none is provided in its response.\"\"\"\n\n    def __init__(self, response: requests.Response) -&gt; None:\n        super().__init__(\n            response,\n            \"Server requested client to use a DPoP `nonce`, but the `DPoP-Nonce` HTTP header is missing.\",\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.RepeatedDPoPNonce","title":"<code>RepeatedDPoPNonce</code>","text":"<p>               Bases: <code>InvalidUseDPoPNonceResponse</code></p> <p>Raised when the server requests a DPoP nonce value that is the same as already included in the request.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>class RepeatedDPoPNonce(InvalidUseDPoPNonceResponse):\n    \"\"\"Raised when the server requests a DPoP nonce value that is the same as already included in the request.\"\"\"\n\n    def __init__(self, response: requests.Response) -&gt; None:\n        super().__init__(\n            response,\n            \"\"\"\\\nServer requested client to use a DPoP `nonce`,\nbut provided the same value for that nonce that was already included in the DPoP proof.\"\"\",\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.AccessDenied","title":"<code>AccessDenied</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when the Authorization Server returns <code>error = access_denied</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AccessDenied(EndpointError):\n    \"\"\"Raised when the Authorization Server returns `error = access_denied`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.AccountSelectionRequired","title":"<code>AccountSelectionRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = account_selection_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AccountSelectionRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = account_selection_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationPending","title":"<code>AuthorizationPending</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = authorization_pending</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AuthorizationPending(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = authorization_pending`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationResponseError","title":"<code>AuthorizationResponseError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for error responses returned by the Authorization endpoint.</p> <p>An <code>AuthorizationResponseError</code> contains the error message, description and uri that are returned by the AS.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>str</code> <p>the <code>error</code> identifier as returned by the AS</p> required <code>description</code> <code>str | None</code> <p>the <code>error_description</code> as returned by the AS</p> <code>None</code> <code>uri</code> <code>str | None</code> <p>the <code>error_uri</code> as returned by the AS</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AuthorizationResponseError(Exception):\n    \"\"\"Base class for error responses returned by the Authorization endpoint.\n\n    An `AuthorizationResponseError` contains the error message, description and uri that are\n    returned by the AS.\n\n    Args:\n        error: the `error` identifier as returned by the AS\n        description: the `error_description` as returned by the AS\n        uri: the `error_uri` as returned by the AS\n\n    \"\"\"\n\n    def __init__(\n        self,\n        request: AuthorizationRequest,\n        response: str,\n        error: str,\n        description: str | None = None,\n        uri: str | None = None,\n    ) -&gt; None:\n        self.error = error\n        self.description = description\n        self.uri = uri\n        self.request = request\n        self.response = response\n</code></pre>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationError","title":"<code>BackChannelAuthenticationError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for errors returned by the BackChannel Authentication endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class BackChannelAuthenticationError(EndpointError):\n    \"\"\"Base class for errors returned by the BackChannel Authentication endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.ConsentRequired","title":"<code>ConsentRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = consent_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ConsentRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = consent_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.DeviceAuthorizationError","title":"<code>DeviceAuthorizationError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for Device Authorization Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class DeviceAuthorizationError(EndpointError):\n    \"\"\"Base class for Device Authorization Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.EndpointError","title":"<code>EndpointError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Base class for exceptions raised from backend endpoint errors.</p> <p>This contains the error message, description and uri that are returned by the AS in the OAuth 2.0 standardised way.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the raw response containing the error.</p> required <code>error</code> <code>str</code> <p>the <code>error</code> identifier as returned by the AS.</p> required <code>description</code> <code>str | None</code> <p>the <code>error_description</code> as returned by the AS.</p> <code>None</code> <code>uri</code> <code>str | None</code> <p>the <code>error_uri</code> as returned by the AS.</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class EndpointError(OAuth2Error):\n    \"\"\"Base class for exceptions raised from backend endpoint errors.\n\n    This contains the error message, description and uri that are returned\n    by the AS in the OAuth 2.0 standardised way.\n\n    Args:\n        response: the raw response containing the error.\n        error: the `error` identifier as returned by the AS.\n        description: the `error_description` as returned by the AS.\n        uri: the `error_uri` as returned by the AS.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        response: requests.Response,\n        client: OAuth2Client,\n        error: str,\n        description: str | None = None,\n        uri: str | None = None,\n    ) -&gt; None:\n        super().__init__(response=response, client=client, description=description)\n        self.error = error\n        self.uri = uri\n</code></pre>"},{"location":"api/#requests_oauth2client.ExpiredToken","title":"<code>ExpiredToken</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = expired_token</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ExpiredToken(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = expired_token`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InteractionRequired","title":"<code>InteractionRequired</code>","text":"<p>               Bases: <code>AuthorizationResponseError</code></p> <p>Raised when the Authorization Endpoint returns <code>error = interaction_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InteractionRequired(AuthorizationResponseError):\n    \"\"\"Raised when the Authorization Endpoint returns `error = interaction_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.IntrospectionError","title":"<code>IntrospectionError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for Introspection Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class IntrospectionError(EndpointError):\n    \"\"\"Base class for Introspection Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidAuthResponse","title":"<code>InvalidAuthResponse</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when the Authorization Endpoint returns an invalid response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidAuthResponse(ValueError):\n    \"\"\"Raised when the Authorization Endpoint returns an invalid response.\"\"\"\n\n    def __init__(self, message: str, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(f\"The Authorization Response is invalid: {message}\")\n        self.request = request\n        self.response = response\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidBackChannelAuthenticationResponse","title":"<code>InvalidBackChannelAuthenticationResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the BackChannel Authentication endpoint returns a non-standard response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidBackChannelAuthenticationResponse(OAuth2Error):\n    \"\"\"Raised when the BackChannel Authentication endpoint returns a non-standard response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidClient","title":"<code>InvalidClient</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_client</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidClient(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_client`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidDeviceAuthorizationResponse","title":"<code>InvalidDeviceAuthorizationResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Device Authorization Endpoint returns a non-standard error response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidDeviceAuthorizationResponse(OAuth2Error):\n    \"\"\"Raised when the Device Authorization Endpoint returns a non-standard error response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidGrant","title":"<code>InvalidGrant</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_grant</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidGrant(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_grant`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidPushedAuthorizationResponse","title":"<code>InvalidPushedAuthorizationResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Pushed Authorization Endpoint returns an error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidPushedAuthorizationResponse(OAuth2Error):\n    \"\"\"Raised when the Pushed Authorization Endpoint returns an error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidRequest","title":"<code>InvalidRequest</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_request</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidRequest(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_request`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidScope","title":"<code>InvalidScope</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_scope</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidScope(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_scope`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidTarget","title":"<code>InvalidTarget</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_target</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidTarget(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_target`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidTokenResponse","title":"<code>InvalidTokenResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Token Endpoint returns a non-standard response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidTokenResponse(OAuth2Error):\n    \"\"\"Raised when the Token Endpoint returns a non-standard response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.LoginRequired","title":"<code>LoginRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = login_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class LoginRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = login_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIssuer","title":"<code>MismatchingIssuer</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised on mismatching <code>iss</code> value.</p> <p>This happens when the Authorization Endpoints returns an 'iss' that doesn't match the expected value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingIssuer(InvalidAuthResponse):\n    \"\"\"Raised on mismatching `iss` value.\n\n    This happens when the Authorization Endpoints returns an 'iss' that doesn't match the expected value.\n\n    \"\"\"\n\n    def __init__(self, received: str, expected: str, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(f\"mismatching `iss` (received '{received}', expected '{expected}')\", request, response)\n        self.received = received\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingState","title":"<code>MismatchingState</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised on mismatching <code>state</code> value.</p> <p>This happens when the Authorization Endpoints returns a 'state' parameter that doesn't match the value passed in the Authorization Request.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingState(InvalidAuthResponse):\n    \"\"\"Raised on mismatching `state` value.\n\n    This happens when the Authorization Endpoints returns a 'state' parameter that doesn't match the value passed in the\n    Authorization Request.\n\n    \"\"\"\n\n    def __init__(self, received: str, expected: str, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(f\"mismatching `state` (received '{received}', expected '{expected}')\", request, response)\n        self.received = received\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingAuthCode","title":"<code>MissingAuthCode</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return the mandatory <code>code</code>.</p> <p>This happens when the Authorization Endpoint does not return an error, but does not return an authorization <code>code</code> either.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingAuthCode(InvalidAuthResponse):\n    \"\"\"Raised when the Authorization Endpoint does not return the mandatory `code`.\n\n    This happens when the Authorization Endpoint does not return an error, but does not return an\n    authorization `code` either.\n\n    \"\"\"\n\n    def __init__(self, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(\"missing `code` query parameter in response\", request, response)\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingIssuer","title":"<code>MissingIssuer</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return an <code>iss</code> parameter as expected.</p> <p>The Authorization Server advertises its support with a flag <code>authorization_response_iss_parameter_supported</code> in its discovery document. If it is set to <code>true</code>, it must include an <code>iss</code> parameter in its authorization responses, containing its issuer identifier.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingIssuer(InvalidAuthResponse):\n    \"\"\"Raised when the Authorization Endpoint does not return an `iss` parameter as expected.\n\n    The Authorization Server advertises its support with a flag\n    `authorization_response_iss_parameter_supported` in its discovery document. If it is set to\n    `true`, it must include an `iss` parameter in its authorization responses, containing its issuer\n    identifier.\n\n    \"\"\"\n\n    def __init__(self, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(\"missing `iss` query parameter in response\", request, response)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Error","title":"<code>OAuth2Error</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for Exceptions raised when a backend endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the HTTP response containing the error</p> required <code>client</code> <p>the OAuth2Client used to send the request</p> required <code>description</code> <code>str | None</code> <p>description of the error</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class OAuth2Error(Exception):\n    \"\"\"Base class for Exceptions raised when a backend endpoint returns an error.\n\n    Args:\n        response: the HTTP response containing the error\n        client : the OAuth2Client used to send the request\n        description: description of the error\n\n    \"\"\"\n\n    def __init__(self, response: requests.Response, client: OAuth2Client, description: str | None = None) -&gt; None:\n        super().__init__(f\"The remote endpoint returned an error: {description or 'no description provided'}\")\n        self.response = response\n        self.client = client\n        self.description = description\n\n    @property\n    def request(self) -&gt; requests.PreparedRequest:\n        \"\"\"The request leading to the error.\"\"\"\n        return self.response.request\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Error.request","title":"<code>request</code>  <code>property</code>","text":"<p>The request leading to the error.</p>"},{"location":"api/#requests_oauth2client.RevocationError","title":"<code>RevocationError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for Revocation Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class RevocationError(EndpointError):\n    \"\"\"Base class for Revocation Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.ServerError","title":"<code>ServerError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when the token endpoint returns <code>error = server_error</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ServerError(EndpointError):\n    \"\"\"Raised when the token endpoint returns `error = server_error`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.SessionSelectionRequired","title":"<code>SessionSelectionRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = session_selection_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class SessionSelectionRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = session_selection_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.SlowDown","title":"<code>SlowDown</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = slow_down</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class SlowDown(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = slow_down`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.TokenEndpointError","title":"<code>TokenEndpointError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for errors that are specific to the token endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class TokenEndpointError(EndpointError):\n    \"\"\"Base class for errors that are specific to the token endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnauthorizedClient","title":"<code>UnauthorizedClient</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when the Authorization Server returns <code>error = unauthorized_client</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnauthorizedClient(EndpointError):\n    \"\"\"Raised when the Authorization Server returns `error = unauthorized_client`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnknownIntrospectionError","title":"<code>UnknownIntrospectionError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Introspection Endpoint returns a non-standard error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnknownIntrospectionError(OAuth2Error):\n    \"\"\"Raised when the Introspection Endpoint returns a non-standard error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnknownTokenEndpointError","title":"<code>UnknownTokenEndpointError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when the token endpoint returns an otherwise unknown error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnknownTokenEndpointError(EndpointError):\n    \"\"\"Raised when the token endpoint returns an otherwise unknown error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnsupportedTokenType","title":"<code>UnsupportedTokenType</code>","text":"<p>               Bases: <code>RevocationError</code></p> <p>Raised when the Revocation endpoint returns <code>error = unsupported_token_type</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnsupportedTokenType(RevocationError):\n    \"\"\"Raised when the Revocation endpoint returns `error = unsupported_token_type`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UseDPoPNonce","title":"<code>UseDPoPNonce</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint raises error = use_dpop_nonce`.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UseDPoPNonce(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint raises error = use_dpop_nonce`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseTokenEndpointPoolingJob","title":"<code>BaseTokenEndpointPoolingJob</code>","text":"<p>Base class for Token Endpoint pooling jobs.</p> <p>This is used for decoupled flows like CIBA or Device Authorization.</p> <p>This class must be subclassed to implement actual BackChannel flows. This needs an OAuth2Client that will be used to pool the token endpoint. The initial pooling <code>interval</code> is configurable.</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>@define\nclass BaseTokenEndpointPoolingJob:\n    \"\"\"Base class for Token Endpoint pooling jobs.\n\n    This is used for decoupled flows like CIBA or Device Authorization.\n\n    This class must be subclassed to implement actual BackChannel flows. This needs an\n    [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token\n    endpoint. The initial pooling `interval` is configurable.\n\n    \"\"\"\n\n    client: OAuth2Client = field(on_setattr=setters.frozen)\n    requests_kwargs: dict[str, Any] = field(on_setattr=setters.frozen)\n    token_kwargs: dict[str, Any] = field(on_setattr=setters.frozen)\n    slow_down_interval: int = field(on_setattr=setters.frozen)\n    interval: int\n\n    def __call__(self) -&gt; BearerToken | None:\n        \"\"\"Wrap the actual Token Endpoint call with a pooling interval.\n\n        Everytime this method is called, it will wait for the entire duration of the pooling\n        interval before calling\n        [token_request()][requests_oauth2client.pooling.TokenEndpointPoolingJob.token_request]. So\n        you can call it immediately after initiating the BackChannel flow, and it will wait before\n        initiating the first call.\n\n        This implements the logic to handle\n        [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] or\n        [SlowDown][requests_oauth2client.exceptions.SlowDown] requests by the AS.\n\n        Returns:\n            a `BearerToken` if the AS returns one, or `None` if the Authorization is still pending.\n\n        \"\"\"\n        self.sleep()\n        try:\n            return self.token_request()\n        except SlowDown:\n            self.slow_down()\n        except AuthorizationPending:\n            self.authorization_pending()\n        return None\n\n    def sleep(self) -&gt; None:\n        \"\"\"Implement the wait between two requests of the token endpoint.\n\n        By default, relies on time.sleep().\n\n        \"\"\"\n        time.sleep(self.interval)\n\n    def slow_down(self) -&gt; None:\n        \"\"\"Implement the behavior when receiving a 'slow_down' response from the AS.\n\n        By default, it increases the pooling interval by the slow down interval.\n\n        \"\"\"\n        self.interval += self.slow_down_interval\n\n    def authorization_pending(self) -&gt; None:\n        \"\"\"Implement the behavior when receiving an 'authorization_pending' response from the AS.\n\n        By default, it does nothing.\n\n        \"\"\"\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Abstract method for the token endpoint call.\n\n        Subclasses must implement this. This method must raise\n        [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after\n        the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase\n        the pooling interval by `slow_down_interval` seconds.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseTokenEndpointPoolingJob.sleep","title":"<code>sleep()</code>","text":"<p>Implement the wait between two requests of the token endpoint.</p> <p>By default, relies on time.sleep().</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def sleep(self) -&gt; None:\n    \"\"\"Implement the wait between two requests of the token endpoint.\n\n    By default, relies on time.sleep().\n\n    \"\"\"\n    time.sleep(self.interval)\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseTokenEndpointPoolingJob.slow_down","title":"<code>slow_down()</code>","text":"<p>Implement the behavior when receiving a 'slow_down' response from the AS.</p> <p>By default, it increases the pooling interval by the slow down interval.</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def slow_down(self) -&gt; None:\n    \"\"\"Implement the behavior when receiving a 'slow_down' response from the AS.\n\n    By default, it increases the pooling interval by the slow down interval.\n\n    \"\"\"\n    self.interval += self.slow_down_interval\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseTokenEndpointPoolingJob.authorization_pending","title":"<code>authorization_pending()</code>","text":"<p>Implement the behavior when receiving an 'authorization_pending' response from the AS.</p> <p>By default, it does nothing.</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def authorization_pending(self) -&gt; None:\n    \"\"\"Implement the behavior when receiving an 'authorization_pending' response from the AS.\n\n    By default, it does nothing.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseTokenEndpointPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Abstract method for the token endpoint call.</p> <p>Subclasses must implement this. This method must raise AuthorizationPending to retry after the pooling interval, or SlowDown to increase the pooling interval by <code>slow_down_interval</code> seconds.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Abstract method for the token endpoint call.\n\n    Subclasses must implement this. This method must raise\n    [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after\n    the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase\n    the pooling interval by `slow_down_interval` seconds.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerToken","title":"<code>BearerToken</code>","text":"<p>               Bases: <code>TokenResponse</code>, <code>AuthBase</code></p> <p>Represents a Bearer Token as returned by a Token Endpoint.</p> <p>This is a wrapper around a Bearer Token and associated parameters, such as expiration date and refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint.</p> <p>All parameters are as returned by a Token Endpoint. The token expiration date can be passed as datetime in the <code>expires_at</code> parameter, or an <code>expires_in</code> parameter, as number of seconds in the future, can be passed instead.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>str</code> <p>an <code>access_token</code>, as returned by the AS.</p> required <code>expires_at</code> <code>datetime | None</code> <p>an expiration date. This method also accepts an <code>expires_in</code> hint as returned by the AS, if any.</p> <code>None</code> <code>scope</code> <code>str | None</code> <p>a <code>scope</code>, as returned by the AS, if any.</p> <code>None</code> <code>refresh_token</code> <code>str | None</code> <p>a <code>refresh_token</code>, as returned by the AS, if any.</p> <code>None</code> <code>token_type</code> <code>str</code> <p>a <code>token_type</code>, as returned by the AS.</p> <code>TOKEN_TYPE</code> <code>id_token</code> <code>str | bytes | IdToken | JweCompact | None</code> <p>an <code>id_token</code>, as returned by the AS, if any.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters as returned by the AS, if any.</p> <code>{}</code> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@frozen(init=False)\nclass BearerToken(TokenResponse, requests.auth.AuthBase):\n    \"\"\"Represents a Bearer Token as returned by a Token Endpoint.\n\n    This is a wrapper around a Bearer Token and associated parameters, such as expiration date and\n    refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint.\n\n    All parameters are as returned by a Token Endpoint. The token expiration date can be passed as\n    datetime in the `expires_at` parameter, or an `expires_in` parameter, as number of seconds in\n    the future, can be passed instead.\n\n    Args:\n        access_token: an `access_token`, as returned by the AS.\n        expires_at: an expiration date. This method also accepts an `expires_in` hint as\n            returned by the AS, if any.\n        scope: a `scope`, as returned by the AS, if any.\n        refresh_token: a `refresh_token`, as returned by the AS, if any.\n        token_type: a `token_type`, as returned by the AS.\n        id_token: an `id_token`, as returned by the AS, if any.\n        **kwargs: additional parameters as returned by the AS, if any.\n\n    \"\"\"\n\n    TOKEN_TYPE: ClassVar[str] = AccessTokenTypes.BEARER.value\n    AUTHORIZATION_HEADER: ClassVar[str] = \"Authorization\"\n    AUTHORIZATION_SCHEME: ClassVar[str] = AccessTokenTypes.BEARER.value\n\n    access_token: str\n    expires_at: datetime | None\n    scope: str | None\n    refresh_token: str | None\n    token_type: str\n    id_token: IdToken | jwskate.JweCompact | None\n    kwargs: dict[str, Any]\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        access_token: str,\n        *,\n        expires_at: datetime | None = None,\n        scope: str | None = None,\n        refresh_token: str | None = None,\n        token_type: str = TOKEN_TYPE,\n        id_token: str | bytes | IdToken | jwskate.JweCompact | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        if token_type.title() != self.TOKEN_TYPE.title():\n            raise UnsupportedTokenType(token_type)\n\n        id_token = id_token_converter(id_token)\n\n        self.__attrs_init__(\n            access_token=access_token,\n            expires_at=expires_at,\n            scope=scope,\n            refresh_token=refresh_token,\n            token_type=token_type,\n            id_token=id_token,\n            kwargs=kwargs,\n        )\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Check if the access token is expired.\n\n        Args:\n            leeway: If the token expires in the next given number of seconds,\n                then consider it expired already.\n\n        Returns:\n            One of:\n\n            - `True` if the access token is expired\n            - `False` if it is still valid\n            - `None` if there is no expires_in hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) + timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n\n    def authorization_header(self) -&gt; str:\n        \"\"\"Return the appropriate Authorization Header value for this token.\n\n        The value is formatted correctly according to RFC6750.\n\n        Returns:\n            the value to use in an HTTP Authorization Header\n\n        \"\"\"\n        return f\"{self.AUTHORIZATION_SCHEME} {self.access_token}\"\n\n    def validate_id_token(  # noqa: PLR0915, C901\n        self, client: OAuth2Client, azr: AuthorizationResponse, exp_leeway: int = 0, auth_time_leeway: int = 10\n    ) -&gt; Self:\n        \"\"\"Validate the ID Token, and return a new instance with the decrypted ID Token.\n\n        If the ID Token was not encrypted, the returned instance will contain the same ID Token.\n\n        This will validate the id_token as described in [OIDC 1.0\n        $3.1.3.7](https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation).\n\n        Args:\n            client: the `OAuth2Client` that was used to obtain this token\n            azr: the `AuthorizationResponse`, as obtained by a call to `AuthorizationRequest.validate()`\n            exp_leeway: a leeway, in seconds, applied to the ID Token expiration date\n            auth_time_leeway: a leeway, in seconds, applied to the `auth_time` validation\n\n        Raises:\n            MissingIdToken: if the ID Token is missing\n            InvalidIdToken: this is a base exception class, which is raised:\n\n                - if the ID Token is not a JWT\n                - or is encrypted while a clear-text token is expected\n                - or is clear-text while an encrypted token is expected\n                - if token is encrypted but client does not have a decryption key\n                - if the token does not contain an `alg` header\n            MismatchingIdTokenAlg: if the `alg` header from the ID Token does not match\n                the expected `client.id_token_signed_response_alg`.\n            MismatchingIdTokenIssuer: if the `iss` claim from the ID Token does not match\n                the expected `azr.issuer`.\n            MismatchingIdTokenAcr: if the `acr` claim from the ID Token does not match\n                on of the expected `azr.acr_values`.\n            MismatchingIdTokenAudience: if the `aud` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenAzp: if the `azp` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenNonce: if the `nonce` claim from the ID Token does not match\n                the expected `azr.nonce`.\n            ExpiredIdToken: if the ID Token is expired at the time of the check.\n            UnsupportedIdTokenAlg: if the signature alg for the ID Token is not supported.\n\n        \"\"\"\n        if not self.id_token:\n            raise MissingIdToken(self)\n\n        raw_id_token = self.id_token\n\n        if isinstance(raw_id_token, jwskate.JweCompact) and client.id_token_encrypted_response_alg is None:\n            msg = \"token is encrypted while it should be clear-text\"\n            raise InvalidIdToken(msg, raw_id_token, self)\n        if isinstance(raw_id_token, IdToken) and client.id_token_encrypted_response_alg is not None:\n            msg = \"token is clear-text while it should be encrypted\"\n            raise InvalidIdToken(msg, raw_id_token, self)\n\n        if isinstance(raw_id_token, jwskate.JweCompact):\n            enc_jwk = client.id_token_decryption_key\n            if enc_jwk is None:\n                msg = \"token is encrypted but client does not have a decryption key\"\n                raise InvalidIdToken(msg, raw_id_token, self)\n            nested_id_token = raw_id_token.decrypt(enc_jwk)\n            id_token = IdToken(nested_id_token)\n        else:\n            id_token = raw_id_token\n\n        id_token_alg = id_token.get_header(\"alg\")\n        if id_token_alg is None:\n            id_token_alg = client.id_token_signed_response_alg\n        if id_token_alg is None:\n            msg = \"\"\"\ntoken does not contain an `alg` parameter to specify the signature algorithm,\nand no algorithm has been configured for the client (using param `id_token_signed_response_alg`).\n\"\"\"\n            raise InvalidIdToken(msg, id_token, self)\n        if client.id_token_signed_response_alg is not None and id_token_alg != client.id_token_signed_response_alg:\n            raise MismatchingIdTokenAlg(id_token.alg, client.id_token_signed_response_alg, self, id_token)\n\n        verification_jwk: jwskate.Jwk\n\n        if id_token_alg in jwskate.SignatureAlgs.ALL_SYMMETRIC:\n            if not client.client_secret:\n                msg = \"token is symmetrically signed but this client does not have a Client Secret.\"\n                raise InvalidIdToken(msg, id_token, self)\n            verification_jwk = jwskate.SymmetricJwk.from_bytes(client.client_secret, alg=id_token_alg)\n            id_token.verify_signature(verification_jwk, alg=id_token_alg)\n        elif id_token_alg in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n            if not client.authorization_server_jwks:\n                msg = \"token is asymmetrically signed but the Authorization Server JWKS is not available.\"\n                raise InvalidIdToken(msg, id_token, self)\n\n            if id_token.get_header(\"kid\") is None:\n                msg = \"\"\"\ntoken does not contain a Key ID (kid) to specify the asymmetric key\nto use for signature verification.\"\"\"\n                raise InvalidIdToken(msg, id_token, self)\n            try:\n                verification_jwk = client.authorization_server_jwks.get_jwk_by_kid(id_token.kid)\n            except KeyError:\n                msg = f\"\"\"\\\ntoken is asymmetrically signed but there is no key\nwith kid='{id_token.kid}' in the Authorization Server JWKS.\"\"\"\n                raise InvalidIdToken(msg, id_token, self) from None\n\n            if id_token_alg not in verification_jwk.supported_signing_algorithms():\n                msg = \"token is asymmetrically signed but its algorithm is not supported by the verification key.\"\n                raise InvalidIdToken(msg, id_token, self)\n        else:\n            raise UnsupportedIdTokenAlg(self, id_token, id_token_alg)\n\n        id_token.verify(verification_jwk, alg=id_token_alg)\n\n        if azr.issuer and id_token.issuer != azr.issuer:\n            raise MismatchingIdTokenIssuer(id_token.issuer, azr.issuer, self, id_token)\n\n        if id_token.audiences and client.client_id not in id_token.audiences:\n            raise MismatchingIdTokenAudience(id_token.audiences, client.client_id, self, id_token)\n\n        if id_token.authorized_party is not None and id_token.authorized_party != client.client_id:\n            raise MismatchingIdTokenAzp(id_token.azp, client.client_id, self, id_token)\n\n        if id_token.is_expired(leeway=exp_leeway):\n            raise ExpiredIdToken(self, id_token)\n\n        if azr.nonce and id_token.nonce != azr.nonce:\n            raise MismatchingIdTokenNonce(id_token.nonce, azr.nonce, self, id_token)\n\n        if azr.acr_values and id_token.acr not in azr.acr_values:\n            raise MismatchingIdTokenAcr(id_token.acr, azr.acr_values, self, id_token)\n\n        hash_function = IdToken.hash_method(verification_jwk, id_token_alg)\n\n        at_hash = id_token.get_claim(\"at_hash\")\n        if at_hash is not None:\n            expected_at_hash = hash_function(self.access_token)\n            if expected_at_hash != at_hash:\n                msg = f\"mismatching 'at_hash' value (expected '{expected_at_hash}', got '{at_hash}')\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        c_hash = id_token.get_claim(\"c_hash\")\n        if c_hash is not None:\n            expected_c_hash = hash_function(azr.code)\n            if expected_c_hash != c_hash:\n                msg = f\"mismatching 'c_hash' value (expected '{expected_c_hash}', got '{c_hash}')\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        s_hash = id_token.get_claim(\"s_hash\")\n        if s_hash is not None:\n            if azr.state is None:\n                msg = \"token has a 's_hash' claim but no state was included in the request.\"\n                raise InvalidIdToken(msg, id_token, self)\n            expected_s_hash = hash_function(azr.state)\n            if expected_s_hash != s_hash:\n                msg = f\"mismatching 's_hash' value (expected '{expected_s_hash}', got '{s_hash}')\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        if azr.max_age is not None:\n            auth_time = id_token.auth_datetime\n            if auth_time is None:\n                msg = \"\"\"\na `max_age` parameter was included in the authorization request,\nbut the ID Token does not contain an `auth_time` claim.\n\"\"\"\n                raise InvalidIdToken(msg, id_token, self) from None\n            auth_age = datetime.now(tz=timezone.utc) - auth_time\n            if auth_age.total_seconds() &gt; azr.max_age + auth_time_leeway:\n                msg = f\"\"\"\nuser authentication happened too far in the past.\nThe `auth_time` parameter from the ID Token indicate that\nthe last Authentication Time was at {auth_time} ({auth_age.total_seconds()} sec ago),\nbut the authorization request `max_age` parameter specified that it must\nbe a maximum of {azr.max_age} sec ago.\n\"\"\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        return self.__class__(\n            access_token=self.access_token,\n            expires_at=self.expires_at,\n            scope=self.scope,\n            refresh_token=self.refresh_token,\n            token_type=self.token_type,\n            id_token=id_token,\n            **self.kwargs,\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the access token value, as a string.\n\n        Returns:\n            the access token string\n\n        \"\"\"\n        return self.access_token\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dict of parameters.\n\n        That is suitable for serialization or to init another BearerToken.\n\n        \"\"\"\n        d = asdict(self)\n        d.pop(\"expires_at\")\n        d[\"expires_in\"] = self.expires_in\n        d.update(**d.pop(\"kwargs\", {}))\n        return {key: val for key, val in d.items() if val is not None}\n\n    @property\n    def expires_in(self) -&gt; int | None:\n        \"\"\"Number of seconds until expiration.\"\"\"\n        if self.expires_at:\n            return ceil((self.expires_at - datetime.now(tz=timezone.utc)).total_seconds())\n        return None\n\n    def __getattr__(self, key: str) -&gt; Any:\n        \"\"\"Return custom attributes from this BearerToken.\n\n        Args:\n            key: a key\n\n        Returns:\n            the associated value in this token response\n\n        Raises:\n            AttributeError: if the attribute is not found in this response.\n\n        \"\"\"\n        return self.kwargs.get(key) or super().__getattribute__(key)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the usage of Bearer Tokens in requests.\n\n        This will add a properly formatted `Authorization: Bearer &lt;token&gt;` header in the request.\n\n        If the configured token is an instance of BearerToken with an expires_at attribute, raises\n        [ExpiredAccessToken][requests_oauth2client.exceptions.ExpiredAccessToken] once the access\n        token is expired.\n\n        Args:\n            request: the request\n\n        Returns:\n            the same request with an Access Token added in `Authorization` Header\n\n        Raises:\n            ExpiredAccessToken: if the token is expired\n\n        \"\"\"\n        if self.access_token is None:\n            return request  # pragma: no cover\n        if self.is_expired():\n            raise ExpiredAccessToken(self)\n        request.headers[self.AUTHORIZATION_HEADER] = self.authorization_header()\n        return request\n\n    @cached_property\n    def access_token_jwt(self) -&gt; jwskate.SignedJwt:\n        \"\"\"If the access token is a JWT, return it as an instance of `jwskate.SignedJwt`.\n\n        This method is just a helper for AS testing purposes. Note that, as an OAuth 2.0 Client, you should never have\n        to decode or analyze an access token, since it is simply an abstract string value. It is not even mandatory that\n        Access Tokens are JWTs, just an implementation choice. Only Resource Servers (APIs) should check for the\n        contents of Access Tokens they receive.\n\n        \"\"\"\n        return jwskate.SignedJwt(self.access_token)\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerToken.expires_in","title":"<code>expires_in</code>  <code>property</code>","text":"<p>Number of seconds until expiration.</p>"},{"location":"api/#requests_oauth2client.BearerToken.access_token_jwt","title":"<code>access_token_jwt</code>  <code>cached</code> <code>property</code>","text":"<p>If the access token is a JWT, return it as an instance of <code>jwskate.SignedJwt</code>.</p> <p>This method is just a helper for AS testing purposes. Note that, as an OAuth 2.0 Client, you should never have to decode or analyze an access token, since it is simply an abstract string value. It is not even mandatory that Access Tokens are JWTs, just an implementation choice. Only Resource Servers (APIs) should check for the contents of Access Tokens they receive.</p>"},{"location":"api/#requests_oauth2client.BearerToken.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Check if the access token is expired.</p> <p>Parameters:</p> Name Type Description Default <code>leeway</code> <code>int</code> <p>If the token expires in the next given number of seconds, then consider it expired already.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>One of:</p> <code>bool | None</code> <ul> <li><code>True</code> if the access token is expired</li> </ul> <code>bool | None</code> <ul> <li><code>False</code> if it is still valid</li> </ul> <code>bool | None</code> <ul> <li><code>None</code> if there is no expires_in hint.</li> </ul> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Check if the access token is expired.\n\n    Args:\n        leeway: If the token expires in the next given number of seconds,\n            then consider it expired already.\n\n    Returns:\n        One of:\n\n        - `True` if the access token is expired\n        - `False` if it is still valid\n        - `None` if there is no expires_in hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) + timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerToken.authorization_header","title":"<code>authorization_header()</code>","text":"<p>Return the appropriate Authorization Header value for this token.</p> <p>The value is formatted correctly according to RFC6750.</p> <p>Returns:</p> Type Description <code>str</code> <p>the value to use in an HTTP Authorization Header</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def authorization_header(self) -&gt; str:\n    \"\"\"Return the appropriate Authorization Header value for this token.\n\n    The value is formatted correctly according to RFC6750.\n\n    Returns:\n        the value to use in an HTTP Authorization Header\n\n    \"\"\"\n    return f\"{self.AUTHORIZATION_SCHEME} {self.access_token}\"\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerToken.validate_id_token","title":"<code>validate_id_token(client, azr, exp_leeway=0, auth_time_leeway=10)</code>","text":"<p>Validate the ID Token, and return a new instance with the decrypted ID Token.</p> <p>If the ID Token was not encrypted, the returned instance will contain the same ID Token.</p> <p>This will validate the id_token as described in OIDC 1.0 $3.1.3.7.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the <code>OAuth2Client</code> that was used to obtain this token</p> required <code>azr</code> <code>AuthorizationResponse</code> <p>the <code>AuthorizationResponse</code>, as obtained by a call to <code>AuthorizationRequest.validate()</code></p> required <code>exp_leeway</code> <code>int</code> <p>a leeway, in seconds, applied to the ID Token expiration date</p> <code>0</code> <code>auth_time_leeway</code> <code>int</code> <p>a leeway, in seconds, applied to the <code>auth_time</code> validation</p> <code>10</code> <p>Raises:</p> Type Description <code>MissingIdToken</code> <p>if the ID Token is missing</p> <code>InvalidIdToken</code> <p>this is a base exception class, which is raised:</p> <ul> <li>if the ID Token is not a JWT</li> <li>or is encrypted while a clear-text token is expected</li> <li>or is clear-text while an encrypted token is expected</li> <li>if token is encrypted but client does not have a decryption key</li> <li>if the token does not contain an <code>alg</code> header</li> </ul> <code>MismatchingIdTokenAlg</code> <p>if the <code>alg</code> header from the ID Token does not match the expected <code>client.id_token_signed_response_alg</code>.</p> <code>MismatchingIdTokenIssuer</code> <p>if the <code>iss</code> claim from the ID Token does not match the expected <code>azr.issuer</code>.</p> <code>MismatchingIdTokenAcr</code> <p>if the <code>acr</code> claim from the ID Token does not match on of the expected <code>azr.acr_values</code>.</p> <code>MismatchingIdTokenAudience</code> <p>if the <code>aud</code> claim from the ID Token does not match the expected <code>client.client_id</code>.</p> <code>MismatchingIdTokenAzp</code> <p>if the <code>azp</code> claim from the ID Token does not match the expected <code>client.client_id</code>.</p> <code>MismatchingIdTokenNonce</code> <p>if the <code>nonce</code> claim from the ID Token does not match the expected <code>azr.nonce</code>.</p> <code>ExpiredIdToken</code> <p>if the ID Token is expired at the time of the check.</p> <code>UnsupportedIdTokenAlg</code> <p>if the signature alg for the ID Token is not supported.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>    def validate_id_token(  # noqa: PLR0915, C901\n        self, client: OAuth2Client, azr: AuthorizationResponse, exp_leeway: int = 0, auth_time_leeway: int = 10\n    ) -&gt; Self:\n        \"\"\"Validate the ID Token, and return a new instance with the decrypted ID Token.\n\n        If the ID Token was not encrypted, the returned instance will contain the same ID Token.\n\n        This will validate the id_token as described in [OIDC 1.0\n        $3.1.3.7](https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation).\n\n        Args:\n            client: the `OAuth2Client` that was used to obtain this token\n            azr: the `AuthorizationResponse`, as obtained by a call to `AuthorizationRequest.validate()`\n            exp_leeway: a leeway, in seconds, applied to the ID Token expiration date\n            auth_time_leeway: a leeway, in seconds, applied to the `auth_time` validation\n\n        Raises:\n            MissingIdToken: if the ID Token is missing\n            InvalidIdToken: this is a base exception class, which is raised:\n\n                - if the ID Token is not a JWT\n                - or is encrypted while a clear-text token is expected\n                - or is clear-text while an encrypted token is expected\n                - if token is encrypted but client does not have a decryption key\n                - if the token does not contain an `alg` header\n            MismatchingIdTokenAlg: if the `alg` header from the ID Token does not match\n                the expected `client.id_token_signed_response_alg`.\n            MismatchingIdTokenIssuer: if the `iss` claim from the ID Token does not match\n                the expected `azr.issuer`.\n            MismatchingIdTokenAcr: if the `acr` claim from the ID Token does not match\n                on of the expected `azr.acr_values`.\n            MismatchingIdTokenAudience: if the `aud` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenAzp: if the `azp` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenNonce: if the `nonce` claim from the ID Token does not match\n                the expected `azr.nonce`.\n            ExpiredIdToken: if the ID Token is expired at the time of the check.\n            UnsupportedIdTokenAlg: if the signature alg for the ID Token is not supported.\n\n        \"\"\"\n        if not self.id_token:\n            raise MissingIdToken(self)\n\n        raw_id_token = self.id_token\n\n        if isinstance(raw_id_token, jwskate.JweCompact) and client.id_token_encrypted_response_alg is None:\n            msg = \"token is encrypted while it should be clear-text\"\n            raise InvalidIdToken(msg, raw_id_token, self)\n        if isinstance(raw_id_token, IdToken) and client.id_token_encrypted_response_alg is not None:\n            msg = \"token is clear-text while it should be encrypted\"\n            raise InvalidIdToken(msg, raw_id_token, self)\n\n        if isinstance(raw_id_token, jwskate.JweCompact):\n            enc_jwk = client.id_token_decryption_key\n            if enc_jwk is None:\n                msg = \"token is encrypted but client does not have a decryption key\"\n                raise InvalidIdToken(msg, raw_id_token, self)\n            nested_id_token = raw_id_token.decrypt(enc_jwk)\n            id_token = IdToken(nested_id_token)\n        else:\n            id_token = raw_id_token\n\n        id_token_alg = id_token.get_header(\"alg\")\n        if id_token_alg is None:\n            id_token_alg = client.id_token_signed_response_alg\n        if id_token_alg is None:\n            msg = \"\"\"\ntoken does not contain an `alg` parameter to specify the signature algorithm,\nand no algorithm has been configured for the client (using param `id_token_signed_response_alg`).\n\"\"\"\n            raise InvalidIdToken(msg, id_token, self)\n        if client.id_token_signed_response_alg is not None and id_token_alg != client.id_token_signed_response_alg:\n            raise MismatchingIdTokenAlg(id_token.alg, client.id_token_signed_response_alg, self, id_token)\n\n        verification_jwk: jwskate.Jwk\n\n        if id_token_alg in jwskate.SignatureAlgs.ALL_SYMMETRIC:\n            if not client.client_secret:\n                msg = \"token is symmetrically signed but this client does not have a Client Secret.\"\n                raise InvalidIdToken(msg, id_token, self)\n            verification_jwk = jwskate.SymmetricJwk.from_bytes(client.client_secret, alg=id_token_alg)\n            id_token.verify_signature(verification_jwk, alg=id_token_alg)\n        elif id_token_alg in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n            if not client.authorization_server_jwks:\n                msg = \"token is asymmetrically signed but the Authorization Server JWKS is not available.\"\n                raise InvalidIdToken(msg, id_token, self)\n\n            if id_token.get_header(\"kid\") is None:\n                msg = \"\"\"\ntoken does not contain a Key ID (kid) to specify the asymmetric key\nto use for signature verification.\"\"\"\n                raise InvalidIdToken(msg, id_token, self)\n            try:\n                verification_jwk = client.authorization_server_jwks.get_jwk_by_kid(id_token.kid)\n            except KeyError:\n                msg = f\"\"\"\\\ntoken is asymmetrically signed but there is no key\nwith kid='{id_token.kid}' in the Authorization Server JWKS.\"\"\"\n                raise InvalidIdToken(msg, id_token, self) from None\n\n            if id_token_alg not in verification_jwk.supported_signing_algorithms():\n                msg = \"token is asymmetrically signed but its algorithm is not supported by the verification key.\"\n                raise InvalidIdToken(msg, id_token, self)\n        else:\n            raise UnsupportedIdTokenAlg(self, id_token, id_token_alg)\n\n        id_token.verify(verification_jwk, alg=id_token_alg)\n\n        if azr.issuer and id_token.issuer != azr.issuer:\n            raise MismatchingIdTokenIssuer(id_token.issuer, azr.issuer, self, id_token)\n\n        if id_token.audiences and client.client_id not in id_token.audiences:\n            raise MismatchingIdTokenAudience(id_token.audiences, client.client_id, self, id_token)\n\n        if id_token.authorized_party is not None and id_token.authorized_party != client.client_id:\n            raise MismatchingIdTokenAzp(id_token.azp, client.client_id, self, id_token)\n\n        if id_token.is_expired(leeway=exp_leeway):\n            raise ExpiredIdToken(self, id_token)\n\n        if azr.nonce and id_token.nonce != azr.nonce:\n            raise MismatchingIdTokenNonce(id_token.nonce, azr.nonce, self, id_token)\n\n        if azr.acr_values and id_token.acr not in azr.acr_values:\n            raise MismatchingIdTokenAcr(id_token.acr, azr.acr_values, self, id_token)\n\n        hash_function = IdToken.hash_method(verification_jwk, id_token_alg)\n\n        at_hash = id_token.get_claim(\"at_hash\")\n        if at_hash is not None:\n            expected_at_hash = hash_function(self.access_token)\n            if expected_at_hash != at_hash:\n                msg = f\"mismatching 'at_hash' value (expected '{expected_at_hash}', got '{at_hash}')\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        c_hash = id_token.get_claim(\"c_hash\")\n        if c_hash is not None:\n            expected_c_hash = hash_function(azr.code)\n            if expected_c_hash != c_hash:\n                msg = f\"mismatching 'c_hash' value (expected '{expected_c_hash}', got '{c_hash}')\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        s_hash = id_token.get_claim(\"s_hash\")\n        if s_hash is not None:\n            if azr.state is None:\n                msg = \"token has a 's_hash' claim but no state was included in the request.\"\n                raise InvalidIdToken(msg, id_token, self)\n            expected_s_hash = hash_function(azr.state)\n            if expected_s_hash != s_hash:\n                msg = f\"mismatching 's_hash' value (expected '{expected_s_hash}', got '{s_hash}')\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        if azr.max_age is not None:\n            auth_time = id_token.auth_datetime\n            if auth_time is None:\n                msg = \"\"\"\na `max_age` parameter was included in the authorization request,\nbut the ID Token does not contain an `auth_time` claim.\n\"\"\"\n                raise InvalidIdToken(msg, id_token, self) from None\n            auth_age = datetime.now(tz=timezone.utc) - auth_time\n            if auth_age.total_seconds() &gt; azr.max_age + auth_time_leeway:\n                msg = f\"\"\"\nuser authentication happened too far in the past.\nThe `auth_time` parameter from the ID Token indicate that\nthe last Authentication Time was at {auth_time} ({auth_age.total_seconds()} sec ago),\nbut the authorization request `max_age` parameter specified that it must\nbe a maximum of {azr.max_age} sec ago.\n\"\"\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        return self.__class__(\n            access_token=self.access_token,\n            expires_at=self.expires_at,\n            scope=self.scope,\n            refresh_token=self.refresh_token,\n            token_type=self.token_type,\n            id_token=id_token,\n            **self.kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerToken.as_dict","title":"<code>as_dict()</code>","text":"<p>Return a dict of parameters.</p> <p>That is suitable for serialization or to init another BearerToken.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return a dict of parameters.\n\n    That is suitable for serialization or to init another BearerToken.\n\n    \"\"\"\n    d = asdict(self)\n    d.pop(\"expires_at\")\n    d[\"expires_in\"] = self.expires_in\n    d.update(**d.pop(\"kwargs\", {}))\n    return {key: val for key, val in d.items() if val is not None}\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerTokenSerializer","title":"<code>BearerTokenSerializer</code>","text":"<p>A helper class to serialize Token Response returned by an AS.</p> <p>This may be used to store BearerTokens in session or cookies.</p> <p>It needs a <code>dumper</code> and a <code>loader</code> functions that will respectively serialize and deserialize BearerTokens. Default implementations are provided with use gzip and base64url on the serialized JSON representation.</p> <p>Parameters:</p> Name Type Description Default <code>dumper</code> <code>Callable[[BearerToken], str] | None</code> <p>a function to serialize a token into a <code>str</code>.</p> <code>None</code> <code>loader</code> <code>Callable[[str], BearerToken] | None</code> <p>a function to deserialize a serialized token representation.</p> <code>None</code> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class BearerTokenSerializer:\n    \"\"\"A helper class to serialize Token Response returned by an AS.\n\n    This may be used to store BearerTokens in session or cookies.\n\n    It needs a `dumper` and a `loader` functions that will respectively serialize and deserialize\n    BearerTokens. Default implementations are provided with use gzip and base64url on the serialized\n    JSON representation.\n\n    Args:\n        dumper: a function to serialize a token into a `str`.\n        loader: a function to deserialize a serialized token representation.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        dumper: Callable[[BearerToken], str] | None = None,\n        loader: Callable[[str], BearerToken] | None = None,\n    ) -&gt; None:\n        self.dumper = dumper or self.default_dumper\n        self.loader = loader or self.default_loader\n\n    @staticmethod\n    def default_dumper(token: BearerToken) -&gt; str:\n        \"\"\"Serialize a token as JSON, then compress with deflate, then encodes as base64url.\n\n        Args:\n            token: the `BearerToken` to serialize\n\n        Returns:\n            the serialized value\n\n        \"\"\"\n        d = asdict(token)\n        d.update(**d.pop(\"kwargs\", {}))\n        return (\n            BinaPy.serialize_to(\"json\", {k: w for k, w in d.items() if w is not None}).to(\"deflate\").to(\"b64u\").ascii()\n        )\n\n    def default_loader(self, serialized: str, token_class: type[BearerToken] = BearerToken) -&gt; BearerToken:\n        \"\"\"Deserialize a BearerToken.\n\n        This does the opposite operations than `default_dumper`.\n\n        Args:\n            serialized: the serialized token\n            token_class: class to use to deserialize the Token\n\n        Returns:\n            a BearerToken\n\n        \"\"\"\n        attrs = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n        expires_at = attrs.get(\"expires_at\")\n        if expires_at:\n            attrs[\"expires_at\"] = datetime.fromtimestamp(expires_at, tz=timezone.utc)\n        return token_class(**attrs)\n\n    def dumps(self, token: BearerToken) -&gt; str:\n        \"\"\"Serialize and compress a given token for easier storage.\n\n        Args:\n            token: a BearerToken to serialize\n\n        Returns:\n            the serialized token, as a str\n\n        \"\"\"\n        return self.dumper(token)\n\n    def loads(self, serialized: str) -&gt; BearerToken:\n        \"\"\"Deserialize a serialized token.\n\n        Args:\n            serialized: the serialized token\n\n        Returns:\n            the deserialized token\n\n        \"\"\"\n        return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerTokenSerializer.default_dumper","title":"<code>default_dumper(token)</code>  <code>staticmethod</code>","text":"<p>Serialize a token as JSON, then compress with deflate, then encodes as base64url.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BearerToken</code> <p>the <code>BearerToken</code> to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized value</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@staticmethod\ndef default_dumper(token: BearerToken) -&gt; str:\n    \"\"\"Serialize a token as JSON, then compress with deflate, then encodes as base64url.\n\n    Args:\n        token: the `BearerToken` to serialize\n\n    Returns:\n        the serialized value\n\n    \"\"\"\n    d = asdict(token)\n    d.update(**d.pop(\"kwargs\", {}))\n    return (\n        BinaPy.serialize_to(\"json\", {k: w for k, w in d.items() if w is not None}).to(\"deflate\").to(\"b64u\").ascii()\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerTokenSerializer.default_loader","title":"<code>default_loader(serialized, token_class=BearerToken)</code>","text":"<p>Deserialize a BearerToken.</p> <p>This does the opposite operations than <code>default_dumper</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized token</p> required <code>token_class</code> <code>type[BearerToken]</code> <p>class to use to deserialize the Token</p> <code>BearerToken</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def default_loader(self, serialized: str, token_class: type[BearerToken] = BearerToken) -&gt; BearerToken:\n    \"\"\"Deserialize a BearerToken.\n\n    This does the opposite operations than `default_dumper`.\n\n    Args:\n        serialized: the serialized token\n        token_class: class to use to deserialize the Token\n\n    Returns:\n        a BearerToken\n\n    \"\"\"\n    attrs = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n    expires_at = attrs.get(\"expires_at\")\n    if expires_at:\n        attrs[\"expires_at\"] = datetime.fromtimestamp(expires_at, tz=timezone.utc)\n    return token_class(**attrs)\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerTokenSerializer.dumps","title":"<code>dumps(token)</code>","text":"<p>Serialize and compress a given token for easier storage.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BearerToken</code> <p>a BearerToken to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized token, as a str</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def dumps(self, token: BearerToken) -&gt; str:\n    \"\"\"Serialize and compress a given token for easier storage.\n\n    Args:\n        token: a BearerToken to serialize\n\n    Returns:\n        the serialized token, as a str\n\n    \"\"\"\n    return self.dumper(token)\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerTokenSerializer.loads","title":"<code>loads(serialized)</code>","text":"<p>Deserialize a serialized token.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized token</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>the deserialized token</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def loads(self, serialized: str) -&gt; BearerToken:\n    \"\"\"Deserialize a serialized token.\n\n    Args:\n        serialized: the serialized token\n\n    Returns:\n        the deserialized token\n\n    \"\"\"\n    return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.ExpiredAccessToken","title":"<code>ExpiredAccessToken</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Raised when an expired access token is used.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class ExpiredAccessToken(RuntimeError):\n    \"\"\"Raised when an expired access token is used.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.ExpiredIdToken","title":"<code>ExpiredIdToken</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token is expired.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class ExpiredIdToken(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token is expired.\"\"\"\n\n    def __init__(self, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(\"token is expired\", id_token, token)\n        self.received = id_token.expires_at\n        self.expected = datetime.now(tz=timezone.utc)\n</code></pre>"},{"location":"api/#requests_oauth2client.IdToken","title":"<code>IdToken</code>","text":"<p>               Bases: <code>SignedJwt</code></p> <p>Represent an ID Token.</p> <p>An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be decoded beforehand.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class IdToken(jwskate.SignedJwt):\n    \"\"\"Represent an ID Token.\n\n    An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be decoded beforehand.\n\n    \"\"\"\n\n    @property\n    def authorized_party(self) -&gt; str | None:\n        \"\"\"The Authorized Party (azp).\"\"\"\n        azp = self.claims.get(\"azp\")\n        if azp is None or isinstance(azp, str):\n            return azp\n        msg = \"`azp` attribute must be a string.\"\n        raise AttributeError(msg)\n\n    @property\n    def auth_datetime(self) -&gt; datetime | None:\n        \"\"\"The last user authentication time (auth_time).\"\"\"\n        auth_time = self.claims.get(\"auth_time\")\n        if auth_time is None:\n            return None\n        if isinstance(auth_time, int) and auth_time &gt; 0:\n            return self.timestamp_to_datetime(auth_time)\n        msg = \"`auth_time` must be a positive integer\"\n        raise AttributeError(msg)\n\n    @classmethod\n    def hash_method(cls, key: jwskate.Jwk, alg: str | None = None) -&gt; Callable[[str], str]:\n        \"\"\"Returns a callable that generates valid OIDC hashes, such as `at_hash`, `c_hash`, etc.\n\n        Args:\n            key: the ID token signature verification public key\n            alg: the ID token signature algorithm\n\n        Returns:\n            a callable that takes a string as input and produces a valid hash as a str output\n\n        \"\"\"\n        alg_class = jwskate.select_alg_class(key.SIGNATURE_ALGORITHMS, jwk_alg=key.alg, alg=alg)\n        if alg_class == jwskate.EdDsa:\n            if key.crv == \"Ed25519\":\n\n                def hash_method(token: str) -&gt; str:\n                    return BinaPy(token).to(\"sha512\")[:32].to(\"b64u\").decode()\n\n            elif key.crv == \"Ed448\":\n\n                def hash_method(token: str) -&gt; str:\n                    return BinaPy(token).to(\"shake256\", 456).to(\"b64u\").decode()\n\n        else:\n            hash_alg = alg_class.hashing_alg.name\n            hash_size = alg_class.hashing_alg.digest_size\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(hash_alg)[: hash_size // 2].to(\"b64u\").decode()\n\n        return hash_method\n</code></pre>"},{"location":"api/#requests_oauth2client.IdToken.authorized_party","title":"<code>authorized_party</code>  <code>property</code>","text":"<p>The Authorized Party (azp).</p>"},{"location":"api/#requests_oauth2client.IdToken.auth_datetime","title":"<code>auth_datetime</code>  <code>property</code>","text":"<p>The last user authentication time (auth_time).</p>"},{"location":"api/#requests_oauth2client.IdToken.hash_method","title":"<code>hash_method(key, alg=None)</code>  <code>classmethod</code>","text":"<p>Returns a callable that generates valid OIDC hashes, such as <code>at_hash</code>, <code>c_hash</code>, etc.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Jwk</code> <p>the ID token signature verification public key</p> required <code>alg</code> <code>str | None</code> <p>the ID token signature algorithm</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[str], str]</code> <p>a callable that takes a string as input and produces a valid hash as a str output</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@classmethod\ndef hash_method(cls, key: jwskate.Jwk, alg: str | None = None) -&gt; Callable[[str], str]:\n    \"\"\"Returns a callable that generates valid OIDC hashes, such as `at_hash`, `c_hash`, etc.\n\n    Args:\n        key: the ID token signature verification public key\n        alg: the ID token signature algorithm\n\n    Returns:\n        a callable that takes a string as input and produces a valid hash as a str output\n\n    \"\"\"\n    alg_class = jwskate.select_alg_class(key.SIGNATURE_ALGORITHMS, jwk_alg=key.alg, alg=alg)\n    if alg_class == jwskate.EdDsa:\n        if key.crv == \"Ed25519\":\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(\"sha512\")[:32].to(\"b64u\").decode()\n\n        elif key.crv == \"Ed448\":\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(\"shake256\", 456).to(\"b64u\").decode()\n\n    else:\n        hash_alg = alg_class.hashing_alg.name\n        hash_size = alg_class.hashing_alg.digest_size\n\n        def hash_method(token: str) -&gt; str:\n            return BinaPy(token).to(hash_alg)[: hash_size // 2].to(\"b64u\").decode()\n\n    return hash_method\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidIdToken","title":"<code>InvalidIdToken</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when trying to validate an invalid ID Token value.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class InvalidIdToken(ValueError):\n    \"\"\"Raised when trying to validate an invalid ID Token value.\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        id_token: IdToken | jwskate.JweCompact | object | None = None,\n        token_resp: TokenResponse | None = None,\n    ) -&gt; None:\n        super().__init__(f\"Invalid ID Token: {message}\")\n        self.id_token = id_token\n        self.token_resp = token_resp\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIdTokenAcr","title":"<code>MismatchingIdTokenAcr</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token doesn't contain one of the requested ACR Values.</p> <p>This happens when the authorization request includes an <code>acr_values</code> parameter but the returned ID Token includes a different value.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAcr(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token doesn't contain one of the requested ACR Values.\n\n    This happens when the authorization request includes an `acr_values` parameter but the returned\n    ID Token includes a different value.\n\n    \"\"\"\n\n    def __init__(self, acr: str, expected: Sequence[str], token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"token contains acr '{acr}' while client expects one of '{expected}'\", id_token, token)\n        self.received = acr\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIdTokenAlg","title":"<code>MismatchingIdTokenAlg</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token is signed with an unexpected alg.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAlg(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token is signed with an unexpected alg.\"\"\"\n\n    def __init__(self, token_alg: str, client_alg: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"token is signed with alg {token_alg}, client expects {client_alg}\", id_token, token)\n        self.received = token_alg\n        self.expected = client_alg\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIdTokenAudience","title":"<code>MismatchingIdTokenAudience</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the ID Token audience does not include the requesting Client ID.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAudience(InvalidIdToken):\n    \"\"\"Raised when the ID Token audience does not include the requesting Client ID.\"\"\"\n\n    def __init__(self, audiences: Sequence[str], client_id: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(\n            f\"token audience (`aud`) '{audiences}' does not match client_id '{client_id}'\",\n            id_token,\n            token,\n        )\n        self.received = audiences\n        self.expected = client_id\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIdTokenAzp","title":"<code>MismatchingIdTokenAzp</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the ID Token Authorized Presenter (azp) claim is not the Client ID.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAzp(InvalidIdToken):\n    \"\"\"Raised when the ID Token Authorized Presenter (azp) claim is not the Client ID.\"\"\"\n\n    def __init__(self, azp: str, client_id: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(\n            f\"token Authorized Presenter (`azp`) claim '{azp}' does not match client_id '{client_id}'\", id_token, token\n        )\n        self.received = azp\n        self.expected = client_id\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIdTokenIssuer","title":"<code>MismatchingIdTokenIssuer</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised on mismatching <code>iss</code> value in an ID Token.</p> <p>This happens when the expected <code>issuer</code> value is different from the <code>iss</code> value in an obtained ID Token.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenIssuer(InvalidIdToken):\n    \"\"\"Raised on mismatching `iss` value in an ID Token.\n\n    This happens when the expected `issuer` value is different from the `iss` value in an obtained ID Token.\n\n    \"\"\"\n\n    def __init__(self, iss: str | None, expected: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"`iss` from token '{iss}' does not match expected value '{expected}'\", id_token, token)\n        self.received = iss\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIdTokenNonce","title":"<code>MismatchingIdTokenNonce</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised on mismatching <code>nonce</code> value in an ID Token.</p> <p>This happens when the authorization request includes a <code>nonce</code> but the returned ID Token include a different value.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenNonce(InvalidIdToken):\n    \"\"\"Raised on mismatching `nonce` value in an ID Token.\n\n    This happens when the authorization request includes a `nonce` but the returned ID Token include\n    a different value.\n\n    \"\"\"\n\n    def __init__(self, nonce: str, expected: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"nonce from token '{nonce}' does not match expected value '{expected}'\", id_token, token)\n        self.received = nonce\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingIdToken","title":"<code>MissingIdToken</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the Authorization Endpoint does not return a mandatory ID Token.</p> <p>This happens when the Authorization Endpoint does not return an error, but does not return an ID Token either.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MissingIdToken(InvalidIdToken):\n    \"\"\"Raised when the Authorization Endpoint does not return a mandatory ID Token.\n\n    This happens when the Authorization Endpoint does not return an error, but does not return an ID Token either.\n\n    \"\"\"\n\n    def __init__(self, token: TokenResponse) -&gt; None:\n        super().__init__(\"An expected `id_token` is missing in the response.\", token, None)\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidUri","title":"<code>InvalidUri</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a URI does not pass validation by <code>validate_endpoint_uri()</code>.</p> Source code in <code>requests_oauth2client/utils.py</code> <pre><code>class InvalidUri(ValueError):\n    \"\"\"Raised when a URI does not pass validation by `validate_endpoint_uri()`.\"\"\"\n\n    def __init__(\n        self, url: str, *, https: bool, no_credentials: bool, no_port: bool, no_fragment: bool, path: bool\n    ) -&gt; None:\n        super().__init__(\"Invalid endpoint uri.\")\n        self.url = url\n        self.https = https\n        self.no_credentials = no_credentials\n        self.no_port = no_port\n        self.no_fragment = no_fragment\n        self.path = path\n\n    def errors(self) -&gt; Iterator[str]:\n        \"\"\"Iterate over all error descriptions, as str.\"\"\"\n        if self.https:\n            yield \"must use https\"\n        if self.no_credentials:\n            yield \"must not contain basic credentials\"\n        if self.no_port:\n            yield \"no custom port number allowed\"\n        if self.no_fragment:\n            yield \"must not contain a uri fragment\"\n        if self.path:\n            yield \"must include a path other than /\"\n\n    def __str__(self) -&gt; str:\n        all_errors = \", \".join(self.errors())\n        return f\"Invalid URI: {all_errors}\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidUri.errors","title":"<code>errors()</code>","text":"<p>Iterate over all error descriptions, as str.</p> Source code in <code>requests_oauth2client/utils.py</code> <pre><code>def errors(self) -&gt; Iterator[str]:\n    \"\"\"Iterate over all error descriptions, as str.\"\"\"\n    if self.https:\n        yield \"must use https\"\n    if self.no_credentials:\n        yield \"must not contain basic credentials\"\n    if self.no_port:\n        yield \"no custom port number allowed\"\n    if self.no_fragment:\n        yield \"must not contain a uri fragment\"\n    if self.path:\n        yield \"must include a path other than /\"\n</code></pre>"},{"location":"api/#requests_oauth2client.oauth2_discovery_document_url","title":"<code>oauth2_discovery_document_url(issuer)</code>","text":"<p>Construct the standardised OAuth 2.0 discovery document url for a given <code>issuer</code>.</p> <p>Based an <code>issuer</code> identifier, returns the standardised URL where the OAuth20 server metadata can be retrieved.</p> <p>The returned URL is built as specified in RFC8414.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>an OAuth20 Authentication Server <code>issuer</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>the standardised discovery document URL. Note that no attempt to fetch this document is</p> <code>str</code> <p>made.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def oauth2_discovery_document_url(issuer: str) -&gt; str:\n    \"\"\"Construct the standardised OAuth 2.0 discovery document url for a given `issuer`.\n\n    Based an `issuer` identifier, returns the standardised URL where the OAuth20 server metadata can\n    be retrieved.\n\n    The returned URL is built as specified in\n    [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414).\n\n    Args:\n        issuer: an OAuth20 Authentication Server `issuer`\n\n    Returns:\n        the standardised discovery document URL. Note that no attempt to fetch this document is\n        made.\n\n    \"\"\"\n    return well_known_uri(issuer, \"oauth-authorization-server\", at_root=True)\n</code></pre>"},{"location":"api/#requests_oauth2client.oidc_discovery_document_url","title":"<code>oidc_discovery_document_url(issuer)</code>","text":"<p>Construct the OIDC discovery document url for a given <code>issuer</code>.</p> <p>Given an <code>issuer</code> identifier, return the standardised URL where the OIDC discovery document can be retrieved.</p> <p>The returned URL is biuilt as specified in OpenID Connect Discovery 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>an OIDC Authentication Server <code>issuer</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>the standardised discovery document URL. Note that no attempt to fetch this document is</p> <code>str</code> <p>made.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def oidc_discovery_document_url(issuer: str) -&gt; str:\n    \"\"\"Construct the OIDC discovery document url for a given `issuer`.\n\n    Given an `issuer` identifier, return the standardised URL where the OIDC discovery document can\n    be retrieved.\n\n    The returned URL is biuilt as specified in [OpenID Connect Discovery\n    1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Args:\n        issuer: an OIDC Authentication Server `issuer`\n\n    Returns:\n        the standardised discovery document URL. Note that no attempt to fetch this document is\n        made.\n\n    \"\"\"\n    return well_known_uri(issuer, \"openid-configuration\", at_root=False)\n</code></pre>"},{"location":"api/#requests_oauth2client.well_known_uri","title":"<code>well_known_uri(origin, name, *, at_root=True)</code>","text":"<p>Return the location of a well-known document on an origin url.</p> <p>See RFC8615 and OIDC Discovery.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>str</code> <p>origin to use to build the well-known uri.</p> required <code>name</code> <code>str</code> <p>document name to use to build the well-known uri.</p> required <code>at_root</code> <code>bool</code> <p>if <code>True</code>, assume the well-known document is at root level (as defined in RFC8615). If <code>False</code>, assume the well-known location is per-directory, as defined in OpenID Connect Discovery 1.0.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>the well-know uri, relative to origin, where the well-known document named <code>name</code> should be</p> <code>str</code> <p>found.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def well_known_uri(origin: str, name: str, *, at_root: bool = True) -&gt; str:\n    \"\"\"Return the location of a well-known document on an origin url.\n\n    See [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615) and [OIDC\n    Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Args:\n        origin: origin to use to build the well-known uri.\n        name: document name to use to build the well-known uri.\n        at_root: if `True`, assume the well-known document is at root level (as defined in [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615)).\n            If `False`, assume the well-known location is per-directory, as defined in [OpenID\n            Connect Discovery\n            1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Returns:\n        the well-know uri, relative to origin, where the well-known document named `name` should be\n        found.\n\n    \"\"\"\n    url = furl(origin)\n    if at_root:\n        url.path = Path(\".well-known\") / url.path / name\n    else:\n        url.path.add(Path(\".well-known\") / name)\n    return str(url)\n</code></pre>"},{"location":"api/#requests_oauth2client.validate_dpop_proof","title":"<code>validate_dpop_proof(proof, *, htm, htu, ath=None, nonce=None, leeway=60, alg=None, algs=())</code>","text":"<p>Validate a DPoP proof.</p> <p>Parameters:</p> Name Type Description Default <code>proof</code> <code>str | bytes</code> <p>The serialized DPoP proof.</p> required <code>htm</code> <code>str</code> <p>The value of the HTTP method of the request to which the JWT is attached.</p> required <code>htu</code> <code>str</code> <p>The HTTP target URI of the request to which the JWT is attached, without query and fragment parts.</p> required <code>ath</code> <code>str | None</code> <p>The Hash of the access token.</p> <code>None</code> <code>nonce</code> <code>str | None</code> <p>A recent nonce provided via the DPoP-Nonce HTTP header, from either the AS or RS.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>A leeway, in number of seconds, to validate the proof <code>iat</code> claim.</p> <code>60</code> <code>alg</code> <code>str | None</code> <p>Allowed signature alg, if there is only one. Use this or <code>algs</code>.</p> <code>None</code> <code>algs</code> <code>Sequence[str]</code> <p>Allowed signature algs, if there is several. Use this or <code>alg</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>SignedJwt</code> <p>The validated DPoP proof, as a <code>SignedJwt</code>.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>def validate_dpop_proof(  # noqa: C901\n    proof: str | bytes,\n    *,\n    htm: str,\n    htu: str,\n    ath: str | None = None,\n    nonce: str | None = None,\n    leeway: int = 60,\n    alg: str | None = None,\n    algs: Sequence[str] = (),\n) -&gt; jwskate.SignedJwt:\n    \"\"\"Validate a DPoP proof.\n\n    Args:\n        proof: The serialized DPoP proof.\n        htm: The value of the HTTP method of the request to which the JWT is attached.\n        htu: The HTTP target URI of the request to which the JWT is attached, without query and fragment parts.\n        ath: The Hash of the access token.\n        nonce: A recent nonce provided via the DPoP-Nonce HTTP header, from either the AS or RS.\n        leeway: A leeway, in number of seconds, to validate the proof `iat` claim.\n        alg: Allowed signature alg, if there is only one. Use this or `algs`.\n        algs: Allowed signature algs, if there is several. Use this or `alg`.\n\n    Returns:\n        The validated DPoP proof, as a `SignedJwt`.\n\n    \"\"\"\n    if not isinstance(proof, bytes):\n        proof = proof.encode()\n    try:\n        proof_jwt = jwskate.SignedJwt(proof)\n    except jwskate.InvalidJwt as exc:\n        raise InvalidDPoPProof(proof, \"not a syntactically valid JWT\") from exc\n    if proof_jwt.typ != \"dpop+jwt\":\n        raise InvalidDPoPProof(proof, f\"typ '{proof_jwt.typ}' is not the expected 'dpop+jwt'.\")\n    if \"jwk\" not in proof_jwt.headers:\n        raise InvalidDPoPProof(proof, \"'jwk' header is missing\")\n    try:\n        public_jwk = jwskate.Jwk(proof_jwt.headers[\"jwk\"])\n    except jwskate.InvalidJwk as exc:\n        raise InvalidDPoPProof(proof, \"'jwk' header is not a valid JWK key.\") from exc\n    if public_jwk.is_private or public_jwk.is_symmetric:\n        raise InvalidDPoPProof(proof, \"'jwk' header is a private or symmetric key.\")\n\n    if not proof_jwt.verify_signature(public_jwk, alg=alg, algs=algs):\n        raise InvalidDPoPProof(proof, \"signature does not verify.\")\n\n    if proof_jwt.issued_at is None:\n        raise InvalidDPoPProof(proof, \"a Issued At (iat) claim is missing.\")\n    now = datetime.now(tz=timezone.utc)\n    if not now - timedelta(seconds=leeway) &lt; proof_jwt.issued_at &lt; now + timedelta(seconds=leeway):\n        msg = f\"\"\"\\\nIssued At timestamp (iat) is too far away in the past or future (received: {proof_jwt.issued_at}, now: {now}).\"\"\"\n        raise InvalidDPoPProof(\n            proof,\n            msg,\n        )\n    if proof_jwt.jwt_token_id is None:\n        raise InvalidDPoPProof(proof, \"a Unique Identifier (jti) claim is missing.\")\n    if \"htm\" not in proof_jwt.claims:\n        raise InvalidDPoPProof(proof, \"the HTTP method (htm) claim is missing.\")\n    if proof_jwt.htm != htm:\n        raise InvalidDPoPProof(proof, f\"HTTP Method (htm) '{proof_jwt.htm}' does not matches expected '{htm}'.\")\n    if \"htu\" not in proof_jwt.claims:\n        raise InvalidDPoPProof(proof, \"the HTTP URI (htu) claim is missing.\")\n    if proof_jwt.htu != htu:\n        raise InvalidDPoPProof(proof, f\"HTTP URI (htu) '{proof_jwt.htu}' does not matches expected '{htu}'.\")\n    if ath:\n        if \"ath\" not in proof_jwt.claims:\n            raise InvalidDPoPProof(proof, \"the Access Token hash (ath) claim is missing.\")\n        if proof_jwt.ath != ath:\n            raise InvalidDPoPProof(\n                proof, f\"Access Token Hash (ath) value '{proof_jwt.ath}' does not match expected '{ath}'.\"\n            )\n    if nonce:\n        if \"nonce\" not in proof_jwt.claims:\n            raise InvalidDPoPProof(proof, \"the DPoP Nonce (nonce) claim is missing.\")\n        if proof_jwt.nonce != nonce:\n            raise InvalidDPoPProof(\n                proof, f\"DPoP Nonce (nonce) value '{proof_jwt.nonce}' does not match expected '{nonce}'.\"\n            )\n\n    return proof_jwt\n</code></pre>"},{"location":"api/#requests_oauth2client.validate_endpoint_uri","title":"<code>validate_endpoint_uri(uri, *, https=True, no_credentials=True, no_port=False, no_fragment=True, path=True)</code>","text":"<p>Validate that a URI is suitable as an endpoint URI.</p> <p>It checks:</p> <ul> <li>that the scheme is <code>https</code></li> <li>that no custom port number is being used</li> <li>that no username or password are included</li> <li>that no fragment is included</li> <li>that a path is present</li> </ul> <p>Those checks can be individually disabled by using the parameters.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>the uri</p> required <code>https</code> <code>bool</code> <p>if <code>True</code>, check that the uri is https</p> <code>True</code> <code>no_port</code> <code>bool</code> <p>if <code>True</code>, check that no custom port number is included</p> <code>False</code> <code>no_credentials</code> <code>bool</code> <p>if <code>True</code>, check that no username/password are included</p> <code>True</code> <code>no_fragment</code> <code>bool</code> <p>if <code>True</code>, check that the uri contains no fragment</p> <code>True</code> <code>path</code> <code>bool</code> <p>if <code>True</code>, check that the uri contains a path component</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the supplied url is not suitable</p> <p>Returns:</p> Type Description <code>str</code> <p>the endpoint URI, if all checks passed</p> Source code in <code>requests_oauth2client/utils.py</code> <pre><code>def validate_endpoint_uri(\n    uri: str,\n    *,\n    https: bool = True,\n    no_credentials: bool = True,\n    no_port: bool = False,\n    no_fragment: bool = True,\n    path: bool = True,\n) -&gt; str:\n    \"\"\"Validate that a URI is suitable as an endpoint URI.\n\n    It checks:\n\n    - that the scheme is `https`\n    - that no custom port number is being used\n    - that no username or password are included\n    - that no fragment is included\n    - that a path is present\n\n    Those checks can be individually disabled by using the parameters.\n\n    Args:\n        uri: the uri\n        https: if `True`, check that the uri is https\n        no_port: if `True`, check that no custom port number is included\n        no_credentials: if ` True`, check that no username/password are included\n        no_fragment: if `True`, check that the uri contains no fragment\n        path: if `True`, check that the uri contains a path component\n\n    Raises:\n        ValueError: if the supplied url is not suitable\n\n    Returns:\n        the endpoint URI, if all checks passed\n\n    \"\"\"\n    url = furl(uri)\n    if https and url.scheme == \"https\":\n        https = False\n    if no_port and url.port == 443:  # noqa: PLR2004\n        no_port = False\n    if no_credentials and not url.username and not url.password:\n        no_credentials = False\n    if no_fragment and not url.fragment:\n        no_fragment = False\n    if path and url.path and url.path != \"/\":\n        path = False\n\n    if https or no_port or no_credentials or no_fragment or path:\n        raise InvalidUri(\n            uri, https=https, no_port=no_port, no_credentials=no_credentials, no_fragment=no_fragment, path=path\n        )\n\n    return uri\n</code></pre>"},{"location":"api/#requests_oauth2client.validate_issuer_uri","title":"<code>validate_issuer_uri(uri)</code>","text":"<p>Validate that an Issuer Identifier URI is valid.</p> <p>This is almost the same as a valid endpoint URI, but a path is not mandatory.</p> Source code in <code>requests_oauth2client/utils.py</code> <pre><code>def validate_issuer_uri(uri: str) -&gt; str:\n    \"\"\"Validate that an Issuer Identifier URI is valid.\n\n    This is almost the same as a valid endpoint URI, but a path is not mandatory.\n\n    \"\"\"\n    return validate_endpoint_uri(uri, path=False)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client","title":"<code>api_client</code>","text":"<p><code>ApiClient</code> main module.</p>"},{"location":"api/#requests_oauth2client.api_client.InvalidBoolFieldsParam","title":"<code>InvalidBoolFieldsParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an invalid value is passed as 'bool_fields' parameter.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>class InvalidBoolFieldsParam(ValueError):\n    \"\"\"Raised when an invalid value is passed as 'bool_fields' parameter.\"\"\"\n\n    def __init__(self, bool_fields: object) -&gt; None:\n        super().__init__(\"\"\"\\\nInvalid value for `bool_fields` parameter. It must be an iterable of 2 `str` values:\n- first one for the `True` value,\n- second one for the `False` value.\nBoolean fields in `data` or `params` with a boolean value (`True` or `False`)\nwill be serialized to the corresponding value.\nDefault is `('true', 'false')`\nUse this parameter when the target API expects some other values, e.g.:\n- ('on', 'off')\n- ('1', '0')\n- ('yes', 'no')\n\"\"\")\n        self.value = bool_fields\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.InvalidPathParam","title":"<code>InvalidPathParam</code>","text":"<p>               Bases: <code>TypeError</code>, <code>ValueError</code></p> <p>Raised when an unexpected path is passed as 'url' parameter.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>class InvalidPathParam(TypeError, ValueError):\n    \"\"\"Raised when an unexpected path is passed as 'url' parameter.\"\"\"\n\n    def __init__(self, path: None | str | bytes | Iterable[str | bytes | int]) -&gt; None:\n        super().__init__(\"\"\"\\\nUnexpected path. Please provide a path that is relative to the configured `base_url`:\n- `None` (default) to call the base_url\n- a `str` or `bytes`, that will be joined to the base_url (with a / separator, if required)\n- or an iterable of string-able objects, which will be joined to the base_url with / separators\n\"\"\")\n        self.url = path\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient","title":"<code>ApiClient</code>","text":"<p>A Wrapper around requests.Session with extra features for REST API calls.</p> <p>Additional features compared to using a requests.Session directly:</p> <ul> <li>You must set a root url at creation time, which then allows passing relative urls at request time.</li> <li>It may also raise exceptions instead of returning error responses.</li> <li>You can also pass additional kwargs at init time, which will be used to configure the Session, instead of setting them later.</li> <li>for parameters passed as <code>json</code>, <code>params</code> or <code>data</code>, values that are <code>None</code> can be automatically discarded from the request</li> <li>boolean values in <code>data</code> or <code>params</code> fields can be serialized to values that are suitable for the target API, like <code>\"true\"</code>  or <code>\"false\"</code>, or <code>\"1\"</code> / <code>\"0\"</code>, instead of the default values <code>\"True\"</code> or <code>\"False\"</code>,</li> <li>you may pass <code>cookies</code> and <code>headers</code>, which will be added to the session cookie handler or request headers respectively.</li> <li>you may use the <code>user_agent</code> parameter to change the <code>User-Agent</code> header easily. Set it to   <code>None</code> to remove that header.</li> </ul> <p><code>base_url</code> will serve as root for relative urls passed to ApiClient.request(), ApiClient.get(), etc.</p> <p>A requests.HTTPError will be raised everytime an API call returns an error code (&gt;= 400), unless you set <code>raise_for_status</code> to <code>False</code>. Additional parameters passed at init time, including <code>auth</code> will be used to configure the Session.</p> Example <pre><code>from requests_oauth2client import ApiClient\n\napi = ApiClient(\"https://myapi.local/resource\", timeout=10)\nresp = api.get(\"/myid\")  # this will send a GET request\n# to https://myapi.local/resource/myid\n\n# you can pass an underlying requests.Session at init time\nsession = requests.Session()\nsession.proxies = {\"https\": \"https://localhost:3128\"}\napi = ApiClient(\"https://myapi.local/resource\", session=session)\n\n# or you can let ApiClient init its own session and provide additional configuration\n# parameters:\napi = ApiClient(\n    \"https://myapi.local/resource\",\n    proxies={\"https\": \"https://localhost:3128\"},\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>the base api url, that is the root for all the target API endpoints.</p> required <code>auth</code> <code>AuthBase | None</code> <p>the requests.auth.AuthBase to use as authentication handler.</p> <code>None</code> <code>timeout</code> <code>int | None</code> <p>the default timeout, in seconds, to use for each request from this <code>ApiClient</code>. Can be set to <code>None</code> to disable timeout.</p> <code>60</code> <code>raise_for_status</code> <code>bool</code> <p>if <code>True</code>, exceptions will be raised everytime a request returns an error code (&gt;= 400).</p> <code>True</code> <code>none_fields</code> <code>Literal['include', 'exclude', 'empty']</code> <p>defines what to do with parameters with value <code>None</code> in <code>data</code> or <code>json</code> fields.</p> <ul> <li>if <code>\"exclude\"</code> (default), fields whose values are <code>None</code> are not included in the request.</li> <li>if <code>\"include\"</code>, they are included with string value <code>None</code>. This is the default behavior of <code>requests</code>. Note that they will be serialized to <code>null</code> in JSON.</li> <li>if <code>\"empty\"</code>, they are included with an empty value (as an empty string).</li> </ul> <code>'exclude'</code> <code>bool_fields</code> <code>tuple[Any, Any] | None</code> <p>a tuple of <code>(true_value, false_value)</code>. Fields from <code>data</code> or <code>params</code> with a boolean value (<code>True</code> or <code>False</code>) will be serialized to the corresponding value. This can be useful since some APIs expect a <code>'true'</code> or <code>'false'</code> value as boolean, and <code>requests</code> serializes <code>True</code> to <code>'True'</code> and <code>False</code> to <code>'False'</code>. Set it to <code>None</code> to restore default requests behavior.</p> <code>('true', 'false')</code> <code>cookies</code> <code>Mapping[str, Any] | None</code> <p>a mapping of cookies to set in the underlying <code>requests.Session</code>.</p> <code>None</code> <code>headers</code> <code>Mapping[str, Any] | None</code> <p>a mapping of headers to set in the underlying <code>requests.Session</code>.</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>a preconfigured <code>requests.Session</code> to use with this <code>ApiClient</code>.</p> <code>None</code> <code>**session_kwargs</code> <code>Any</code> <p>additional kwargs to configure the underlying <code>requests.Session</code>.</p> <code>{}</code> <p>Raises:</p> Type Description <code>InvalidBoolFieldsParam</code> <p>if the provided <code>bool_fields</code> parameter is invalid.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>@frozen(init=False)\nclass ApiClient:\n    \"\"\"A Wrapper around [requests.Session][] with extra features for REST API calls.\n\n    Additional features compared to using a [requests.Session][] directly:\n\n    - You must set a root url at creation time, which then allows passing relative urls at request time.\n    - It may also raise exceptions instead of returning error responses.\n    - You can also pass additional kwargs at init time, which will be used to configure the\n    [Session][requests.Session], instead of setting them later.\n    - for parameters passed as `json`, `params` or `data`, values that are `None` can be\n    automatically discarded from the request\n    - boolean values in `data` or `params` fields can be serialized to values that are suitable\n    for the target API, like `\"true\"`  or `\"false\"`, or `\"1\"` / `\"0\"`, instead of the default\n    values `\"True\"` or `\"False\"`,\n    - you may pass `cookies` and `headers`, which will be added to the session cookie handler or\n    request headers respectively.\n    - you may use the `user_agent` parameter to change the `User-Agent` header easily. Set it to\n      `None` to remove that header.\n\n    `base_url` will serve as root for relative urls passed to\n    [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request],\n    [ApiClient.get()][requests_oauth2client.api_client.ApiClient.get], etc.\n\n    A [requests.HTTPError][] will be raised everytime an API call returns an error code (&gt;= 400), unless\n    you set `raise_for_status` to `False`. Additional parameters passed at init time, including\n    `auth` will be used to configure the [Session][requests.Session].\n\n    Example:\n        ```python\n        from requests_oauth2client import ApiClient\n\n        api = ApiClient(\"https://myapi.local/resource\", timeout=10)\n        resp = api.get(\"/myid\")  # this will send a GET request\n        # to https://myapi.local/resource/myid\n\n        # you can pass an underlying requests.Session at init time\n        session = requests.Session()\n        session.proxies = {\"https\": \"https://localhost:3128\"}\n        api = ApiClient(\"https://myapi.local/resource\", session=session)\n\n        # or you can let ApiClient init its own session and provide additional configuration\n        # parameters:\n        api = ApiClient(\n            \"https://myapi.local/resource\",\n            proxies={\"https\": \"https://localhost:3128\"},\n        )\n        ```\n\n    Args:\n        base_url: the base api url, that is the root for all the target API endpoints.\n        auth: the [requests.auth.AuthBase][] to use as authentication handler.\n        timeout: the default timeout, in seconds, to use for each request from this `ApiClient`.\n            Can be set to `None` to disable timeout.\n        raise_for_status: if `True`, exceptions will be raised everytime a request returns an\n            error code (&gt;= 400).\n        none_fields: defines what to do with parameters with value `None` in `data` or `json` fields.\n\n            - if `\"exclude\"` (default), fields whose values are `None` are not included in the request.\n            - if `\"include\"`, they are included with string value `None`. This is\n            the default behavior of `requests`. Note that they will be serialized to `null` in JSON.\n            - if `\"empty\"`, they are included with an empty value (as an empty string).\n        bool_fields: a tuple of `(true_value, false_value)`. Fields from `data` or `params` with\n            a boolean value (`True` or `False`) will be serialized to the corresponding value.\n            This can be useful since some APIs expect a `'true'` or `'false'` value as boolean,\n            and `requests` serializes `True` to `'True'` and `False` to `'False'`.\n            Set it to `None` to restore default requests behavior.\n        cookies: a mapping of cookies to set in the underlying `requests.Session`.\n        headers: a mapping of headers to set in the underlying `requests.Session`.\n        session: a preconfigured `requests.Session` to use with this `ApiClient`.\n        **session_kwargs: additional kwargs to configure the underlying `requests.Session`.\n\n    Raises:\n        InvalidBoolFieldsParam: if the provided `bool_fields` parameter is invalid.\n\n    \"\"\"\n\n    base_url: str\n    auth: requests.auth.AuthBase | None\n    timeout: int | None\n    raise_for_status: bool\n    none_fields: Literal[\"include\", \"exclude\", \"empty\"]\n    bool_fields: tuple[Any, Any] | None\n    session: requests.Session\n\n    def __init__(\n        self,\n        base_url: str,\n        *,\n        auth: requests.auth.AuthBase | None = None,\n        timeout: int | None = 60,\n        raise_for_status: bool = True,\n        none_fields: Literal[\"include\", \"exclude\", \"empty\"] = \"exclude\",\n        bool_fields: tuple[Any, Any] | None = (\"true\", \"false\"),\n        cookies: Mapping[str, Any] | None = None,\n        headers: Mapping[str, Any] | None = None,\n        user_agent: str | None = requests.utils.default_user_agent(),\n        session: requests.Session | None = None,\n        **session_kwargs: Any,\n    ) -&gt; None:\n        session = session or requests.Session()\n\n        if cookies:\n            for key, val in cookies.items():\n                session.cookies[key] = str(val)\n\n        if headers:\n            for key, val in headers.items():\n                session.headers[key] = str(val)\n\n        if user_agent is None:\n            session.headers.pop(\"User-Agent\", None)\n        else:\n            session.headers[\"User-Agent\"] = str(user_agent)\n\n        for key, val in session_kwargs.items():\n            setattr(session, key, val)\n\n        if bool_fields is None:\n            bool_fields = (\"True\", \"False\")\n        else:\n            validate_bool_fields(bool_fields)\n\n        self.__attrs_init__(\n            base_url=base_url,\n            auth=auth,\n            raise_for_status=raise_for_status,\n            none_fields=none_fields,\n            bool_fields=bool_fields,\n            timeout=timeout,\n            session=session,\n        )\n\n    def request(  # noqa: C901, PLR0913, D417\n        self,\n        method: str,\n        path: None | str | bytes | Iterable[str | bytes | int] = None,\n        *,\n        params: None | bytes | MutableMapping[str, str] = None,\n        data: (\n            Iterable[bytes]\n            | str\n            | bytes\n            | list[tuple[Any, Any]]\n            | tuple[tuple[Any, Any], ...]\n            | Mapping[Any, Any]\n            | None\n        ) = None,\n        headers: MutableMapping[str, str] | None = None,\n        cookies: None | RequestsCookieJar | MutableMapping[str, str] = None,\n        files: MutableMapping[str, IO[Any]] | None = None,\n        auth: (\n            None\n            | tuple[str, str]\n            | requests.auth.AuthBase\n            | Callable[[requests.PreparedRequest], requests.PreparedRequest]\n        ) = None,\n        timeout: None | float | tuple[float, float] | tuple[float, None] = None,\n        allow_redirects: bool = False,\n        proxies: MutableMapping[str, str] | None = None,\n        hooks: None\n        | (\n            MutableMapping[\n                str,\n                (Iterable[Callable[[requests.Response], Any]] | Callable[[requests.Response], Any]),\n            ]\n        ) = None,\n        stream: bool | None = None,\n        verify: str | bool | None = None,\n        cert: str | tuple[str, str] | None = None,\n        json: Mapping[str, Any] | None = None,\n        raise_for_status: bool | None = None,\n        none_fields: Literal[\"include\", \"exclude\", \"empty\"] | None = None,\n        bool_fields: tuple[Any, Any] | None = None,\n    ) -&gt; requests.Response:\n        \"\"\"A wrapper around [requests.Session.request][] method with extra features.\n\n        Additional features are described in\n        [ApiClient][requests_oauth2client.api_client.ApiClient] documentation.\n\n        All parameters will be passed as-is to [requests.Session.request][], expected those\n        described below which have a special behavior.\n\n        Args:\n          path: the url where the request will be sent to. Can be:\n\n            - a path, as `str`: that path will be joined to the configured API url,\n            - an iterable of path segments: that will be joined to the root url.\n          raise_for_status: like the parameter of the same name from\n            [ApiClient][requests_oauth2client.api_client.ApiClient],\n            but this will be applied for this request only.\n          none_fields: like the parameter of the same name from\n            [ApiClient][requests_oauth2client.api_client.ApiClient],\n            but this will be applied for this request only.\n          bool_fields: like the parameter of the same name from\n            [ApiClient][requests_oauth2client.api_client.ApiClient],\n            but this will be applied for this request only.\n\n        Returns:\n          a Response as returned by requests\n\n        Raises:\n            InvalidBoolFieldsParam: if the provided `bool_fields` parameter is invalid.\n\n        \"\"\"\n        path = self.to_absolute_url(path)\n\n        if none_fields is None:\n            none_fields = self.none_fields\n\n        if none_fields == \"exclude\":\n            if isinstance(data, Mapping):\n                data = {key: val for key, val in data.items() if val is not None}\n            if isinstance(json, Mapping):\n                json = {key: val for key, val in json.items() if val is not None}\n        elif none_fields == \"empty\":\n            if isinstance(data, Mapping):\n                data = {key: val if val is not None else \"\" for key, val in data.items()}\n            if isinstance(json, Mapping):\n                json = {key: val if val is not None else \"\" for key, val in json.items()}\n\n        if bool_fields is None:\n            bool_fields = self.bool_fields\n\n        if bool_fields:\n            true_value, false_value = validate_bool_fields(bool_fields)\n            if isinstance(data, MutableMapping):\n                for key, val in data.items():\n                    if val is True:\n                        data[key] = true_value\n                    elif val is False:\n                        data[key] = false_value\n            if isinstance(params, MutableMapping):\n                for key, val in params.items():\n                    if val is True:\n                        params[key] = true_value\n                    elif val is False:\n                        params[key] = false_value\n\n        timeout = timeout or self.timeout\n\n        response = self.session.request(\n            method,\n            path,\n            params=params,\n            data=data,\n            headers=headers,\n            cookies=cookies,\n            files=files,\n            auth=auth or self.auth,\n            timeout=timeout,\n            allow_redirects=allow_redirects,\n            proxies=proxies,\n            hooks=hooks,\n            stream=stream,\n            verify=verify,\n            cert=cert,\n            json=json,\n        )\n\n        if raise_for_status is None:\n            raise_for_status = self.raise_for_status\n        if raise_for_status:\n            response.raise_for_status()\n        return response\n\n    def to_absolute_url(self, path: None | str | bytes | Iterable[str | bytes | int] = None) -&gt; str:\n        \"\"\"Convert a relative url to an absolute url.\n\n        Given a `path`, return the matching absolute url, based on the `base_url` that is\n        configured for this API.\n\n        The result of this method is different from a standard `urljoin()`, because a relative_url\n        that starts with a \"/\" will not override the path from the base url. You can also pass an\n        iterable of path parts as relative url, which will be properly joined with \"/\". Those parts\n        may be `str` (which will be urlencoded) or `bytes` (which will be decoded as UTF-8 first) or\n        any other type (which will be converted to `str` first, using the `str() function`). See the\n        table below for example results which would exhibit most cases:\n\n        | base_url | relative_url | result_url |\n        |---------------------------|-----------------------------|-------------------------------------------|\n        | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `b\"/path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `\"path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `None` | `\"https://myhost.com/root\"` |\n        | `\"https://myhost.com/root\"` |  `(\"user\", 1, \"resource\")` | `\"https://myhost.com/root/user/1/resource\"` |\n        | `\"https://myhost.com/root\"` | `\"https://otherhost.org/foo\"` | `ValueError` |\n\n        Args:\n          path: a relative url\n\n        Returns:\n          the resulting absolute url\n\n        Raises:\n            InvalidPathParam: if the provided path does not allow constructing a valid url\n\n        \"\"\"\n        url = path\n\n        if url is None:\n            url = self.base_url\n        else:\n            if not isinstance(url, (str, bytes)):\n                try:\n                    url = \"/\".join(\n                        [urlencode(part.decode() if isinstance(part, bytes) else str(part)) for part in url if part],\n                    )\n                except Exception as exc:\n                    raise InvalidPathParam(url) from exc\n\n            if isinstance(url, bytes):\n                url = url.decode()\n\n            if \"://\" in url:\n                raise InvalidPathParam(url)\n\n            url = urljoin(self.base_url + \"/\", url.lstrip(\"/\"))\n\n        if url is None or not isinstance(url, str):\n            raise InvalidPathParam(url)  # pragma: no cover\n\n        return url\n\n    def get(\n        self,\n        path: None | str | bytes | Iterable[str | bytes | int] = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a GET request and return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n            path: the path where the request will be sent.\n            raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n            **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n            a response object.\n\n        Raises:\n            requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"GET\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def post(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a POST request and return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n          a response object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"POST\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def patch(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a PATCH request. Return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"PATCH\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def put(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a PUT request. Return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"PUT\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def delete(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a DELETE request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time. It takes the same\n        parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`.\n\n        Returns:\n          a response object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"DELETE\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def __getattr__(self, item: str) -&gt; ApiClient:\n        \"\"\"Allow access sub resources with an attribute-based syntax.\n\n        Args:\n            item: a subpath\n\n        Returns:\n            a new `ApiClient` initialized on the new base url\n\n        Example:\n            ```python\n            from requests_oauth2client import ApiClient\n\n            api = ApiClient(\"https://myapi.local\")\n            resource1 = api.resource1.get()  # GET https://myapi.local/resource1\n            resource2 = api.resource2.get()  # GET https://myapi.local/resource2\n            ```\n\n        \"\"\"\n        return self[item]\n\n    def __getitem__(self, item: str) -&gt; ApiClient:\n        \"\"\"Allow access to sub resources with a subscription-based syntax.\n\n        Args:\n            item: a subpath\n\n        Returns:\n            a new `ApiClient` initialized on the new base url\n\n        Example:\n            ```python\n            from requests_oauth2client import ApiClient\n\n            api = ApiClient(\"https://myapi.local\")\n            resource1 = api[\"resource1\"].get()  # GET https://myapi.local/resource1\n            resource2 = api[\"resource2\"].get()  # GET https://myapi.local/resource2\n            ```\n\n        \"\"\"\n        new_base_uri = self.to_absolute_url(item)\n        return ApiClient(\n            new_base_uri,\n            session=self.session,\n            none_fields=self.none_fields,\n            bool_fields=self.bool_fields,\n            timeout=self.timeout,\n            raise_for_status=self.raise_for_status,\n        )\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Allow `ApiClient` to act as a context manager.\n\n        You can then use an `ApiClient` instance in a `with` clause, the same way as\n        `requests.Session`. The underlying request.Session will be closed on exit.\n\n        Example:\n            ```python\n            with ApiClient(\"https://myapi.com/path\") as client:\n                resp = client.get(\"resource\")\n            ```\n\n        \"\"\"\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Close the underlying requests.Session on exit.\"\"\"\n        self.session.close()\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.request","title":"<code>request(method, path=None, *, params=None, data=None, headers=None, cookies=None, files=None, auth=None, timeout=None, allow_redirects=False, proxies=None, hooks=None, stream=None, verify=None, cert=None, json=None, raise_for_status=None, none_fields=None, bool_fields=None)</code>","text":"<p>A wrapper around requests.Session.request method with extra features.</p> <p>Additional features are described in ApiClient documentation.</p> <p>All parameters will be passed as-is to requests.Session.request, expected those described below which have a special behavior.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>the url where the request will be sent to. Can be:</p> <ul> <li>a path, as <code>str</code>: that path will be joined to the configured API url,</li> <li>an iterable of path segments: that will be joined to the root url.</li> </ul> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>like the parameter of the same name from ApiClient, but this will be applied for this request only.</p> <code>None</code> <code>none_fields</code> <code>Literal['include', 'exclude', 'empty'] | None</code> <p>like the parameter of the same name from ApiClient, but this will be applied for this request only.</p> <code>None</code> <code>bool_fields</code> <code>tuple[Any, Any] | None</code> <p>like the parameter of the same name from ApiClient, but this will be applied for this request only.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response as returned by requests</p> <p>Raises:</p> Type Description <code>InvalidBoolFieldsParam</code> <p>if the provided <code>bool_fields</code> parameter is invalid.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def request(  # noqa: C901, PLR0913, D417\n    self,\n    method: str,\n    path: None | str | bytes | Iterable[str | bytes | int] = None,\n    *,\n    params: None | bytes | MutableMapping[str, str] = None,\n    data: (\n        Iterable[bytes]\n        | str\n        | bytes\n        | list[tuple[Any, Any]]\n        | tuple[tuple[Any, Any], ...]\n        | Mapping[Any, Any]\n        | None\n    ) = None,\n    headers: MutableMapping[str, str] | None = None,\n    cookies: None | RequestsCookieJar | MutableMapping[str, str] = None,\n    files: MutableMapping[str, IO[Any]] | None = None,\n    auth: (\n        None\n        | tuple[str, str]\n        | requests.auth.AuthBase\n        | Callable[[requests.PreparedRequest], requests.PreparedRequest]\n    ) = None,\n    timeout: None | float | tuple[float, float] | tuple[float, None] = None,\n    allow_redirects: bool = False,\n    proxies: MutableMapping[str, str] | None = None,\n    hooks: None\n    | (\n        MutableMapping[\n            str,\n            (Iterable[Callable[[requests.Response], Any]] | Callable[[requests.Response], Any]),\n        ]\n    ) = None,\n    stream: bool | None = None,\n    verify: str | bool | None = None,\n    cert: str | tuple[str, str] | None = None,\n    json: Mapping[str, Any] | None = None,\n    raise_for_status: bool | None = None,\n    none_fields: Literal[\"include\", \"exclude\", \"empty\"] | None = None,\n    bool_fields: tuple[Any, Any] | None = None,\n) -&gt; requests.Response:\n    \"\"\"A wrapper around [requests.Session.request][] method with extra features.\n\n    Additional features are described in\n    [ApiClient][requests_oauth2client.api_client.ApiClient] documentation.\n\n    All parameters will be passed as-is to [requests.Session.request][], expected those\n    described below which have a special behavior.\n\n    Args:\n      path: the url where the request will be sent to. Can be:\n\n        - a path, as `str`: that path will be joined to the configured API url,\n        - an iterable of path segments: that will be joined to the root url.\n      raise_for_status: like the parameter of the same name from\n        [ApiClient][requests_oauth2client.api_client.ApiClient],\n        but this will be applied for this request only.\n      none_fields: like the parameter of the same name from\n        [ApiClient][requests_oauth2client.api_client.ApiClient],\n        but this will be applied for this request only.\n      bool_fields: like the parameter of the same name from\n        [ApiClient][requests_oauth2client.api_client.ApiClient],\n        but this will be applied for this request only.\n\n    Returns:\n      a Response as returned by requests\n\n    Raises:\n        InvalidBoolFieldsParam: if the provided `bool_fields` parameter is invalid.\n\n    \"\"\"\n    path = self.to_absolute_url(path)\n\n    if none_fields is None:\n        none_fields = self.none_fields\n\n    if none_fields == \"exclude\":\n        if isinstance(data, Mapping):\n            data = {key: val for key, val in data.items() if val is not None}\n        if isinstance(json, Mapping):\n            json = {key: val for key, val in json.items() if val is not None}\n    elif none_fields == \"empty\":\n        if isinstance(data, Mapping):\n            data = {key: val if val is not None else \"\" for key, val in data.items()}\n        if isinstance(json, Mapping):\n            json = {key: val if val is not None else \"\" for key, val in json.items()}\n\n    if bool_fields is None:\n        bool_fields = self.bool_fields\n\n    if bool_fields:\n        true_value, false_value = validate_bool_fields(bool_fields)\n        if isinstance(data, MutableMapping):\n            for key, val in data.items():\n                if val is True:\n                    data[key] = true_value\n                elif val is False:\n                    data[key] = false_value\n        if isinstance(params, MutableMapping):\n            for key, val in params.items():\n                if val is True:\n                    params[key] = true_value\n                elif val is False:\n                    params[key] = false_value\n\n    timeout = timeout or self.timeout\n\n    response = self.session.request(\n        method,\n        path,\n        params=params,\n        data=data,\n        headers=headers,\n        cookies=cookies,\n        files=files,\n        auth=auth or self.auth,\n        timeout=timeout,\n        allow_redirects=allow_redirects,\n        proxies=proxies,\n        hooks=hooks,\n        stream=stream,\n        verify=verify,\n        cert=cert,\n        json=json,\n    )\n\n    if raise_for_status is None:\n        raise_for_status = self.raise_for_status\n    if raise_for_status:\n        response.raise_for_status()\n    return response\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.to_absolute_url","title":"<code>to_absolute_url(path=None)</code>","text":"<p>Convert a relative url to an absolute url.</p> <p>Given a <code>path</code>, return the matching absolute url, based on the <code>base_url</code> that is configured for this API.</p> <p>The result of this method is different from a standard <code>urljoin()</code>, because a relative_url that starts with a \"/\" will not override the path from the base url. You can also pass an iterable of path parts as relative url, which will be properly joined with \"/\". Those parts may be <code>str</code> (which will be urlencoded) or <code>bytes</code> (which will be decoded as UTF-8 first) or any other type (which will be converted to <code>str</code> first, using the <code>str() function</code>). See the table below for example results which would exhibit most cases:</p> base_url relative_url result_url <code>\"https://myhost.com/root\"</code> <code>\"/path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>\"/path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>b\"/path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>\"path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>None</code> <code>\"https://myhost.com/root\"</code> <code>\"https://myhost.com/root\"</code> <code>(\"user\", 1, \"resource\")</code> <code>\"https://myhost.com/root/user/1/resource\"</code> <code>\"https://myhost.com/root\"</code> <code>\"https://otherhost.org/foo\"</code> <code>ValueError</code> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>a relative url</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the resulting absolute url</p> <p>Raises:</p> Type Description <code>InvalidPathParam</code> <p>if the provided path does not allow constructing a valid url</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def to_absolute_url(self, path: None | str | bytes | Iterable[str | bytes | int] = None) -&gt; str:\n    \"\"\"Convert a relative url to an absolute url.\n\n    Given a `path`, return the matching absolute url, based on the `base_url` that is\n    configured for this API.\n\n    The result of this method is different from a standard `urljoin()`, because a relative_url\n    that starts with a \"/\" will not override the path from the base url. You can also pass an\n    iterable of path parts as relative url, which will be properly joined with \"/\". Those parts\n    may be `str` (which will be urlencoded) or `bytes` (which will be decoded as UTF-8 first) or\n    any other type (which will be converted to `str` first, using the `str() function`). See the\n    table below for example results which would exhibit most cases:\n\n    | base_url | relative_url | result_url |\n    |---------------------------|-----------------------------|-------------------------------------------|\n    | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `b\"/path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `\"path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `None` | `\"https://myhost.com/root\"` |\n    | `\"https://myhost.com/root\"` |  `(\"user\", 1, \"resource\")` | `\"https://myhost.com/root/user/1/resource\"` |\n    | `\"https://myhost.com/root\"` | `\"https://otherhost.org/foo\"` | `ValueError` |\n\n    Args:\n      path: a relative url\n\n    Returns:\n      the resulting absolute url\n\n    Raises:\n        InvalidPathParam: if the provided path does not allow constructing a valid url\n\n    \"\"\"\n    url = path\n\n    if url is None:\n        url = self.base_url\n    else:\n        if not isinstance(url, (str, bytes)):\n            try:\n                url = \"/\".join(\n                    [urlencode(part.decode() if isinstance(part, bytes) else str(part)) for part in url if part],\n                )\n            except Exception as exc:\n                raise InvalidPathParam(url) from exc\n\n        if isinstance(url, bytes):\n            url = url.decode()\n\n        if \"://\" in url:\n            raise InvalidPathParam(url)\n\n        url = urljoin(self.base_url + \"/\", url.lstrip(\"/\"))\n\n    if url is None or not isinstance(url, str):\n        raise InvalidPathParam(url)  # pragma: no cover\n\n    return url\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.get","title":"<code>get(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a GET request and return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def get(\n    self,\n    path: None | str | bytes | Iterable[str | bytes | int] = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a GET request and return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n        path: the path where the request will be sent.\n        raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n        **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n        a response object.\n\n    Raises:\n        requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"GET\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.post","title":"<code>post(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a POST request and return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def post(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a POST request and return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n      a response object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"POST\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.patch","title":"<code>patch(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a PATCH request. Return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def patch(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a PATCH request. Return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"PATCH\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.put","title":"<code>put(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a PUT request. Return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def put(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a PUT request. Return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"PUT\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.delete","title":"<code>delete(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a DELETE request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def delete(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a DELETE request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time. It takes the same\n    parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`.\n\n    Returns:\n      a response object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"DELETE\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.validate_bool_fields","title":"<code>validate_bool_fields(bool_fields)</code>","text":"<p>Validate the <code>bool_fields</code> parameter.</p> <p>It must be a sequence of 2 values. First one is the <code>True</code> value, second one is the <code>False</code> value. Both must be <code>str</code> or string-able values.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def validate_bool_fields(bool_fields: tuple[str, str]) -&gt; tuple[str, str]:\n    \"\"\"Validate the `bool_fields` parameter.\n\n    It must be a sequence of 2 values. First one is the `True` value, second one is the `False` value.\n    Both must be `str` or string-able values.\n\n    \"\"\"\n    try:\n        true_value, false_value = bool_fields\n    except ValueError:\n        raise InvalidBoolFieldsParam(bool_fields) from None\n    else:\n        return str(true_value), str(false_value)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth","title":"<code>auth</code>","text":"<p>This module contains <code>requests</code>-compatible Auth Handlers that implement OAuth 2.0.</p>"},{"location":"api/#requests_oauth2client.auth.NonRenewableTokenError","title":"<code>NonRenewableTokenError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when attempting to renew a token non-interactively when missing renewing material.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class NonRenewableTokenError(Exception):\n    \"\"\"Raised when attempting to renew a token non-interactively when missing renewing material.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AccessTokenAuth","title":"<code>OAuth2AccessTokenAuth</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Authentication Handler for OAuth 2.0 Access Tokens and (optional) Refresh Tokens.</p> <p>This Requests Auth handler implementation uses an access token as Bearer or DPoP token, and can automatically refresh it when expired, if a refresh token is available.</p> <p>Token can be a simple <code>str</code> containing a raw access token value, or a BearerToken that can contain a <code>refresh_token</code>.</p> <p>In addition to adding a properly formatted <code>Authorization</code> header, this will obtain a new token once the current token is expired. Expiration is detected based on the <code>expires_in</code> hint returned by the AS. A configurable <code>leeway</code>, in number of seconds, will make sure that a new token is obtained some seconds before the actual expiration is reached. This may help in situations where the client, AS and RS have slightly offset clocks.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the client to use to refresh tokens.</p> required <code>token</code> <code>str | BearerToken</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> required <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds.</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import BearerToken, OAuth2Client, OAuth2AccessTokenAuth, requests\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n# obtain a BearerToken any way you see fit, optionally including a refresh token\n# for this example, the token value is hardcoded\ntoken = BearerToken(access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\")\nauth = OAuth2AccessTokenAuth(client, token, scope=\"my_scope\")\nresp = requests.post(\"https://my.api.local/resource\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2AccessTokenAuth(requests.auth.AuthBase):\n    \"\"\"Authentication Handler for OAuth 2.0 Access Tokens and (optional) Refresh Tokens.\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation uses an access token as\n    Bearer or DPoP token, and can automatically refresh it when expired, if a refresh token is available.\n\n    Token can be a simple `str` containing a raw access token value, or a\n    [BearerToken][requests_oauth2client.tokens.BearerToken] that can contain a `refresh_token`.\n\n    In addition to adding a properly formatted `Authorization` header, this will obtain a new token\n    once the current token is expired. Expiration is detected based on the `expires_in` hint\n    returned by the AS. A configurable `leeway`, in number of seconds, will make sure that a new\n    token is obtained some seconds before the actual expiration is reached. This may help in\n    situations where the client, AS and RS have slightly offset clocks.\n\n    Args:\n        client: the client to use to refresh tokens.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds.\n        **token_kwargs: additional kwargs to pass to the token endpoint.\n\n    Example:\n        ```python\n        from requests_oauth2client import BearerToken, OAuth2Client, OAuth2AccessTokenAuth, requests\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        # obtain a BearerToken any way you see fit, optionally including a refresh token\n        # for this example, the token value is hardcoded\n        token = BearerToken(access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\")\n        auth = OAuth2AccessTokenAuth(client, token, scope=\"my_scope\")\n        resp = requests.post(\"https://my.api.local/resource\", auth=auth)\n        ```\n\n    \"\"\"\n\n    client: OAuth2Client = field(on_setattr=setters.frozen)\n    token: BearerToken | None\n    leeway: int = field(on_setattr=setters.frozen)\n    token_kwargs: dict[str, Any] = field(on_setattr=setters.frozen)\n\n    def __init__(\n        self, client: OAuth2Client, token: str | BearerToken, *, leeway: int = 20, **token_kwargs: Any\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(client=client, token=token, leeway=leeway, token_kwargs=token_kwargs)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the Access Token to the request.\n\n        If Access Token is not specified or expired, obtain a new one first.\n\n        Raises:\n            NonRenewableTokenError: if the token is not renewable\n\n        \"\"\"\n        if self.token is None or self.token.is_expired(self.leeway):\n            self.renew_token()\n        if self.token is None:\n            raise NonRenewableTokenError  # pragma: no cover\n        return self.token(request)\n\n    def renew_token(self) -&gt; None:\n        \"\"\"Obtain a new Bearer Token.\n\n        This will try to use the `refresh_token`, if there is one.\n\n        \"\"\"\n        if self.token is not None and self.token.refresh_token is not None:\n            self.token = self.client.refresh_token(refresh_token=self.token, **self.token_kwargs)\n\n    def forget_token(self) -&gt; None:\n        \"\"\"Forget the current token, forcing a renewal on the next HTTP request.\"\"\"\n        self.token = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AccessTokenAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new Bearer Token.</p> <p>This will try to use the <code>refresh_token</code>, if there is one.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def renew_token(self) -&gt; None:\n    \"\"\"Obtain a new Bearer Token.\n\n    This will try to use the `refresh_token`, if there is one.\n\n    \"\"\"\n    if self.token is not None and self.token.refresh_token is not None:\n        self.token = self.client.refresh_token(refresh_token=self.token, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AccessTokenAuth.forget_token","title":"<code>forget_token()</code>","text":"<p>Forget the current token, forcing a renewal on the next HTTP request.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def forget_token(self) -&gt; None:\n    \"\"\"Forget the current token, forcing a renewal on the next HTTP request.\"\"\"\n    self.token = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2ClientCredentialsAuth","title":"<code>OAuth2ClientCredentialsAuth</code>","text":"<p>               Bases: <code>OAuth2AccessTokenAuth</code></p> <p>An Auth Handler for the Client Credentials grant.</p> <p>This requests AuthBase automatically gets Access Tokens from an OAuth 2.0 Token Endpoint with the Client Credentials grant, and will get a new one once the current one is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>extra kw parameters to pass to the Token Endpoint. May include <code>scope</code>, <code>resource</code>, etc.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import OAuth2Client, OAuth2ClientCredentialsAuth, requests\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\noauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\")\nresp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2ClientCredentialsAuth(OAuth2AccessTokenAuth):\n    \"\"\"An Auth Handler for the [Client Credentials grant](https://www.rfc-editor.org/rfc/rfc6749#section-4.4).\n\n    This [requests AuthBase][requests.auth.AuthBase] automatically gets Access Tokens from an OAuth\n    2.0 Token Endpoint with the Client Credentials grant, and will get a new one once the current\n    one is expired.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds\n        **token_kwargs: extra kw parameters to pass to the Token Endpoint. May include `scope`, `resource`, etc.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, OAuth2ClientCredentialsAuth, requests\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        oauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\")\n        resp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc)\n        ```\n\n    \"\"\"\n\n    def __init__(\n        self, client: OAuth2Client, *, leeway: int = 20, token: str | BearerToken | None = None, **token_kwargs: Any\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(client=client, token=token, leeway=leeway, token_kwargs=token_kwargs)\n\n    @override\n    def renew_token(self) -&gt; None:\n        \"\"\"Obtain a new token for use within this Auth Handler.\"\"\"\n        self.token = self.client.client_credentials(**self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2ClientCredentialsAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new token for use within this Auth Handler.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@override\ndef renew_token(self) -&gt; None:\n    \"\"\"Obtain a new token for use within this Auth Handler.\"\"\"\n    self.token = self.client.client_credentials(**self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AuthorizationCodeAuth","title":"<code>OAuth2AuthorizationCodeAuth</code>","text":"<p>               Bases: <code>OAuth2AccessTokenAuth</code></p> <p>Authentication handler for the Authorization Code grant.</p> <p>This Requests Auth handler implementation exchanges an Authorization Code for an access token, then automatically refreshes it once it is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the client to use to obtain Access Tokens.</p> required <code>code</code> <code>str | AuthorizationResponse | None</code> <p>an Authorization Code that has been obtained from the AS.</p> required <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds.</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import ApiClient, OAuth2Client, OAuth2AuthorizationCodeAuth\n\nclient = OAuth2Client(token_endpoint=\"https://myas.local/token\", auth=(\"client_id\", \"client_secret\"))\ncode = \"my_code\"  # you must obtain this code yourself\napi = ApiClient(\"https://my.api.local/resource\", auth=OAuth2AuthorizationCodeAuth(client, code))\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2AuthorizationCodeAuth(OAuth2AccessTokenAuth):  # type: ignore[override]\n    \"\"\"Authentication handler for the [Authorization Code grant](https://www.rfc-editor.org/rfc/rfc6749#section-4.1).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges an Authorization\n    Code for an access token, then automatically refreshes it once it is expired.\n\n    Args:\n        client: the client to use to obtain Access Tokens.\n        code: an Authorization Code that has been obtained from the AS.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds.\n        **token_kwargs: additional kwargs to pass to the token endpoint.\n\n    Example:\n        ```python\n        from requests_oauth2client import ApiClient, OAuth2Client, OAuth2AuthorizationCodeAuth\n\n        client = OAuth2Client(token_endpoint=\"https://myas.local/token\", auth=(\"client_id\", \"client_secret\"))\n        code = \"my_code\"  # you must obtain this code yourself\n        api = ApiClient(\"https://my.api.local/resource\", auth=OAuth2AuthorizationCodeAuth(client, code))\n        ```\n\n    \"\"\"\n\n    code: str | AuthorizationResponse | None\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        code: str | AuthorizationResponse | None,\n        *,\n        leeway: int = 20,\n        token: str | BearerToken | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(\n            client=client,\n            token=token,\n            code=code,\n            leeway=leeway,\n            token_kwargs=token_kwargs,\n        )\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the Authorization Code grant as an Authentication Handler.\n\n        This exchanges an Authorization Code for an access token and adds it in the request.\n\n        Args:\n            request: the request\n\n        Returns:\n            the request, with an Access Token added in Authorization Header\n\n        \"\"\"\n        if self.token is None or self.token.is_expired():\n            self.exchange_code_for_token()\n        return super().__call__(request)\n\n    def exchange_code_for_token(self) -&gt; None:\n        \"\"\"Exchange the authorization code for an access token.\"\"\"\n        if self.code:  # pragma: no branch\n            self.token = self.client.authorization_code(code=self.code, **self.token_kwargs)\n            self.code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AuthorizationCodeAuth.exchange_code_for_token","title":"<code>exchange_code_for_token()</code>","text":"<p>Exchange the authorization code for an access token.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def exchange_code_for_token(self) -&gt; None:\n    \"\"\"Exchange the authorization code for an access token.\"\"\"\n    if self.code:  # pragma: no branch\n        self.token = self.client.authorization_code(code=self.code, **self.token_kwargs)\n        self.code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2ResourceOwnerPasswordAuth","title":"<code>OAuth2ResourceOwnerPasswordAuth</code>","text":"<p>               Bases: <code>OAuth2AccessTokenAuth</code></p> <p>Authentication Handler for the Resource Owner Password Credentials Flow.</p> <p>This Requests Auth handler implementation exchanges the user credentials for an Access Token, then automatically repeats the process to get a new one once the current one is expired.</p> <p>Note that this flow is considered deprecated, and the Authorization Code flow should be used whenever possible. Among other bad things, ROPC:</p> <ul> <li>does not support SSO between multiple apps,</li> <li>does not support MFA or risk-based adaptative authentication,</li> <li>depends on the user typing its credentials directly inside the application, instead of on a dedicated, centralized login page managed by the AS, which makes it totally insecure for 3rd party apps.</li> </ul> <p>It needs the username and password and an OAuth2Client to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the client to use to obtain Access Tokens</p> required <code>username</code> <code>str</code> <p>the username</p> required <code>password</code> <code>str</code> <p>the user password</p> required <code>leeway</code> <code>int</code> <p>an amount of time, in seconds</p> <code>20</code> <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint</p> <code>{}</code> Example <pre><code>from requests_oauth2client import ApiClient, OAuth2Client, OAuth2ResourceOwnerPasswordAuth\n\nclient = OAuth2Client(\n    token_endpoint=\"https://myas.local/token\",\n    auth=(\"client_id\", \"client_secret\"),\n)\nusername = \"my_username\"\npassword = \"my_password\"  # you must obtain those credentials from the user\nauth = OAuth2ResourceOwnerPasswordAuth(client, username=username, password=password)\napi = ApiClient(\"https://myapi.local\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2ResourceOwnerPasswordAuth(OAuth2AccessTokenAuth):  # type: ignore[override]\n    \"\"\"Authentication Handler for the [Resource Owner Password Credentials Flow](https://www.rfc-editor.org/rfc/rfc6749#section-4.3).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges the user\n    credentials for an Access Token, then automatically repeats the process to get a new one\n    once the current one is expired.\n\n    Note that this flow is considered *deprecated*, and the Authorization Code flow should be\n    used whenever possible.\n    Among other bad things, ROPC:\n\n    - does not support SSO between multiple apps,\n    - does not support MFA or risk-based adaptative authentication,\n    - depends on the user typing its credentials directly inside the application, instead of on a\n    dedicated, centralized login page managed by the AS, which makes it totally insecure for 3rd party apps.\n\n    It needs the username and password and an\n    [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be able to get a token from\n    the AS Token Endpoint just before the first request using this Auth Handler is being sent.\n\n    Args:\n        client: the client to use to obtain Access Tokens\n        username: the username\n        password: the user password\n        leeway: an amount of time, in seconds\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        **token_kwargs: additional kwargs to pass to the token endpoint\n\n    Example:\n        ```python\n        from requests_oauth2client import ApiClient, OAuth2Client, OAuth2ResourceOwnerPasswordAuth\n\n        client = OAuth2Client(\n            token_endpoint=\"https://myas.local/token\",\n            auth=(\"client_id\", \"client_secret\"),\n        )\n        username = \"my_username\"\n        password = \"my_password\"  # you must obtain those credentials from the user\n        auth = OAuth2ResourceOwnerPasswordAuth(client, username=username, password=password)\n        api = ApiClient(\"https://myapi.local\", auth=auth)\n        ```\n    \"\"\"\n\n    username: str\n    password: str\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        *,\n        username: str,\n        password: str,\n        leeway: int = 20,\n        token: str | BearerToken | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(\n            client=client,\n            token=token,\n            leeway=leeway,\n            token_kwargs=token_kwargs,\n            username=username,\n            password=password,\n        )\n\n    @override\n    def renew_token(self) -&gt; None:\n        \"\"\"Exchange the user credentials for an Access Token.\"\"\"\n        self.token = self.client.resource_owner_password(\n            username=self.username,\n            password=self.password,\n            **self.token_kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2ResourceOwnerPasswordAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Exchange the user credentials for an Access Token.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@override\ndef renew_token(self) -&gt; None:\n    \"\"\"Exchange the user credentials for an Access Token.\"\"\"\n    self.token = self.client.resource_owner_password(\n        username=self.username,\n        password=self.password,\n        **self.token_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2DeviceCodeAuth","title":"<code>OAuth2DeviceCodeAuth</code>","text":"<p>               Bases: <code>OAuth2AccessTokenAuth</code></p> <p>Authentication Handler for the Device Code Flow.</p> <p>This Requests Auth handler implementation exchanges a Device Code for an Access Token, then automatically refreshes it once it is expired.</p> <p>It needs a Device Code and an OAuth2Client to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a Device Code obtained from the AS.</p> required <code>interval</code> <code>int</code> <p>the interval to use to pool the Token Endpoint, in seconds.</p> <code>5</code> <code>expires_in</code> <code>int</code> <p>the lifetime of the token, in seconds.</p> <code>360</code> <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds.</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import OAuth2Client, OAuth2DeviceCodeAuth, requests\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\ndevice_code = client.device_authorization()\nauth = OAuth2DeviceCodeAuth(client, device_code)\nresp = requests.post(\"https://my.api.local/resource\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2DeviceCodeAuth(OAuth2AccessTokenAuth):  # type: ignore[override]\n    \"\"\"Authentication Handler for the [Device Code Flow](https://www.rfc-editor.org/rfc/rfc8628).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges a Device Code for\n    an Access Token, then automatically refreshes it once it is expired.\n\n    It needs a Device Code and an [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be\n    able to get a token from the AS Token Endpoint just before the first request using this Auth\n    Handler is being sent.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        device_code: a Device Code obtained from the AS.\n        interval: the interval to use to pool the Token Endpoint, in seconds.\n        expires_in: the lifetime of the token, in seconds.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds.\n        **token_kwargs: additional kwargs to pass to the token endpoint.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, OAuth2DeviceCodeAuth, requests\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        device_code = client.device_authorization()\n        auth = OAuth2DeviceCodeAuth(client, device_code)\n        resp = requests.post(\"https://my.api.local/resource\", auth=auth)\n        ```\n\n    \"\"\"\n\n    device_code: str | DeviceAuthorizationResponse | None\n    interval: int\n    expires_in: int\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        *,\n        device_code: str | DeviceAuthorizationResponse,\n        leeway: int = 20,\n        interval: int = 5,\n        expires_in: int = 360,\n        token: str | BearerToken | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(\n            client=client,\n            token=token,\n            leeway=leeway,\n            token_kwargs=token_kwargs,\n            device_code=device_code,\n            interval=interval,\n            expires_in=expires_in,\n        )\n\n    @override\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the Device Code grant as a request Authentication Handler.\n\n        This exchanges a Device Code for an access token and adds it in HTTP requests.\n\n        Args:\n            request: a [requests.PreparedRequest][]\n\n        Returns:\n            a [requests.PreparedRequest][] with an Access Token added in Authorization Header\n\n        \"\"\"\n        if self.token is None:\n            self.exchange_device_code_for_token()\n        return super().__call__(request)\n\n    def exchange_device_code_for_token(self) -&gt; None:\n        \"\"\"Exchange the Device Code for an access token.\n\n        This will poll the Token Endpoint until the user finishes the authorization process.\n\n        \"\"\"\n        from .device_authorization import DeviceAuthorizationPoolingJob\n\n        if self.device_code:  # pragma: no branch\n            pooling_job = DeviceAuthorizationPoolingJob(\n                client=self.client,\n                device_code=self.device_code,\n                interval=self.interval,\n            )\n            token = None\n            while token is None:\n                token = pooling_job()\n            self.token = token\n            self.device_code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2DeviceCodeAuth.exchange_device_code_for_token","title":"<code>exchange_device_code_for_token()</code>","text":"<p>Exchange the Device Code for an access token.</p> <p>This will poll the Token Endpoint until the user finishes the authorization process.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def exchange_device_code_for_token(self) -&gt; None:\n    \"\"\"Exchange the Device Code for an access token.\n\n    This will poll the Token Endpoint until the user finishes the authorization process.\n\n    \"\"\"\n    from .device_authorization import DeviceAuthorizationPoolingJob\n\n    if self.device_code:  # pragma: no branch\n        pooling_job = DeviceAuthorizationPoolingJob(\n            client=self.client,\n            device_code=self.device_code,\n            interval=self.interval,\n        )\n        token = None\n        while token is None:\n            token = pooling_job()\n        self.token = token\n        self.device_code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request","title":"<code>authorization_request</code>","text":"<p>Classes and utilities related to Authorization Requests and Responses.</p>"},{"location":"api/#requests_oauth2client.authorization_request.ResponseTypes","title":"<code>ResponseTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>All standardised <code>response_type</code> values.</p> <p>Note that you should always use <code>code</code>. All other values are deprecated.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class ResponseTypes(str, Enum):\n    \"\"\"All standardised `response_type` values.\n\n    Note that you should always use `code`. All other values are deprecated.\n\n    \"\"\"\n\n    CODE = \"code\"\n    NONE = \"none\"\n    TOKEN = \"token\"\n    IDTOKEN = \"id_token\"\n    CODE_IDTOKEN = \"code id_token\"\n    CODE_TOKEN = \"code token\"\n    CODE_IDTOKEN_TOKEN = \"code id_token token\"\n    IDTOKEN_TOKEN = \"id_token token\"\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.CodeChallengeMethods","title":"<code>CodeChallengeMethods</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>All standardised <code>code_challenge_method</code> values.</p> <p>You should always use <code>S256</code>.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class CodeChallengeMethods(str, Enum):\n    \"\"\"All standardised `code_challenge_method` values.\n\n    You should always use `S256`.\n\n    \"\"\"\n\n    S256 = \"S256\"\n    plain = \"plain\"\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.UnsupportedCodeChallengeMethod","title":"<code>UnsupportedCodeChallengeMethod</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an unsupported <code>code_challenge_method</code> is provided.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class UnsupportedCodeChallengeMethod(ValueError):\n    \"\"\"Raised when an unsupported `code_challenge_method` is provided.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.InvalidCodeVerifierParam","title":"<code>InvalidCodeVerifierParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an invalid code_verifier is supplied.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class InvalidCodeVerifierParam(ValueError):\n    \"\"\"Raised when an invalid code_verifier is supplied.\"\"\"\n\n    def __init__(self, code_verifier: str) -&gt; None:\n        super().__init__(\"\"\"\\\nInvalid 'code_verifier'. It must be a 43 to 128 characters long string, with:\n- lowercase letters\n- uppercase letters\n- digits\n- underscore, dash, tilde, or dot (_-~.)\n\"\"\")\n        self.code_verifier = code_verifier\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils","title":"<code>PkceUtils</code>","text":"<p>Contains helper methods for PKCE, as described in RFC7636.</p> <p>See RFC7636.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class PkceUtils:\n    \"\"\"Contains helper methods for PKCE, as described in RFC7636.\n\n    See [RFC7636](https://tools.ietf.org/html/rfc7636).\n\n    \"\"\"\n\n    code_verifier_pattern = re.compile(r\"^[a-zA-Z0-9_\\-~.]{43,128}$\")\n    \"\"\"A regex that matches valid code verifiers.\"\"\"\n\n    @classmethod\n    def generate_code_verifier(cls) -&gt; str:\n        \"\"\"Generate a valid `code_verifier`.\n\n        Returns:\n            a `code_verifier` ready to use for PKCE\n\n        \"\"\"\n        return secrets.token_urlsafe(96)\n\n    @classmethod\n    def derive_challenge(cls, verifier: str | bytes, method: str = CodeChallengeMethods.S256) -&gt; str:\n        \"\"\"Derive the `code_challenge` from a given `code_verifier`.\n\n        Args:\n            verifier: a code verifier\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            a `code_challenge` derived from the given verifier\n\n        Raises:\n            InvalidCodeVerifierParam: if the `verifier` does not match `code_verifier_pattern`\n            UnsupportedCodeChallengeMethod: if the method is not supported\n\n        \"\"\"\n        if isinstance(verifier, bytes):\n            verifier = verifier.decode()\n\n        if not cls.code_verifier_pattern.match(verifier):\n            raise InvalidCodeVerifierParam(verifier)\n\n        if method == CodeChallengeMethods.S256:\n            return BinaPy(verifier).to(\"sha256\").to(\"b64u\").ascii()\n        if method == CodeChallengeMethods.plain:\n            return verifier\n\n        raise UnsupportedCodeChallengeMethod(method)\n\n    @classmethod\n    def generate_code_verifier_and_challenge(cls, method: str = CodeChallengeMethods.S256) -&gt; tuple[str, str]:\n        \"\"\"Generate a valid `code_verifier` and its matching `code_challenge`.\n\n        Args:\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            a `(code_verifier, code_challenge)` tuple.\n\n        \"\"\"\n        verifier = cls.generate_code_verifier()\n        challenge = cls.derive_challenge(verifier, method)\n        return verifier, challenge\n\n    @classmethod\n    def validate_code_verifier(cls, verifier: str, challenge: str, method: str = CodeChallengeMethods.S256) -&gt; bool:\n        \"\"\"Validate a `code_verifier` against a `code_challenge`.\n\n        Args:\n            verifier: the `code_verifier`, exactly as submitted by the client on token request.\n            challenge: the `code_challenge`, exactly as submitted by the client on authorization request.\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            `True` if verifier is valid, or `False` otherwise\n\n        \"\"\"\n        return (\n            cls.code_verifier_pattern.match(verifier) is not None\n            and cls.derive_challenge(verifier, method) == challenge\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.code_verifier_pattern","title":"<code>code_verifier_pattern = re.compile('^[a-zA-Z0-9_\\\\-~.]{43,128}$')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A regex that matches valid code verifiers.</p>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.generate_code_verifier","title":"<code>generate_code_verifier()</code>  <code>classmethod</code>","text":"<p>Generate a valid <code>code_verifier</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>a <code>code_verifier</code> ready to use for PKCE</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_code_verifier(cls) -&gt; str:\n    \"\"\"Generate a valid `code_verifier`.\n\n    Returns:\n        a `code_verifier` ready to use for PKCE\n\n    \"\"\"\n    return secrets.token_urlsafe(96)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.derive_challenge","title":"<code>derive_challenge(verifier, method=CodeChallengeMethods.S256)</code>  <code>classmethod</code>","text":"<p>Derive the <code>code_challenge</code> from a given <code>code_verifier</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>str | bytes</code> <p>a code verifier</p> required <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>S256</code> <p>Returns:</p> Type Description <code>str</code> <p>a <code>code_challenge</code> derived from the given verifier</p> <p>Raises:</p> Type Description <code>InvalidCodeVerifierParam</code> <p>if the <code>verifier</code> does not match <code>code_verifier_pattern</code></p> <code>UnsupportedCodeChallengeMethod</code> <p>if the method is not supported</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef derive_challenge(cls, verifier: str | bytes, method: str = CodeChallengeMethods.S256) -&gt; str:\n    \"\"\"Derive the `code_challenge` from a given `code_verifier`.\n\n    Args:\n        verifier: a code verifier\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        a `code_challenge` derived from the given verifier\n\n    Raises:\n        InvalidCodeVerifierParam: if the `verifier` does not match `code_verifier_pattern`\n        UnsupportedCodeChallengeMethod: if the method is not supported\n\n    \"\"\"\n    if isinstance(verifier, bytes):\n        verifier = verifier.decode()\n\n    if not cls.code_verifier_pattern.match(verifier):\n        raise InvalidCodeVerifierParam(verifier)\n\n    if method == CodeChallengeMethods.S256:\n        return BinaPy(verifier).to(\"sha256\").to(\"b64u\").ascii()\n    if method == CodeChallengeMethods.plain:\n        return verifier\n\n    raise UnsupportedCodeChallengeMethod(method)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.generate_code_verifier_and_challenge","title":"<code>generate_code_verifier_and_challenge(method=CodeChallengeMethods.S256)</code>  <code>classmethod</code>","text":"<p>Generate a valid <code>code_verifier</code> and its matching <code>code_challenge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>S256</code> <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>a <code>(code_verifier, code_challenge)</code> tuple.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_code_verifier_and_challenge(cls, method: str = CodeChallengeMethods.S256) -&gt; tuple[str, str]:\n    \"\"\"Generate a valid `code_verifier` and its matching `code_challenge`.\n\n    Args:\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        a `(code_verifier, code_challenge)` tuple.\n\n    \"\"\"\n    verifier = cls.generate_code_verifier()\n    challenge = cls.derive_challenge(verifier, method)\n    return verifier, challenge\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.validate_code_verifier","title":"<code>validate_code_verifier(verifier, challenge, method=CodeChallengeMethods.S256)</code>  <code>classmethod</code>","text":"<p>Validate a <code>code_verifier</code> against a <code>code_challenge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>str</code> <p>the <code>code_verifier</code>, exactly as submitted by the client on token request.</p> required <code>challenge</code> <code>str</code> <p>the <code>code_challenge</code>, exactly as submitted by the client on authorization request.</p> required <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>S256</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if verifier is valid, or <code>False</code> otherwise</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef validate_code_verifier(cls, verifier: str, challenge: str, method: str = CodeChallengeMethods.S256) -&gt; bool:\n    \"\"\"Validate a `code_verifier` against a `code_challenge`.\n\n    Args:\n        verifier: the `code_verifier`, exactly as submitted by the client on token request.\n        challenge: the `code_challenge`, exactly as submitted by the client on authorization request.\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        `True` if verifier is valid, or `False` otherwise\n\n    \"\"\"\n    return (\n        cls.code_verifier_pattern.match(verifier) is not None\n        and cls.derive_challenge(verifier, method) == challenge\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.UnsupportedResponseTypeParam","title":"<code>UnsupportedResponseTypeParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an unsupported response_type is passed as parameter.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class UnsupportedResponseTypeParam(ValueError):\n    \"\"\"Raised when an unsupported response_type is passed as parameter.\"\"\"\n\n    def __init__(self, response_type: str) -&gt; None:\n        super().__init__(\"\"\"The only supported response type is 'code'.\"\"\", response_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.MissingIssuerParam","title":"<code>MissingIssuerParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when the 'issuer' parameter is required but not provided.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class MissingIssuerParam(ValueError):\n    \"\"\"Raised when the 'issuer' parameter is required but not provided.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"\"\"\\\nWhen 'authorization_response_iss_parameter_supported' is `True`, you must\nprovide the expected `issuer` as parameter.\n\"\"\")\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.InvalidMaxAgeParam","title":"<code>InvalidMaxAgeParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an invalid 'max_age' parameter is provided.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class InvalidMaxAgeParam(ValueError):\n    \"\"\"Raised when an invalid 'max_age' parameter is provided.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"\"\"\\\nInvalid 'max_age' parameter. It must be a positive number of seconds.\nThis specifies the allowable elapsed time in seconds since the last time\nthe End-User was actively authenticated by the OP.\n\"\"\")\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationResponse","title":"<code>AuthorizationResponse</code>","text":"<p>Represent a successful Authorization Response.</p> <p>An Authorization Response is the redirection initiated by the AS to the client's redirection endpoint (redirect_uri), after an Authorization Request. This Response is typically created with a call to <code>AuthorizationRequest.validate_callback()</code> once the call to the client Redirection Endpoint is made. <code>AuthorizationResponse</code> contains the following attributes:</p> <ul> <li>all the parameters that have been returned by the AS, most notably the <code>code</code>, and optional    parameters such as <code>state</code>.</li> <li>the <code>redirect_uri</code> that was used for the Authorization Request</li> <li>the <code>code_verifier</code> matching the <code>code_challenge</code> that was used for the Authorization Request</li> </ul> <p>Parameters <code>redirect_uri</code> and <code>code_verifier</code> must be those from the matching <code>AuthorizationRequest</code>. All other parameters including <code>code</code> and <code>state</code> must be those extracted from the Authorization Response parameters.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>The authorization <code>code</code> returned by the AS.</p> required <code>redirect_uri</code> <code>str | None</code> <p>The <code>redirect_uri</code> that was passed as parameter in the Authorization Request.</p> <code>None</code> <code>code_verifier</code> <code>str | None</code> <p>the <code>code_verifier</code> matching the <code>code_challenge</code> that was passed as parameter in the Authorization Request.</p> <code>None</code> <code>state</code> <code>str | None</code> <p>the <code>state</code> that was was passed as parameter in the Authorization Request and returned by the AS.</p> <code>None</code> <code>nonce</code> <code>str | None</code> <p>the <code>nonce</code> that was was passed as parameter in the Authorization Request.</p> <code>None</code> <code>acr_values</code> <code>str | Sequence[str] | None</code> <p>the <code>acr_values</code> that was passed as parameter in the Authorization Request.</p> <code>None</code> <code>max_age</code> <code>int | None</code> <p>the <code>max_age</code> that was passed as parameter in the Authorization Request.</p> <code>None</code> <code>issuer</code> <code>str | None</code> <p>the expected <code>issuer</code> identifier.</p> <code>None</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used for Authorization Code DPoP binding.</p> <code>None</code> <code>**kwargs</code> <code>str</code> <p>other parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass AuthorizationResponse:\n    \"\"\"Represent a successful Authorization Response.\n\n    An Authorization Response is the redirection initiated by the AS to the client's redirection\n    endpoint (redirect_uri), after an Authorization Request.\n    This Response is typically created with a call to `AuthorizationRequest.validate_callback()`\n    once the call to the client Redirection Endpoint is made.\n    `AuthorizationResponse` contains the following attributes:\n\n     - all the parameters that have been returned by the AS, most notably the `code`, and optional\n       parameters such as `state`.\n     - the `redirect_uri` that was used for the Authorization Request\n     - the `code_verifier` matching the `code_challenge` that was used for the Authorization Request\n\n    Parameters `redirect_uri` and `code_verifier` must be those from the matching\n    `AuthorizationRequest`. All other parameters including `code` and `state` must be those\n    extracted from the Authorization Response parameters.\n\n    Args:\n        code: The authorization `code` returned by the AS.\n        redirect_uri: The `redirect_uri` that was passed as parameter in the Authorization Request.\n        code_verifier: the `code_verifier` matching the `code_challenge` that was passed as\n            parameter in the Authorization Request.\n        state: the `state` that was was passed as parameter in the Authorization Request and returned by the AS.\n        nonce: the `nonce` that was was passed as parameter in the Authorization Request.\n        acr_values: the `acr_values` that was passed as parameter in the Authorization Request.\n        max_age: the `max_age` that was passed as parameter in the Authorization Request.\n        issuer: the expected `issuer` identifier.\n        dpop_key: the `DPoPKey` that was used for Authorization Code DPoP binding.\n        **kwargs: other parameters as returned by the AS.\n\n    \"\"\"\n\n    code: str\n    redirect_uri: str | None\n    code_verifier: str | None\n    state: str | None\n    nonce: str | None\n    acr_values: tuple[str, ...] | None\n    max_age: int | None\n    issuer: str | None\n    dpop_key: DPoPKey | None\n    kwargs: dict[str, Any]\n\n    def __init__(\n        self,\n        *,\n        code: str,\n        redirect_uri: str | None = None,\n        code_verifier: str | None = None,\n        state: str | None = None,\n        nonce: str | None = None,\n        acr_values: str | Sequence[str] | None = None,\n        max_age: int | None = None,\n        issuer: str | None = None,\n        dpop_key: DPoPKey | None = None,\n        **kwargs: str,\n    ) -&gt; None:\n        if not acr_values:\n            acr_values = None\n        elif isinstance(acr_values, str):\n            acr_values = tuple(acr_values.split(\" \"))\n        else:\n            acr_values = tuple(acr_values)\n\n        self.__attrs_init__(\n            code=code,\n            redirect_uri=redirect_uri,\n            code_verifier=code_verifier,\n            state=state,\n            nonce=nonce,\n            acr_values=acr_values,\n            max_age=max_age,\n            issuer=issuer,\n            dpop_key=dpop_key,\n            kwargs=kwargs,\n        )\n\n    def __getattr__(self, item: str) -&gt; str | None:\n        \"\"\"Make additional parameters available as attributes.\n\n        Args:\n            item: the attribute name\n\n        Returns:\n            the attribute value, or None if it isn't part of the returned attributes\n\n        \"\"\"\n        return self.kwargs.get(item)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest","title":"<code>AuthorizationRequest</code>","text":"<p>Represent an Authorization Request.</p> <p>This class makes it easy to generate valid Authorization Request URI (possibly including a state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization Response.</p> <p>All parameters passed at init time will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour:</p> <ul> <li><code>state</code>: if <code>...</code> (default), a random <code>state</code> parameter will be generated for you.   You may pass your own <code>state</code> as <code>str</code>, or set it to <code>None</code> so that the <code>state</code> parameter   will not be included in the request. You may access that state in the <code>state</code> attribute   from this request.</li> <li><code>nonce</code>: if <code>...</code> (default) and <code>scope</code> includes 'openid', a random <code>nonce</code> will be   generated and included in the request. You may access that <code>nonce</code> in the <code>nonce</code> attribute   from this request.</li> <li><code>code_verifier</code>: if <code>None</code>, and <code>code_challenge_method</code> is <code>'S256'</code> or <code>'plain'</code>,   a valid <code>code_challenge</code> and <code>code_verifier</code> for PKCE will be automatically generated,   and the <code>code_challenge</code> will be included in the request.   You may pass your own <code>code_verifier</code> as a <code>str</code> parameter, in which case the   appropriate <code>code_challenge</code> will be included in the request, according to the   <code>code_challenge_method</code>.</li> <li> <p><code>authorization_response_iss_parameter_supported</code> and <code>issuer</code>:    those are used for Server Issuer Identification. By default:</p> <ul> <li>If <code>\u00ecssuer</code> is set and an issuer is included in the Authorization Response, then the consistency between those 2 values will be checked when using <code>validate_callback()</code>.</li> <li>If issuer is not included in the response, then no issuer check is performed.</li> </ul> <p>Set <code>authorization_response_iss_parameter_supported</code> to <code>True</code> to enforce server identification:</p> <ul> <li>an <code>issuer</code> must also be provided as parameter, and the AS must return that same value for the response to be considered valid by <code>validate_callback()</code>.</li> <li>if no issuer is included in the Authorization Response, then an error will be raised.</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the uri for the authorization endpoint.</p> required <code>client_id</code> <code>str</code> <p>the client_id to include in the request.</p> required <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri to include in the request. This is required in OAuth 2.0 and optional in OAuth 2.1. Pass <code>None</code> if you don't need any redirect_uri in the Authorization Request.</p> <code>None</code> <code>scope</code> <code>None | str | Iterable[str]</code> <p>the scope to include in the request, as an iterable of <code>str</code>, or a single space-separated <code>str</code>.</p> <code>'openid'</code> <code>response_type</code> <code>str</code> <p>the response type to include in the request.</p> <code>CODE</code> <code>state</code> <code>str | ellipsis | None</code> <p>the state to include in the request, or <code>...</code> to autogenerate one (default).</p> <code>...</code> <code>nonce</code> <code>str | ellipsis | None</code> <p>the nonce to include in the request, or <code>...</code> to autogenerate one (default).</p> <code>...</code> <code>code_verifier</code> <code>str | None</code> <p>the code verifier to include in the request. If left as <code>None</code> and <code>code_challenge_method</code> is set, a valid code_verifier will be generated.</p> <code>None</code> <code>code_challenge_method</code> <code>str | None</code> <p>the method to use to derive the <code>code_challenge</code> from the <code>code_verifier</code>.</p> <code>S256</code> <code>acr_values</code> <code>str | Iterable[str] | None</code> <p>requested Authentication Context Class Reference values.</p> <code>None</code> <code>issuer</code> <code>str | None</code> <p>Issuer Identifier value from the OAuth/OIDC Server, if using Server Issuer Identification.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>extra parameters to include in the request, as-is.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import AuthorizationRequest\n\nazr = AuthorizationRequest(\n    authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n    client_id=\"my_client_id\",\n    redirect_uri=\"http://localhost/callback\",\n    scope=\"openid email profile\",\n)\nprint(azr)\n</code></pre> <p>Raises:</p> Type Description <code>InvalidMaxAgeParam</code> <p>if the <code>max_age</code> parameter is invalid.</p> <code>MissingIssuerParam</code> <p>if <code>authorization_response_iss_parameter_supported</code> is set to <code>True</code> but the <code>issuer</code> parameter is not provided.</p> <code>UnsupportedResponseTypeParam</code> <p>if <code>response_type</code> is not supported.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False, repr=False)\nclass AuthorizationRequest:\n    \"\"\"Represent an Authorization Request.\n\n    This class makes it easy to generate valid Authorization Request URI (possibly including a\n    state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization\n    Response.\n\n    All parameters passed at init time will be included in the request query parameters as-is,\n    excepted for a few parameters which have a special behaviour:\n\n    - `state`: if `...` (default), a random `state` parameter will be generated for you.\n      You may pass your own `state` as `str`, or set it to `None` so that the `state` parameter\n      will not be included in the request. You may access that state in the `state` attribute\n      from this request.\n    - `nonce`: if `...` (default) and `scope` includes 'openid', a random `nonce` will be\n      generated and included in the request. You may access that `nonce` in the `nonce` attribute\n      from this request.\n    - `code_verifier`: if `None`, and `code_challenge_method` is `'S256'` or `'plain'`,\n      a valid `code_challenge` and `code_verifier` for PKCE will be automatically generated,\n      and the `code_challenge` will be included in the request.\n      You may pass your own `code_verifier` as a `str` parameter, in which case the\n      appropriate `code_challenge` will be included in the request, according to the\n      `code_challenge_method`.\n    - `authorization_response_iss_parameter_supported` and `issuer`:\n       those are used for Server Issuer Identification. By default:\n\n        - If `\u00ecssuer` is set and an issuer is included in the Authorization Response,\n        then the consistency between those 2 values will be checked when using `validate_callback()`.\n        - If issuer is not included in the response, then no issuer check is performed.\n\n        Set `authorization_response_iss_parameter_supported` to `True` to enforce server identification:\n\n        - an `issuer` must also be provided as parameter, and the AS must return that same value\n        for the response to be considered valid by `validate_callback()`.\n        - if no issuer is included in the Authorization Response, then an error will be raised.\n\n    Args:\n        authorization_endpoint: the uri for the authorization endpoint.\n        client_id: the client_id to include in the request.\n        redirect_uri: the redirect_uri to include in the request. This is required in OAuth 2.0 and optional\n            in OAuth 2.1. Pass `None` if you don't need any redirect_uri in the Authorization\n            Request.\n        scope: the scope to include in the request, as an iterable of `str`, or a single space-separated `str`.\n        response_type: the response type to include in the request.\n        state: the state to include in the request, or `...` to autogenerate one (default).\n        nonce: the nonce to include in the request, or `...` to autogenerate one (default).\n        code_verifier: the code verifier to include in the request.\n            If left as `None` and `code_challenge_method` is set, a valid code_verifier\n            will be generated.\n        code_challenge_method: the method to use to derive the `code_challenge` from the `code_verifier`.\n        acr_values: requested Authentication Context Class Reference values.\n        issuer: Issuer Identifier value from the OAuth/OIDC Server, if using Server Issuer Identification.\n        **kwargs: extra parameters to include in the request, as-is.\n\n    Example:\n        ```python\n        from requests_oauth2client import AuthorizationRequest\n\n        azr = AuthorizationRequest(\n            authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n            client_id=\"my_client_id\",\n            redirect_uri=\"http://localhost/callback\",\n            scope=\"openid email profile\",\n        )\n        print(azr)\n        ```\n\n    Raises:\n        InvalidMaxAgeParam: if the `max_age` parameter is invalid.\n        MissingIssuerParam: if `authorization_response_iss_parameter_supported` is set to `True`\n            but the `issuer` parameter is not provided.\n        UnsupportedResponseTypeParam: if `response_type` is not supported.\n\n    \"\"\"\n\n    authorization_endpoint: str\n\n    client_id: str = field(metadata={\"query\": True})\n    redirect_uri: str | None = field(metadata={\"query\": True})\n    scope: tuple[str, ...] | None = field(metadata={\"query\": True})\n    response_type: str = field(metadata={\"query\": True})\n    state: str | None = field(metadata={\"query\": True})\n    nonce: str | None = field(metadata={\"query\": True})\n    code_challenge_method: str | None = field(metadata={\"query\": True})\n    acr_values: tuple[str, ...] | None = field(metadata={\"query\": True})\n    max_age: int | None = field(metadata={\"query\": True})\n    kwargs: dict[str, Any]\n\n    code_verifier: str | None\n    authorization_response_iss_parameter_supported: bool\n    issuer: str | None\n\n    dpop_key: DPoPKey | None = None\n\n    exception_classes: ClassVar[dict[str, type[AuthorizationResponseError]]] = {\n        \"interaction_required\": InteractionRequired,\n        \"login_required\": LoginRequired,\n        \"session_selection_required\": SessionSelectionRequired,\n        \"consent_required\": ConsentRequired,\n    }\n\n    @classmethod\n    def generate_state(cls) -&gt; str:\n        \"\"\"Generate a random `state` parameter.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    @classmethod\n    def generate_nonce(cls) -&gt; str:\n        \"\"\"Generate a random `nonce`.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    def __init__(  # noqa: PLR0913, C901\n        self,\n        authorization_endpoint: str,\n        *,\n        client_id: str,\n        redirect_uri: str | None = None,\n        scope: None | str | Iterable[str] = \"openid\",\n        response_type: str = ResponseTypes.CODE,\n        state: str | ellipsis | None = ...,  # noqa: F821\n        nonce: str | ellipsis | None = ...,  # noqa: F821\n        code_verifier: str | None = None,\n        code_challenge_method: str | None = CodeChallengeMethods.S256,\n        acr_values: str | Iterable[str] | None = None,\n        max_age: int | None = None,\n        issuer: str | None = None,\n        authorization_response_iss_parameter_supported: bool = False,\n        dpop: bool = False,\n        dpop_alg: str = SignatureAlgs.ES256,\n        dpop_key: DPoPKey | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        if response_type != ResponseTypes.CODE:\n            raise UnsupportedResponseTypeParam(response_type)\n\n        if authorization_response_iss_parameter_supported and not issuer:\n            raise MissingIssuerParam\n\n        if state is ...:\n            state = self.generate_state()\n        if state is not None and not isinstance(state, str):\n            state = str(state)  # pragma: no cover\n\n        if nonce is ...:\n            nonce = self.generate_nonce() if scope is not None and \"openid\" in scope else None\n        if nonce is not None and not isinstance(nonce, str):\n            nonce = str(nonce)  # pragma: no cover\n\n        if not scope:\n            scope = None\n\n        if scope is not None:\n            scope = tuple(scope.split(\" \")) if isinstance(scope, str) else tuple(scope)\n\n        if acr_values is not None:\n            acr_values = tuple(acr_values.split()) if isinstance(acr_values, str) else tuple(acr_values)\n\n        if max_age is not None and max_age &lt; 0:\n            raise InvalidMaxAgeParam\n\n        if \"code_challenge\" in kwargs:\n            msg = (\n                \"A `code_challenge` must not be passed as parameter. Pass the `code_verifier`\"\n                \" instead, and the appropriate `code_challenge` will automatically be derived\"\n                \" from it and included in the request, based on `code_challenge_method`.\"\n            )\n            raise ValueError(msg)\n\n        if code_challenge_method:\n            if not code_verifier:\n                code_verifier = PkceUtils.generate_code_verifier()\n        else:\n            code_verifier = None\n\n        if dpop and not dpop_key:\n            dpop_key = DPoPKey.generate(dpop_alg)\n\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            redirect_uri=redirect_uri,\n            issuer=issuer,\n            response_type=response_type,\n            scope=scope,\n            state=state,\n            nonce=nonce,\n            code_verifier=code_verifier,\n            code_challenge_method=code_challenge_method,\n            acr_values=acr_values,\n            max_age=max_age,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            dpop_key=dpop_key,\n            kwargs=kwargs,\n        )\n\n    @cached_property\n    def code_challenge(self) -&gt; str | None:\n        \"\"\"The `code_challenge` that matches `code_verifier` and `code_challenge_method`.\"\"\"\n        if self.code_verifier and self.code_challenge_method:\n            return PkceUtils.derive_challenge(self.code_verifier, self.code_challenge_method)\n        return None\n\n    @cached_property\n    def dpop_jkt(self) -&gt; str | None:\n        \"\"\"The DPoP JWK thumbprint that matches ``dpop_key`.\"\"\"\n        if self.dpop_key:\n            return self.dpop_key.dpop_jkt\n        return None\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the full argument dict.\n\n        This can be used to serialize this request and/or to initialize a similar request.\n\n        \"\"\"\n        d = asdict(self)\n        d.update(**d.pop(\"kwargs\", {}))\n        return d\n\n    @property\n    def args(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dict with all the query parameters from this AuthorizationRequest.\n\n        Returns:\n            a dict of parameters\n\n        \"\"\"\n        d = {field.name: getattr(self, field.name) for field in fields(type(self)) if field.metadata.get(\"query\")}\n        if d[\"scope\"]:\n            d[\"scope\"] = \" \".join(d[\"scope\"])\n        d[\"code_challenge\"] = self.code_challenge\n        d[\"dpop_jkt\"] = self.dpop_jkt\n        d.update(self.kwargs)\n\n        return {key: val for key, val in d.items() if val is not None}\n\n    def validate_callback(self, response: str) -&gt; AuthorizationResponse:\n        \"\"\"Validate an Authorization Response against this Request.\n\n        Validate a given Authorization Response URI against this Authorization Request, and return\n        an [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse].\n\n        This includes matching the `state` parameter, checking for returned errors, and extracting\n        the returned `code` and other parameters.\n\n        Args:\n            response: the Authorization Response URI. This can be the full URL, or just the\n                query parameters (still encoded as x-www-form-urlencoded).\n\n        Returns:\n            the extracted code, if all checks are successful\n\n        Raises:\n            MissingAuthCode: if the `code` is missing in the response\n            MissingIssuer: if Server Issuer verification is active and the response does\n                not contain an `iss`.\n            MismatchingIssuer: if the 'iss' received from the response does not match the\n                expected value.\n            MismatchingState: if the response `state` does not match the expected value.\n            OAuth2Error: if the response includes an error.\n            MissingAuthCode: if the response does not contain a `code`.\n            UnsupportedResponseTypeParam: if response_type anything else than 'code'.\n\n        \"\"\"\n        try:\n            response_url = furl(response)\n        except ValueError:\n            return self.on_response_error(response)\n\n        # validate 'iss' according to RFC9207\n        received_issuer = response_url.args.get(\"iss\")\n        if self.authorization_response_iss_parameter_supported or received_issuer:\n            if received_issuer is None:\n                raise MissingIssuer(self, response)\n            if self.issuer and received_issuer != self.issuer:\n                raise MismatchingIssuer(self.issuer, received_issuer, self, response)\n\n        # validate state\n        requested_state = self.state\n        if requested_state:\n            received_state = response_url.args.get(\"state\")\n            if requested_state != received_state:\n                raise MismatchingState(requested_state, received_state, self, response)\n\n        error = response_url.args.get(\"error\")\n        if error:\n            return self.on_response_error(response)\n\n        if self.response_type == ResponseTypes.CODE:\n            code: str = response_url.args.get(\"code\")\n            if code is None:\n                raise MissingAuthCode(self, response)\n        else:\n            raise UnsupportedResponseTypeParam(self.response_type)  # pragma: no cover\n\n        return AuthorizationResponse(\n            code_verifier=self.code_verifier,\n            redirect_uri=self.redirect_uri,\n            nonce=self.nonce,\n            acr_values=self.acr_values,\n            max_age=self.max_age,\n            dpop_key=self.dpop_key,\n            **response_url.args,\n        )\n\n    def sign_request_jwt(\n        self,\n        jwk: Jwk | dict[str, Any],\n        alg: str | None = None,\n        lifetime: int | None = None,\n    ) -&gt; SignedJwt:\n        \"\"\"Sign the `request` object that matches this Authorization Request parameters.\n\n        Args:\n            jwk: the JWK to use to sign the request\n            alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n            lifetime: an optional number of seconds of validity for the signed request.\n                If present, `iat` an `exp` claims will be included in the signed JWT.\n\n        Returns:\n            a `Jwt` that contains the signed request object.\n\n        \"\"\"\n        claims = self.args\n        if lifetime:\n            claims[\"iat\"] = Jwt.timestamp()\n            claims[\"exp\"] = Jwt.timestamp(lifetime)\n        return Jwt.sign(\n            claims,\n            key=jwk,\n            alg=alg,\n        )\n\n    def sign(\n        self,\n        jwk: Jwk | dict[str, Any],\n        alg: str | None = None,\n        lifetime: int | None = None,\n        **kwargs: Any,\n    ) -&gt; RequestParameterAuthorizationRequest:\n        \"\"\"Sign this Authorization Request and return a new one.\n\n        This replaces all parameters with a signed `request` JWT.\n\n        Args:\n            jwk: the JWK to use to sign the request\n            alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, don't use an 'exp' claim.\n            kwargs: additional query parameters to include in the signed authorization request\n\n        Returns:\n            the signed Authorization Request\n\n        \"\"\"\n        request_jwt = self.sign_request_jwt(jwk, alg, lifetime)\n        return RequestParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request=str(request_jwt),\n            expires_at=request_jwt.expires_at,\n            **kwargs,\n        )\n\n    def sign_and_encrypt_request_jwt(\n        self,\n        sign_jwk: Jwk | dict[str, Any],\n        enc_jwk: Jwk | dict[str, Any],\n        sign_alg: str | None = None,\n        enc_alg: str | None = None,\n        enc: str = \"A128CBC-HS256\",\n        lifetime: int | None = None,\n    ) -&gt; JweCompact:\n        \"\"\"Sign and encrypt a `request` object for this Authorization Request.\n\n        The signed `request` will contain the same parameters as this AuthorizationRequest.\n\n        Args:\n            sign_jwk: the JWK to use to sign the request\n            enc_jwk: the JWK to use to encrypt the request\n            sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n            enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n            enc: the encoding to use to encrypt the request.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, do not include an 'exp' claim.\n\n        Returns:\n            the signed and encrypted request object, as a `jwskate.Jwt`\n\n        \"\"\"\n        claims = self.args\n        if lifetime:\n            claims[\"iat\"] = Jwt.timestamp()\n            claims[\"exp\"] = Jwt.timestamp(lifetime)\n        return Jwt.sign_and_encrypt(\n            claims=claims,\n            sign_key=sign_jwk,\n            sign_alg=sign_alg,\n            enc_key=enc_jwk,\n            enc_alg=enc_alg,\n            enc=enc,\n        )\n\n    def sign_and_encrypt(\n        self,\n        sign_jwk: Jwk | dict[str, Any],\n        enc_jwk: Jwk | dict[str, Any],\n        sign_alg: str | None = None,\n        enc_alg: str | None = None,\n        enc: str = \"A128CBC-HS256\",\n        lifetime: int | None = None,\n    ) -&gt; RequestParameterAuthorizationRequest:\n        \"\"\"Sign and encrypt the current Authorization Request.\n\n        This replaces all parameters with a matching `request` object.\n\n        Args:\n            sign_jwk: the JWK to use to sign the request\n            enc_jwk: the JWK to use to encrypt the request\n            sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n            enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n            enc: the encoding to use to encrypt the request.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, do not include an 'exp' claim.\n\n        Returns:\n            a `RequestParameterAuthorizationRequest`, with a request object as parameter\n\n        \"\"\"\n        request_jwt = self.sign_and_encrypt_request_jwt(\n            sign_jwk=sign_jwk,\n            enc_jwk=enc_jwk,\n            sign_alg=sign_alg,\n            enc_alg=enc_alg,\n            enc=enc,\n            lifetime=lifetime,\n        )\n        return RequestParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request=str(request_jwt),\n        )\n\n    def on_response_error(self, response: str) -&gt; AuthorizationResponse:\n        \"\"\"Error handler for Authorization Response errors.\n\n        Triggered by\n        [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback]\n        if the response uri contains an error.\n\n        Args:\n            response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n        Returns:\n            may return a default code that will be returned by `validate_callback`. But this method\n            will most likely raise exceptions instead.\n\n        Raises:\n            AuthorizationResponseError: if the response contains an `error`. The raised exception may be a subclass\n\n        \"\"\"\n        response_url = furl(response)\n        error = response_url.args.get(\"error\")\n        error_description = response_url.args.get(\"error_description\")\n        error_uri = response_url.args.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, AuthorizationResponseError)\n        raise exception_class(\n            request=self, response=response, error=error, description=error_description, uri=error_uri\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl`.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args=self.args,\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.code_challenge","title":"<code>code_challenge</code>  <code>cached</code> <code>property</code>","text":"<p>The <code>code_challenge</code> that matches <code>code_verifier</code> and <code>code_challenge_method</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.dpop_jkt","title":"<code>dpop_jkt</code>  <code>cached</code> <code>property</code>","text":"<p>The DPoP JWK thumbprint that matches <code>`dpop_key</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.args","title":"<code>args</code>  <code>property</code>","text":"<p>Return a dict with all the query parameters from this AuthorizationRequest.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>a dict of parameters</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.furl","title":"<code>furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.uri","title":"<code>uri</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.generate_state","title":"<code>generate_state()</code>  <code>classmethod</code>","text":"<p>Generate a random <code>state</code> parameter.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_state(cls) -&gt; str:\n    \"\"\"Generate a random `state` parameter.\"\"\"\n    return secrets.token_urlsafe(32)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.generate_nonce","title":"<code>generate_nonce()</code>  <code>classmethod</code>","text":"<p>Generate a random <code>nonce</code>.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_nonce(cls) -&gt; str:\n    \"\"\"Generate a random `nonce`.\"\"\"\n    return secrets.token_urlsafe(32)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the full argument dict.</p> <p>This can be used to serialize this request and/or to initialize a similar request.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the full argument dict.\n\n    This can be used to serialize this request and/or to initialize a similar request.\n\n    \"\"\"\n    d = asdict(self)\n    d.update(**d.pop(\"kwargs\", {}))\n    return d\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback","title":"<code>validate_callback(response)</code>","text":"<p>Validate an Authorization Response against this Request.</p> <p>Validate a given Authorization Response URI against this Authorization Request, and return an AuthorizationResponse.</p> <p>This includes matching the <code>state</code> parameter, checking for returned errors, and extracting the returned <code>code</code> and other parameters.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>the Authorization Response URI. This can be the full URL, or just the query parameters (still encoded as x-www-form-urlencoded).</p> required <p>Returns:</p> Type Description <code>AuthorizationResponse</code> <p>the extracted code, if all checks are successful</p> <p>Raises:</p> Type Description <code>MissingAuthCode</code> <p>if the <code>code</code> is missing in the response</p> <code>MissingIssuer</code> <p>if Server Issuer verification is active and the response does not contain an <code>iss</code>.</p> <code>MismatchingIssuer</code> <p>if the 'iss' received from the response does not match the expected value.</p> <code>MismatchingState</code> <p>if the response <code>state</code> does not match the expected value.</p> <code>OAuth2Error</code> <p>if the response includes an error.</p> <code>MissingAuthCode</code> <p>if the response does not contain a <code>code</code>.</p> <code>UnsupportedResponseTypeParam</code> <p>if response_type anything else than 'code'.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def validate_callback(self, response: str) -&gt; AuthorizationResponse:\n    \"\"\"Validate an Authorization Response against this Request.\n\n    Validate a given Authorization Response URI against this Authorization Request, and return\n    an [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse].\n\n    This includes matching the `state` parameter, checking for returned errors, and extracting\n    the returned `code` and other parameters.\n\n    Args:\n        response: the Authorization Response URI. This can be the full URL, or just the\n            query parameters (still encoded as x-www-form-urlencoded).\n\n    Returns:\n        the extracted code, if all checks are successful\n\n    Raises:\n        MissingAuthCode: if the `code` is missing in the response\n        MissingIssuer: if Server Issuer verification is active and the response does\n            not contain an `iss`.\n        MismatchingIssuer: if the 'iss' received from the response does not match the\n            expected value.\n        MismatchingState: if the response `state` does not match the expected value.\n        OAuth2Error: if the response includes an error.\n        MissingAuthCode: if the response does not contain a `code`.\n        UnsupportedResponseTypeParam: if response_type anything else than 'code'.\n\n    \"\"\"\n    try:\n        response_url = furl(response)\n    except ValueError:\n        return self.on_response_error(response)\n\n    # validate 'iss' according to RFC9207\n    received_issuer = response_url.args.get(\"iss\")\n    if self.authorization_response_iss_parameter_supported or received_issuer:\n        if received_issuer is None:\n            raise MissingIssuer(self, response)\n        if self.issuer and received_issuer != self.issuer:\n            raise MismatchingIssuer(self.issuer, received_issuer, self, response)\n\n    # validate state\n    requested_state = self.state\n    if requested_state:\n        received_state = response_url.args.get(\"state\")\n        if requested_state != received_state:\n            raise MismatchingState(requested_state, received_state, self, response)\n\n    error = response_url.args.get(\"error\")\n    if error:\n        return self.on_response_error(response)\n\n    if self.response_type == ResponseTypes.CODE:\n        code: str = response_url.args.get(\"code\")\n        if code is None:\n            raise MissingAuthCode(self, response)\n    else:\n        raise UnsupportedResponseTypeParam(self.response_type)  # pragma: no cover\n\n    return AuthorizationResponse(\n        code_verifier=self.code_verifier,\n        redirect_uri=self.redirect_uri,\n        nonce=self.nonce,\n        acr_values=self.acr_values,\n        max_age=self.max_age,\n        dpop_key=self.dpop_key,\n        **response_url.args,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign_request_jwt","title":"<code>sign_request_jwt(jwk, alg=None, lifetime=None)</code>","text":"<p>Sign the <code>request</code> object that matches this Authorization Request parameters.</p> <p>Parameters:</p> Name Type Description Default <code>jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>lifetime</code> <code>int | None</code> <p>an optional number of seconds of validity for the signed request. If present, <code>iat</code> an <code>exp</code> claims will be included in the signed JWT.</p> <code>None</code> <p>Returns:</p> Type Description <code>SignedJwt</code> <p>a <code>Jwt</code> that contains the signed request object.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_request_jwt(\n    self,\n    jwk: Jwk | dict[str, Any],\n    alg: str | None = None,\n    lifetime: int | None = None,\n) -&gt; SignedJwt:\n    \"\"\"Sign the `request` object that matches this Authorization Request parameters.\n\n    Args:\n        jwk: the JWK to use to sign the request\n        alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n        lifetime: an optional number of seconds of validity for the signed request.\n            If present, `iat` an `exp` claims will be included in the signed JWT.\n\n    Returns:\n        a `Jwt` that contains the signed request object.\n\n    \"\"\"\n    claims = self.args\n    if lifetime:\n        claims[\"iat\"] = Jwt.timestamp()\n        claims[\"exp\"] = Jwt.timestamp(lifetime)\n    return Jwt.sign(\n        claims,\n        key=jwk,\n        alg=alg,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign","title":"<code>sign(jwk, alg=None, lifetime=None, **kwargs)</code>","text":"<p>Sign this Authorization Request and return a new one.</p> <p>This replaces all parameters with a signed <code>request</code> JWT.</p> <p>Parameters:</p> Name Type Description Default <code>jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, don't use an 'exp' claim.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>additional query parameters to include in the signed authorization request</p> <code>{}</code> <p>Returns:</p> Type Description <code>RequestParameterAuthorizationRequest</code> <p>the signed Authorization Request</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign(\n    self,\n    jwk: Jwk | dict[str, Any],\n    alg: str | None = None,\n    lifetime: int | None = None,\n    **kwargs: Any,\n) -&gt; RequestParameterAuthorizationRequest:\n    \"\"\"Sign this Authorization Request and return a new one.\n\n    This replaces all parameters with a signed `request` JWT.\n\n    Args:\n        jwk: the JWK to use to sign the request\n        alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, don't use an 'exp' claim.\n        kwargs: additional query parameters to include in the signed authorization request\n\n    Returns:\n        the signed Authorization Request\n\n    \"\"\"\n    request_jwt = self.sign_request_jwt(jwk, alg, lifetime)\n    return RequestParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request=str(request_jwt),\n        expires_at=request_jwt.expires_at,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign_and_encrypt_request_jwt","title":"<code>sign_and_encrypt_request_jwt(sign_jwk, enc_jwk, sign_alg=None, enc_alg=None, enc='A128CBC-HS256', lifetime=None)</code>","text":"<p>Sign and encrypt a <code>request</code> object for this Authorization Request.</p> <p>The signed <code>request</code> will contain the same parameters as this AuthorizationRequest.</p> <p>Parameters:</p> Name Type Description Default <code>sign_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>enc_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to encrypt the request</p> required <code>sign_alg</code> <code>str | None</code> <p>the alg to use to sign the request, if <code>sign_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc_alg</code> <code>str | None</code> <p>the alg to use to encrypt the request, if <code>enc_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc</code> <code>str</code> <p>the encoding to use to encrypt the request.</p> <code>'A128CBC-HS256'</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.</p> <code>None</code> <p>Returns:</p> Type Description <code>JweCompact</code> <p>the signed and encrypted request object, as a <code>jwskate.Jwt</code></p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_and_encrypt_request_jwt(\n    self,\n    sign_jwk: Jwk | dict[str, Any],\n    enc_jwk: Jwk | dict[str, Any],\n    sign_alg: str | None = None,\n    enc_alg: str | None = None,\n    enc: str = \"A128CBC-HS256\",\n    lifetime: int | None = None,\n) -&gt; JweCompact:\n    \"\"\"Sign and encrypt a `request` object for this Authorization Request.\n\n    The signed `request` will contain the same parameters as this AuthorizationRequest.\n\n    Args:\n        sign_jwk: the JWK to use to sign the request\n        enc_jwk: the JWK to use to encrypt the request\n        sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n        enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n        enc: the encoding to use to encrypt the request.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, do not include an 'exp' claim.\n\n    Returns:\n        the signed and encrypted request object, as a `jwskate.Jwt`\n\n    \"\"\"\n    claims = self.args\n    if lifetime:\n        claims[\"iat\"] = Jwt.timestamp()\n        claims[\"exp\"] = Jwt.timestamp(lifetime)\n    return Jwt.sign_and_encrypt(\n        claims=claims,\n        sign_key=sign_jwk,\n        sign_alg=sign_alg,\n        enc_key=enc_jwk,\n        enc_alg=enc_alg,\n        enc=enc,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign_and_encrypt","title":"<code>sign_and_encrypt(sign_jwk, enc_jwk, sign_alg=None, enc_alg=None, enc='A128CBC-HS256', lifetime=None)</code>","text":"<p>Sign and encrypt the current Authorization Request.</p> <p>This replaces all parameters with a matching <code>request</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>sign_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>enc_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to encrypt the request</p> required <code>sign_alg</code> <code>str | None</code> <p>the alg to use to sign the request, if <code>sign_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc_alg</code> <code>str | None</code> <p>the alg to use to encrypt the request, if <code>enc_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc</code> <code>str</code> <p>the encoding to use to encrypt the request.</p> <code>'A128CBC-HS256'</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.</p> <code>None</code> <p>Returns:</p> Type Description <code>RequestParameterAuthorizationRequest</code> <p>a <code>RequestParameterAuthorizationRequest</code>, with a request object as parameter</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_and_encrypt(\n    self,\n    sign_jwk: Jwk | dict[str, Any],\n    enc_jwk: Jwk | dict[str, Any],\n    sign_alg: str | None = None,\n    enc_alg: str | None = None,\n    enc: str = \"A128CBC-HS256\",\n    lifetime: int | None = None,\n) -&gt; RequestParameterAuthorizationRequest:\n    \"\"\"Sign and encrypt the current Authorization Request.\n\n    This replaces all parameters with a matching `request` object.\n\n    Args:\n        sign_jwk: the JWK to use to sign the request\n        enc_jwk: the JWK to use to encrypt the request\n        sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n        enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n        enc: the encoding to use to encrypt the request.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, do not include an 'exp' claim.\n\n    Returns:\n        a `RequestParameterAuthorizationRequest`, with a request object as parameter\n\n    \"\"\"\n    request_jwt = self.sign_and_encrypt_request_jwt(\n        sign_jwk=sign_jwk,\n        enc_jwk=enc_jwk,\n        sign_alg=sign_alg,\n        enc_alg=enc_alg,\n        enc=enc,\n        lifetime=lifetime,\n    )\n    return RequestParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request=str(request_jwt),\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.on_response_error","title":"<code>on_response_error(response)</code>","text":"<p>Error handler for Authorization Response errors.</p> <p>Triggered by validate_callback() if the response uri contains an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>the Authorization Response URI. This can be the full URL, or just the query parameters.</p> required <p>Returns:</p> Type Description <code>AuthorizationResponse</code> <p>may return a default code that will be returned by <code>validate_callback</code>. But this method</p> <code>AuthorizationResponse</code> <p>will most likely raise exceptions instead.</p> <p>Raises:</p> Type Description <code>AuthorizationResponseError</code> <p>if the response contains an <code>error</code>. The raised exception may be a subclass</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def on_response_error(self, response: str) -&gt; AuthorizationResponse:\n    \"\"\"Error handler for Authorization Response errors.\n\n    Triggered by\n    [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback]\n    if the response uri contains an error.\n\n    Args:\n        response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n    Returns:\n        may return a default code that will be returned by `validate_callback`. But this method\n        will most likely raise exceptions instead.\n\n    Raises:\n        AuthorizationResponseError: if the response contains an `error`. The raised exception may be a subclass\n\n    \"\"\"\n    response_url = furl(response)\n    error = response_url.args.get(\"error\")\n    error_description = response_url.args.get(\"error_description\")\n    error_uri = response_url.args.get(\"error_uri\")\n    exception_class = self.exception_classes.get(error, AuthorizationResponseError)\n    raise exception_class(\n        request=self, response=response, error=error, description=error_description, uri=error_uri\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.RequestParameterAuthorizationRequest","title":"<code>RequestParameterAuthorizationRequest</code>","text":"<p>Represent an Authorization Request that includes a <code>request</code> JWT.</p> <p>To construct such a request yourself, the easiest way is to initialize an <code>AuthorizationRequest</code> then sign it with <code>AuthorizationRequest.sign()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the Authorization Endpoint uri</p> required <code>client_id</code> <code>str</code> <p>the client_id</p> required <code>request</code> <code>Jwt | str</code> <p>the request JWT</p> required <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for this request</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>extra parameters to include in the request</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False, repr=False)\nclass RequestParameterAuthorizationRequest:\n    \"\"\"Represent an Authorization Request that includes a `request` JWT.\n\n    To construct such a request yourself, the easiest way is to initialize\n    an [`AuthorizationRequest`][requests_oauth2client.authorization_request.AuthorizationRequest]\n    then sign it with\n    [`AuthorizationRequest.sign()`][requests_oauth2client.authorization_request.AuthorizationRequest.sign].\n\n    Args:\n        authorization_endpoint: the Authorization Endpoint uri\n        client_id: the client_id\n        request: the request JWT\n        expires_at: the expiration date for this request\n        kwargs: extra parameters to include in the request\n\n    \"\"\"\n\n    authorization_endpoint: str\n    client_id: str\n    request: Jwt\n    expires_at: datetime | None\n    dpop_key: DPoPKey | None\n    kwargs: dict[str, Any]\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        authorization_endpoint: str,\n        client_id: str,\n        request: Jwt | str,\n        expires_at: datetime | None = None,\n        dpop_key: DPoPKey | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        if isinstance(request, str):\n            request = Jwt(request)\n\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            request=request,\n            expires_at=expires_at,\n            dpop_key=dpop_key,\n            kwargs=kwargs,\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl` instance.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args={\"client_id\": self.client_id, \"request\": str(self.request), **self.kwargs},\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\n\n        Returns:\n             the Authorization Request URI\n\n        \"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.RequestParameterAuthorizationRequest.furl","title":"<code>furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code> instance.</p>"},{"location":"api/#requests_oauth2client.authorization_request.RequestParameterAuthorizationRequest.uri","title":"<code>uri</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest","title":"<code>RequestUriParameterAuthorizationRequest</code>","text":"<p>Represent an Authorization Request that includes a <code>request_uri</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>The Authorization Endpoint uri.</p> required <code>client_id</code> <code>str</code> <p>The Client ID.</p> required <code>request_uri</code> <code>str</code> <p>The <code>request_uri</code>.</p> required <code>expires_at</code> <code>datetime | None</code> <p>The expiration date for this request.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Extra query parameters to include in the request.</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass RequestUriParameterAuthorizationRequest:\n    \"\"\"Represent an Authorization Request that includes a `request_uri` parameter.\n\n    Args:\n        authorization_endpoint: The Authorization Endpoint uri.\n        client_id: The Client ID.\n        request_uri: The `request_uri`.\n        expires_at: The expiration date for this request.\n        kwargs: Extra query parameters to include in the request.\n\n    \"\"\"\n\n    authorization_endpoint: str\n    client_id: str\n    request_uri: str\n    expires_at: datetime | None\n    dpop_key: DPoPKey | None\n    kwargs: dict[str, Any]\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        authorization_endpoint: str,\n        *,\n        client_id: str,\n        request_uri: str,\n        expires_at: datetime | None = None,\n        dpop_key: DPoPKey | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            request_uri=request_uri,\n            expires_at=expires_at,\n            dpop_key=dpop_key,\n            kwargs=kwargs,\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl` instance.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args={\"client_id\": self.client_id, \"request_uri\": self.request_uri, **self.kwargs},\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest.furl","title":"<code>furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code> instance.</p>"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest.uri","title":"<code>uri</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer","title":"<code>AuthorizationRequestSerializer</code>","text":"<p>(De)Serializer for <code>AuthorizationRequest</code> instances.</p> <p>You might need to store pending authorization requests in session, either server-side or client- side. This class is here to help you do that.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class AuthorizationRequestSerializer:\n    \"\"\"(De)Serializer for `AuthorizationRequest` instances.\n\n    You might need to store pending authorization requests in session, either server-side or client- side. This class is\n    here to help you do that.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        dumper: Callable[[AuthorizationRequest], str] | None = None,\n        loader: Callable[[str], AuthorizationRequest] | None = None,\n    ) -&gt; None:\n        self.dumper = dumper or self.default_dumper\n        self.loader = loader or self.default_loader\n\n    @staticmethod\n    def default_dumper(azr: AuthorizationRequest) -&gt; str:\n        \"\"\"Provide a default dumper implementation.\n\n        Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as\n        base64url.\n\n        Args:\n            azr: the `AuthorizationRequest` to serialize\n\n        Returns:\n            the serialized value\n\n        \"\"\"\n        d = asdict(azr)\n        if azr.dpop_key:\n            d[\"dpop_key\"][\"private_key\"] = azr.dpop_key.private_key.to_dict()\n        d.update(**d.pop(\"kwargs\", {}))\n        return BinaPy.serialize_to(\"json\", d).to(\"deflate\").to(\"b64u\").ascii()\n\n    @staticmethod\n    def default_loader(\n        serialized: str,\n        azr_class: type[AuthorizationRequest] = AuthorizationRequest,\n    ) -&gt; AuthorizationRequest:\n        \"\"\"Provide a default deserializer implementation.\n\n        This does the opposite operations than `default_dumper`.\n\n        Args:\n            serialized: the serialized AuthorizationRequest\n            azr_class: the class to deserialize the Authorization Request to\n\n        Returns:\n            an AuthorizationRequest\n\n        \"\"\"\n        args = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n\n        if dpop_key := args.get(\"dpop_key\"):\n            dpop_key[\"private_key\"] = Jwk(dpop_key[\"private_key\"])\n            dpop_key.pop(\"jti_generator\", None)\n            dpop_key.pop(\"iat_generator\", None)\n            dpop_key.pop(\"dpop_token_class\", None)\n            args[\"dpop_key\"] = DPoPKey(**dpop_key)\n\n        return azr_class(**args)\n\n    def dumps(self, azr: AuthorizationRequest) -&gt; str:\n        \"\"\"Serialize and compress a given AuthorizationRequest for easier storage.\n\n        Args:\n            azr: an AuthorizationRequest to serialize\n\n        Returns:\n            the serialized AuthorizationRequest, as a str\n\n        \"\"\"\n        return self.dumper(azr)\n\n    def loads(self, serialized: str) -&gt; AuthorizationRequest:\n        \"\"\"Deserialize a serialized AuthorizationRequest.\n\n        Args:\n            serialized: the serialized AuthorizationRequest\n\n        Returns:\n            the deserialized AuthorizationRequest\n\n        \"\"\"\n        return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.default_dumper","title":"<code>default_dumper(azr)</code>  <code>staticmethod</code>","text":"<p>Provide a default dumper implementation.</p> <p>Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as base64url.</p> <p>Parameters:</p> Name Type Description Default <code>azr</code> <code>AuthorizationRequest</code> <p>the <code>AuthorizationRequest</code> to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized value</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@staticmethod\ndef default_dumper(azr: AuthorizationRequest) -&gt; str:\n    \"\"\"Provide a default dumper implementation.\n\n    Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as\n    base64url.\n\n    Args:\n        azr: the `AuthorizationRequest` to serialize\n\n    Returns:\n        the serialized value\n\n    \"\"\"\n    d = asdict(azr)\n    if azr.dpop_key:\n        d[\"dpop_key\"][\"private_key\"] = azr.dpop_key.private_key.to_dict()\n    d.update(**d.pop(\"kwargs\", {}))\n    return BinaPy.serialize_to(\"json\", d).to(\"deflate\").to(\"b64u\").ascii()\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.default_loader","title":"<code>default_loader(serialized, azr_class=AuthorizationRequest)</code>  <code>staticmethod</code>","text":"<p>Provide a default deserializer implementation.</p> <p>This does the opposite operations than <code>default_dumper</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized AuthorizationRequest</p> required <code>azr_class</code> <code>type[AuthorizationRequest]</code> <p>the class to deserialize the Authorization Request to</p> <code>AuthorizationRequest</code> <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>an AuthorizationRequest</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@staticmethod\ndef default_loader(\n    serialized: str,\n    azr_class: type[AuthorizationRequest] = AuthorizationRequest,\n) -&gt; AuthorizationRequest:\n    \"\"\"Provide a default deserializer implementation.\n\n    This does the opposite operations than `default_dumper`.\n\n    Args:\n        serialized: the serialized AuthorizationRequest\n        azr_class: the class to deserialize the Authorization Request to\n\n    Returns:\n        an AuthorizationRequest\n\n    \"\"\"\n    args = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n\n    if dpop_key := args.get(\"dpop_key\"):\n        dpop_key[\"private_key\"] = Jwk(dpop_key[\"private_key\"])\n        dpop_key.pop(\"jti_generator\", None)\n        dpop_key.pop(\"iat_generator\", None)\n        dpop_key.pop(\"dpop_token_class\", None)\n        args[\"dpop_key\"] = DPoPKey(**dpop_key)\n\n    return azr_class(**args)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.dumps","title":"<code>dumps(azr)</code>","text":"<p>Serialize and compress a given AuthorizationRequest for easier storage.</p> <p>Parameters:</p> Name Type Description Default <code>azr</code> <code>AuthorizationRequest</code> <p>an AuthorizationRequest to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized AuthorizationRequest, as a str</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def dumps(self, azr: AuthorizationRequest) -&gt; str:\n    \"\"\"Serialize and compress a given AuthorizationRequest for easier storage.\n\n    Args:\n        azr: an AuthorizationRequest to serialize\n\n    Returns:\n        the serialized AuthorizationRequest, as a str\n\n    \"\"\"\n    return self.dumper(azr)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.loads","title":"<code>loads(serialized)</code>","text":"<p>Deserialize a serialized AuthorizationRequest.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized AuthorizationRequest</p> required <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>the deserialized AuthorizationRequest</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def loads(self, serialized: str) -&gt; AuthorizationRequest:\n    \"\"\"Deserialize a serialized AuthorizationRequest.\n\n    Args:\n        serialized: the serialized AuthorizationRequest\n\n    Returns:\n        the deserialized AuthorizationRequest\n\n    \"\"\"\n    return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication","title":"<code>backchannel_authentication</code>","text":"<p>Implementation of CIBA.</p> <p>CIBA stands for Client Initiated BackChannel Authentication and is standardised by the OpenID Fundation. https://openid.net/specs/openid-client-initiated-backchannel- authentication-core-1_0.html.</p>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse","title":"<code>BackChannelAuthenticationResponse</code>","text":"<p>Represent a BackChannel Authentication Response.</p> <p>This contains all the parameters that are returned by the AS as a result of a BackChannel Authentication Request, such as <code>auth_req_id</code> (required), and the optional <code>expires_at</code>, <code>interval</code>, and/or any custom parameters.</p> <p>Parameters:</p> Name Type Description Default <code>auth_req_id</code> <code>str</code> <p>the <code>auth_req_id</code> as returned by the AS.</p> required <code>expires_at</code> <code>datetime | None</code> <p>the date when the <code>auth_req_id</code> expires. Note that this request also accepts an <code>expires_in</code> parameter, in seconds.</p> <code>None</code> <code>interval</code> <code>int | None</code> <p>the Token Endpoint pooling interval, in seconds, as returned by the AS.</p> <code>20</code> <code>**kwargs</code> <code>Any</code> <p>any additional custom parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>class BackChannelAuthenticationResponse:\n    \"\"\"Represent a BackChannel Authentication Response.\n\n    This contains all the parameters that are returned by the AS as a result of a BackChannel\n    Authentication Request, such as `auth_req_id` (required), and the optional `expires_at`,\n    `interval`, and/or any custom parameters.\n\n    Args:\n        auth_req_id: the `auth_req_id` as returned by the AS.\n        expires_at: the date when the `auth_req_id` expires.\n            Note that this request also accepts an `expires_in` parameter, in seconds.\n        interval: the Token Endpoint pooling interval, in seconds, as returned by the AS.\n        **kwargs: any additional custom parameters as returned by the AS.\n\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        auth_req_id: str,\n        expires_at: datetime | None = None,\n        interval: int | None = 20,\n        **kwargs: Any,\n    ) -&gt; None:\n        self.auth_req_id = auth_req_id\n        self.expires_at = expires_at\n        self.interval = interval\n        self.other = kwargs\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Return `True` if the `auth_req_id` within this response is expired.\n\n        Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is\n        derived from the `expires_in` hint returned by the AS BackChannel Authentication endpoint),\n        this will return `None`.\n\n        Returns:\n            `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is\n            no `expires_in` hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n\n    @property\n    def expires_in(self) -&gt; int | None:\n        \"\"\"Number of seconds until expiration.\"\"\"\n        if self.expires_at:\n            return ceil((self.expires_at - datetime.now(tz=timezone.utc)).total_seconds())\n        return None\n\n    def __getattr__(self, key: str) -&gt; Any:\n        \"\"\"Return attributes from this `BackChannelAuthenticationResponse`.\n\n        Allows accessing response parameters with `token_response.expires_in` or\n        `token_response.any_custom_attribute`.\n\n        Args:\n            key: a key\n\n        Returns:\n            the associated value in this token response\n\n        Raises:\n            AttributeError: if the attribute is not present in the response\n\n        \"\"\"\n        return self.other.get(key) or super().__getattribute__(key)\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse.expires_in","title":"<code>expires_in</code>  <code>property</code>","text":"<p>Number of seconds until expiration.</p>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Return <code>True</code> if the <code>auth_req_id</code> within this response is expired.</p> <p>Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is derived from the <code>expires_in</code> hint returned by the AS BackChannel Authentication endpoint), this will return <code>None</code>.</p> <p>Returns:</p> Type Description <code>bool | None</code> <p><code>True</code> if the auth_req_id is expired, <code>False</code> if it is still valid, <code>None</code> if there is</p> <code>bool | None</code> <p>no <code>expires_in</code> hint.</p> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Return `True` if the `auth_req_id` within this response is expired.\n\n    Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is\n    derived from the `expires_in` hint returned by the AS BackChannel Authentication endpoint),\n    this will return `None`.\n\n    Returns:\n        `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is\n        no `expires_in` hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationPoolingJob","title":"<code>BackChannelAuthenticationPoolingJob</code>","text":"<p>               Bases: <code>BaseTokenEndpointPoolingJob</code></p> <p>A pooling job for the BackChannel Authentication flow.</p> <p>This will poll the Token Endpoint until the user finishes with its authentication.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client that will be used to pool the token endpoint.</p> required <code>auth_req_id</code> <code>str | BackChannelAuthenticationResponse</code> <p>an <code>auth_req_id</code> as <code>str</code> or a <code>BackChannelAuthenticationResponse</code>.</p> required <code>interval</code> <code>int | None</code> <p>The pooling interval, in seconds, to use. This overrides the one in <code>auth_req_id</code> if it is a <code>BackChannelAuthenticationResponse</code>. Defaults to 5 seconds.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>Number of seconds to add to the pooling interval when the AS returns a slow down request.</p> <code>5</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the underlying calls to requests.request.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token request.</p> <code>{}</code> Example <pre><code>client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\npool_job = BackChannelAuthenticationPoolingJob(\n    client=client,\n    auth_req_id=\"my_auth_req_id\",\n)\n\ntoken = None\nwhile token is None:\n    token = pool_job()\n</code></pre> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>@define(init=False)\nclass BackChannelAuthenticationPoolingJob(BaseTokenEndpointPoolingJob):\n    \"\"\"A pooling job for the BackChannel Authentication flow.\n\n    This will poll the Token Endpoint until the user finishes with its authentication.\n\n    Args:\n        client: an OAuth2Client that will be used to pool the token endpoint.\n        auth_req_id: an `auth_req_id` as `str` or a `BackChannelAuthenticationResponse`.\n        interval: The pooling interval, in seconds, to use. This overrides\n            the one in `auth_req_id` if it is a `BackChannelAuthenticationResponse`.\n            Defaults to 5 seconds.\n        slow_down_interval: Number of seconds to add to the pooling interval when the AS returns\n            a slow down request.\n        requests_kwargs: Additional parameters for the underlying calls to [requests.request][].\n        **token_kwargs: Additional parameters for the token request.\n\n    Example:\n        ```python\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        pool_job = BackChannelAuthenticationPoolingJob(\n            client=client,\n            auth_req_id=\"my_auth_req_id\",\n        )\n\n        token = None\n        while token is None:\n            token = pool_job()\n        ```\n\n    \"\"\"\n\n    auth_req_id: str\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        auth_req_id: str | BackChannelAuthenticationResponse,\n        *,\n        interval: int | None = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n            interval = interval or auth_req_id.interval\n            auth_req_id = auth_req_id.auth_req_id\n\n        self.__attrs_init__(\n            client=client,\n            auth_req_id=auth_req_id,\n            interval=interval or 5,\n            slow_down_interval=slow_down_interval,\n            requests_kwargs=requests_kwargs or {},\n            token_kwargs=token_kwargs,\n        )\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Implement the CIBA token request.\n\n        This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        return self.client.ciba(self.auth_req_id, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Implement the CIBA token request.</p> <p>This actually calls [OAuth2Client.ciba(auth_req_id)] on <code>client</code>.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Implement the CIBA token request.\n\n    This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    return self.client.ciba(self.auth_req_id, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client","title":"<code>client</code>","text":"<p>This module contains the <code>OAuth2Client</code> class.</p>"},{"location":"api/#requests_oauth2client.client.InvalidParam","title":"<code>InvalidParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Base class for invalid parameters errors.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidParam(ValueError):\n    \"\"\"Base class for invalid parameters errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.client.MissingIdTokenEncryptedResponseAlgParam","title":"<code>MissingIdTokenEncryptedResponseAlgParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an ID Token encryption is required but not provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingIdTokenEncryptedResponseAlgParam(InvalidParam):\n    \"\"\"Raised when an ID Token encryption is required but not provided.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"\"\"\\\nAn ID Token decryption key has been provided but no decryption algorithm is defined.\nYou can either pass an `id_token_encrypted_response_alg` parameter with the alg identifier,\nor include an `alg` attribute in the decryption key, if it is in Jwk format.\n\"\"\")\n</code></pre>"},{"location":"api/#requests_oauth2client.client.InvalidEndpointUri","title":"<code>InvalidEndpointUri</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid endpoint uri is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidEndpointUri(InvalidParam):\n    \"\"\"Raised when an invalid endpoint uri is provided.\"\"\"\n\n    def __init__(self, endpoint: str, uri: str, exc: InvalidUri) -&gt; None:\n        super().__init__(f\"Invalid endpoint uri '{uri}' for '{endpoint}': {exc}\")\n        self.endpoint = endpoint\n        self.uri = uri\n</code></pre>"},{"location":"api/#requests_oauth2client.client.InvalidIssuer","title":"<code>InvalidIssuer</code>","text":"<p>               Bases: <code>InvalidEndpointUri</code></p> <p>Raised when an invalid issuer parameter is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidIssuer(InvalidEndpointUri):\n    \"\"\"Raised when an invalid issuer parameter is provided.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.client.InvalidScopeParam","title":"<code>InvalidScopeParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid scope parameter is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidScopeParam(InvalidParam):\n    \"\"\"Raised when an invalid scope parameter is provided.\"\"\"\n\n    def __init__(self, scope: object) -&gt; None:\n        super().__init__(\"\"\"\\\nUnsupported scope value. It must be one of:\n- a space separated `str` of scopes names\n- an iterable of scope names as `str`\n\"\"\")\n        self.scope = scope\n</code></pre>"},{"location":"api/#requests_oauth2client.client.MissingRefreshToken","title":"<code>MissingRefreshToken</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a refresh token is required but not present.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingRefreshToken(ValueError):\n    \"\"\"Raised when a refresh token is required but not present.\"\"\"\n\n    def __init__(self, token: TokenResponse) -&gt; None:\n        super().__init__(\"A refresh_token is required but is not present in this Access Token.\")\n        self.token = token\n</code></pre>"},{"location":"api/#requests_oauth2client.client.MissingDeviceCode","title":"<code>MissingDeviceCode</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a device_code is required but not provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingDeviceCode(ValueError):\n    \"\"\"Raised when a device_code is required but not provided.\"\"\"\n\n    def __init__(self, dar: DeviceAuthorizationResponse) -&gt; None:\n        super().__init__(\"A device_code is missing in this DeviceAuthorizationResponse\")\n        self.device_authorization_response = dar\n</code></pre>"},{"location":"api/#requests_oauth2client.client.MissingAuthRequestId","title":"<code>MissingAuthRequestId</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an 'auth_req_id' is missing in a BackChannelAuthenticationResponse.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingAuthRequestId(ValueError):\n    \"\"\"Raised when an 'auth_req_id' is missing in a BackChannelAuthenticationResponse.\"\"\"\n\n    def __init__(self, bcar: BackChannelAuthenticationResponse) -&gt; None:\n        super().__init__(\"An 'auth_req_id' is required but is missing from this BackChannelAuthenticationResponse.\")\n        self.backchannel_authentication_response = bcar\n</code></pre>"},{"location":"api/#requests_oauth2client.client.UnknownTokenType","title":"<code>UnknownTokenType</code>","text":"<p>               Bases: <code>InvalidParam</code>, <code>TypeError</code></p> <p>Raised when the type of a token cannot be determined automatically.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class UnknownTokenType(InvalidParam, TypeError):\n    \"\"\"Raised when the type of a token cannot be determined automatically.\"\"\"\n\n    def __init__(self, message: str, token: object, token_type: str | None) -&gt; None:\n        super().__init__(f\"Unable to determine the type of token provided: {message}\")\n        self.token = token\n        self.token_type = token_type\n</code></pre>"},{"location":"api/#requests_oauth2client.client.UnknownSubjectTokenType","title":"<code>UnknownSubjectTokenType</code>","text":"<p>               Bases: <code>UnknownTokenType</code></p> <p>Raised when the type of subject_token cannot be determined automatically.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class UnknownSubjectTokenType(UnknownTokenType):\n    \"\"\"Raised when the type of subject_token cannot be determined automatically.\"\"\"\n\n    def __init__(self, subject_token: object, subject_token_type: str | None) -&gt; None:\n        super().__init__(\"subject_token\", subject_token, subject_token_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.UnknownActorTokenType","title":"<code>UnknownActorTokenType</code>","text":"<p>               Bases: <code>UnknownTokenType</code></p> <p>Raised when the type of actor_token cannot be determined automatically.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class UnknownActorTokenType(UnknownTokenType):\n    \"\"\"Raised when the type of actor_token cannot be determined automatically.\"\"\"\n\n    def __init__(self, actor_token: object, actor_token_type: str | None) -&gt; None:\n        super().__init__(\"actor_token\", token=actor_token, token_type=actor_token_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.InvalidBackchannelAuthenticationRequestHintParam","title":"<code>InvalidBackchannelAuthenticationRequestHintParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid hint is provided in a backchannel authentication request.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidBackchannelAuthenticationRequestHintParam(InvalidParam):\n    \"\"\"Raised when an invalid hint is provided in a backchannel authentication request.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.client.InvalidAcrValuesParam","title":"<code>InvalidAcrValuesParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid 'acr_values' parameter is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidAcrValuesParam(InvalidParam):\n    \"\"\"Raised when an invalid 'acr_values' parameter is provided.\"\"\"\n\n    def __init__(self, acr_values: object) -&gt; None:\n        super().__init__(f\"Invalid 'acr_values' parameter: {acr_values}\")\n        self.acr_values = acr_values\n</code></pre>"},{"location":"api/#requests_oauth2client.client.InvalidDiscoveryDocument","title":"<code>InvalidDiscoveryDocument</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when handling an invalid Discovery Document.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidDiscoveryDocument(ValueError):\n    \"\"\"Raised when handling an invalid Discovery Document.\"\"\"\n\n    def __init__(self, message: str, discovery_document: dict[str, Any]) -&gt; None:\n        super().__init__(f\"Invalid discovery document: {message}\")\n        self.discovery_document = discovery_document\n</code></pre>"},{"location":"api/#requests_oauth2client.client.Endpoints","title":"<code>Endpoints</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>All standardised OAuth 2.0 and extensions endpoints.</p> <p>If an endpoint is not mentioned here, then its usage is not supported by OAuth2Client.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class Endpoints(str, Enum):\n    \"\"\"All standardised OAuth 2.0 and extensions endpoints.\n\n    If an endpoint is not mentioned here, then its usage is not supported by OAuth2Client.\n\n    \"\"\"\n\n    TOKEN = \"token_endpoint\"\n    AUTHORIZATION = \"authorization_endpoint\"\n    BACKCHANNEL_AUTHENTICATION = \"backchannel_authentication_endpoint\"\n    DEVICE_AUTHORIZATION = \"device_authorization_endpoint\"\n    INTROSPECTION = \"introspection_endpoint\"\n    REVOCATION = \"revocation_endpoint\"\n    PUSHED_AUTHORIZATION_REQUEST = \"pushed_authorization_request_endpoint\"\n    JWKS = \"jwks_uri\"\n    USER_INFO = \"userinfo_endpoint\"\n</code></pre>"},{"location":"api/#requests_oauth2client.client.MissingEndpointUri","title":"<code>MissingEndpointUri</code>","text":"<p>               Bases: <code>AttributeError</code></p> <p>Raised when a required endpoint uri is not known.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingEndpointUri(AttributeError):\n    \"\"\"Raised when a required endpoint uri is not known.\"\"\"\n\n    def __init__(self, endpoint: str) -&gt; None:\n        super().__init__(f\"No '{endpoint}' defined for this client.\")\n</code></pre>"},{"location":"api/#requests_oauth2client.client.GrantTypes","title":"<code>GrantTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum of standardized <code>grant_type</code> values.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class GrantTypes(str, Enum):\n    \"\"\"An enum of standardized `grant_type` values.\"\"\"\n\n    CLIENT_CREDENTIALS = \"client_credentials\"\n    AUTHORIZATION_CODE = \"authorization_code\"\n    REFRESH_TOKEN = \"refresh_token\"\n    RESOURCE_OWNER_PASSWORD = \"password\"\n    TOKEN_EXCHANGE = \"urn:ietf:params:oauth:grant-type:token-exchange\"\n    JWT_BEARER = \"urn:ietf:params:oauth:grant-type:jwt-bearer\"\n    CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION = \"urn:openid:params:grant-type:ciba\"\n    DEVICE_CODE = \"urn:ietf:params:oauth:grant-type:device_code\"\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client","title":"<code>OAuth2Client</code>","text":"<p>An OAuth 2.x Client that can send requests to an OAuth 2.x Authorization Server.</p> <p><code>OAuth2Client</code> is able to obtain tokens from the Token Endpoint using any of the standardised Grant Types, and to communicate with the various backend endpoints like the Revocation, Introspection, and UserInfo Endpoint.</p> <p>To init an OAuth2Client, you only need the url to the Token Endpoint and the Credentials (a client_id and one of a secret or private_key) that will be used to authenticate to that endpoint. Other endpoint urls, such as the Authorization Endpoint, Revocation Endpoint, etc. can be passed as parameter as well if you intend to use them.</p> <p>This class is not intended to help with the end-user authentication or any request that goes in a browser. For authentication requests, see AuthorizationRequest. You may use the method <code>authorization_request()</code> to generate <code>AuthorizationRequest</code>s with the preconfigured <code>authorization_endpoint</code>, <code>client_id</code> and `redirect_uri' from this client.</p> <p>Parameters:</p> Name Type Description Default <code>token_endpoint</code> <code>str</code> <p>the Token Endpoint URI where this client will get access tokens</p> required <code>auth</code> <code>AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None</code> <p>the authentication handler to use for client authentication on the token endpoint. Can be:</p> <ul> <li>a requests.auth.AuthBase instance (which will be used as-is)</li> <li>a tuple of <code>(client_id, client_secret)</code> which will initialize an instance of ClientSecretPost</li> <li>a <code>(client_id, jwk)</code> to initialize a PrivateKeyJwt,</li> <li>or a <code>client_id</code> which will use PublicApp authentication.</li> </ul> <code>None</code> <code>client_id</code> <code>str | None</code> <p>client ID (use either this or <code>auth</code>)</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>client secret (use either this or <code>auth</code>)</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>private_key to use for client authentication (use either this or <code>auth</code>)</p> <code>None</code> <code>revocation_endpoint</code> <code>str | None</code> <p>the Revocation Endpoint URI to use for revoking tokens</p> <code>None</code> <code>introspection_endpoint</code> <code>str | None</code> <p>the Introspection Endpoint URI to use to get info about tokens</p> <code>None</code> <code>userinfo_endpoint</code> <code>str | None</code> <p>the Userinfo Endpoint URI to use to get information about the user</p> <code>None</code> <code>authorization_endpoint</code> <code>str | None</code> <p>the Authorization Endpoint URI, used for initializing Authorization Requests</p> <code>None</code> <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri for this client</p> <code>None</code> <code>backchannel_authentication_endpoint</code> <code>str | None</code> <p>the BackChannel Authentication URI</p> <code>None</code> <code>device_authorization_endpoint</code> <code>str | None</code> <p>the Device Authorization Endpoint URI to use to authorize devices</p> <code>None</code> <code>jwks_uri</code> <code>str | None</code> <p>the JWKS URI to use to obtain the AS public keys</p> <code>None</code> <code>code_challenge_method</code> <code>str</code> <p>challenge method to use for PKCE (should always be 'S256')</p> <code>S256</code> <code>session</code> <code>Session | None</code> <p>a requests Session to use when sending HTTP requests. Useful if some extra parameters such as proxy or client certificate must be used to connect to the AS.</p> <code>None</code> <code>token_class</code> <code>type[BearerToken]</code> <p>a custom BearerToken class, if required</p> <code>BearerToken</code> <code>dpop_bound_access_tokens</code> <code>bool</code> <p>if <code>True</code>, DPoP will be used by default for every token request. otherwise, you can enable DPoP by passing <code>dpop=True</code> when doing a token request.</p> <code>False</code> <code>dpop_key_generator</code> <code>Callable[[str], DPoPKey]</code> <p>a callable that generates a DPoPKey, for whill be called when doing a token request with DPoP enabled.</p> <code>generate</code> <code>testing</code> <code>bool</code> <p>if <code>True</code>, don't verify the validity of the endpoint urls that are passed as parameter.</p> <code>False</code> <code>**extra_metadata</code> <code>Any</code> <p>additional metadata for this client, unused by this class, but may be used by subclasses. Those will be accessible with the <code>extra_metadata</code> attribute.</p> <code>{}</code> Example <pre><code>client = OAuth2Client(\n    token_endpoint=\"https://my.as.local/token\",\n    revocation_endpoint=\"https://my.as.local/revoke\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\n# once initialized, a client can send requests to its configured endpoints\ncc_token = client.client_credentials(scope=\"my_scope\")\nac_token = client.authorization_code(code=\"my_code\")\nclient.revoke_access_token(cc_token)\n</code></pre> <p>Raises:</p> Type Description <code>MissingIDTokenEncryptedResponseAlgParam</code> <p>if an <code>id_token_decryption_key</code> is provided but no decryption alg is provided, either:</p> <ul> <li>using <code>id_token_encrypted_response_alg</code>,</li> <li>or in the <code>alg</code> parameter of the <code>Jwk</code> key</li> </ul> <code>MissingIssuerParam</code> <p>if <code>authorization_response_iss_parameter_supported</code> is set to <code>True</code> but the <code>issuer</code> is not provided.</p> <code>InvalidEndpointUri</code> <p>if a provided endpoint uri is not considered valid. For the rare cases where those checks must be disabled, you can use <code>testing=True</code>.</p> <code>InvalidIssuer</code> <p>if the <code>issuer</code> value is not considered valid.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@frozen(init=False)\nclass OAuth2Client:\n    \"\"\"An OAuth 2.x Client that can send requests to an OAuth 2.x Authorization Server.\n\n    `OAuth2Client` is able to obtain tokens from the Token Endpoint using any of the standardised\n    Grant Types, and to communicate with the various backend endpoints like the Revocation,\n    Introspection, and UserInfo Endpoint.\n\n    To init an OAuth2Client, you only need the url to the Token Endpoint and the Credentials\n    (a client_id and one of a secret or private_key) that will be used to authenticate to that endpoint.\n    Other endpoint urls, such as the Authorization Endpoint, Revocation Endpoint, etc. can be passed as\n    parameter as well if you intend to use them.\n\n\n    This class is not intended to help with the end-user authentication or any request that goes in\n    a browser. For authentication requests, see\n    [AuthorizationRequest][requests_oauth2client.authorization_request.AuthorizationRequest]. You\n    may use the method `authorization_request()` to generate `AuthorizationRequest`s with the\n    preconfigured `authorization_endpoint`, `client_id` and `redirect_uri' from this client.\n\n    Args:\n        token_endpoint: the Token Endpoint URI where this client will get access tokens\n        auth: the authentication handler to use for client authentication on the token endpoint.\n            Can be:\n\n            - a [requests.auth.AuthBase][] instance (which will be used as-is)\n            - a tuple of `(client_id, client_secret)` which will initialize an instance\n            of [ClientSecretPost][requests_oauth2client.client_authentication.ClientSecretPost]\n            - a `(client_id, jwk)` to initialize\n            a [PrivateKeyJwt][requests_oauth2client.client_authentication.PrivateKeyJwt],\n            - or a `client_id` which will\n            use [PublicApp][requests_oauth2client.client_authentication.PublicApp] authentication.\n\n        client_id: client ID (use either this or `auth`)\n        client_secret: client secret (use either this or `auth`)\n        private_key: private_key to use for client authentication (use either this or `auth`)\n        revocation_endpoint: the Revocation Endpoint URI to use for revoking tokens\n        introspection_endpoint: the Introspection Endpoint URI to use to get info about tokens\n        userinfo_endpoint: the Userinfo Endpoint URI to use to get information about the user\n        authorization_endpoint: the Authorization Endpoint URI, used for initializing Authorization Requests\n        redirect_uri: the redirect_uri for this client\n        backchannel_authentication_endpoint: the BackChannel Authentication URI\n        device_authorization_endpoint: the Device Authorization Endpoint URI to use to authorize devices\n        jwks_uri: the JWKS URI to use to obtain the AS public keys\n        code_challenge_method: challenge method to use for PKCE (should always be 'S256')\n        session: a requests Session to use when sending HTTP requests.\n            Useful if some extra parameters such as proxy or client certificate must be used\n            to connect to the AS.\n        token_class: a custom BearerToken class, if required\n        dpop_bound_access_tokens: if `True`, DPoP will be used by default for every token request.\n            otherwise, you can enable DPoP by passing `dpop=True` when doing a token request.\n        dpop_key_generator: a callable that generates a DPoPKey, for whill be called when doing a token request\n            with DPoP enabled.\n        testing: if `True`, don't verify the validity of the endpoint urls that are passed as parameter.\n        **extra_metadata: additional metadata for this client, unused by this class, but may be\n            used by subclasses. Those will be accessible with the `extra_metadata` attribute.\n\n    Example:\n        ```python\n        client = OAuth2Client(\n            token_endpoint=\"https://my.as.local/token\",\n            revocation_endpoint=\"https://my.as.local/revoke\",\n            client_id=\"client_id\",\n            client_secret=\"client_secret\",\n        )\n\n        # once initialized, a client can send requests to its configured endpoints\n        cc_token = client.client_credentials(scope=\"my_scope\")\n        ac_token = client.authorization_code(code=\"my_code\")\n        client.revoke_access_token(cc_token)\n        ```\n\n    Raises:\n        MissingIDTokenEncryptedResponseAlgParam: if an `id_token_decryption_key` is provided\n            but no decryption alg is provided, either:\n\n            - using `id_token_encrypted_response_alg`,\n            - or in the `alg` parameter of the `Jwk` key\n        MissingIssuerParam: if `authorization_response_iss_parameter_supported` is set to `True`\n            but the `issuer` is not provided.\n        InvalidEndpointUri: if a provided endpoint uri is not considered valid. For the rare cases\n            where those checks must be disabled, you can use `testing=True`.\n        InvalidIssuer: if the `issuer` value is not considered valid.\n\n    \"\"\"\n\n    auth: requests.auth.AuthBase\n    token_endpoint: str = field()\n    revocation_endpoint: str | None = field()\n    introspection_endpoint: str | None = field()\n    userinfo_endpoint: str | None = field()\n    authorization_endpoint: str | None = field()\n    redirect_uri: str | None = field()\n    backchannel_authentication_endpoint: str | None = field()\n    device_authorization_endpoint: str | None = field()\n    pushed_authorization_request_endpoint: str | None = field()\n    jwks_uri: str | None = field()\n    authorization_server_jwks: JwkSet\n    issuer: str | None = field()\n    id_token_signed_response_alg: str | None\n    id_token_encrypted_response_alg: str | None\n    id_token_decryption_key: Jwk | None\n    code_challenge_method: str | None\n    authorization_response_iss_parameter_supported: bool\n    session: requests.Session\n    extra_metadata: dict[str, Any]\n    testing: bool\n\n    dpop_bound_access_tokens: bool\n    dpop_key_generator: Callable[[str], DPoPKey]\n    dpop_alg: str\n\n    token_class: type[BearerToken]\n\n    exception_classes: ClassVar[dict[str, type[EndpointError]]] = {\n        \"server_error\": ServerError,\n        \"invalid_request\": InvalidRequest,\n        \"invalid_client\": InvalidClient,\n        \"invalid_scope\": InvalidScope,\n        \"invalid_target\": InvalidTarget,\n        \"invalid_grant\": InvalidGrant,\n        \"access_denied\": AccessDenied,\n        \"unauthorized_client\": UnauthorizedClient,\n        \"authorization_pending\": AuthorizationPending,\n        \"slow_down\": SlowDown,\n        \"expired_token\": ExpiredToken,\n        \"use_dpop_nonce\": UseDPoPNonce,\n        \"unsupported_token_type\": UnsupportedTokenType,\n    }\n\n    def __init__(  # noqa: PLR0913\n        self,\n        token_endpoint: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        revocation_endpoint: str | None = None,\n        introspection_endpoint: str | None = None,\n        userinfo_endpoint: str | None = None,\n        authorization_endpoint: str | None = None,\n        redirect_uri: str | None = None,\n        backchannel_authentication_endpoint: str | None = None,\n        device_authorization_endpoint: str | None = None,\n        pushed_authorization_request_endpoint: str | None = None,\n        jwks_uri: str | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        issuer: str | None = None,\n        id_token_signed_response_alg: str | None = SignatureAlgs.RS256,\n        id_token_encrypted_response_alg: str | None = None,\n        id_token_decryption_key: Jwk | dict[str, Any] | None = None,\n        code_challenge_method: str = CodeChallengeMethods.S256,\n        authorization_response_iss_parameter_supported: bool = False,\n        token_class: type[BearerToken] = BearerToken,\n        session: requests.Session | None = None,\n        dpop_bound_access_tokens: bool = False,\n        dpop_key_generator: Callable[[str], DPoPKey] = DPoPKey.generate,\n        dpop_alg: str = SignatureAlgs.ES256,\n        testing: bool = False,\n        **extra_metadata: Any,\n    ) -&gt; None:\n        if authorization_response_iss_parameter_supported and not issuer:\n            raise MissingIssuerParam\n\n        auth = client_auth_factory(\n            auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            default_auth_handler=ClientSecretPost,\n        )\n\n        if authorization_server_jwks is None:\n            authorization_server_jwks = JwkSet()\n        elif not isinstance(authorization_server_jwks, JwkSet):\n            authorization_server_jwks = JwkSet(authorization_server_jwks)\n\n        if id_token_decryption_key is not None and not isinstance(id_token_decryption_key, Jwk):\n            id_token_decryption_key = Jwk(id_token_decryption_key)\n\n        if id_token_decryption_key is not None and id_token_encrypted_response_alg is None:\n            if id_token_decryption_key.alg:\n                id_token_encrypted_response_alg = id_token_decryption_key.alg\n            else:\n                raise MissingIdTokenEncryptedResponseAlgParam\n\n        if dpop_alg not in SignatureAlgs.ALL_ASYMMETRIC:\n            raise InvalidDPoPAlg(dpop_alg)\n\n        if session is None:\n            session = requests.Session()\n\n        self.__attrs_init__(\n            testing=testing,\n            token_endpoint=token_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            redirect_uri=redirect_uri,\n            backchannel_authentication_endpoint=backchannel_authentication_endpoint,\n            device_authorization_endpoint=device_authorization_endpoint,\n            pushed_authorization_request_endpoint=pushed_authorization_request_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            issuer=issuer,\n            session=session,\n            auth=auth,\n            id_token_signed_response_alg=id_token_signed_response_alg,\n            id_token_encrypted_response_alg=id_token_encrypted_response_alg,\n            id_token_decryption_key=id_token_decryption_key,\n            code_challenge_method=code_challenge_method,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            extra_metadata=extra_metadata,\n            token_class=token_class,\n            dpop_key_generator=dpop_key_generator,\n            dpop_bound_access_tokens=dpop_bound_access_tokens,\n            dpop_alg=dpop_alg,\n        )\n\n    @token_endpoint.validator\n    @revocation_endpoint.validator\n    @introspection_endpoint.validator\n    @userinfo_endpoint.validator\n    @authorization_endpoint.validator\n    @backchannel_authentication_endpoint.validator\n    @device_authorization_endpoint.validator\n    @pushed_authorization_request_endpoint.validator\n    @jwks_uri.validator\n    def validate_endpoint_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n        \"\"\"Validate that an endpoint URI is suitable for use.\n\n        If you need to disable some checks (for AS testing purposes only!), provide a different method here.\n\n        \"\"\"\n        if self.testing or uri is None:\n            return uri\n        try:\n            return validate_endpoint_uri(uri)\n        except InvalidUri as exc:\n            raise InvalidEndpointUri(endpoint=attribute.name, uri=uri, exc=exc) from exc\n\n    @issuer.validator\n    def validate_issuer_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n        \"\"\"Validate that an Issuer identifier is suitable for use.\n\n        This is the same check as an endpoint URI, but the path may be (and usually is) empty.\n\n        \"\"\"\n        if self.testing or uri is None:\n            return uri\n        try:\n            return validate_issuer_uri(uri)\n        except InvalidUri as exc:\n            raise InvalidIssuer(attribute.name, uri, exc) from exc\n\n    @property\n    def client_id(self) -&gt; str:\n        \"\"\"Client ID.\"\"\"\n        if hasattr(self.auth, \"client_id\"):\n            return self.auth.client_id  # type: ignore[no-any-return]\n        msg = \"This client uses a custom authentication method without client_id.\"\n        raise AttributeError(msg)  # pragma: no cover\n\n    @property\n    def client_secret(self) -&gt; str | None:\n        \"\"\"Client Secret.\"\"\"\n        if hasattr(self.auth, \"client_secret\"):\n            return self.auth.client_secret  # type: ignore[no-any-return]\n        return None\n\n    @property\n    def client_jwks(self) -&gt; JwkSet:\n        \"\"\"A `JwkSet` containing the public keys for this client.\n\n        Keys are:\n\n        - the public key for client assertion signature verification (if using private_key_jwt)\n        - the ID Token encryption key\n\n        \"\"\"\n        jwks = JwkSet()\n        if isinstance(self.auth, PrivateKeyJwt):\n            jwks.add_jwk(self.auth.private_jwk.public_jwk().with_usage_parameters())\n        if self.id_token_decryption_key:\n            jwks.add_jwk(self.id_token_decryption_key.public_jwk().with_usage_parameters())\n        return jwks\n\n    def _request(\n        self,\n        endpoint: str,\n        *,\n        on_success: Callable[[requests.Response, DefaultNamedArg(DPoPKey | None, \"dpop_key\")], T],\n        on_failure: Callable[[requests.Response, DefaultNamedArg(DPoPKey | None, \"dpop_key\")], T],\n        dpop_key: DPoPKey | None = None,\n        accept: str = \"application/json\",\n        method: str = \"POST\",\n        **requests_kwargs: Any,\n    ) -&gt; T:\n        \"\"\"Send a request to one of the endpoints.\n\n        This is a helper method that takes care of the following tasks:\n\n        - make sure the endpoint as been configured\n        - set `Accept: application/json` header\n        - send the HTTP POST request, then\n            - apply `on_success` to a successful response\n            - or apply `on_failure` otherwise\n        - return the result\n\n        Args:\n            endpoint: name of the endpoint to use\n            on_success: a callable to apply to successful responses\n            on_failure: a callable to apply to error responses\n            dpop_key: a `DPoPKey` to proof the request. If `None` (default), no DPoP proofing is done.\n            accept: the Accept header to include in the request\n            method: the HTTP method to use\n            **requests_kwargs: keyword arguments for the request\n\n        Raises:\n            InvalidTokenResponse: if the AS response contains a `use_dpop_nonce` error but:\n              - the response comes in reply to a non-DPoP request\n              - the DPoPKey.handle_as_provided_dpop_nonce() method raises an exception. This should happen:\n                    - if the response does not include a DPoP-Nonce HTTP header with the requested nonce value\n                    - or if the requested nonce is the same value that was sent in the request DPoP proof\n              - a new nonce value is requested again for the 3rd time in a row\n\n        \"\"\"\n        endpoint_uri = self._require_endpoint(endpoint)\n        requests_kwargs.setdefault(\"headers\", {})\n        requests_kwargs[\"headers\"][\"Accept\"] = accept\n\n        for _ in range(3):\n            if dpop_key:\n                dpop_proof = dpop_key.proof(htm=\"POST\", htu=endpoint_uri, nonce=dpop_key.as_nonce)\n                requests_kwargs.setdefault(\"headers\", {})\n                requests_kwargs[\"headers\"][\"DPoP\"] = str(dpop_proof)\n\n            response = self.session.request(\n                method,\n                endpoint_uri,\n                **requests_kwargs,\n            )\n            if response.ok:\n                return on_success(response, dpop_key=dpop_key)\n\n            try:\n                return on_failure(response, dpop_key=dpop_key)\n            except UseDPoPNonce as exc:\n                if dpop_key is None:\n                    raise InvalidTokenResponse(\n                        response,\n                        self,\n                        \"\"\"\\\nAuthorization Server requested client to include a DPoP `nonce` in its DPoP proof,\nbut the initial request did not include a DPoP proof.\n\"\"\",\n                    ) from exc\n                try:\n                    dpop_key.handle_as_provided_dpop_nonce(response)\n                except (MissingDPoPNonce, RepeatedDPoPNonce) as exc:\n                    raise InvalidTokenResponse(response, self, str(exc)) from exc\n\n        raise InvalidTokenResponse(\n            response,\n            self,\n            \"\"\"\\\nAuthorization Server requested client to use a different DPoP `nonce` for the third time in row.\nThis should never happen. This exception is raised to avoid a potential endless loop where the client\nkeeps trying to obey the new DPoP `nonce` values as provided by the Authorization Server after each token request.\n\"\"\",\n        )\n\n    def token_request(\n        self,\n        data: dict[str, Any],\n        *,\n        timeout: int = 10,\n        dpop: bool | None = None,\n        dpop_key: DPoPKey | None = None,\n        **requests_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint.\n\n        Authentication will be added automatically based on the defined `auth` for this client.\n\n        Args:\n          data: parameters to send to the token endpoint. Items with a `None`\n               or empty value will not be sent in the request.\n          timeout: a timeout value for the call\n          dpop: toggles DPoP-proofing for the token request:\n\n                - if `False`, disable it,\n                - if `True`, enable it,\n                - if `None`, defaults to `dpop_bound_access_tokens` configuration parameter for the client.\n          dpop_key: a chosen `DPoPKey` for this request. If `None`, a new key will be generated automatically\n                with a call to this client `dpop_key_generator`.\n          **requests_kwargs: additional parameters for requests.post()\n\n        Returns:\n            the token endpoint response\n\n        \"\"\"\n        if dpop is None:\n            dpop = self.dpop_bound_access_tokens\n        if dpop and not dpop_key:\n            dpop_key = self.dpop_key_generator(self.dpop_alg)\n\n        return self._request(\n            Endpoints.TOKEN,\n            auth=self.auth,\n            data=data,\n            timeout=timeout,\n            dpop_key=dpop_key,\n            on_success=self.parse_token_response,\n            on_failure=self.on_token_error,\n            **requests_kwargs,\n        )\n\n    def parse_token_response(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; BearerToken:\n        \"\"\"Parse a Response returned by the Token Endpoint.\n\n        Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse\n        responses returned by the Token Endpoint. Those responses contain an `access_token` and\n        additional attributes.\n\n        Args:\n            response: the `Response` returned by the Token Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            a `BearerToken` based on the response contents.\n\n        \"\"\"\n        token_class = dpop_key.dpop_token_class if dpop_key is not None else self.token_class\n        try:\n            token_response = token_class(**response.json(), _dpop_key=dpop_key)\n        except Exception:  # noqa: BLE001\n            return self.on_token_error(response, dpop_key=dpop_key)\n        else:\n            return token_response\n\n    def on_token_error(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,  # noqa: ARG002\n    ) -&gt; BearerToken:\n        \"\"\"Error handler for `token_request()`.\n\n        Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the\n        Token Endpoint returns an error.\n\n        Args:\n            response: the `Response` returned by the Token Endpoint.\n            dpop_key: the DPoPKey that was used to proof the token request, if any.\n\n        Returns:\n            nothing, and raises an exception instead. But a subclass may return a\n            `BearerToken` to implement a default behaviour if needed.\n\n        Raises:\n            InvalidTokenResponse: if the error response does not contain an OAuth 2.0 standard\n                error response.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidTokenResponse(\n                response=response,\n                client=self,\n                description=f\"An error happened while processing the error response: {exc}\",\n            ) from exc\n        raise exception\n\n    def client_credentials(\n        self,\n        scope: str | Iterable[str] | None = None,\n        *,\n        dpop: bool | None = None,\n        dpop_key: DPoPKey | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint using the `client_credentials` grant.\n\n        Args:\n            scope: the scope to send with the request. Can be a str, or an iterable of str.\n                to pass that way include `scope`, `audience`, `resource`, etc.\n            dpop: toggles DPoP-proofing for the token request:\n\n                - if `False`, disable it,\n                - if `True`, enable it,\n                - if `None`, defaults to `dpop_bound_access_tokens` configuration parameter for the client.\n            dpop_key: a chosen `DPoPKey` for this request. If `None`, a new key will be generated automatically\n                with a call to `dpop_key_generator`.\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters that will be added in the form data for the token endpoint,\n                 alongside `grant_type`.\n\n        Returns:\n            a `BearerToken` or `DPoPToken`, depending on the AS response.\n\n        Raises:\n            InvalidScopeParam: if the `scope` parameter is not suitable\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if scope and not isinstance(scope, str):\n            try:\n                scope = \" \".join(scope)\n            except Exception as exc:\n                raise InvalidScopeParam(scope) from exc\n\n        data = dict(grant_type=GrantTypes.CLIENT_CREDENTIALS, scope=scope, **token_kwargs)\n        return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n\n    def authorization_code(\n        self,\n        code: str | AuthorizationResponse,\n        *,\n        validate: bool = True,\n        dpop: bool = False,\n        dpop_key: DPoPKey | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint with the `authorization_code` grant.\n\n        You can either pass an authorization code, as a `str`, or pass an `AuthorizationResponse` instance as\n        returned by `AuthorizationRequest.validate_callback()` (recommended). If you do the latter, this will\n        automatically:\n\n        - add the appropriate `redirect_uri` value that was initially passed in the Authorization Request parameters.\n        This is no longer mandatory in OAuth 2.1, but a lot of Authorization Servers are still expecting it since it was\n        part of the OAuth 2.0 specifications.\n        - add the appropriate `code_verifier` for PKCE that was generated before sending the AuthorizationRequest.\n        - handle DPoP binding based on the same `DPoPKey` that was used to initialize the `AuthenticationRequest` and\n        whose JWK thumbprint was passed as `dpop_jkt` parameter in the Auth Request.\n\n        Args:\n            code: An authorization code or an `AuthorizationResponse` to exchange for tokens.\n            validate: If `True`, validate the ID Token (this works only if `code` is an `AuthorizationResponse`).\n            dpop: Toggles DPoP binding for the Access Token,\n                 even if Authorization Code DPoP binding was not initially done.\n            dpop_key: A chosen DPoP key. Leave `None` to automatically generate a key, if `dpop` is `True`.\n            requests_kwargs: Additional parameters for the call to the underlying HTTP `requests` call.\n            **token_kwargs: Additional parameters that will be added in the form data for the token endpoint,\n                alongside `grant_type`, `code`, etc.\n\n        Returns:\n            The Token Endpoint Response.\n\n        \"\"\"\n        azr: AuthorizationResponse | None = None\n        if isinstance(code, AuthorizationResponse):\n            token_kwargs.setdefault(\"code_verifier\", code.code_verifier)\n            token_kwargs.setdefault(\"redirect_uri\", code.redirect_uri)\n            azr = code\n            dpop_key = code.dpop_key\n            code = code.code\n\n        requests_kwargs = requests_kwargs or {}\n\n        data = dict(grant_type=GrantTypes.AUTHORIZATION_CODE, code=code, **token_kwargs)\n        token = self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n        if validate and token.id_token and isinstance(azr, AuthorizationResponse):\n            return token.validate_id_token(self, azr)\n        return token\n\n    def refresh_token(\n        self,\n        refresh_token: str | BearerToken,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint with the `refresh_token` grant.\n\n        If `refresh_token` is a `DPoPToken` instance, (which means that DPoP was used to obtain the initial\n        Access/Refresh Tokens), then the same DPoP key will be used to DPoP proof the refresh token request,\n        as defined in RFC9449.\n\n        Args:\n            refresh_token: A refresh_token, as a string, or as a `BearerToken`.\n                That `BearerToken` must have a `refresh_token`.\n            requests_kwargs: Additional parameters for the call to `requests`.\n            **token_kwargs: Additional parameters for the token endpoint,\n                alongside `grant_type`, `refresh_token`, etc.\n\n        Returns:\n            The token endpoint response.\n\n        Raises:\n            MissingRefreshToken: If `refresh_token` is a `BearerToken` instance but does not\n                contain a `refresh_token`.\n\n        \"\"\"\n        dpop_key: DPoPKey | None = None\n        if isinstance(refresh_token, BearerToken):\n            if refresh_token.refresh_token is None or not isinstance(refresh_token.refresh_token, str):\n                raise MissingRefreshToken(refresh_token)\n            if isinstance(refresh_token, DPoPToken):\n                dpop_key = refresh_token.dpop_key\n            refresh_token = refresh_token.refresh_token\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(grant_type=GrantTypes.REFRESH_TOKEN, refresh_token=refresh_token, **token_kwargs)\n        return self.token_request(data, dpop_key=dpop_key, **requests_kwargs)\n\n    def device_code(\n        self,\n        device_code: str | DeviceAuthorizationResponse,\n        *,\n        dpop: bool = False,\n        dpop_key: DPoPKey | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint using the Device Code grant.\n\n        The grant_type is `urn:ietf:params:oauth:grant-type:device_code`. This needs a Device Code,\n        or a `DeviceAuthorizationResponse` as parameter.\n\n        Args:\n            device_code: A device code, or a `DeviceAuthorizationResponse`.\n            dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n            dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n            requests_kwargs: Additional parameters for the call to requests.\n            **token_kwargs: Additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc.\n\n        Returns:\n            The Token Endpoint response.\n\n        Raises:\n            MissingDeviceCode: if `device_code` is a DeviceAuthorizationResponse but does not\n                contain a `device_code`.\n\n        \"\"\"\n        if isinstance(device_code, DeviceAuthorizationResponse):\n            if device_code.device_code is None or not isinstance(device_code.device_code, str):\n                raise MissingDeviceCode(device_code)\n            device_code = device_code.device_code\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantTypes.DEVICE_CODE,\n            device_code=device_code,\n            **token_kwargs,\n        )\n        return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n\n    def ciba(\n        self,\n        auth_req_id: str | BackChannelAuthenticationResponse,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a CIBA request to the Token Endpoint.\n\n        A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant.\n\n        Args:\n            auth_req_id: an authentication request ID, as returned by the AS\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc.\n\n        Returns:\n            The Token Endpoint response.\n\n        Raises:\n            MissingAuthRequestId: if `auth_req_id` is a BackChannelAuthenticationResponse but does not contain\n                an `auth_req_id`.\n\n        \"\"\"\n        if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n            if auth_req_id.auth_req_id is None or not isinstance(auth_req_id.auth_req_id, str):\n                raise MissingAuthRequestId(auth_req_id)\n            auth_req_id = auth_req_id.auth_req_id\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantTypes.CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION,\n            auth_req_id=auth_req_id,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def token_exchange(\n        self,\n        *,\n        subject_token: str | BearerToken | IdToken,\n        subject_token_type: str | None = None,\n        actor_token: None | str | BearerToken | IdToken = None,\n        actor_token_type: str | None = None,\n        requested_token_type: str | None = None,\n        dpop: bool = False,\n        dpop_key: DPoPKey | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a Token Exchange request.\n\n        A Token Exchange request is actually a request to the Token Endpoint with a grant_type\n        `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n        Args:\n            subject_token: The subject token to exchange for a new token.\n            subject_token_type: A token type identifier for the subject_token, mandatory if it cannot be guessed based\n                on `type(subject_token)`.\n            actor_token: The actor token to include in the request, if any.\n            actor_token_type: A token type identifier for the actor_token, mandatory if it cannot be guessed based\n                on `type(actor_token)`.\n            requested_token_type: A token type identifier for the requested token.\n            dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n            dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n            requests_kwargs: Additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: Additional parameters to include in the request body.\n\n        Returns:\n            The Token Endpoint response.\n\n        Raises:\n            UnknownSubjectTokenType: If the type of `subject_token` cannot be determined automatically.\n            UnknownActorTokenType: If the type of `actor_token` cannot be determined automatically.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        try:\n            subject_token_type = self.get_token_type(subject_token_type, subject_token)\n        except ValueError as exc:\n            raise UnknownSubjectTokenType(subject_token, subject_token_type) from exc\n        if actor_token:  # pragma: no branch\n            try:\n                actor_token_type = self.get_token_type(actor_token_type, actor_token)\n            except ValueError as exc:\n                raise UnknownActorTokenType(actor_token, actor_token_type) from exc\n\n        data = dict(\n            grant_type=GrantTypes.TOKEN_EXCHANGE,\n            subject_token=subject_token,\n            subject_token_type=subject_token_type,\n            actor_token=actor_token,\n            actor_token_type=actor_token_type,\n            requested_token_type=requested_token_type,\n            **token_kwargs,\n        )\n        return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n\n    def jwt_bearer(\n        self,\n        assertion: Jwt | str,\n        *,\n        dpop: bool = False,\n        dpop_key: DPoPKey | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request using a JWT as authorization grant.\n\n        This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).\n\n        Args:\n            assertion: A JWT (as an instance of `jwskate.Jwt` or as a `str`) to use as authorization grant.\n            dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n            dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n            requests_kwargs: Additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: Additional parameters to include in the request body.\n\n        Returns:\n            The Token Endpoint response.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if not isinstance(assertion, Jwt):\n            assertion = Jwt(assertion)\n\n        data = dict(\n            grant_type=GrantTypes.JWT_BEARER,\n            assertion=assertion,\n            **token_kwargs,\n        )\n\n        return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n\n    def resource_owner_password(\n        self,\n        username: str,\n        password: str,\n        *,\n        dpop: bool | None = None,\n        dpop_key: DPoPKey | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request using the Resource Owner Password Grant.\n\n        This Grant Type is deprecated and should only be used when there is no other choice.\n\n        Args:\n            username: the resource owner user name\n            password: the resource owner password\n            dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n            dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            The Token Endpoint response.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantTypes.RESOURCE_OWNER_PASSWORD,\n            username=username,\n            password=password,\n            **token_kwargs,\n        )\n\n        return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n\n    def authorization_request(\n        self,\n        *,\n        scope: None | str | Iterable[str] = \"openid\",\n        response_type: str = ResponseTypes.CODE,\n        redirect_uri: str | None = None,\n        state: str | ellipsis | None = ...,  # noqa: F821\n        nonce: str | ellipsis | None = ...,  # noqa: F821\n        code_verifier: str | None = None,\n        dpop: bool | None = None,\n        dpop_key: DPoPKey | None = None,\n        dpop_alg: str | None = None,\n        **kwargs: Any,\n    ) -&gt; AuthorizationRequest:\n        \"\"\"Generate an Authorization Request for this client.\n\n        Args:\n            scope: The `scope` to use.\n            response_type: The `response_type` to use.\n            redirect_uri: The `redirect_uri` to include in the request. By default,\n                the `redirect_uri` defined at init time is used.\n            state: The `state` parameter to use. Leave default to generate a random value.\n            nonce: A `nonce`. Leave default to generate a random value.\n            dpop: Toggles DPoP binding.\n                - if `True`, DPoP binding is used\n                - if `False`, DPoP is not used\n                - if `None`, defaults to `self.dpop_bound_access_tokens`\n            dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for you.\n            dpop_alg: A signature alg to sign the DPoP proof. If `None`, this defaults to `self.dpop_alg`.\n                If DPoP is not used, or a chosen `dpop_key` is provided, this is ignored.\n                This affects the key type if a DPoP key must be generated.\n            code_verifier: The PKCE `code_verifier` to use. Leave default to generate a random value.\n            **kwargs: Additional query parameters to include in the auth request.\n\n        Returns:\n            The Token Endpoint response.\n\n        \"\"\"\n        authorization_endpoint = self._require_endpoint(\"authorization_endpoint\")\n\n        redirect_uri = redirect_uri or self.redirect_uri\n\n        if dpop is None:\n            dpop = self.dpop_bound_access_tokens\n        if dpop_alg is None:\n            dpop_alg = self.dpop_alg\n\n        return AuthorizationRequest(\n            authorization_endpoint=authorization_endpoint,\n            client_id=self.client_id,\n            redirect_uri=redirect_uri,\n            issuer=self.issuer,\n            response_type=response_type,\n            scope=scope,\n            state=state,\n            nonce=nonce,\n            code_verifier=code_verifier,\n            code_challenge_method=self.code_challenge_method,\n            dpop=dpop,\n            dpop_key=dpop_key,\n            dpop_alg=dpop_alg,\n            **kwargs,\n        )\n\n    def pushed_authorization_request(\n        self,\n        authorization_request: AuthorizationRequest,\n        requests_kwargs: dict[str, Any] | None = None,\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Send a Pushed Authorization Request.\n\n        This sends a request to the Pushed Authorization Request Endpoint, and returns a\n        `RequestUriParameterAuthorizationRequest` initialized with the AS response.\n\n        Args:\n            authorization_request: The authorization request to send.\n            requests_kwargs: Additional parameters for `requests.request()`.\n\n        Returns:\n            The `RequestUriParameterAuthorizationRequest` initialized based on the AS response.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n        return self._request(\n            Endpoints.PUSHED_AUTHORIZATION_REQUEST,\n            data=authorization_request.args,\n            auth=self.auth,\n            on_success=self.parse_pushed_authorization_response,\n            on_failure=self.on_pushed_authorization_request_error,\n            dpop_key=authorization_request.dpop_key,\n            **requests_kwargs,\n        )\n\n    def parse_pushed_authorization_response(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Parse the response obtained by `pushed_authorization_request()`.\n\n        Args:\n            response: The `requests.Response` returned by the PAR endpoint.\n            dpop_key: The `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            A `RequestUriParameterAuthorizationRequest` instance initialized based on the PAR endpoint response.\n\n        \"\"\"\n        response_json = response.json()\n        request_uri = response_json.get(\"request_uri\")\n        expires_in = response_json.get(\"expires_in\")\n\n        return RequestUriParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request_uri=request_uri,\n            expires_in=expires_in,\n            dpop_key=dpop_key,\n        )\n\n    def on_pushed_authorization_request_error(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,  # noqa: ARG002\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Error Handler for Pushed Authorization Endpoint errors.\n\n        Args:\n            response: The HTTP response as returned by the AS PAR endpoint.\n            dpop_key: The `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            Should not return anything, but raise an Exception instead. A `RequestUriParameterAuthorizationRequest`\n            may be returned by subclasses for testing purposes.\n\n        Raises:\n            EndpointError: A subclass of this error depending on the error returned by the AS.\n            InvalidPushedAuthorizationResponse: If the returned response is not following the specifications.\n            UnknownTokenEndpointError: For unknown/unhandled errors.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidPushedAuthorizationResponse(response=response, client=self) from exc\n        raise exception\n\n    def userinfo(self, access_token: BearerToken | str) -&gt; Any:\n        \"\"\"Call the UserInfo endpoint.\n\n        This sends a request to the UserInfo endpoint, with the specified access_token, and returns\n        the parsed result.\n\n        Args:\n            access_token: the access token to use\n\n        Returns:\n            the [Response][requests.Response] returned by the userinfo endpoint.\n\n        \"\"\"\n        if isinstance(access_token, str):\n            access_token = BearerToken(access_token)\n        return self._request(\n            Endpoints.USER_INFO,\n            auth=access_token,\n            on_success=self.parse_userinfo_response,\n            on_failure=self.on_userinfo_error,\n        )\n\n    def parse_userinfo_response(self, resp: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; Any:  # noqa: ARG002\n        \"\"\"Parse the response obtained by `userinfo()`.\n\n        Invoked by [userinfo()][requests_oauth2client.client.OAuth2Client.userinfo] to parse the\n        response from the UserInfo endpoint, this will extract and return its JSON content.\n\n        Args:\n            resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            the parsed JSON content from this response.\n\n        \"\"\"\n        return resp.json()\n\n    def on_userinfo_error(self, resp: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; Any:  # noqa: ARG002\n        \"\"\"Parse UserInfo error response.\n\n        Args:\n            resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            nothing, raises exception instead.\n\n        \"\"\"\n        resp.raise_for_status()\n\n    @classmethod\n    def get_token_type(  # noqa: C901\n        cls,\n        token_type: str | None = None,\n        token: None | str | BearerToken | IdToken = None,\n    ) -&gt; str:\n        \"\"\"Get standardized token type identifiers.\n\n        Return a standardized token type identifier, based on a short `token_type` hint and/or a\n        token value.\n\n        Args:\n            token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\"\n                or \"id_token\"\n            token: a token value, as an instance of `BearerToken` or IdToken, or as a `str`.\n\n        Returns:\n            the token_type as defined in the Token Exchange RFC8693.\n\n        Raises:\n            UnknownTokenType: if the type of token cannot be determined\n\n        \"\"\"\n        if not (token_type or token):\n            msg = \"Cannot determine type of an empty token without a token_type hint\"\n            raise UnknownTokenType(msg, token, token_type)\n\n        if token_type is None:\n            if isinstance(token, str):\n                msg = \"\"\"\\\nCannot determine the type of provided token when it is a bare `str`. Please specify a 'token_type'.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            if isinstance(token, BearerToken):\n                return \"urn:ietf:params:oauth:token-type:access_token\"\n            if isinstance(token, IdToken):\n                return \"urn:ietf:params:oauth:token-type:id_token\"\n            msg = f\"Unknown token type {type(token)}\"\n            raise UnknownTokenType(msg, token, token_type)\n        if token_type == TokenType.ACCESS_TOKEN:\n            if token is not None and not isinstance(token, (str, BearerToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nA BearerToken or an access_token as a `str` is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:access_token\"\n        if token_type == TokenType.REFRESH_TOKEN:\n            if token is not None and isinstance(token, BearerToken) and not token.refresh_token:\n                msg = f\"\"\"\\\nThe supplied BearerToken does not contain a refresh_token, which is inconsistent with token_type '{token_type}'.\nA BearerToken containing a refresh_token is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:refresh_token\"\n        if token_type == TokenType.ID_TOKEN:\n            if token is not None and not isinstance(token, (str, IdToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nAn IdToken or a string representation of it is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:id_token\"\n\n        return {\n            \"saml1\": \"urn:ietf:params:oauth:token-type:saml1\",\n            \"saml2\": \"urn:ietf:params:oauth:token-type:saml2\",\n            \"jwt\": \"urn:ietf:params:oauth:token-type:jwt\",\n        }.get(token_type, token_type)\n\n    def revoke_access_token(\n        self,\n        access_token: BearerToken | str,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a request to the Revocation Endpoint to revoke an access token.\n\n        Args:\n            access_token: the access token to revoke\n            requests_kwargs: additional parameters for the underlying requests.post() call\n            **revoke_kwargs: additional parameters to pass to the revocation endpoint\n\n        \"\"\"\n        return self.revoke_token(\n            access_token,\n            token_type_hint=TokenType.ACCESS_TOKEN,\n            requests_kwargs=requests_kwargs,\n            **revoke_kwargs,\n        )\n\n    def revoke_refresh_token(\n        self,\n        refresh_token: str | BearerToken,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a request to the Revocation Endpoint to revoke a refresh token.\n\n        Args:\n            refresh_token: the refresh token to revoke.\n            requests_kwargs: additional parameters to pass to the revocation endpoint.\n            **revoke_kwargs: additional parameters to pass to the revocation endpoint.\n\n        Returns:\n            `True` if the revocation request is successful, `False` if this client has no configured\n            revocation endpoint.\n\n        Raises:\n            MissingRefreshToken: when `refresh_token` is a [BearerToken][requests_oauth2client.tokens.BearerToken]\n                but does not contain a `refresh_token`.\n\n        \"\"\"\n        if isinstance(refresh_token, BearerToken):\n            if refresh_token.refresh_token is None:\n                raise MissingRefreshToken(refresh_token)\n            refresh_token = refresh_token.refresh_token\n\n        return self.revoke_token(\n            refresh_token,\n            token_type_hint=TokenType.REFRESH_TOKEN,\n            requests_kwargs=requests_kwargs,\n            **revoke_kwargs,\n        )\n\n    def revoke_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a Token Revocation request.\n\n        By default, authentication will be the same than the one used for the Token Endpoint.\n\n        Args:\n            token: the token to revoke.\n            token_type_hint: a token_type_hint to send to the revocation endpoint.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **revoke_kwargs: additional parameters to send to the revocation endpoint.\n\n        Returns:\n            the result from `parse_revocation_response` on the returned AS response.\n\n        Raises:\n            MissingEndpointUri: if the Revocation Endpoint URI is not configured.\n            MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n                but does not contain a `refresh_token`.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if token_type_hint == TokenType.REFRESH_TOKEN and isinstance(token, BearerToken):\n            if token.refresh_token is None:\n                raise MissingRefreshToken(token)\n            token = token.refresh_token\n\n        data = dict(revoke_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            Endpoints.REVOCATION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_revocation_response,\n            on_failure=self.on_revocation_error,\n            **requests_kwargs,\n        )\n\n    def parse_revocation_response(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; bool:  # noqa: ARG002\n        \"\"\"Parse reponses from the Revocation Endpoint.\n\n        Since those do not return any meaningful information in a standardised fashion, this just returns `True`.\n\n        Args:\n            response: the `requests.Response` as returned by the Revocation Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            `True` if the revocation succeeds, `False` if no revocation endpoint is present or a\n            non-standardised error is returned.\n\n        \"\"\"\n        return True\n\n    def on_revocation_error(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; bool:  # noqa: ARG002\n        \"\"\"Error handler for `revoke_token()`.\n\n        Invoked by [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token] when the\n        revocation endpoint returns an error.\n\n        Args:\n            response: the `requests.Response` as returned by the Revocation Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            `False` to signal that an error occurred. May raise exceptions instead depending on the\n            revocation response.\n\n        Raises:\n            EndpointError: if the response contains a standardised OAuth 2.0 error.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, RevocationError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception:  # noqa: BLE001\n            return False\n        raise exception\n\n    def introspect_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **introspect_kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"Send a request to the Introspection Endpoint.\n\n        Parameter `token` can be:\n\n        - a `str`\n        - a `BearerToken` instance\n\n        You may pass any arbitrary `token` and `token_type_hint` values as `str`. Those will\n        be included in the request, as-is.\n        If `token` is a `BearerToken`, then `token_type_hint` must be either:\n\n        - `None`: the access_token will be instrospected and no token_type_hint will be included\n        in the request\n        - `access_token`: same as `None`, but the token_type_hint will be included\n        - or `refresh_token`: only available if a Refresh Token is present in the BearerToken.\n\n        Args:\n            token: the token to instrospect\n            token_type_hint: the `token_type_hint` to include in the request.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **introspect_kwargs: additional parameters to send to the introspection endpoint.\n\n        Returns:\n            the response as returned by the Introspection Endpoint.\n\n        Raises:\n            MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n                but does not contain a `refresh_token`.\n            UnknownTokenType: if `token_type_hint` is neither `None`, `\"access_token\"` or `\"refresh_token\"`.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if isinstance(token, BearerToken):\n            if token_type_hint is None or token_type_hint == TokenType.ACCESS_TOKEN:\n                token = token.access_token\n            elif token_type_hint == TokenType.REFRESH_TOKEN:\n                if token.refresh_token is None:\n                    raise MissingRefreshToken(token)\n\n                token = token.refresh_token\n            else:\n                msg = \"\"\"\\\nInvalid `token_type_hint`. To test arbitrary `token_type_hint` values, you must provide `token` as a `str`.\"\"\"\n                raise UnknownTokenType(msg, token, token_type_hint)\n\n        data = dict(introspect_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            Endpoints.INTROSPECTION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_introspection_response,\n            on_failure=self.on_introspection_error,\n            **requests_kwargs,\n        )\n\n    def parse_introspection_response(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,  # noqa: ARG002\n    ) -&gt; Any:\n        \"\"\"Parse Token Introspection Responses received by `introspect_token()`.\n\n        Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n        to parse the returned response. This decodes the JSON content if possible, otherwise it\n        returns the response as a string.\n\n        Args:\n            response: the [Response][requests.Response] as returned by the Introspection Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            the decoded JSON content, or a `str` with the content.\n\n        \"\"\"\n        try:\n            return response.json()\n        except ValueError:\n            return response.text\n\n    def on_introspection_error(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; Any:  # noqa: ARG002\n        \"\"\"Error handler for `introspect_token()`.\n\n        Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n        to parse the returned response in the case an error is returned.\n\n        Args:\n            response: the response as returned by the Introspection Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            usually raises exceptions. A subclass can return a default response instead.\n\n        Raises:\n            EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n            UnknownIntrospectionError: if the response is not a standard error response.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, IntrospectionError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise UnknownIntrospectionError(response=response, client=self) from exc\n        raise exception\n\n    def backchannel_authentication_request(  # noqa: PLR0913\n        self,\n        scope: None | str | Iterable[str] = \"openid\",\n        *,\n        client_notification_token: str | None = None,\n        acr_values: None | str | Iterable[str] = None,\n        login_hint_token: str | None = None,\n        id_token_hint: str | None = None,\n        login_hint: str | None = None,\n        binding_message: str | None = None,\n        user_code: str | None = None,\n        requested_expiry: int | None = None,\n        private_jwk: Jwk | dict[str, Any] | None = None,\n        alg: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **ciba_kwargs: Any,\n    ) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Send a CIBA Authentication Request.\n\n        Args:\n             scope: the scope to include in the request.\n             client_notification_token: the Client Notification Token to include in the request.\n             acr_values: the acr values to include in the request.\n             login_hint_token: the Login Hint Token to include in the request.\n             id_token_hint: the ID Token Hint to include in the request.\n             login_hint: the Login Hint to include in the request.\n             binding_message: the Binding Message to include in the request.\n             user_code: the User Code to include in the request\n             requested_expiry: the Requested Expiry, in seconds, to include in the request.\n             private_jwk: the JWK to use to sign the request (optional)\n             alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.\n             requests_kwargs: additional parameters for\n             **ciba_kwargs: additional parameters to include in the request.\n\n        Returns:\n            a BackChannelAuthenticationResponse as returned by AS\n\n        Raises:\n            InvalidBackchannelAuthenticationRequestHintParam: if none of `login_hint`, `login_hint_token`\n                or `id_token_hint` is provided, or more than one of them is provided.\n            InvalidScopeParam: if the `scope` parameter is invalid.\n            InvalidAcrValuesParam: if the `acr_values` parameter is invalid.\n\n        \"\"\"\n        if not (login_hint or login_hint_token or id_token_hint):\n            msg = \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n            raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n        if (login_hint_token and id_token_hint) or (login_hint and id_token_hint) or (login_hint_token and login_hint):\n            msg = \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n            raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n        requests_kwargs = requests_kwargs or {}\n\n        if scope is not None and not isinstance(scope, str):\n            try:\n                scope = \" \".join(scope)\n            except Exception as exc:\n                raise InvalidScopeParam(scope) from exc\n\n        if acr_values is not None and not isinstance(acr_values, str):\n            try:\n                acr_values = \" \".join(acr_values)\n            except Exception as exc:\n                raise InvalidAcrValuesParam(acr_values) from exc\n\n        data = dict(\n            ciba_kwargs,\n            scope=scope,\n            client_notification_token=client_notification_token,\n            acr_values=acr_values,\n            login_hint_token=login_hint_token,\n            id_token_hint=id_token_hint,\n            login_hint=login_hint,\n            binding_message=binding_message,\n            user_code=user_code,\n            requested_expiry=requested_expiry,\n        )\n\n        if private_jwk is not None:\n            data = {\"request\": str(Jwt.sign(data, key=private_jwk, alg=alg))}\n\n        return self._request(\n            Endpoints.BACKCHANNEL_AUTHENTICATION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_backchannel_authentication_response,\n            on_failure=self.on_backchannel_authentication_error,\n            **requests_kwargs,\n        )\n\n    def parse_backchannel_authentication_response(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,  # noqa: ARG002\n    ) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Parse a response received by `backchannel_authentication_request()`.\n\n        Invoked by\n        [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n        to parse the response returned by the BackChannel Authentication Endpoint.\n\n        Args:\n            response: the response returned by the BackChannel Authentication Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            a `BackChannelAuthenticationResponse`\n\n        Raises:\n            InvalidBackChannelAuthenticationResponse: if the response does not contain a standard\n                BackChannel Authentication response.\n\n        \"\"\"\n        try:\n            return BackChannelAuthenticationResponse(**response.json())\n        except TypeError as exc:\n            raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n\n    def on_backchannel_authentication_error(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,  # noqa: ARG002\n    ) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Error handler for `backchannel_authentication_request()`.\n\n        Invoked by\n        [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n        to parse the response returned by the BackChannel Authentication Endpoint, when it is an\n        error.\n\n        Args:\n            response: the response returned by the BackChannel Authentication Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            usually raises an exception. But a subclass can return a default response instead.\n\n        Raises:\n            EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n            InvalidBackChannelAuthenticationResponse: for non-standard error responses.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, BackChannelAuthenticationError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n        raise exception\n\n    def authorize_device(\n        self,\n        requests_kwargs: dict[str, Any] | None = None,\n        **data: Any,\n    ) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Send a Device Authorization Request.\n\n        Args:\n            **data: additional data to send to the Device Authorization Endpoint\n            requests_kwargs: additional parameters for `requests.request()`\n\n        Returns:\n            a Device Authorization Response\n\n        Raises:\n            MissingEndpointUri: if the Device Authorization URI is not configured\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        return self._request(\n            Endpoints.DEVICE_AUTHORIZATION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_device_authorization_response,\n            on_failure=self.on_device_authorization_error,\n            **requests_kwargs,\n        )\n\n    def parse_device_authorization_response(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,  # noqa: ARG002\n    ) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Parse a Device Authorization Response received by `authorize_device()`.\n\n        Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n        to parse the response returned by the Device Authorization Endpoint.\n\n        Args:\n            response: the response returned by the Device Authorization Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            a `DeviceAuthorizationResponse` as returned by AS\n\n        \"\"\"\n        return DeviceAuthorizationResponse(**response.json())\n\n    def on_device_authorization_error(\n        self,\n        response: requests.Response,\n        *,\n        dpop_key: DPoPKey | None = None,  # noqa: ARG002\n    ) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Error handler for `authorize_device()`.\n\n        Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n        to parse the response returned by the Device Authorization Endpoint, when that response is\n        an error.\n\n        Args:\n            response: the response returned by the Device Authorization Endpoint.\n            dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n        Returns:\n            usually raises an Exception. But a subclass may return a default response instead.\n\n        Raises:\n            EndpointError: for standard OAuth 2.0 errors\n            InvalidDeviceAuthorizationResponse: for non-standard error responses.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, DeviceAuthorizationError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidDeviceAuthorizationResponse(response=response, client=self) from exc\n        raise exception\n\n    def update_authorization_server_public_keys(self, requests_kwargs: dict[str, Any] | None = None) -&gt; JwkSet:\n        \"\"\"Update the cached AS public keys by retrieving them from its `jwks_uri`.\n\n        Public keys are returned by this method, as a `jwskate.JwkSet`. They are also\n        available in attribute `authorization_server_jwks`.\n\n        Returns:\n            the retrieved public keys\n\n        Raises:\n            ValueError: if no `jwks_uri` is configured\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n        requests_kwargs.setdefault(\"auth\", None)\n\n        jwks_uri = self._require_endpoint(Endpoints.JWKS)\n        resp = self.session.get(jwks_uri, **requests_kwargs)\n        resp.raise_for_status()\n        jwks = resp.json()\n        self.authorization_server_jwks.update(jwks)\n        return self.authorization_server_jwks\n\n    @classmethod\n    def from_discovery_endpoint(\n        cls,\n        url: str | None = None,\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        session: requests.Session | None = None,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an `OAuth2Client` using an AS Discovery Document endpoint.\n\n        If an `url` is provided, an HTTPS request will be done to that URL to obtain the Authorization Server Metadata.\n\n        If an `issuer` is provided, the OpenID Connect Discovery document url will be automatically\n        derived from it, as specified in [OpenID Connect Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationRequest).\n\n        Once the standardized metadata document is obtained, this will extract\n        all Endpoint Uris from that document, will fetch the current public keys from its\n        `jwks_uri`, then will initialize an OAuth2Client based on those endpoints.\n\n        Args:\n          url: The url where the server metadata will be retrieved.\n          issuer: The issuer value that is expected in the discovery document.\n            If not `url` is given, the OpenID Connect Discovery url for this issuer will be retrieved.\n          auth: The authentication handler to use for client authentication.\n          client_id: Client ID.\n          client_secret: Client secret to use to authenticate the client.\n          private_key: Private key to sign client assertions.\n          session: A `requests.Session` to use to retrieve the document and initialise the client with.\n          testing: If `True`, do not try to validate the issuer uri nor the endpoint urls\n            that are part of the document.\n          **kwargs: Additional keyword parameters to pass to `OAuth2Client`.\n\n        Returns:\n          An `OAuth2Client` with endpoints initialized based on the obtained metadata.\n\n        Raises:\n          InvalidIssuer: If `issuer` is not using https, or contains credentials or fragment.\n          InvalidParam: If neither `url` nor `issuer` are suitable urls.\n          requests.HTTPError: If an error happens while fetching the documents.\n\n        Example:\n            ```python\n            from requests_oauth2client import OAuth2Client\n\n            client = OAuth2Client.from_discovery_endpoint(\n                issuer=\"https://myserver.net\",\n                client_id=\"my_client_id,\n                client_secret=\"my_client_secret\",\n            )\n            ```\n\n        \"\"\"\n        if issuer is not None and not testing:\n            try:\n                validate_issuer_uri(issuer)\n            except InvalidUri as exc:\n                raise InvalidIssuer(\"issuer\", issuer, exc) from exc  # noqa: EM101\n        if url is None and issuer is not None:\n            url = oidc_discovery_document_url(issuer)\n        if url is None:\n            msg = \"Please specify at least one of `issuer` or `url`\"\n            raise InvalidParam(msg)\n\n        if not testing:\n            validate_endpoint_uri(url, path=False)\n\n        session = session or requests.Session()\n        discovery = session.get(url).json()\n\n        jwks_uri = discovery.get(\"jwks_uri\")\n        jwks = JwkSet(session.get(jwks_uri).json()) if jwks_uri else None\n\n        return cls.from_discovery_document(\n            discovery,\n            issuer=issuer,\n            auth=auth,\n            session=session,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            authorization_server_jwks=jwks,\n            testing=testing,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_discovery_document(\n        cls,\n        discovery: dict[str, Any],\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        https: bool = True,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an `OAuth2Client`, based on an AS Discovery Document.\n\n        Args:\n          discovery: A `dict` of server metadata, in the same format as retrieved from a discovery endpoint.\n          issuer: If an issuer is given, check that it matches the one mentioned in the document.\n          auth: The authentication handler to use for client authentication.\n          client_id: Client ID.\n          client_secret: Client secret to use to authenticate the client.\n          private_key: Private key to sign client assertions.\n          authorization_server_jwks: The current authorization server JWKS keys.\n          https: (deprecated) If `True`, validates that urls in the discovery document use the https scheme.\n          testing: If `True`, don't try to validate the endpoint urls that are part of the document.\n          **kwargs: Additional args that will be passed to `OAuth2Client`.\n\n        Returns:\n            An `OAuth2Client` initialized with the endpoints from the discovery document.\n\n        Raises:\n            InvalidDiscoveryDocument: If the document does not contain at least a `\"token_endpoint\"`.\n\n        Examples:\n            ```python\n            from requests_oauth2client import OAuth2Client\n\n            client = OAuth2Client.from_discovery_document(\n                {\n                    \"issuer\": \"https://myas.local\",\n                    \"token_endpoint\": \"https://myas.local/token\",\n                },\n                client_id=\"client_id\",\n                client_secret=\"client_secret\",\n            )\n            ```\n\n        \"\"\"\n        if not https:\n            warnings.warn(\n                \"\"\"\\\nThe `https` parameter is deprecated.\nTo disable endpoint uri validation, set `testing=True` when initializing your `OAuth2Client`.\"\"\",\n                stacklevel=1,\n            )\n            testing = True\n        if issuer and discovery.get(\"issuer\") != issuer:\n            msg = f\"\"\"\\\nMismatching `issuer` value in discovery document (received '{discovery.get(\"issuer\")}', expected '{issuer}').\"\"\"\n            raise InvalidParam(\n                msg,\n                issuer,\n                discovery.get(\"issuer\"),\n            )\n        if issuer is None:\n            issuer = discovery.get(\"issuer\")\n\n        token_endpoint = discovery.get(Endpoints.TOKEN)\n        if token_endpoint is None:\n            msg = \"token_endpoint not found in that discovery document\"\n            raise InvalidDiscoveryDocument(msg, discovery)\n        authorization_endpoint = discovery.get(Endpoints.AUTHORIZATION)\n        revocation_endpoint = discovery.get(Endpoints.REVOCATION)\n        introspection_endpoint = discovery.get(Endpoints.INTROSPECTION)\n        userinfo_endpoint = discovery.get(Endpoints.USER_INFO)\n        pushed_authorization_request_endpoint = discovery.get(Endpoints.PUSHED_AUTHORIZATION_REQUEST)\n        jwks_uri = discovery.get(Endpoints.JWKS)\n        if jwks_uri is not None and not testing:\n            validate_endpoint_uri(jwks_uri)\n        authorization_response_iss_parameter_supported = discovery.get(\n            \"authorization_response_iss_parameter_supported\",\n            False,\n        )\n\n        return cls(\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            pushed_authorization_request_endpoint=pushed_authorization_request_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            issuer=issuer,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            testing=testing,\n            **kwargs,\n        )\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Allow using `OAuth2Client` as a context-manager.\n\n        The Authorization Server public keys are retrieved on `__enter__`.\n\n        \"\"\"\n        self.update_authorization_server_public_keys()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; bool:\n        return True\n\n    def _require_endpoint(self, endpoint: str) -&gt; str:\n        \"\"\"Check that a required endpoint url is set.\"\"\"\n        url = getattr(self, endpoint, None)\n        if not url:\n            raise MissingEndpointUri(endpoint)\n\n        return str(url)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_id","title":"<code>client_id</code>  <code>property</code>","text":"<p>Client ID.</p>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_secret","title":"<code>client_secret</code>  <code>property</code>","text":"<p>Client Secret.</p>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_jwks","title":"<code>client_jwks</code>  <code>property</code>","text":"<p>A <code>JwkSet</code> containing the public keys for this client.</p> <p>Keys are:</p> <ul> <li>the public key for client assertion signature verification (if using private_key_jwt)</li> <li>the ID Token encryption key</li> </ul>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.validate_endpoint_uri","title":"<code>validate_endpoint_uri(attribute, uri)</code>","text":"<p>Validate that an endpoint URI is suitable for use.</p> <p>If you need to disable some checks (for AS testing purposes only!), provide a different method here.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@token_endpoint.validator\n@revocation_endpoint.validator\n@introspection_endpoint.validator\n@userinfo_endpoint.validator\n@authorization_endpoint.validator\n@backchannel_authentication_endpoint.validator\n@device_authorization_endpoint.validator\n@pushed_authorization_request_endpoint.validator\n@jwks_uri.validator\ndef validate_endpoint_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n    \"\"\"Validate that an endpoint URI is suitable for use.\n\n    If you need to disable some checks (for AS testing purposes only!), provide a different method here.\n\n    \"\"\"\n    if self.testing or uri is None:\n        return uri\n    try:\n        return validate_endpoint_uri(uri)\n    except InvalidUri as exc:\n        raise InvalidEndpointUri(endpoint=attribute.name, uri=uri, exc=exc) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.validate_issuer_uri","title":"<code>validate_issuer_uri(attribute, uri)</code>","text":"<p>Validate that an Issuer identifier is suitable for use.</p> <p>This is the same check as an endpoint URI, but the path may be (and usually is) empty.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@issuer.validator\ndef validate_issuer_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n    \"\"\"Validate that an Issuer identifier is suitable for use.\n\n    This is the same check as an endpoint URI, but the path may be (and usually is) empty.\n\n    \"\"\"\n    if self.testing or uri is None:\n        return uri\n    try:\n        return validate_issuer_uri(uri)\n    except InvalidUri as exc:\n        raise InvalidIssuer(attribute.name, uri, exc) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.token_request","title":"<code>token_request(data, *, timeout=10, dpop=None, dpop_key=None, **requests_kwargs)</code>","text":"<p>Send a request to the token endpoint.</p> <p>Authentication will be added automatically based on the defined <code>auth</code> for this client.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>parameters to send to the token endpoint. Items with a <code>None</code>    or empty value will not be sent in the request.</p> required <code>timeout</code> <code>int</code> <p>a timeout value for the call</p> <code>10</code> <code>dpop</code> <code>bool | None</code> <p>toggles DPoP-proofing for the token request:</p> <pre><code>- if `False`, disable it,\n- if `True`, enable it,\n- if `None`, defaults to `dpop_bound_access_tokens` configuration parameter for the client.\n</code></pre> <code>None</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>a chosen <code>DPoPKey</code> for this request. If <code>None</code>, a new key will be generated automatically     with a call to this client <code>dpop_key_generator</code>.</p> <code>None</code> <code>**requests_kwargs</code> <code>Any</code> <p>additional parameters for requests.post()</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>the token endpoint response</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def token_request(\n    self,\n    data: dict[str, Any],\n    *,\n    timeout: int = 10,\n    dpop: bool | None = None,\n    dpop_key: DPoPKey | None = None,\n    **requests_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint.\n\n    Authentication will be added automatically based on the defined `auth` for this client.\n\n    Args:\n      data: parameters to send to the token endpoint. Items with a `None`\n           or empty value will not be sent in the request.\n      timeout: a timeout value for the call\n      dpop: toggles DPoP-proofing for the token request:\n\n            - if `False`, disable it,\n            - if `True`, enable it,\n            - if `None`, defaults to `dpop_bound_access_tokens` configuration parameter for the client.\n      dpop_key: a chosen `DPoPKey` for this request. If `None`, a new key will be generated automatically\n            with a call to this client `dpop_key_generator`.\n      **requests_kwargs: additional parameters for requests.post()\n\n    Returns:\n        the token endpoint response\n\n    \"\"\"\n    if dpop is None:\n        dpop = self.dpop_bound_access_tokens\n    if dpop and not dpop_key:\n        dpop_key = self.dpop_key_generator(self.dpop_alg)\n\n    return self._request(\n        Endpoints.TOKEN,\n        auth=self.auth,\n        data=data,\n        timeout=timeout,\n        dpop_key=dpop_key,\n        on_success=self.parse_token_response,\n        on_failure=self.on_token_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_token_response","title":"<code>parse_token_response(response, *, dpop_key=None)</code>","text":"<p>Parse a Response returned by the Token Endpoint.</p> <p>Invoked by token_request to parse responses returned by the Token Endpoint. Those responses contain an <code>access_token</code> and additional attributes.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the <code>Response</code> returned by the Token Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> based on the response contents.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_token_response(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; BearerToken:\n    \"\"\"Parse a Response returned by the Token Endpoint.\n\n    Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse\n    responses returned by the Token Endpoint. Those responses contain an `access_token` and\n    additional attributes.\n\n    Args:\n        response: the `Response` returned by the Token Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        a `BearerToken` based on the response contents.\n\n    \"\"\"\n    token_class = dpop_key.dpop_token_class if dpop_key is not None else self.token_class\n    try:\n        token_response = token_class(**response.json(), _dpop_key=dpop_key)\n    except Exception:  # noqa: BLE001\n        return self.on_token_error(response, dpop_key=dpop_key)\n    else:\n        return token_response\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_token_error","title":"<code>on_token_error(response, *, dpop_key=None)</code>","text":"<p>Error handler for <code>token_request()</code>.</p> <p>Invoked by token_request when the Token Endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the <code>Response</code> returned by the Token Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the DPoPKey that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>nothing, and raises an exception instead. But a subclass may return a</p> <code>BearerToken</code> <p><code>BearerToken</code> to implement a default behaviour if needed.</p> <p>Raises:</p> Type Description <code>InvalidTokenResponse</code> <p>if the error response does not contain an OAuth 2.0 standard error response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_token_error(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,  # noqa: ARG002\n) -&gt; BearerToken:\n    \"\"\"Error handler for `token_request()`.\n\n    Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the\n    Token Endpoint returns an error.\n\n    Args:\n        response: the `Response` returned by the Token Endpoint.\n        dpop_key: the DPoPKey that was used to proof the token request, if any.\n\n    Returns:\n        nothing, and raises an exception instead. But a subclass may return a\n        `BearerToken` to implement a default behaviour if needed.\n\n    Raises:\n        InvalidTokenResponse: if the error response does not contain an OAuth 2.0 standard\n            error response.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidTokenResponse(\n            response=response,\n            client=self,\n            description=f\"An error happened while processing the error response: {exc}\",\n        ) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_credentials","title":"<code>client_credentials(scope=None, *, dpop=None, dpop_key=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint using the <code>client_credentials</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>str | Iterable[str] | None</code> <p>the scope to send with the request. Can be a str, or an iterable of str. to pass that way include <code>scope</code>, <code>audience</code>, <code>resource</code>, etc.</p> <code>None</code> <code>dpop</code> <code>bool | None</code> <p>toggles DPoP-proofing for the token request:</p> <ul> <li>if <code>False</code>, disable it,</li> <li>if <code>True</code>, enable it,</li> <li>if <code>None</code>, defaults to <code>dpop_bound_access_tokens</code> configuration parameter for the client.</li> </ul> <code>None</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>a chosen <code>DPoPKey</code> for this request. If <code>None</code>, a new key will be generated automatically with a call to <code>dpop_key_generator</code>.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters that will be added in the form data for the token endpoint,  alongside <code>grant_type</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> or <code>DPoPToken</code>, depending on the AS response.</p> <p>Raises:</p> Type Description <code>InvalidScopeParam</code> <p>if the <code>scope</code> parameter is not suitable</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def client_credentials(\n    self,\n    scope: str | Iterable[str] | None = None,\n    *,\n    dpop: bool | None = None,\n    dpop_key: DPoPKey | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint using the `client_credentials` grant.\n\n    Args:\n        scope: the scope to send with the request. Can be a str, or an iterable of str.\n            to pass that way include `scope`, `audience`, `resource`, etc.\n        dpop: toggles DPoP-proofing for the token request:\n\n            - if `False`, disable it,\n            - if `True`, enable it,\n            - if `None`, defaults to `dpop_bound_access_tokens` configuration parameter for the client.\n        dpop_key: a chosen `DPoPKey` for this request. If `None`, a new key will be generated automatically\n            with a call to `dpop_key_generator`.\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters that will be added in the form data for the token endpoint,\n             alongside `grant_type`.\n\n    Returns:\n        a `BearerToken` or `DPoPToken`, depending on the AS response.\n\n    Raises:\n        InvalidScopeParam: if the `scope` parameter is not suitable\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if scope and not isinstance(scope, str):\n        try:\n            scope = \" \".join(scope)\n        except Exception as exc:\n            raise InvalidScopeParam(scope) from exc\n\n    data = dict(grant_type=GrantTypes.CLIENT_CREDENTIALS, scope=scope, **token_kwargs)\n    return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorization_code","title":"<code>authorization_code(code, *, validate=True, dpop=False, dpop_key=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint with the <code>authorization_code</code> grant.</p> <p>You can either pass an authorization code, as a <code>str</code>, or pass an <code>AuthorizationResponse</code> instance as returned by <code>AuthorizationRequest.validate_callback()</code> (recommended). If you do the latter, this will automatically:</p> <ul> <li>add the appropriate <code>redirect_uri</code> value that was initially passed in the Authorization Request parameters. This is no longer mandatory in OAuth 2.1, but a lot of Authorization Servers are still expecting it since it was part of the OAuth 2.0 specifications.</li> <li>add the appropriate <code>code_verifier</code> for PKCE that was generated before sending the AuthorizationRequest.</li> <li>handle DPoP binding based on the same <code>DPoPKey</code> that was used to initialize the <code>AuthenticationRequest</code> and whose JWK thumbprint was passed as <code>dpop_jkt</code> parameter in the Auth Request.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str | AuthorizationResponse</code> <p>An authorization code or an <code>AuthorizationResponse</code> to exchange for tokens.</p> required <code>validate</code> <code>bool</code> <p>If <code>True</code>, validate the ID Token (this works only if <code>code</code> is an <code>AuthorizationResponse</code>).</p> <code>True</code> <code>dpop</code> <code>bool</code> <p>Toggles DPoP binding for the Access Token,  even if Authorization Code DPoP binding was not initially done.</p> <code>False</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>A chosen DPoP key. Leave <code>None</code> to automatically generate a key, if <code>dpop</code> is <code>True</code>.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the call to the underlying HTTP <code>requests</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters that will be added in the form data for the token endpoint, alongside <code>grant_type</code>, <code>code</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>The Token Endpoint Response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorization_code(\n    self,\n    code: str | AuthorizationResponse,\n    *,\n    validate: bool = True,\n    dpop: bool = False,\n    dpop_key: DPoPKey | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint with the `authorization_code` grant.\n\n    You can either pass an authorization code, as a `str`, or pass an `AuthorizationResponse` instance as\n    returned by `AuthorizationRequest.validate_callback()` (recommended). If you do the latter, this will\n    automatically:\n\n    - add the appropriate `redirect_uri` value that was initially passed in the Authorization Request parameters.\n    This is no longer mandatory in OAuth 2.1, but a lot of Authorization Servers are still expecting it since it was\n    part of the OAuth 2.0 specifications.\n    - add the appropriate `code_verifier` for PKCE that was generated before sending the AuthorizationRequest.\n    - handle DPoP binding based on the same `DPoPKey` that was used to initialize the `AuthenticationRequest` and\n    whose JWK thumbprint was passed as `dpop_jkt` parameter in the Auth Request.\n\n    Args:\n        code: An authorization code or an `AuthorizationResponse` to exchange for tokens.\n        validate: If `True`, validate the ID Token (this works only if `code` is an `AuthorizationResponse`).\n        dpop: Toggles DPoP binding for the Access Token,\n             even if Authorization Code DPoP binding was not initially done.\n        dpop_key: A chosen DPoP key. Leave `None` to automatically generate a key, if `dpop` is `True`.\n        requests_kwargs: Additional parameters for the call to the underlying HTTP `requests` call.\n        **token_kwargs: Additional parameters that will be added in the form data for the token endpoint,\n            alongside `grant_type`, `code`, etc.\n\n    Returns:\n        The Token Endpoint Response.\n\n    \"\"\"\n    azr: AuthorizationResponse | None = None\n    if isinstance(code, AuthorizationResponse):\n        token_kwargs.setdefault(\"code_verifier\", code.code_verifier)\n        token_kwargs.setdefault(\"redirect_uri\", code.redirect_uri)\n        azr = code\n        dpop_key = code.dpop_key\n        code = code.code\n\n    requests_kwargs = requests_kwargs or {}\n\n    data = dict(grant_type=GrantTypes.AUTHORIZATION_CODE, code=code, **token_kwargs)\n    token = self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n    if validate and token.id_token and isinstance(azr, AuthorizationResponse):\n        return token.validate_id_token(self, azr)\n    return token\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.refresh_token","title":"<code>refresh_token(refresh_token, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint with the <code>refresh_token</code> grant.</p> <p>If <code>refresh_token</code> is a <code>DPoPToken</code> instance, (which means that DPoP was used to obtain the initial Access/Refresh Tokens), then the same DPoP key will be used to DPoP proof the refresh token request, as defined in RFC9449.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str | BearerToken</code> <p>A refresh_token, as a string, or as a <code>BearerToken</code>. That <code>BearerToken</code> must have a <code>refresh_token</code>.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the call to <code>requests</code>.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>refresh_token</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>The token endpoint response.</p> <p>Raises:</p> Type Description <code>MissingRefreshToken</code> <p>If <code>refresh_token</code> is a <code>BearerToken</code> instance but does not contain a <code>refresh_token</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def refresh_token(\n    self,\n    refresh_token: str | BearerToken,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint with the `refresh_token` grant.\n\n    If `refresh_token` is a `DPoPToken` instance, (which means that DPoP was used to obtain the initial\n    Access/Refresh Tokens), then the same DPoP key will be used to DPoP proof the refresh token request,\n    as defined in RFC9449.\n\n    Args:\n        refresh_token: A refresh_token, as a string, or as a `BearerToken`.\n            That `BearerToken` must have a `refresh_token`.\n        requests_kwargs: Additional parameters for the call to `requests`.\n        **token_kwargs: Additional parameters for the token endpoint,\n            alongside `grant_type`, `refresh_token`, etc.\n\n    Returns:\n        The token endpoint response.\n\n    Raises:\n        MissingRefreshToken: If `refresh_token` is a `BearerToken` instance but does not\n            contain a `refresh_token`.\n\n    \"\"\"\n    dpop_key: DPoPKey | None = None\n    if isinstance(refresh_token, BearerToken):\n        if refresh_token.refresh_token is None or not isinstance(refresh_token.refresh_token, str):\n            raise MissingRefreshToken(refresh_token)\n        if isinstance(refresh_token, DPoPToken):\n            dpop_key = refresh_token.dpop_key\n        refresh_token = refresh_token.refresh_token\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(grant_type=GrantTypes.REFRESH_TOKEN, refresh_token=refresh_token, **token_kwargs)\n    return self.token_request(data, dpop_key=dpop_key, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.device_code","title":"<code>device_code(device_code, *, dpop=False, dpop_key=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint using the Device Code grant.</p> <p>The grant_type is <code>urn:ietf:params:oauth:grant-type:device_code</code>. This needs a Device Code, or a <code>DeviceAuthorizationResponse</code> as parameter.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>A device code, or a <code>DeviceAuthorizationResponse</code>.</p> required <code>dpop</code> <code>bool</code> <p>Toggles DPoP Binding. If <code>None</code>, defaults to <code>self.dpop_bound_access_tokens</code>.</p> <code>False</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>A chosen DPoP key. Leave <code>None</code> to have a new key generated for this request.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the call to requests.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>device_code</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>The Token Endpoint response.</p> <p>Raises:</p> Type Description <code>MissingDeviceCode</code> <p>if <code>device_code</code> is a DeviceAuthorizationResponse but does not contain a <code>device_code</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def device_code(\n    self,\n    device_code: str | DeviceAuthorizationResponse,\n    *,\n    dpop: bool = False,\n    dpop_key: DPoPKey | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint using the Device Code grant.\n\n    The grant_type is `urn:ietf:params:oauth:grant-type:device_code`. This needs a Device Code,\n    or a `DeviceAuthorizationResponse` as parameter.\n\n    Args:\n        device_code: A device code, or a `DeviceAuthorizationResponse`.\n        dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n        dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n        requests_kwargs: Additional parameters for the call to requests.\n        **token_kwargs: Additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc.\n\n    Returns:\n        The Token Endpoint response.\n\n    Raises:\n        MissingDeviceCode: if `device_code` is a DeviceAuthorizationResponse but does not\n            contain a `device_code`.\n\n    \"\"\"\n    if isinstance(device_code, DeviceAuthorizationResponse):\n        if device_code.device_code is None or not isinstance(device_code.device_code, str):\n            raise MissingDeviceCode(device_code)\n        device_code = device_code.device_code\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantTypes.DEVICE_CODE,\n        device_code=device_code,\n        **token_kwargs,\n    )\n    return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.ciba","title":"<code>ciba(auth_req_id, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a CIBA request to the Token Endpoint.</p> <p>A CIBA request is a Token Request using the <code>urn:openid:params:grant-type:ciba</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>auth_req_id</code> <code>str | BackChannelAuthenticationResponse</code> <p>an authentication request ID, as returned by the AS</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>auth_req_id</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>The Token Endpoint response.</p> <p>Raises:</p> Type Description <code>MissingAuthRequestId</code> <p>if <code>auth_req_id</code> is a BackChannelAuthenticationResponse but does not contain an <code>auth_req_id</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def ciba(\n    self,\n    auth_req_id: str | BackChannelAuthenticationResponse,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a CIBA request to the Token Endpoint.\n\n    A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant.\n\n    Args:\n        auth_req_id: an authentication request ID, as returned by the AS\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc.\n\n    Returns:\n        The Token Endpoint response.\n\n    Raises:\n        MissingAuthRequestId: if `auth_req_id` is a BackChannelAuthenticationResponse but does not contain\n            an `auth_req_id`.\n\n    \"\"\"\n    if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n        if auth_req_id.auth_req_id is None or not isinstance(auth_req_id.auth_req_id, str):\n            raise MissingAuthRequestId(auth_req_id)\n        auth_req_id = auth_req_id.auth_req_id\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantTypes.CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION,\n        auth_req_id=auth_req_id,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.token_exchange","title":"<code>token_exchange(*, subject_token, subject_token_type=None, actor_token=None, actor_token_type=None, requested_token_type=None, dpop=False, dpop_key=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a Token Exchange request.</p> <p>A Token Exchange request is actually a request to the Token Endpoint with a grant_type <code>urn:ietf:params:oauth:grant-type:token-exchange</code>.</p> <p>Parameters:</p> Name Type Description Default <code>subject_token</code> <code>str | BearerToken | IdToken</code> <p>The subject token to exchange for a new token.</p> required <code>subject_token_type</code> <code>str | None</code> <p>A token type identifier for the subject_token, mandatory if it cannot be guessed based on <code>type(subject_token)</code>.</p> <code>None</code> <code>actor_token</code> <code>None | str | BearerToken | IdToken</code> <p>The actor token to include in the request, if any.</p> <code>None</code> <code>actor_token_type</code> <code>str | None</code> <p>A token type identifier for the actor_token, mandatory if it cannot be guessed based on <code>type(actor_token)</code>.</p> <code>None</code> <code>requested_token_type</code> <code>str | None</code> <p>A token type identifier for the requested token.</p> <code>None</code> <code>dpop</code> <code>bool</code> <p>Toggles DPoP Binding. If <code>None</code>, defaults to <code>self.dpop_bound_access_tokens</code>.</p> <code>False</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>A chosen DPoP key. Leave <code>None</code> to have a new key generated for this request.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>The Token Endpoint response.</p> <p>Raises:</p> Type Description <code>UnknownSubjectTokenType</code> <p>If the type of <code>subject_token</code> cannot be determined automatically.</p> <code>UnknownActorTokenType</code> <p>If the type of <code>actor_token</code> cannot be determined automatically.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def token_exchange(\n    self,\n    *,\n    subject_token: str | BearerToken | IdToken,\n    subject_token_type: str | None = None,\n    actor_token: None | str | BearerToken | IdToken = None,\n    actor_token_type: str | None = None,\n    requested_token_type: str | None = None,\n    dpop: bool = False,\n    dpop_key: DPoPKey | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a Token Exchange request.\n\n    A Token Exchange request is actually a request to the Token Endpoint with a grant_type\n    `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n    Args:\n        subject_token: The subject token to exchange for a new token.\n        subject_token_type: A token type identifier for the subject_token, mandatory if it cannot be guessed based\n            on `type(subject_token)`.\n        actor_token: The actor token to include in the request, if any.\n        actor_token_type: A token type identifier for the actor_token, mandatory if it cannot be guessed based\n            on `type(actor_token)`.\n        requested_token_type: A token type identifier for the requested token.\n        dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n        dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n        requests_kwargs: Additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: Additional parameters to include in the request body.\n\n    Returns:\n        The Token Endpoint response.\n\n    Raises:\n        UnknownSubjectTokenType: If the type of `subject_token` cannot be determined automatically.\n        UnknownActorTokenType: If the type of `actor_token` cannot be determined automatically.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    try:\n        subject_token_type = self.get_token_type(subject_token_type, subject_token)\n    except ValueError as exc:\n        raise UnknownSubjectTokenType(subject_token, subject_token_type) from exc\n    if actor_token:  # pragma: no branch\n        try:\n            actor_token_type = self.get_token_type(actor_token_type, actor_token)\n        except ValueError as exc:\n            raise UnknownActorTokenType(actor_token, actor_token_type) from exc\n\n    data = dict(\n        grant_type=GrantTypes.TOKEN_EXCHANGE,\n        subject_token=subject_token,\n        subject_token_type=subject_token_type,\n        actor_token=actor_token,\n        actor_token_type=actor_token_type,\n        requested_token_type=requested_token_type,\n        **token_kwargs,\n    )\n    return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.jwt_bearer","title":"<code>jwt_bearer(assertion, *, dpop=False, dpop_key=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request using a JWT as authorization grant.</p> <p>This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).</p> <p>Parameters:</p> Name Type Description Default <code>assertion</code> <code>Jwt | str</code> <p>A JWT (as an instance of <code>jwskate.Jwt</code> or as a <code>str</code>) to use as authorization grant.</p> required <code>dpop</code> <code>bool</code> <p>Toggles DPoP Binding. If <code>None</code>, defaults to <code>self.dpop_bound_access_tokens</code>.</p> <code>False</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>A chosen DPoP key. Leave <code>None</code> to have a new key generated for this request.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>The Token Endpoint response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def jwt_bearer(\n    self,\n    assertion: Jwt | str,\n    *,\n    dpop: bool = False,\n    dpop_key: DPoPKey | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request using a JWT as authorization grant.\n\n    This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).\n\n    Args:\n        assertion: A JWT (as an instance of `jwskate.Jwt` or as a `str`) to use as authorization grant.\n        dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n        dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n        requests_kwargs: Additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: Additional parameters to include in the request body.\n\n    Returns:\n        The Token Endpoint response.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if not isinstance(assertion, Jwt):\n        assertion = Jwt(assertion)\n\n    data = dict(\n        grant_type=GrantTypes.JWT_BEARER,\n        assertion=assertion,\n        **token_kwargs,\n    )\n\n    return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.resource_owner_password","title":"<code>resource_owner_password(username, password, *, dpop=None, dpop_key=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request using the Resource Owner Password Grant.</p> <p>This Grant Type is deprecated and should only be used when there is no other choice.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>the resource owner user name</p> required <code>password</code> <code>str</code> <p>the resource owner password</p> required <code>dpop</code> <code>bool | None</code> <p>Toggles DPoP Binding. If <code>None</code>, defaults to <code>self.dpop_bound_access_tokens</code>.</p> <code>None</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>A chosen DPoP key. Leave <code>None</code> to have a new key generated for this request.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>The Token Endpoint response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def resource_owner_password(\n    self,\n    username: str,\n    password: str,\n    *,\n    dpop: bool | None = None,\n    dpop_key: DPoPKey | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request using the Resource Owner Password Grant.\n\n    This Grant Type is deprecated and should only be used when there is no other choice.\n\n    Args:\n        username: the resource owner user name\n        password: the resource owner password\n        dpop: Toggles DPoP Binding. If `None`, defaults to `self.dpop_bound_access_tokens`.\n        dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for this request.\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        The Token Endpoint response.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantTypes.RESOURCE_OWNER_PASSWORD,\n        username=username,\n        password=password,\n        **token_kwargs,\n    )\n\n    return self.token_request(data, dpop=dpop, dpop_key=dpop_key, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorization_request","title":"<code>authorization_request(*, scope='openid', response_type=ResponseTypes.CODE, redirect_uri=None, state=..., nonce=..., code_verifier=None, dpop=None, dpop_key=None, dpop_alg=None, **kwargs)</code>","text":"<p>Generate an Authorization Request for this client.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>None | str | Iterable[str]</code> <p>The <code>scope</code> to use.</p> <code>'openid'</code> <code>response_type</code> <code>str</code> <p>The <code>response_type</code> to use.</p> <code>CODE</code> <code>redirect_uri</code> <code>str | None</code> <p>The <code>redirect_uri</code> to include in the request. By default, the <code>redirect_uri</code> defined at init time is used.</p> <code>None</code> <code>state</code> <code>str | ellipsis | None</code> <p>The <code>state</code> parameter to use. Leave default to generate a random value.</p> <code>...</code> <code>nonce</code> <code>str | ellipsis | None</code> <p>A <code>nonce</code>. Leave default to generate a random value.</p> <code>...</code> <code>dpop</code> <code>bool | None</code> <p>Toggles DPoP binding. - if <code>True</code>, DPoP binding is used - if <code>False</code>, DPoP is not used - if <code>None</code>, defaults to <code>self.dpop_bound_access_tokens</code></p> <code>None</code> <code>dpop_key</code> <code>DPoPKey | None</code> <p>A chosen DPoP key. Leave <code>None</code> to have a new key generated for you.</p> <code>None</code> <code>dpop_alg</code> <code>str | None</code> <p>A signature alg to sign the DPoP proof. If <code>None</code>, this defaults to <code>self.dpop_alg</code>. If DPoP is not used, or a chosen <code>dpop_key</code> is provided, this is ignored. This affects the key type if a DPoP key must be generated.</p> <code>None</code> <code>code_verifier</code> <code>str | None</code> <p>The PKCE <code>code_verifier</code> to use. Leave default to generate a random value.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional query parameters to include in the auth request.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>The Token Endpoint response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorization_request(\n    self,\n    *,\n    scope: None | str | Iterable[str] = \"openid\",\n    response_type: str = ResponseTypes.CODE,\n    redirect_uri: str | None = None,\n    state: str | ellipsis | None = ...,  # noqa: F821\n    nonce: str | ellipsis | None = ...,  # noqa: F821\n    code_verifier: str | None = None,\n    dpop: bool | None = None,\n    dpop_key: DPoPKey | None = None,\n    dpop_alg: str | None = None,\n    **kwargs: Any,\n) -&gt; AuthorizationRequest:\n    \"\"\"Generate an Authorization Request for this client.\n\n    Args:\n        scope: The `scope` to use.\n        response_type: The `response_type` to use.\n        redirect_uri: The `redirect_uri` to include in the request. By default,\n            the `redirect_uri` defined at init time is used.\n        state: The `state` parameter to use. Leave default to generate a random value.\n        nonce: A `nonce`. Leave default to generate a random value.\n        dpop: Toggles DPoP binding.\n            - if `True`, DPoP binding is used\n            - if `False`, DPoP is not used\n            - if `None`, defaults to `self.dpop_bound_access_tokens`\n        dpop_key: A chosen DPoP key. Leave `None` to have a new key generated for you.\n        dpop_alg: A signature alg to sign the DPoP proof. If `None`, this defaults to `self.dpop_alg`.\n            If DPoP is not used, or a chosen `dpop_key` is provided, this is ignored.\n            This affects the key type if a DPoP key must be generated.\n        code_verifier: The PKCE `code_verifier` to use. Leave default to generate a random value.\n        **kwargs: Additional query parameters to include in the auth request.\n\n    Returns:\n        The Token Endpoint response.\n\n    \"\"\"\n    authorization_endpoint = self._require_endpoint(\"authorization_endpoint\")\n\n    redirect_uri = redirect_uri or self.redirect_uri\n\n    if dpop is None:\n        dpop = self.dpop_bound_access_tokens\n    if dpop_alg is None:\n        dpop_alg = self.dpop_alg\n\n    return AuthorizationRequest(\n        authorization_endpoint=authorization_endpoint,\n        client_id=self.client_id,\n        redirect_uri=redirect_uri,\n        issuer=self.issuer,\n        response_type=response_type,\n        scope=scope,\n        state=state,\n        nonce=nonce,\n        code_verifier=code_verifier,\n        code_challenge_method=self.code_challenge_method,\n        dpop=dpop,\n        dpop_key=dpop_key,\n        dpop_alg=dpop_alg,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.pushed_authorization_request","title":"<code>pushed_authorization_request(authorization_request, requests_kwargs=None)</code>","text":"<p>Send a Pushed Authorization Request.</p> <p>This sends a request to the Pushed Authorization Request Endpoint, and returns a <code>RequestUriParameterAuthorizationRequest</code> initialized with the AS response.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_request</code> <code>AuthorizationRequest</code> <p>The authorization request to send.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for <code>requests.request()</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>The <code>RequestUriParameterAuthorizationRequest</code> initialized based on the AS response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def pushed_authorization_request(\n    self,\n    authorization_request: AuthorizationRequest,\n    requests_kwargs: dict[str, Any] | None = None,\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Send a Pushed Authorization Request.\n\n    This sends a request to the Pushed Authorization Request Endpoint, and returns a\n    `RequestUriParameterAuthorizationRequest` initialized with the AS response.\n\n    Args:\n        authorization_request: The authorization request to send.\n        requests_kwargs: Additional parameters for `requests.request()`.\n\n    Returns:\n        The `RequestUriParameterAuthorizationRequest` initialized based on the AS response.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n    return self._request(\n        Endpoints.PUSHED_AUTHORIZATION_REQUEST,\n        data=authorization_request.args,\n        auth=self.auth,\n        on_success=self.parse_pushed_authorization_response,\n        on_failure=self.on_pushed_authorization_request_error,\n        dpop_key=authorization_request.dpop_key,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_pushed_authorization_response","title":"<code>parse_pushed_authorization_response(response, *, dpop_key=None)</code>","text":"<p>Parse the response obtained by <code>pushed_authorization_request()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>The <code>requests.Response</code> returned by the PAR endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>The <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>A <code>RequestUriParameterAuthorizationRequest</code> instance initialized based on the PAR endpoint response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_pushed_authorization_response(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Parse the response obtained by `pushed_authorization_request()`.\n\n    Args:\n        response: The `requests.Response` returned by the PAR endpoint.\n        dpop_key: The `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        A `RequestUriParameterAuthorizationRequest` instance initialized based on the PAR endpoint response.\n\n    \"\"\"\n    response_json = response.json()\n    request_uri = response_json.get(\"request_uri\")\n    expires_in = response_json.get(\"expires_in\")\n\n    return RequestUriParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request_uri=request_uri,\n        expires_in=expires_in,\n        dpop_key=dpop_key,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_pushed_authorization_request_error","title":"<code>on_pushed_authorization_request_error(response, *, dpop_key=None)</code>","text":"<p>Error Handler for Pushed Authorization Endpoint errors.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>The HTTP response as returned by the AS PAR endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>The <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>Should not return anything, but raise an Exception instead. A <code>RequestUriParameterAuthorizationRequest</code></p> <code>RequestUriParameterAuthorizationRequest</code> <p>may be returned by subclasses for testing purposes.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>A subclass of this error depending on the error returned by the AS.</p> <code>InvalidPushedAuthorizationResponse</code> <p>If the returned response is not following the specifications.</p> <code>UnknownTokenEndpointError</code> <p>For unknown/unhandled errors.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_pushed_authorization_request_error(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,  # noqa: ARG002\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Error Handler for Pushed Authorization Endpoint errors.\n\n    Args:\n        response: The HTTP response as returned by the AS PAR endpoint.\n        dpop_key: The `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        Should not return anything, but raise an Exception instead. A `RequestUriParameterAuthorizationRequest`\n        may be returned by subclasses for testing purposes.\n\n    Raises:\n        EndpointError: A subclass of this error depending on the error returned by the AS.\n        InvalidPushedAuthorizationResponse: If the returned response is not following the specifications.\n        UnknownTokenEndpointError: For unknown/unhandled errors.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidPushedAuthorizationResponse(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.userinfo","title":"<code>userinfo(access_token)</code>","text":"<p>Call the UserInfo endpoint.</p> <p>This sends a request to the UserInfo endpoint, with the specified access_token, and returns the parsed result.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>BearerToken | str</code> <p>the access token to use</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the Response returned by the userinfo endpoint.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def userinfo(self, access_token: BearerToken | str) -&gt; Any:\n    \"\"\"Call the UserInfo endpoint.\n\n    This sends a request to the UserInfo endpoint, with the specified access_token, and returns\n    the parsed result.\n\n    Args:\n        access_token: the access token to use\n\n    Returns:\n        the [Response][requests.Response] returned by the userinfo endpoint.\n\n    \"\"\"\n    if isinstance(access_token, str):\n        access_token = BearerToken(access_token)\n    return self._request(\n        Endpoints.USER_INFO,\n        auth=access_token,\n        on_success=self.parse_userinfo_response,\n        on_failure=self.on_userinfo_error,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_userinfo_response","title":"<code>parse_userinfo_response(resp, *, dpop_key=None)</code>","text":"<p>Parse the response obtained by <code>userinfo()</code>.</p> <p>Invoked by userinfo() to parse the response from the UserInfo endpoint, this will extract and return its JSON content.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>a Response returned from the UserInfo endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>the parsed JSON content from this response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_userinfo_response(self, resp: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; Any:  # noqa: ARG002\n    \"\"\"Parse the response obtained by `userinfo()`.\n\n    Invoked by [userinfo()][requests_oauth2client.client.OAuth2Client.userinfo] to parse the\n    response from the UserInfo endpoint, this will extract and return its JSON content.\n\n    Args:\n        resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        the parsed JSON content from this response.\n\n    \"\"\"\n    return resp.json()\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_userinfo_error","title":"<code>on_userinfo_error(resp, *, dpop_key=None)</code>","text":"<p>Parse UserInfo error response.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>a Response returned from the UserInfo endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>nothing, raises exception instead.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_userinfo_error(self, resp: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; Any:  # noqa: ARG002\n    \"\"\"Parse UserInfo error response.\n\n    Args:\n        resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        nothing, raises exception instead.\n\n    \"\"\"\n    resp.raise_for_status()\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.get_token_type","title":"<code>get_token_type(token_type=None, token=None)</code>  <code>classmethod</code>","text":"<p>Get standardized token type identifiers.</p> <p>Return a standardized token type identifier, based on a short <code>token_type</code> hint and/or a token value.</p> <p>Parameters:</p> Name Type Description Default <code>token_type</code> <code>str | None</code> <p>a token_type hint, as <code>str</code>. May be \"access_token\", \"refresh_token\" or \"id_token\"</p> <code>None</code> <code>token</code> <code>None | str | BearerToken | IdToken</code> <p>a token value, as an instance of <code>BearerToken</code> or IdToken, or as a <code>str</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the token_type as defined in the Token Exchange RFC8693.</p> <p>Raises:</p> Type Description <code>UnknownTokenType</code> <p>if the type of token cannot be determined</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>    @classmethod\n    def get_token_type(  # noqa: C901\n        cls,\n        token_type: str | None = None,\n        token: None | str | BearerToken | IdToken = None,\n    ) -&gt; str:\n        \"\"\"Get standardized token type identifiers.\n\n        Return a standardized token type identifier, based on a short `token_type` hint and/or a\n        token value.\n\n        Args:\n            token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\"\n                or \"id_token\"\n            token: a token value, as an instance of `BearerToken` or IdToken, or as a `str`.\n\n        Returns:\n            the token_type as defined in the Token Exchange RFC8693.\n\n        Raises:\n            UnknownTokenType: if the type of token cannot be determined\n\n        \"\"\"\n        if not (token_type or token):\n            msg = \"Cannot determine type of an empty token without a token_type hint\"\n            raise UnknownTokenType(msg, token, token_type)\n\n        if token_type is None:\n            if isinstance(token, str):\n                msg = \"\"\"\\\nCannot determine the type of provided token when it is a bare `str`. Please specify a 'token_type'.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            if isinstance(token, BearerToken):\n                return \"urn:ietf:params:oauth:token-type:access_token\"\n            if isinstance(token, IdToken):\n                return \"urn:ietf:params:oauth:token-type:id_token\"\n            msg = f\"Unknown token type {type(token)}\"\n            raise UnknownTokenType(msg, token, token_type)\n        if token_type == TokenType.ACCESS_TOKEN:\n            if token is not None and not isinstance(token, (str, BearerToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nA BearerToken or an access_token as a `str` is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:access_token\"\n        if token_type == TokenType.REFRESH_TOKEN:\n            if token is not None and isinstance(token, BearerToken) and not token.refresh_token:\n                msg = f\"\"\"\\\nThe supplied BearerToken does not contain a refresh_token, which is inconsistent with token_type '{token_type}'.\nA BearerToken containing a refresh_token is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:refresh_token\"\n        if token_type == TokenType.ID_TOKEN:\n            if token is not None and not isinstance(token, (str, IdToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nAn IdToken or a string representation of it is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:id_token\"\n\n        return {\n            \"saml1\": \"urn:ietf:params:oauth:token-type:saml1\",\n            \"saml2\": \"urn:ietf:params:oauth:token-type:saml2\",\n            \"jwt\": \"urn:ietf:params:oauth:token-type:jwt\",\n        }.get(token_type, token_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_access_token","title":"<code>revoke_access_token(access_token, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a request to the Revocation Endpoint to revoke an access token.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>BearerToken | str</code> <p>the access token to revoke</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the underlying requests.post() call</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to pass to the revocation endpoint</p> <code>{}</code> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_access_token(\n    self,\n    access_token: BearerToken | str,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a request to the Revocation Endpoint to revoke an access token.\n\n    Args:\n        access_token: the access token to revoke\n        requests_kwargs: additional parameters for the underlying requests.post() call\n        **revoke_kwargs: additional parameters to pass to the revocation endpoint\n\n    \"\"\"\n    return self.revoke_token(\n        access_token,\n        token_type_hint=TokenType.ACCESS_TOKEN,\n        requests_kwargs=requests_kwargs,\n        **revoke_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_refresh_token","title":"<code>revoke_refresh_token(refresh_token, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a request to the Revocation Endpoint to revoke a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str | BearerToken</code> <p>the refresh token to revoke.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the revocation endpoint.</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to pass to the revocation endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the revocation request is successful, <code>False</code> if this client has no configured</p> <code>bool</code> <p>revocation endpoint.</p> <p>Raises:</p> Type Description <code>MissingRefreshToken</code> <p>when <code>refresh_token</code> is a BearerToken but does not contain a <code>refresh_token</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_refresh_token(\n    self,\n    refresh_token: str | BearerToken,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a request to the Revocation Endpoint to revoke a refresh token.\n\n    Args:\n        refresh_token: the refresh token to revoke.\n        requests_kwargs: additional parameters to pass to the revocation endpoint.\n        **revoke_kwargs: additional parameters to pass to the revocation endpoint.\n\n    Returns:\n        `True` if the revocation request is successful, `False` if this client has no configured\n        revocation endpoint.\n\n    Raises:\n        MissingRefreshToken: when `refresh_token` is a [BearerToken][requests_oauth2client.tokens.BearerToken]\n            but does not contain a `refresh_token`.\n\n    \"\"\"\n    if isinstance(refresh_token, BearerToken):\n        if refresh_token.refresh_token is None:\n            raise MissingRefreshToken(refresh_token)\n        refresh_token = refresh_token.refresh_token\n\n    return self.revoke_token(\n        refresh_token,\n        token_type_hint=TokenType.REFRESH_TOKEN,\n        requests_kwargs=requests_kwargs,\n        **revoke_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_token","title":"<code>revoke_token(token, token_type_hint=None, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a Token Revocation request.</p> <p>By default, authentication will be the same than the one used for the Token Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str | BearerToken</code> <p>the token to revoke.</p> required <code>token_type_hint</code> <code>str | None</code> <p>a token_type_hint to send to the revocation endpoint.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to the underling call to requests.post()</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to send to the revocation endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>the result from <code>parse_revocation_response</code> on the returned AS response.</p> <p>Raises:</p> Type Description <code>MissingEndpointUri</code> <p>if the Revocation Endpoint URI is not configured.</p> <code>MissingRefreshToken</code> <p>if <code>token_type_hint</code> is <code>\"refresh_token\"</code> and <code>token</code> is a BearerToken but does not contain a <code>refresh_token</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_token(\n    self,\n    token: str | BearerToken,\n    token_type_hint: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a Token Revocation request.\n\n    By default, authentication will be the same than the one used for the Token Endpoint.\n\n    Args:\n        token: the token to revoke.\n        token_type_hint: a token_type_hint to send to the revocation endpoint.\n        requests_kwargs: additional parameters to the underling call to requests.post()\n        **revoke_kwargs: additional parameters to send to the revocation endpoint.\n\n    Returns:\n        the result from `parse_revocation_response` on the returned AS response.\n\n    Raises:\n        MissingEndpointUri: if the Revocation Endpoint URI is not configured.\n        MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n            but does not contain a `refresh_token`.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if token_type_hint == TokenType.REFRESH_TOKEN and isinstance(token, BearerToken):\n        if token.refresh_token is None:\n            raise MissingRefreshToken(token)\n        token = token.refresh_token\n\n    data = dict(revoke_kwargs, token=str(token))\n    if token_type_hint:\n        data[\"token_type_hint\"] = token_type_hint\n\n    return self._request(\n        Endpoints.REVOCATION,\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_revocation_response,\n        on_failure=self.on_revocation_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_revocation_response","title":"<code>parse_revocation_response(response, *, dpop_key=None)</code>","text":"<p>Parse reponses from the Revocation Endpoint.</p> <p>Since those do not return any meaningful information in a standardised fashion, this just returns <code>True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the <code>requests.Response</code> as returned by the Revocation Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the revocation succeeds, <code>False</code> if no revocation endpoint is present or a</p> <code>bool</code> <p>non-standardised error is returned.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_revocation_response(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; bool:  # noqa: ARG002\n    \"\"\"Parse reponses from the Revocation Endpoint.\n\n    Since those do not return any meaningful information in a standardised fashion, this just returns `True`.\n\n    Args:\n        response: the `requests.Response` as returned by the Revocation Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        `True` if the revocation succeeds, `False` if no revocation endpoint is present or a\n        non-standardised error is returned.\n\n    \"\"\"\n    return True\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_revocation_error","title":"<code>on_revocation_error(response, *, dpop_key=None)</code>","text":"<p>Error handler for <code>revoke_token()</code>.</p> <p>Invoked by revoke_token() when the revocation endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the <code>requests.Response</code> as returned by the Revocation Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>False</code> to signal that an error occurred. May raise exceptions instead depending on the</p> <code>bool</code> <p>revocation response.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>if the response contains a standardised OAuth 2.0 error.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_revocation_error(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; bool:  # noqa: ARG002\n    \"\"\"Error handler for `revoke_token()`.\n\n    Invoked by [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token] when the\n    revocation endpoint returns an error.\n\n    Args:\n        response: the `requests.Response` as returned by the Revocation Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        `False` to signal that an error occurred. May raise exceptions instead depending on the\n        revocation response.\n\n    Raises:\n        EndpointError: if the response contains a standardised OAuth 2.0 error.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, RevocationError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception:  # noqa: BLE001\n        return False\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.introspect_token","title":"<code>introspect_token(token, token_type_hint=None, requests_kwargs=None, **introspect_kwargs)</code>","text":"<p>Send a request to the Introspection Endpoint.</p> <p>Parameter <code>token</code> can be:</p> <ul> <li>a <code>str</code></li> <li>a <code>BearerToken</code> instance</li> </ul> <p>You may pass any arbitrary <code>token</code> and <code>token_type_hint</code> values as <code>str</code>. Those will be included in the request, as-is. If <code>token</code> is a <code>BearerToken</code>, then <code>token_type_hint</code> must be either:</p> <ul> <li><code>None</code>: the access_token will be instrospected and no token_type_hint will be included in the request</li> <li><code>access_token</code>: same as <code>None</code>, but the token_type_hint will be included</li> <li>or <code>refresh_token</code>: only available if a Refresh Token is present in the BearerToken.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str | BearerToken</code> <p>the token to instrospect</p> required <code>token_type_hint</code> <code>str | None</code> <p>the <code>token_type_hint</code> to include in the request.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to the underling call to requests.post()</p> <code>None</code> <code>**introspect_kwargs</code> <code>Any</code> <p>additional parameters to send to the introspection endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>the response as returned by the Introspection Endpoint.</p> <p>Raises:</p> Type Description <code>MissingRefreshToken</code> <p>if <code>token_type_hint</code> is <code>\"refresh_token\"</code> and <code>token</code> is a BearerToken but does not contain a <code>refresh_token</code>.</p> <code>UnknownTokenType</code> <p>if <code>token_type_hint</code> is neither <code>None</code>, <code>\"access_token\"</code> or <code>\"refresh_token\"</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>    def introspect_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **introspect_kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"Send a request to the Introspection Endpoint.\n\n        Parameter `token` can be:\n\n        - a `str`\n        - a `BearerToken` instance\n\n        You may pass any arbitrary `token` and `token_type_hint` values as `str`. Those will\n        be included in the request, as-is.\n        If `token` is a `BearerToken`, then `token_type_hint` must be either:\n\n        - `None`: the access_token will be instrospected and no token_type_hint will be included\n        in the request\n        - `access_token`: same as `None`, but the token_type_hint will be included\n        - or `refresh_token`: only available if a Refresh Token is present in the BearerToken.\n\n        Args:\n            token: the token to instrospect\n            token_type_hint: the `token_type_hint` to include in the request.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **introspect_kwargs: additional parameters to send to the introspection endpoint.\n\n        Returns:\n            the response as returned by the Introspection Endpoint.\n\n        Raises:\n            MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n                but does not contain a `refresh_token`.\n            UnknownTokenType: if `token_type_hint` is neither `None`, `\"access_token\"` or `\"refresh_token\"`.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if isinstance(token, BearerToken):\n            if token_type_hint is None or token_type_hint == TokenType.ACCESS_TOKEN:\n                token = token.access_token\n            elif token_type_hint == TokenType.REFRESH_TOKEN:\n                if token.refresh_token is None:\n                    raise MissingRefreshToken(token)\n\n                token = token.refresh_token\n            else:\n                msg = \"\"\"\\\nInvalid `token_type_hint`. To test arbitrary `token_type_hint` values, you must provide `token` as a `str`.\"\"\"\n                raise UnknownTokenType(msg, token, token_type_hint)\n\n        data = dict(introspect_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            Endpoints.INTROSPECTION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_introspection_response,\n            on_failure=self.on_introspection_error,\n            **requests_kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_introspection_response","title":"<code>parse_introspection_response(response, *, dpop_key=None)</code>","text":"<p>Parse Token Introspection Responses received by <code>introspect_token()</code>.</p> <p>Invoked by introspect_token() to parse the returned response. This decodes the JSON content if possible, otherwise it returns the response as a string.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response as returned by the Introspection Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>the decoded JSON content, or a <code>str</code> with the content.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_introspection_response(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,  # noqa: ARG002\n) -&gt; Any:\n    \"\"\"Parse Token Introspection Responses received by `introspect_token()`.\n\n    Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n    to parse the returned response. This decodes the JSON content if possible, otherwise it\n    returns the response as a string.\n\n    Args:\n        response: the [Response][requests.Response] as returned by the Introspection Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        the decoded JSON content, or a `str` with the content.\n\n    \"\"\"\n    try:\n        return response.json()\n    except ValueError:\n        return response.text\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_introspection_error","title":"<code>on_introspection_error(response, *, dpop_key=None)</code>","text":"<p>Error handler for <code>introspect_token()</code>.</p> <p>Invoked by introspect_token() to parse the returned response in the case an error is returned.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response as returned by the Introspection Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>usually raises exceptions. A subclass can return a default response instead.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>(or one of its subclasses) if the response contains a standard OAuth 2.0 error.</p> <code>UnknownIntrospectionError</code> <p>if the response is not a standard error response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_introspection_error(self, response: requests.Response, *, dpop_key: DPoPKey | None = None) -&gt; Any:  # noqa: ARG002\n    \"\"\"Error handler for `introspect_token()`.\n\n    Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n    to parse the returned response in the case an error is returned.\n\n    Args:\n        response: the response as returned by the Introspection Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        usually raises exceptions. A subclass can return a default response instead.\n\n    Raises:\n        EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n        UnknownIntrospectionError: if the response is not a standard error response.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, IntrospectionError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise UnknownIntrospectionError(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.backchannel_authentication_request","title":"<code>backchannel_authentication_request(scope='openid', *, client_notification_token=None, acr_values=None, login_hint_token=None, id_token_hint=None, login_hint=None, binding_message=None, user_code=None, requested_expiry=None, private_jwk=None, alg=None, requests_kwargs=None, **ciba_kwargs)</code>","text":"<p>Send a CIBA Authentication Request.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>None | str | Iterable[str]</code> <p>the scope to include in the request.</p> <code>'openid'</code> <code>client_notification_token</code> <code>str | None</code> <p>the Client Notification Token to include in the request.</p> <code>None</code> <code>acr_values</code> <code>None | str | Iterable[str]</code> <p>the acr values to include in the request.</p> <code>None</code> <code>login_hint_token</code> <code>str | None</code> <p>the Login Hint Token to include in the request.</p> <code>None</code> <code>id_token_hint</code> <code>str | None</code> <p>the ID Token Hint to include in the request.</p> <code>None</code> <code>login_hint</code> <code>str | None</code> <p>the Login Hint to include in the request.</p> <code>None</code> <code>binding_message</code> <code>str | None</code> <p>the Binding Message to include in the request.</p> <code>None</code> <code>user_code</code> <code>str | None</code> <p>the User Code to include in the request</p> <code>None</code> <code>requested_expiry</code> <code>int | None</code> <p>the Requested Expiry, in seconds, to include in the request.</p> <code>None</code> <code>private_jwk</code> <code>Jwk | dict[str, Any] | None</code> <p>the JWK to use to sign the request (optional)</p> <code>None</code> <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for</p> <code>None</code> <code>**ciba_kwargs</code> <code>Any</code> <p>additional parameters to include in the request.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>a BackChannelAuthenticationResponse as returned by AS</p> <p>Raises:</p> Type Description <code>InvalidBackchannelAuthenticationRequestHintParam</code> <p>if none of <code>login_hint</code>, <code>login_hint_token</code> or <code>id_token_hint</code> is provided, or more than one of them is provided.</p> <code>InvalidScopeParam</code> <p>if the <code>scope</code> parameter is invalid.</p> <code>InvalidAcrValuesParam</code> <p>if the <code>acr_values</code> parameter is invalid.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def backchannel_authentication_request(  # noqa: PLR0913\n    self,\n    scope: None | str | Iterable[str] = \"openid\",\n    *,\n    client_notification_token: str | None = None,\n    acr_values: None | str | Iterable[str] = None,\n    login_hint_token: str | None = None,\n    id_token_hint: str | None = None,\n    login_hint: str | None = None,\n    binding_message: str | None = None,\n    user_code: str | None = None,\n    requested_expiry: int | None = None,\n    private_jwk: Jwk | dict[str, Any] | None = None,\n    alg: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **ciba_kwargs: Any,\n) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Send a CIBA Authentication Request.\n\n    Args:\n         scope: the scope to include in the request.\n         client_notification_token: the Client Notification Token to include in the request.\n         acr_values: the acr values to include in the request.\n         login_hint_token: the Login Hint Token to include in the request.\n         id_token_hint: the ID Token Hint to include in the request.\n         login_hint: the Login Hint to include in the request.\n         binding_message: the Binding Message to include in the request.\n         user_code: the User Code to include in the request\n         requested_expiry: the Requested Expiry, in seconds, to include in the request.\n         private_jwk: the JWK to use to sign the request (optional)\n         alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.\n         requests_kwargs: additional parameters for\n         **ciba_kwargs: additional parameters to include in the request.\n\n    Returns:\n        a BackChannelAuthenticationResponse as returned by AS\n\n    Raises:\n        InvalidBackchannelAuthenticationRequestHintParam: if none of `login_hint`, `login_hint_token`\n            or `id_token_hint` is provided, or more than one of them is provided.\n        InvalidScopeParam: if the `scope` parameter is invalid.\n        InvalidAcrValuesParam: if the `acr_values` parameter is invalid.\n\n    \"\"\"\n    if not (login_hint or login_hint_token or id_token_hint):\n        msg = \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n        raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n    if (login_hint_token and id_token_hint) or (login_hint and id_token_hint) or (login_hint_token and login_hint):\n        msg = \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n        raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n    requests_kwargs = requests_kwargs or {}\n\n    if scope is not None and not isinstance(scope, str):\n        try:\n            scope = \" \".join(scope)\n        except Exception as exc:\n            raise InvalidScopeParam(scope) from exc\n\n    if acr_values is not None and not isinstance(acr_values, str):\n        try:\n            acr_values = \" \".join(acr_values)\n        except Exception as exc:\n            raise InvalidAcrValuesParam(acr_values) from exc\n\n    data = dict(\n        ciba_kwargs,\n        scope=scope,\n        client_notification_token=client_notification_token,\n        acr_values=acr_values,\n        login_hint_token=login_hint_token,\n        id_token_hint=id_token_hint,\n        login_hint=login_hint,\n        binding_message=binding_message,\n        user_code=user_code,\n        requested_expiry=requested_expiry,\n    )\n\n    if private_jwk is not None:\n        data = {\"request\": str(Jwt.sign(data, key=private_jwk, alg=alg))}\n\n    return self._request(\n        Endpoints.BACKCHANNEL_AUTHENTICATION,\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_backchannel_authentication_response,\n        on_failure=self.on_backchannel_authentication_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_backchannel_authentication_response","title":"<code>parse_backchannel_authentication_response(response, *, dpop_key=None)</code>","text":"<p>Parse a response received by <code>backchannel_authentication_request()</code>.</p> <p>Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the BackChannel Authentication Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>a <code>BackChannelAuthenticationResponse</code></p> <p>Raises:</p> Type Description <code>InvalidBackChannelAuthenticationResponse</code> <p>if the response does not contain a standard BackChannel Authentication response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_backchannel_authentication_response(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,  # noqa: ARG002\n) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Parse a response received by `backchannel_authentication_request()`.\n\n    Invoked by\n    [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n    to parse the response returned by the BackChannel Authentication Endpoint.\n\n    Args:\n        response: the response returned by the BackChannel Authentication Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        a `BackChannelAuthenticationResponse`\n\n    Raises:\n        InvalidBackChannelAuthenticationResponse: if the response does not contain a standard\n            BackChannel Authentication response.\n\n    \"\"\"\n    try:\n        return BackChannelAuthenticationResponse(**response.json())\n    except TypeError as exc:\n        raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_backchannel_authentication_error","title":"<code>on_backchannel_authentication_error(response, *, dpop_key=None)</code>","text":"<p>Error handler for <code>backchannel_authentication_request()</code>.</p> <p>Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint, when it is an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the BackChannel Authentication Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>usually raises an exception. But a subclass can return a default response instead.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>(or one of its subclasses) if the response contains a standard OAuth 2.0 error.</p> <code>InvalidBackChannelAuthenticationResponse</code> <p>for non-standard error responses.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_backchannel_authentication_error(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,  # noqa: ARG002\n) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Error handler for `backchannel_authentication_request()`.\n\n    Invoked by\n    [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n    to parse the response returned by the BackChannel Authentication Endpoint, when it is an\n    error.\n\n    Args:\n        response: the response returned by the BackChannel Authentication Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        usually raises an exception. But a subclass can return a default response instead.\n\n    Raises:\n        EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n        InvalidBackChannelAuthenticationResponse: for non-standard error responses.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, BackChannelAuthenticationError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorize_device","title":"<code>authorize_device(requests_kwargs=None, **data)</code>","text":"<p>Send a Device Authorization Request.</p> <p>Parameters:</p> Name Type Description Default <code>**data</code> <code>Any</code> <p>additional data to send to the Device Authorization Endpoint</p> <code>{}</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for <code>requests.request()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>a Device Authorization Response</p> <p>Raises:</p> Type Description <code>MissingEndpointUri</code> <p>if the Device Authorization URI is not configured</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorize_device(\n    self,\n    requests_kwargs: dict[str, Any] | None = None,\n    **data: Any,\n) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Send a Device Authorization Request.\n\n    Args:\n        **data: additional data to send to the Device Authorization Endpoint\n        requests_kwargs: additional parameters for `requests.request()`\n\n    Returns:\n        a Device Authorization Response\n\n    Raises:\n        MissingEndpointUri: if the Device Authorization URI is not configured\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    return self._request(\n        Endpoints.DEVICE_AUTHORIZATION,\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_device_authorization_response,\n        on_failure=self.on_device_authorization_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_device_authorization_response","title":"<code>parse_device_authorization_response(response, *, dpop_key=None)</code>","text":"<p>Parse a Device Authorization Response received by <code>authorize_device()</code>.</p> <p>Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the Device Authorization Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>a <code>DeviceAuthorizationResponse</code> as returned by AS</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_device_authorization_response(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,  # noqa: ARG002\n) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Parse a Device Authorization Response received by `authorize_device()`.\n\n    Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n    to parse the response returned by the Device Authorization Endpoint.\n\n    Args:\n        response: the response returned by the Device Authorization Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        a `DeviceAuthorizationResponse` as returned by AS\n\n    \"\"\"\n    return DeviceAuthorizationResponse(**response.json())\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_device_authorization_error","title":"<code>on_device_authorization_error(response, *, dpop_key=None)</code>","text":"<p>Error handler for <code>authorize_device()</code>.</p> <p>Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint, when that response is an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the Device Authorization Endpoint.</p> required <code>dpop_key</code> <code>DPoPKey | None</code> <p>the <code>DPoPKey</code> that was used to proof the token request, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>usually raises an Exception. But a subclass may return a default response instead.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>for standard OAuth 2.0 errors</p> <code>InvalidDeviceAuthorizationResponse</code> <p>for non-standard error responses.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_device_authorization_error(\n    self,\n    response: requests.Response,\n    *,\n    dpop_key: DPoPKey | None = None,  # noqa: ARG002\n) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Error handler for `authorize_device()`.\n\n    Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n    to parse the response returned by the Device Authorization Endpoint, when that response is\n    an error.\n\n    Args:\n        response: the response returned by the Device Authorization Endpoint.\n        dpop_key: the `DPoPKey` that was used to proof the token request, if any.\n\n    Returns:\n        usually raises an Exception. But a subclass may return a default response instead.\n\n    Raises:\n        EndpointError: for standard OAuth 2.0 errors\n        InvalidDeviceAuthorizationResponse: for non-standard error responses.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, DeviceAuthorizationError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidDeviceAuthorizationResponse(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.update_authorization_server_public_keys","title":"<code>update_authorization_server_public_keys(requests_kwargs=None)</code>","text":"<p>Update the cached AS public keys by retrieving them from its <code>jwks_uri</code>.</p> <p>Public keys are returned by this method, as a <code>jwskate.JwkSet</code>. They are also available in attribute <code>authorization_server_jwks</code>.</p> <p>Returns:</p> Type Description <code>JwkSet</code> <p>the retrieved public keys</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if no <code>jwks_uri</code> is configured</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def update_authorization_server_public_keys(self, requests_kwargs: dict[str, Any] | None = None) -&gt; JwkSet:\n    \"\"\"Update the cached AS public keys by retrieving them from its `jwks_uri`.\n\n    Public keys are returned by this method, as a `jwskate.JwkSet`. They are also\n    available in attribute `authorization_server_jwks`.\n\n    Returns:\n        the retrieved public keys\n\n    Raises:\n        ValueError: if no `jwks_uri` is configured\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n    requests_kwargs.setdefault(\"auth\", None)\n\n    jwks_uri = self._require_endpoint(Endpoints.JWKS)\n    resp = self.session.get(jwks_uri, **requests_kwargs)\n    resp.raise_for_status()\n    jwks = resp.json()\n    self.authorization_server_jwks.update(jwks)\n    return self.authorization_server_jwks\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.from_discovery_endpoint","title":"<code>from_discovery_endpoint(url=None, issuer=None, *, auth=None, client_id=None, client_secret=None, private_key=None, session=None, testing=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize an <code>OAuth2Client</code> using an AS Discovery Document endpoint.</p> <p>If an <code>url</code> is provided, an HTTPS request will be done to that URL to obtain the Authorization Server Metadata.</p> <p>If an <code>issuer</code> is provided, the OpenID Connect Discovery document url will be automatically derived from it, as specified in OpenID Connect Discovery.</p> <p>Once the standardized metadata document is obtained, this will extract all Endpoint Uris from that document, will fetch the current public keys from its <code>jwks_uri</code>, then will initialize an OAuth2Client based on those endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | None</code> <p>The url where the server metadata will be retrieved.</p> <code>None</code> <code>issuer</code> <code>str | None</code> <p>The issuer value that is expected in the discovery document. If not <code>url</code> is given, the OpenID Connect Discovery url for this issuer will be retrieved.</p> <code>None</code> <code>auth</code> <code>AuthBase | tuple[str, str] | str | None</code> <p>The authentication handler to use for client authentication.</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>Client ID.</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>Client secret to use to authenticate the client.</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>Private key to sign client assertions.</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>A <code>requests.Session</code> to use to retrieve the document and initialise the client with.</p> <code>None</code> <code>testing</code> <code>bool</code> <p>If <code>True</code>, do not try to validate the issuer uri nor the endpoint urls that are part of the document.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword parameters to pass to <code>OAuth2Client</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>OAuth2Client</code> <p>An <code>OAuth2Client</code> with endpoints initialized based on the obtained metadata.</p> <p>Raises:</p> Type Description <code>InvalidIssuer</code> <p>If <code>issuer</code> is not using https, or contains credentials or fragment.</p> <code>InvalidParam</code> <p>If neither <code>url</code> nor <code>issuer</code> are suitable urls.</p> <code>HTTPError</code> <p>If an error happens while fetching the documents.</p> Example <pre><code>from requests_oauth2client import OAuth2Client\n\nclient = OAuth2Client.from_discovery_endpoint(\n    issuer=\"https://myserver.net\",\n    client_id=\"my_client_id,\n    client_secret=\"my_client_secret\",\n)\n</code></pre> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@classmethod\ndef from_discovery_endpoint(\n    cls,\n    url: str | None = None,\n    issuer: str | None = None,\n    *,\n    auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_key: Jwk | dict[str, Any] | None = None,\n    session: requests.Session | None = None,\n    testing: bool = False,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n    \"\"\"Initialize an `OAuth2Client` using an AS Discovery Document endpoint.\n\n    If an `url` is provided, an HTTPS request will be done to that URL to obtain the Authorization Server Metadata.\n\n    If an `issuer` is provided, the OpenID Connect Discovery document url will be automatically\n    derived from it, as specified in [OpenID Connect Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationRequest).\n\n    Once the standardized metadata document is obtained, this will extract\n    all Endpoint Uris from that document, will fetch the current public keys from its\n    `jwks_uri`, then will initialize an OAuth2Client based on those endpoints.\n\n    Args:\n      url: The url where the server metadata will be retrieved.\n      issuer: The issuer value that is expected in the discovery document.\n        If not `url` is given, the OpenID Connect Discovery url for this issuer will be retrieved.\n      auth: The authentication handler to use for client authentication.\n      client_id: Client ID.\n      client_secret: Client secret to use to authenticate the client.\n      private_key: Private key to sign client assertions.\n      session: A `requests.Session` to use to retrieve the document and initialise the client with.\n      testing: If `True`, do not try to validate the issuer uri nor the endpoint urls\n        that are part of the document.\n      **kwargs: Additional keyword parameters to pass to `OAuth2Client`.\n\n    Returns:\n      An `OAuth2Client` with endpoints initialized based on the obtained metadata.\n\n    Raises:\n      InvalidIssuer: If `issuer` is not using https, or contains credentials or fragment.\n      InvalidParam: If neither `url` nor `issuer` are suitable urls.\n      requests.HTTPError: If an error happens while fetching the documents.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client\n\n        client = OAuth2Client.from_discovery_endpoint(\n            issuer=\"https://myserver.net\",\n            client_id=\"my_client_id,\n            client_secret=\"my_client_secret\",\n        )\n        ```\n\n    \"\"\"\n    if issuer is not None and not testing:\n        try:\n            validate_issuer_uri(issuer)\n        except InvalidUri as exc:\n            raise InvalidIssuer(\"issuer\", issuer, exc) from exc  # noqa: EM101\n    if url is None and issuer is not None:\n        url = oidc_discovery_document_url(issuer)\n    if url is None:\n        msg = \"Please specify at least one of `issuer` or `url`\"\n        raise InvalidParam(msg)\n\n    if not testing:\n        validate_endpoint_uri(url, path=False)\n\n    session = session or requests.Session()\n    discovery = session.get(url).json()\n\n    jwks_uri = discovery.get(\"jwks_uri\")\n    jwks = JwkSet(session.get(jwks_uri).json()) if jwks_uri else None\n\n    return cls.from_discovery_document(\n        discovery,\n        issuer=issuer,\n        auth=auth,\n        session=session,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_key=private_key,\n        authorization_server_jwks=jwks,\n        testing=testing,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.from_discovery_document","title":"<code>from_discovery_document(discovery, issuer=None, *, auth=None, client_id=None, client_secret=None, private_key=None, authorization_server_jwks=None, https=True, testing=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize an <code>OAuth2Client</code>, based on an AS Discovery Document.</p> <p>Parameters:</p> Name Type Description Default <code>discovery</code> <code>dict[str, Any]</code> <p>A <code>dict</code> of server metadata, in the same format as retrieved from a discovery endpoint.</p> required <code>issuer</code> <code>str | None</code> <p>If an issuer is given, check that it matches the one mentioned in the document.</p> <code>None</code> <code>auth</code> <code>AuthBase | tuple[str, str] | str | None</code> <p>The authentication handler to use for client authentication.</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>Client ID.</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>Client secret to use to authenticate the client.</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>Private key to sign client assertions.</p> <code>None</code> <code>authorization_server_jwks</code> <code>JwkSet | dict[str, Any] | None</code> <p>The current authorization server JWKS keys.</p> <code>None</code> <code>https</code> <code>bool</code> <p>(deprecated) If <code>True</code>, validates that urls in the discovery document use the https scheme.</p> <code>True</code> <code>testing</code> <code>bool</code> <p>If <code>True</code>, don't try to validate the endpoint urls that are part of the document.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional args that will be passed to <code>OAuth2Client</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>OAuth2Client</code> <p>An <code>OAuth2Client</code> initialized with the endpoints from the discovery document.</p> <p>Raises:</p> Type Description <code>InvalidDiscoveryDocument</code> <p>If the document does not contain at least a <code>\"token_endpoint\"</code>.</p> <p>Examples:</p> <pre><code>from requests_oauth2client import OAuth2Client\n\nclient = OAuth2Client.from_discovery_document(\n    {\n        \"issuer\": \"https://myas.local\",\n        \"token_endpoint\": \"https://myas.local/token\",\n    },\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n</code></pre> Source code in <code>requests_oauth2client/client.py</code> <pre><code>    @classmethod\n    def from_discovery_document(\n        cls,\n        discovery: dict[str, Any],\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        https: bool = True,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an `OAuth2Client`, based on an AS Discovery Document.\n\n        Args:\n          discovery: A `dict` of server metadata, in the same format as retrieved from a discovery endpoint.\n          issuer: If an issuer is given, check that it matches the one mentioned in the document.\n          auth: The authentication handler to use for client authentication.\n          client_id: Client ID.\n          client_secret: Client secret to use to authenticate the client.\n          private_key: Private key to sign client assertions.\n          authorization_server_jwks: The current authorization server JWKS keys.\n          https: (deprecated) If `True`, validates that urls in the discovery document use the https scheme.\n          testing: If `True`, don't try to validate the endpoint urls that are part of the document.\n          **kwargs: Additional args that will be passed to `OAuth2Client`.\n\n        Returns:\n            An `OAuth2Client` initialized with the endpoints from the discovery document.\n\n        Raises:\n            InvalidDiscoveryDocument: If the document does not contain at least a `\"token_endpoint\"`.\n\n        Examples:\n            ```python\n            from requests_oauth2client import OAuth2Client\n\n            client = OAuth2Client.from_discovery_document(\n                {\n                    \"issuer\": \"https://myas.local\",\n                    \"token_endpoint\": \"https://myas.local/token\",\n                },\n                client_id=\"client_id\",\n                client_secret=\"client_secret\",\n            )\n            ```\n\n        \"\"\"\n        if not https:\n            warnings.warn(\n                \"\"\"\\\nThe `https` parameter is deprecated.\nTo disable endpoint uri validation, set `testing=True` when initializing your `OAuth2Client`.\"\"\",\n                stacklevel=1,\n            )\n            testing = True\n        if issuer and discovery.get(\"issuer\") != issuer:\n            msg = f\"\"\"\\\nMismatching `issuer` value in discovery document (received '{discovery.get(\"issuer\")}', expected '{issuer}').\"\"\"\n            raise InvalidParam(\n                msg,\n                issuer,\n                discovery.get(\"issuer\"),\n            )\n        if issuer is None:\n            issuer = discovery.get(\"issuer\")\n\n        token_endpoint = discovery.get(Endpoints.TOKEN)\n        if token_endpoint is None:\n            msg = \"token_endpoint not found in that discovery document\"\n            raise InvalidDiscoveryDocument(msg, discovery)\n        authorization_endpoint = discovery.get(Endpoints.AUTHORIZATION)\n        revocation_endpoint = discovery.get(Endpoints.REVOCATION)\n        introspection_endpoint = discovery.get(Endpoints.INTROSPECTION)\n        userinfo_endpoint = discovery.get(Endpoints.USER_INFO)\n        pushed_authorization_request_endpoint = discovery.get(Endpoints.PUSHED_AUTHORIZATION_REQUEST)\n        jwks_uri = discovery.get(Endpoints.JWKS)\n        if jwks_uri is not None and not testing:\n            validate_endpoint_uri(jwks_uri)\n        authorization_response_iss_parameter_supported = discovery.get(\n            \"authorization_response_iss_parameter_supported\",\n            False,\n        )\n\n        return cls(\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            pushed_authorization_request_endpoint=pushed_authorization_request_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            issuer=issuer,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            testing=testing,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication","title":"<code>client_authentication</code>","text":"<p>This module implements OAuth 2.0 Client Authentication Methods.</p> <p>An OAuth 2.0 Client must authenticate to the AS whenever it sends a request to the Token Endpoint, by including appropriate credentials. This module contains helper classes and methods that implement the standardized and commonly used Client Authentication Methods.</p>"},{"location":"api/#requests_oauth2client.client_authentication.InvalidRequestForClientAuthentication","title":"<code>InvalidRequestForClientAuthentication</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Raised when a request is not suitable for OAuth 2.0 client authentication.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class InvalidRequestForClientAuthentication(RuntimeError):\n    \"\"\"Raised when a request is not suitable for OAuth 2.0 client authentication.\"\"\"\n\n    def __init__(self, request: requests.PreparedRequest) -&gt; None:\n        super().__init__(\"This request is not suitabe for OAuth 2.0 client authentication.\")\n        self.request = request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.BaseClientAuthenticationMethod","title":"<code>BaseClientAuthenticationMethod</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Base class for all Client Authentication methods. This extends requests.auth.AuthBase.</p> <p>This base class checks that requests are suitable to add Client Authentication parameters to, and does not modify the request.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen\nclass BaseClientAuthenticationMethod(requests.auth.AuthBase):\n    \"\"\"Base class for all Client Authentication methods. This extends [requests.auth.AuthBase][].\n\n    This base class checks that requests are suitable to add Client Authentication parameters to, and does not modify\n    the request.\n\n    \"\"\"\n\n    client_id: str\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Check that the request is suitable for Client Authentication.\n\n        It checks:\n\n        * that the method is `POST`\n        * that the Content-Type is \"application/x-www-form-urlencoded\" or None\n\n        Args:\n            request: a [requests.PreparedRequest][]\n\n        Returns:\n            a [requests.PreparedRequest][], unmodified\n\n        Raises:\n            RuntimeError: if the request is not suitable for OAuth 2.0 Client Authentication\n\n        \"\"\"\n        if request.method != \"POST\" or request.headers.get(\"Content-Type\") not in (\n            \"application/x-www-form-urlencoded\",\n            None,\n        ):\n            raise InvalidRequestForClientAuthentication(request)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretBasic","title":"<code>ClientSecretBasic</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement <code>client_secret_basic</code> authentication.</p> <p>With this method, the client sends its Client ID and Secret, in the HTTP <code>Authorization</code> header, with the <code>Basic</code> scheme, in each authenticated request to the Authorization Server.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>client_secret</code> <code>str</code> <p>Client Secret</p> required Example <pre><code>from requests_oauth2client import ClientSecretBasic, OAuth2Client\n\nauth = ClientSecretBasic(\"my_client_id\", \"my_client_secret\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass ClientSecretBasic(BaseClientAuthenticationMethod):\n    \"\"\"Implement `client_secret_basic` authentication.\n\n    With this method, the client sends its Client ID and Secret, in the HTTP `Authorization` header, with\n    the `Basic` scheme, in each authenticated request to the Authorization Server.\n\n    Args:\n        client_id: Client ID\n        client_secret: Client Secret\n\n    Example:\n        ```python\n        from requests_oauth2client import ClientSecretBasic, OAuth2Client\n\n        auth = ClientSecretBasic(\"my_client_id\", \"my_client_secret\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    client_secret: str\n\n    def __init__(self, client_id: str, client_secret: str) -&gt; None:\n        self.__attrs_init__(\n            client_id=client_id,\n            client_secret=client_secret,\n        )\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the appropriate `Authorization` header in each request.\n\n        The Authorization header is formatted as such:\n        `Authorization: Basic BASE64('&lt;client_id:client_secret&gt;')`\n\n        Args:\n            request: the request\n\n        Returns:\n            a [requests.PreparedRequest][] with the added Authorization header.\n\n        \"\"\"\n        request = super().__call__(request)\n        b64encoded_credentials = BinaPy(f\"{self.client_id}:{self.client_secret}\").to(\"b64\").ascii()\n        request.headers[\"Authorization\"] = f\"Basic {b64encoded_credentials}\"\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretPost","title":"<code>ClientSecretPost</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement <code>client_secret_post</code> client authentication method.</p> <p>With this method, the client inserts its client_id and client_secret in each authenticated request to the AS.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>client_secret</code> <code>str</code> <p>Client Secret</p> required Example <pre><code>from requests_oauth2client import ClientSecretPost, OAuth2Client\n\nauth = ClientSecretPost(\"my_client_id\", \"my_client_secret\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass ClientSecretPost(BaseClientAuthenticationMethod):\n    \"\"\"Implement `client_secret_post` client authentication method.\n\n    With this method, the client inserts its client_id and client_secret in each authenticated\n    request to the AS.\n\n    Args:\n        client_id: Client ID\n        client_secret: Client Secret\n\n    Example:\n        ```python\n        from requests_oauth2client import ClientSecretPost, OAuth2Client\n\n        auth = ClientSecretPost(\"my_client_id\", \"my_client_secret\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    client_secret: str\n\n    def __init__(self, client_id: str, client_secret: str) -&gt; None:\n        self.__attrs_init__(\n            client_id=client_id,\n            client_secret=client_secret,\n        )\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the `client_id` and `client_secret` parameters in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added client credentials fields.\n\n        \"\"\"\n        request = super().__call__(request)\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if isinstance(request.body, (str, bytes))\n            else {}\n        )\n        params[b\"client_id\"] = [self.client_id.encode()]\n        params[b\"client_secret\"] = [self.client_secret.encode()]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.BaseClientAssertionAuthenticationMethod","title":"<code>BaseClientAssertionAuthenticationMethod</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Base class for assertion-based client authentication methods.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen\nclass BaseClientAssertionAuthenticationMethod(BaseClientAuthenticationMethod):\n    \"\"\"Base class for assertion-based client authentication methods.\"\"\"\n\n    lifetime: int\n    jti_gen: Callable[[], str]\n    aud: str | None\n    alg: str | None\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a Client Assertion for a specific audience.\n\n        Args:\n            audience: the audience to use for the `aud` claim of the generated Client Assertion.\n\n        Returns:\n            a Client Assertion, as `str`.\n\n        \"\"\"\n        raise NotImplementedError\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add a `client_assertion` field in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added `client_assertion` field.\n\n        \"\"\"\n        request = super().__call__(request)\n        audience = self.aud or request.url\n        if audience is None:\n            raise InvalidRequestForClientAuthentication(request)  # pragma: no cover\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if request.body\n            else {}\n        )\n        client_assertion = self.client_assertion(audience)\n        params[b\"client_id\"] = [self.client_id.encode()]\n        params[b\"client_assertion\"] = [client_assertion.encode()]\n        params[b\"client_assertion_type\"] = [b\"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.BaseClientAssertionAuthenticationMethod.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a Client Assertion for a specific audience.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the <code>aud</code> claim of the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion, as <code>str</code>.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a Client Assertion for a specific audience.\n\n    Args:\n        audience: the audience to use for the `aud` claim of the generated Client Assertion.\n\n    Returns:\n        a Client Assertion, as `str`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretJwt","title":"<code>ClientSecretJwt</code>","text":"<p>               Bases: <code>BaseClientAssertionAuthenticationMethod</code></p> <p>Implement <code>client_secret_jwt</code> client authentication method.</p> <p>With this method, the client generates a client assertion, then symmetrically signs it with its Client Secret. The assertion is then sent to the AS in a <code>client_assertion</code> field with each authenticated request.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the <code>client_id</code> to use.</p> required <code>client_secret</code> <code>str</code> <p>the <code>client_secret</code> to use to sign generated Client Assertions.</p> required <code>alg</code> <code>str</code> <p>the alg to use to sign generated Client Assertions.</p> <code>HS256</code> <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> <code>60</code> <code>jti_gen</code> <code>Callable[[], str]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> <code>lambda: str(uuid4())</code> <code>aud</code> <code>str | None</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.</p> <code>None</code> Example <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\nauth = ClientSecretJwt(\"my_client_id\", \"my_client_secret\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass ClientSecretJwt(BaseClientAssertionAuthenticationMethod):\n    \"\"\"Implement `client_secret_jwt` client authentication method.\n\n    With this method, the client generates a client assertion, then symmetrically signs it with its Client Secret.\n    The assertion is then sent to the AS in a `client_assertion` field with each authenticated request.\n\n    Args:\n        client_id: the `client_id` to use.\n        client_secret: the `client_secret` to use to sign generated Client Assertions.\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\n        auth = ClientSecretJwt(\"my_client_id\", \"my_client_secret\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    client_secret: str\n\n    def __init__(\n        self,\n        client_id: str,\n        client_secret: str,\n        lifetime: int = 60,\n        alg: str = SignatureAlgs.HS256,\n        jti_gen: Callable[[], str] = lambda: str(uuid4()),\n        aud: str | None = None,\n    ) -&gt; None:\n        self.__attrs_init__(\n            client_id=client_id,\n            client_secret=client_secret,\n            lifetime=lifetime,\n            alg=alg,\n            jti_gen=jti_gen,\n            aud=aud,\n        )\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a symmetrically signed Client Assertion.\n\n        Assertion is signed with the `client_secret` as key and the `alg` passed at init time.\n\n        Args:\n            audience: the audience to use for the generated Client Assertion.\n\n        Returns:\n            a Client Assertion, as `str`.\n\n        \"\"\"\n        iat = int(datetime.now(tz=timezone.utc).timestamp())\n        exp = iat + self.lifetime\n        jti = str(self.jti_gen())\n\n        jwk = SymmetricJwk.from_bytes(self.client_secret.encode())\n\n        jwt = Jwt.sign(\n            claims={\n                \"iss\": self.client_id,\n                \"sub\": self.client_id,\n                \"aud\": audience,\n                \"iat\": iat,\n                \"exp\": exp,\n                \"jti\": jti,\n            },\n            key=jwk,\n            alg=self.alg,\n        )\n        return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretJwt.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a symmetrically signed Client Assertion.</p> <p>Assertion is signed with the <code>client_secret</code> as key and the <code>alg</code> passed at init time.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion, as <code>str</code>.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a symmetrically signed Client Assertion.\n\n    Assertion is signed with the `client_secret` as key and the `alg` passed at init time.\n\n    Args:\n        audience: the audience to use for the generated Client Assertion.\n\n    Returns:\n        a Client Assertion, as `str`.\n\n    \"\"\"\n    iat = int(datetime.now(tz=timezone.utc).timestamp())\n    exp = iat + self.lifetime\n    jti = str(self.jti_gen())\n\n    jwk = SymmetricJwk.from_bytes(self.client_secret.encode())\n\n    jwt = Jwt.sign(\n        claims={\n            \"iss\": self.client_id,\n            \"sub\": self.client_id,\n            \"aud\": audience,\n            \"iat\": iat,\n            \"exp\": exp,\n            \"jti\": jti,\n        },\n        key=jwk,\n        alg=self.alg,\n    )\n    return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.InvalidClientAssertionSigningKeyOrAlg","title":"<code>InvalidClientAssertionSigningKeyOrAlg</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when the client assertion signing alg is not specified or invalid.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class InvalidClientAssertionSigningKeyOrAlg(ValueError):\n    \"\"\"Raised when the client assertion signing alg is not specified or invalid.\"\"\"\n\n    def __init__(self, alg: str | None) -&gt; None:\n        super().__init__(\"\"\"\\\nAn asymmetric private signing key, and an alg that is supported by the signing key is required.\nIt can be provided either:\n- as part of the private `Jwk`, in the parameter 'alg'\n- or passed as parameter `alg` when initializing a `PrivateKeyJwt`.\nExamples of valid `alg` values and matching key type:\n- 'RS256', 'RS512' (with a key of type RSA)\n- 'ES256', 'ES512' (with a key of type EC)\nThe private key must include a Key ID (in its 'kid' parameter).\n\"\"\")\n        self.alg = alg\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.PrivateKeyJwt","title":"<code>PrivateKeyJwt</code>","text":"<p>               Bases: <code>BaseClientAssertionAuthenticationMethod</code></p> <p>Implement <code>private_key_jwt</code> client authentication method.</p> <p>With this method, the client generates and sends a client_assertion, that is asymmetrically signed with a private key, on each direct request to the Authorization Server.</p> <p>The private key must be supplied as a <code>jwskate.Jwk</code> instance, or any key material that can be used to initialize one.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the <code>client_id</code> to use.</p> required <code>private_jwk</code> <code>Jwk | dict[str, Any] | Any</code> <p>the private key to use to sign generated Client Assertions.</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign generated Client Assertions.</p> <code>None</code> <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> <code>60</code> <code>jti_gen</code> <code>Callable[[], str]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> <code>lambda: str(uuid4())</code> <code>aud</code> <code>str | None</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.k</p> <code>None</code> Example <pre><code>from jwskate import Jwk\nfrom requests_oauth2client import OAuth2Client, PrivateKeyJwt\n\n# load your private key from wherever it is stored:\nwith open(\"my_private_key.pem\") as f:\n    my_private_key = Jwk.from_pem(f.read(), password=\"my_private_key_password\")\n\nauth = PrivateKeyJwt(\"my_client_id\", my_private_key, alg=\"RS256\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass PrivateKeyJwt(BaseClientAssertionAuthenticationMethod):\n    \"\"\"Implement `private_key_jwt` client authentication method.\n\n    With this method, the client generates and sends a client_assertion, that is asymmetrically\n    signed with a private key, on each direct request to the Authorization Server.\n\n    The private key must be supplied as a [`jwskate.Jwk`][jwskate.jwk.Jwk] instance,\n    or any key material that can be used to initialize one.\n\n    Args:\n        client_id: the `client_id` to use.\n        private_jwk: the private key to use to sign generated Client Assertions.\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.k\n\n    Example:\n        ```python\n        from jwskate import Jwk\n        from requests_oauth2client import OAuth2Client, PrivateKeyJwt\n\n        # load your private key from wherever it is stored:\n        with open(\"my_private_key.pem\") as f:\n            my_private_key = Jwk.from_pem(f.read(), password=\"my_private_key_password\")\n\n        auth = PrivateKeyJwt(\"my_client_id\", my_private_key, alg=\"RS256\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    private_jwk: Jwk\n\n    def __init__(\n        self,\n        client_id: str,\n        private_jwk: Jwk | dict[str, Any] | Any,\n        *,\n        alg: str | None = None,\n        lifetime: int = 60,\n        jti_gen: Callable[[], str] = lambda: str(uuid4()),\n        aud: str | None = None,\n    ) -&gt; None:\n        private_jwk = to_jwk(private_jwk)\n\n        alg = private_jwk.alg or alg\n        if not alg:\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n        if alg not in private_jwk.supported_signing_algorithms():\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n        if not private_jwk.is_private or private_jwk.is_symmetric:\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n        kid = private_jwk.get(\"kid\")\n        if not kid:\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n        self.__attrs_init__(\n            client_id=client_id,\n            private_jwk=private_jwk,\n            alg=alg,\n            lifetime=lifetime,\n            jti_gen=jti_gen,\n            aud=aud,\n        )\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a Client Assertion, asymmetrically signed with `private_jwk` as key.\n\n        Args:\n            audience: the audience to use for the generated Client Assertion.\n\n        Returns:\n            a Client Assertion.\n\n        \"\"\"\n        iat = int(datetime.now(tz=timezone.utc).timestamp())\n        exp = iat + self.lifetime\n        jti = str(self.jti_gen())\n\n        jwt = Jwt.sign(\n            claims={\n                \"iss\": self.client_id,\n                \"sub\": self.client_id,\n                \"aud\": audience,\n                \"iat\": iat,\n                \"exp\": exp,\n                \"jti\": jti,\n            },\n            key=self.private_jwk,\n            alg=self.alg,\n        )\n        return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.PrivateKeyJwt.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a Client Assertion, asymmetrically signed with <code>private_jwk</code> as key.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a Client Assertion, asymmetrically signed with `private_jwk` as key.\n\n    Args:\n        audience: the audience to use for the generated Client Assertion.\n\n    Returns:\n        a Client Assertion.\n\n    \"\"\"\n    iat = int(datetime.now(tz=timezone.utc).timestamp())\n    exp = iat + self.lifetime\n    jti = str(self.jti_gen())\n\n    jwt = Jwt.sign(\n        claims={\n            \"iss\": self.client_id,\n            \"sub\": self.client_id,\n            \"aud\": audience,\n            \"iat\": iat,\n            \"exp\": exp,\n            \"jti\": jti,\n        },\n        key=self.private_jwk,\n        alg=self.alg,\n    )\n    return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.PublicApp","title":"<code>PublicApp</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement the <code>none</code> authentication method for public apps.</p> <p>This scheme is used for Public Clients, which do not have any secret credentials. Those only send their client_id to the Authorization Server.</p> Example <pre><code>from requests_oauth2client import OAuth2Client, PublicApp\n\nauth = PublicApp(\"my_client_id\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen\nclass PublicApp(BaseClientAuthenticationMethod):\n    \"\"\"Implement the `none` authentication method for public apps.\n\n    This scheme is used for Public Clients, which do not have any secret credentials. Those only\n    send their client_id to the Authorization Server.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, PublicApp\n\n        auth = PublicApp(\"my_client_id\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the `client_id` field in the request body.\n\n        Args:\n            request: a request.\n\n        Returns:\n            the request with the added `client_id` form field.\n\n        \"\"\"\n        request = super().__call__(request)\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if request.body\n            else {}\n        )\n        params[b\"client_id\"] = [self.client_id.encode()]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.UnsupportedClientCredentials","title":"<code>UnsupportedClientCredentials</code>","text":"<p>               Bases: <code>TypeError</code>, <code>ValueError</code></p> <p>Raised when unsupported client credentials are provided.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class UnsupportedClientCredentials(TypeError, ValueError):\n    \"\"\"Raised when unsupported client credentials are provided.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.client_auth_factory","title":"<code>client_auth_factory(auth, *, client_id=None, client_secret=None, private_key=None, default_auth_handler=ClientSecretPost)</code>","text":"<p>Initialize the appropriate Auth Handler based on the provided parameters.</p> <p>This initializes a <code>ClientAuthenticationMethod</code> subclass based on the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>auth</code> <code>AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None</code> <p>can be:</p> <ul> <li>a <code>requests.auth.AuthBase</code> instance (which will be used directly)</li> <li>a tuple of (client_id, client_secret) which will be used to initialize an instance of   <code>default_auth_handler</code>,</li> <li>a tuple of (client_id, jwk), used to initialize a <code>PrivateKeyJwk</code> (<code>jwk</code> being an   instance of <code>jwskate.Jwk</code> or a <code>dict</code>),</li> <li>a <code>client_id</code>, as <code>str</code>,</li> <li>or <code>None</code>, to pass <code>client_id</code> and other credentials as dedicated parameters, see   below.</li> </ul> required <code>client_id</code> <code>str | None</code> <p>the Client ID to use for this client</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>the Client Secret to use for this client, if any (for clients using an authentication method based on a secret)</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>the private key to use for private_key_jwt authentication method</p> <code>None</code> <code>default_auth_handler</code> <code>type[ClientSecretPost | ClientSecretBasic | ClientSecretJwt]</code> <p>if a client_id and client_secret are provided, initialize an instance of this class with those 2 parameters. You can choose between <code>ClientSecretBasic</code>, <code>ClientSecretPost</code>, or <code>ClientSecretJwt</code>.</p> <code>ClientSecretPost</code> <p>Returns:</p> Type Description <code>AuthBase</code> <p>an Auth Handler that will manage client authentication to the AS Token Endpoint or other</p> <code>AuthBase</code> <p>backend endpoints.</p> <p>Raises:</p> Type Description <code>UnsupportedClientCredentials</code> <p>if the provided parameters are not suitable to guess the desired authentication method.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_auth_factory(\n    auth: requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None,\n    *,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_key: Jwk | dict[str, Any] | None = None,\n    default_auth_handler: type[ClientSecretPost | ClientSecretBasic | ClientSecretJwt] = ClientSecretPost,\n) -&gt; requests.auth.AuthBase:\n    \"\"\"Initialize the appropriate Auth Handler based on the provided parameters.\n\n    This initializes a `ClientAuthenticationMethod` subclass based on the provided parameters.\n\n    Args:\n        auth: can be:\n\n            - a `requests.auth.AuthBase` instance (which will be used directly)\n            - a tuple of (client_id, client_secret) which will be used to initialize an instance of\n              `default_auth_handler`,\n            - a tuple of (client_id, jwk), used to initialize a `PrivateKeyJwk` (`jwk` being an\n              instance of `jwskate.Jwk` or a `dict`),\n            - a `client_id`, as `str`,\n            - or `None`, to pass `client_id` and other credentials as dedicated parameters, see\n              below.\n        client_id: the Client ID to use for this client\n        client_secret: the Client Secret to use for this client, if any (for clients using\n            an authentication method based on a secret)\n        private_key: the private key to use for private_key_jwt authentication method\n        default_auth_handler: if a client_id and client_secret are provided, initialize an\n            instance of this class with those 2 parameters.\n            You can choose between `ClientSecretBasic`, `ClientSecretPost`, or `ClientSecretJwt`.\n\n    Returns:\n        an Auth Handler that will manage client authentication to the AS Token Endpoint or other\n        backend endpoints.\n\n    Raises:\n        UnsupportedClientCredentials: if the provided parameters are not suitable to guess the\n            desired authentication method.\n\n    \"\"\"\n    if auth is not None and (client_id is not None or client_secret is not None or private_key is not None):\n        msg = \"\"\"\\\nPlease use either `auth` parameter to provide an authentication method,\nor use `client_id` and one of `client_secret` or `private_key`.\n\"\"\"\n        raise UnsupportedClientCredentials(msg)\n\n    if isinstance(auth, str):\n        client_id = auth\n    elif isinstance(auth, requests.auth.AuthBase):\n        return auth\n    elif isinstance(auth, tuple) and len(auth) == 2:  # noqa: PLR2004\n        client_id, credential = auth\n        if isinstance(credential, (Jwk, dict)):\n            private_key = credential\n        elif isinstance(credential, str):\n            client_secret = credential\n        else:\n            msg = \"This credential type is not supported:\"\n            raise UnsupportedClientCredentials(msg, type(credential), credential)\n\n    if client_id is None:\n        msg = \"A client_id must be provided.\"\n        raise UnsupportedClientCredentials(msg)\n\n    if private_key is not None:\n        return PrivateKeyJwt(client_id, private_jwk=private_key)\n    if client_secret is None:\n        return PublicApp(str(client_id))\n\n    return default_auth_handler(str(client_id), str(client_secret))\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization","title":"<code>device_authorization</code>","text":"<p>Implements the Device Authorization Flow as defined in RFC8628.</p> <p>See RFC8628.</p>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationResponse","title":"<code>DeviceAuthorizationResponse</code>","text":"<p>Represent a response returned by the device Authorization Endpoint.</p> <p>All parameters are those returned by the AS as response to a Device Authorization Request.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>user_code</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>verification_uri</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>verification_uri_complete</code> <code>str | None</code> <p>the <code>device_code</code> as returned by the AS.</p> <code>None</code> <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for the device_code. Also accepts an <code>expires_in</code> parameter, as a number of seconds in the future.</p> <code>None</code> <code>interval</code> <code>int | None</code> <p>the pooling <code>interval</code> as returned by the AS.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>class DeviceAuthorizationResponse:\n    \"\"\"Represent a response returned by the device Authorization Endpoint.\n\n    All parameters are those returned by the AS as response to a Device Authorization Request.\n\n    Args:\n        device_code: the `device_code` as returned by the AS.\n        user_code: the `device_code` as returned by the AS.\n        verification_uri: the `device_code` as returned by the AS.\n        verification_uri_complete: the `device_code` as returned by the AS.\n        expires_at: the expiration date for the device_code.\n            Also accepts an `expires_in` parameter, as a number of seconds in the future.\n        interval: the pooling `interval` as returned by the AS.\n        **kwargs: additional parameters as returned by the AS.\n\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        device_code: str,\n        user_code: str,\n        verification_uri: str,\n        verification_uri_complete: str | None = None,\n        expires_at: datetime | None = None,\n        interval: int | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        self.device_code = device_code\n        self.user_code = user_code\n        self.verification_uri = verification_uri\n        self.verification_uri_complete = verification_uri_complete\n        self.expires_at = expires_at\n        self.interval = interval\n        self.other = kwargs\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Check if the `device_code` within this response is expired.\n\n        Returns:\n            `True` if the device_code is expired, `False` if it is still valid, `None` if there is\n            no `expires_in` hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationResponse.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Check if the <code>device_code</code> within this response is expired.</p> <p>Returns:</p> Type Description <code>bool | None</code> <p><code>True</code> if the device_code is expired, <code>False</code> if it is still valid, <code>None</code> if there is</p> <code>bool | None</code> <p>no <code>expires_in</code> hint.</p> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Check if the `device_code` within this response is expired.\n\n    Returns:\n        `True` if the device_code is expired, `False` if it is still valid, `None` if there is\n        no `expires_in` hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationPoolingJob","title":"<code>DeviceAuthorizationPoolingJob</code>","text":"<p>               Bases: <code>BaseTokenEndpointPoolingJob</code></p> <p>A Token Endpoint pooling job for the Device Authorization Flow.</p> <p>This periodically checks if the user has finished with his authorization in a Device Authorization flow.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client that will be used to pool the token endpoint.</p> required <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a <code>device_code</code> as <code>str</code> or a <code>DeviceAuthorizationResponse</code>.</p> required <code>interval</code> <code>int | None</code> <p>The pooling interval to use. This overrides the one in <code>auth_req_id</code> if it is a <code>BackChannelAuthenticationResponse</code>.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>Number of seconds to add to the pooling interval when the AS returns a slow-down request.</p> <code>5</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the underlying calls to requests.request.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token request.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import DeviceAuthorizationPoolingJob, OAuth2Client\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\npooler = DeviceAuthorizationPoolingJob(client=client, device_code=\"my_device_code\")\n\ntoken = None\nwhile token is None:\n    token = pooler()\n</code></pre> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>@define(init=False)\nclass DeviceAuthorizationPoolingJob(BaseTokenEndpointPoolingJob):\n    \"\"\"A Token Endpoint pooling job for the Device Authorization Flow.\n\n    This periodically checks if the user has finished with his authorization in a Device\n    Authorization flow.\n\n    Args:\n        client: an OAuth2Client that will be used to pool the token endpoint.\n        device_code: a `device_code` as `str` or a `DeviceAuthorizationResponse`.\n        interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is\n            a `BackChannelAuthenticationResponse`.\n        slow_down_interval: Number of seconds to add to the pooling interval when the AS returns\n            a slow-down request.\n        requests_kwargs: Additional parameters for the underlying calls to [requests.request][].\n        **token_kwargs: Additional parameters for the token request.\n\n    Example:\n        ```python\n        from requests_oauth2client import DeviceAuthorizationPoolingJob, OAuth2Client\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        pooler = DeviceAuthorizationPoolingJob(client=client, device_code=\"my_device_code\")\n\n        token = None\n        while token is None:\n            token = pooler()\n        ```\n\n    \"\"\"\n\n    device_code: str\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        device_code: str | DeviceAuthorizationResponse,\n        interval: int | None = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(device_code, DeviceAuthorizationResponse):\n            interval = interval or device_code.interval\n            device_code = device_code.device_code\n\n        self.__attrs_init__(\n            client=client,\n            device_code=device_code,\n            interval=interval or 5,\n            slow_down_interval=slow_down_interval,\n            requests_kwargs=requests_kwargs or {},\n            token_kwargs=token_kwargs,\n        )\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Implement the Device Code token request.\n\n        This actually calls [OAuth2Client.device_code(device_code)][requests_oauth2client.OAuth2Client.device_code]\n        on `self.client`.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        return self.client.device_code(self.device_code, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Implement the Device Code token request.</p> <p>This actually calls OAuth2Client.device_code(device_code) on <code>self.client</code>.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Implement the Device Code token request.\n\n    This actually calls [OAuth2Client.device_code(device_code)][requests_oauth2client.OAuth2Client.device_code]\n    on `self.client`.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    return self.client.device_code(self.device_code, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.discovery","title":"<code>discovery</code>","text":"<p>Implements Metadata discovery documents URLS.</p> <p>This is as defined in RFC8615 and OpenID Connect Discovery 1.0.</p>"},{"location":"api/#requests_oauth2client.discovery.well_known_uri","title":"<code>well_known_uri(origin, name, *, at_root=True)</code>","text":"<p>Return the location of a well-known document on an origin url.</p> <p>See RFC8615 and OIDC Discovery.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>str</code> <p>origin to use to build the well-known uri.</p> required <code>name</code> <code>str</code> <p>document name to use to build the well-known uri.</p> required <code>at_root</code> <code>bool</code> <p>if <code>True</code>, assume the well-known document is at root level (as defined in RFC8615). If <code>False</code>, assume the well-known location is per-directory, as defined in OpenID Connect Discovery 1.0.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>the well-know uri, relative to origin, where the well-known document named <code>name</code> should be</p> <code>str</code> <p>found.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def well_known_uri(origin: str, name: str, *, at_root: bool = True) -&gt; str:\n    \"\"\"Return the location of a well-known document on an origin url.\n\n    See [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615) and [OIDC\n    Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Args:\n        origin: origin to use to build the well-known uri.\n        name: document name to use to build the well-known uri.\n        at_root: if `True`, assume the well-known document is at root level (as defined in [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615)).\n            If `False`, assume the well-known location is per-directory, as defined in [OpenID\n            Connect Discovery\n            1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Returns:\n        the well-know uri, relative to origin, where the well-known document named `name` should be\n        found.\n\n    \"\"\"\n    url = furl(origin)\n    if at_root:\n        url.path = Path(\".well-known\") / url.path / name\n    else:\n        url.path.add(Path(\".well-known\") / name)\n    return str(url)\n</code></pre>"},{"location":"api/#requests_oauth2client.discovery.oidc_discovery_document_url","title":"<code>oidc_discovery_document_url(issuer)</code>","text":"<p>Construct the OIDC discovery document url for a given <code>issuer</code>.</p> <p>Given an <code>issuer</code> identifier, return the standardised URL where the OIDC discovery document can be retrieved.</p> <p>The returned URL is biuilt as specified in OpenID Connect Discovery 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>an OIDC Authentication Server <code>issuer</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>the standardised discovery document URL. Note that no attempt to fetch this document is</p> <code>str</code> <p>made.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def oidc_discovery_document_url(issuer: str) -&gt; str:\n    \"\"\"Construct the OIDC discovery document url for a given `issuer`.\n\n    Given an `issuer` identifier, return the standardised URL where the OIDC discovery document can\n    be retrieved.\n\n    The returned URL is biuilt as specified in [OpenID Connect Discovery\n    1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Args:\n        issuer: an OIDC Authentication Server `issuer`\n\n    Returns:\n        the standardised discovery document URL. Note that no attempt to fetch this document is\n        made.\n\n    \"\"\"\n    return well_known_uri(issuer, \"openid-configuration\", at_root=False)\n</code></pre>"},{"location":"api/#requests_oauth2client.discovery.oauth2_discovery_document_url","title":"<code>oauth2_discovery_document_url(issuer)</code>","text":"<p>Construct the standardised OAuth 2.0 discovery document url for a given <code>issuer</code>.</p> <p>Based an <code>issuer</code> identifier, returns the standardised URL where the OAuth20 server metadata can be retrieved.</p> <p>The returned URL is built as specified in RFC8414.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>an OAuth20 Authentication Server <code>issuer</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>the standardised discovery document URL. Note that no attempt to fetch this document is</p> <code>str</code> <p>made.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def oauth2_discovery_document_url(issuer: str) -&gt; str:\n    \"\"\"Construct the standardised OAuth 2.0 discovery document url for a given `issuer`.\n\n    Based an `issuer` identifier, returns the standardised URL where the OAuth20 server metadata can\n    be retrieved.\n\n    The returned URL is built as specified in\n    [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414).\n\n    Args:\n        issuer: an OAuth20 Authentication Server `issuer`\n\n    Returns:\n        the standardised discovery document URL. Note that no attempt to fetch this document is\n        made.\n\n    \"\"\"\n    return well_known_uri(issuer, \"oauth-authorization-server\", at_root=True)\n</code></pre>"},{"location":"api/#requests_oauth2client.dpop","title":"<code>dpop</code>","text":"<p>Implementation of OAuth 2.0 Demonstrating Proof of Possession (DPoP) (RFC9449).</p>"},{"location":"api/#requests_oauth2client.dpop.InvalidDPoPAccessToken","title":"<code>InvalidDPoPAccessToken</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an access token contains invalid characters.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>class InvalidDPoPAccessToken(ValueError):\n    \"\"\"Raised when an access token contains invalid characters.\"\"\"\n\n    def __init__(self, access_token: str) -&gt; None:\n        super().__init__(\"\"\"\\\nThis DPoP token contains invalid characters. DPoP tokens are limited to a set of 68 characters,\nto avoid encoding inconsistencies when doing the token value hashing for the DPoP proof.\"\"\")\n        self.access_token = access_token\n</code></pre>"},{"location":"api/#requests_oauth2client.dpop.InvalidDPoPKey","title":"<code>InvalidDPoPKey</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a DPoPToken is initialized with a non-suitable key.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>class InvalidDPoPKey(ValueError):\n    \"\"\"Raised when a DPoPToken is initialized with a non-suitable key.\"\"\"\n\n    def __init__(self, key: Any) -&gt; None:\n        super().__init__(\"The key you are trying to use with DPoP is not an asymmetric private key.\")\n        self.key = key\n</code></pre>"},{"location":"api/#requests_oauth2client.dpop.InvalidDPoPAlg","title":"<code>InvalidDPoPAlg</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an invalid or unsupported DPoP alg is given.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>class InvalidDPoPAlg(ValueError):\n    \"\"\"Raised when an invalid or unsupported DPoP alg is given.\"\"\"\n\n    def __init__(self, alg: str) -&gt; None:\n        super().__init__(\"DPoP proofing require an asymmetric signing alg.\")\n        self.alg = alg\n</code></pre>"},{"location":"api/#requests_oauth2client.dpop.InvalidDPoPProof","title":"<code>InvalidDPoPProof</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a DPoP proof does not verify.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>class InvalidDPoPProof(ValueError):\n    \"\"\"Raised when a DPoP proof does not verify.\"\"\"\n\n    def __init__(self, proof: bytes, message: str) -&gt; None:\n        super().__init__(f\"Invalid DPoP proof: {message}\")\n        self.proof = proof\n</code></pre>"},{"location":"api/#requests_oauth2client.dpop.InvalidUseDPoPNonceResponse","title":"<code>InvalidUseDPoPNonceResponse</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for invalid Responses with a <code>use_dpop_nonce</code> error.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>class InvalidUseDPoPNonceResponse(Exception):\n    \"\"\"Base class for invalid Responses with a `use_dpop_nonce` error.\"\"\"\n\n    def __init__(self, response: requests.Response, message: str) -&gt; None:\n        super().__init__(message)\n        self.response = response\n</code></pre>"},{"location":"api/#requests_oauth2client.dpop.MissingDPoPNonce","title":"<code>MissingDPoPNonce</code>","text":"<p>               Bases: <code>InvalidUseDPoPNonceResponse</code></p> <p>Raised when a server requests a DPoP nonce but none is provided in its response.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>class MissingDPoPNonce(InvalidUseDPoPNonceResponse):\n    \"\"\"Raised when a server requests a DPoP nonce but none is provided in its response.\"\"\"\n\n    def __init__(self, response: requests.Response) -&gt; None:\n        super().__init__(\n            response,\n            \"Server requested client to use a DPoP `nonce`, but the `DPoP-Nonce` HTTP header is missing.\",\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.dpop.RepeatedDPoPNonce","title":"<code>RepeatedDPoPNonce</code>","text":"<p>               Bases: <code>InvalidUseDPoPNonceResponse</code></p> <p>Raised when the server requests a DPoP nonce value that is the same as already included in the request.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>class RepeatedDPoPNonce(InvalidUseDPoPNonceResponse):\n    \"\"\"Raised when the server requests a DPoP nonce value that is the same as already included in the request.\"\"\"\n\n    def __init__(self, response: requests.Response) -&gt; None:\n        super().__init__(\n            response,\n            \"\"\"\\\nServer requested client to use a DPoP `nonce`,\nbut provided the same value for that nonce that was already included in the DPoP proof.\"\"\",\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.dpop.DPoPToken","title":"<code>DPoPToken</code>","text":"<p>               Bases: <code>BearerToken</code></p> <p>Represent a DPoP token (RFC9449).</p> <p>A DPoP is very much like a BearerToken, with an additional private key bound to it.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>@frozen(init=False)\nclass DPoPToken(BearerToken):  # type: ignore[override]\n    \"\"\"Represent a DPoP token (RFC9449).\n\n    A DPoP is very much like a BearerToken, with an additional private key bound to it.\n\n    \"\"\"\n\n    TOKEN_TYPE = AccessTokenTypes.DPOP.value\n    AUTHORIZATION_SCHEME = AccessTokenTypes.DPOP.value\n    DPOP_HEADER: ClassVar[str] = \"DPoP\"\n\n    dpop_key: DPoPKey = field(kw_only=True)\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        access_token: str,\n        *,\n        _dpop_key: DPoPKey,\n        expires_at: datetime | None = None,\n        scope: str | None = None,\n        refresh_token: str | None = None,\n        token_type: str = TOKEN_TYPE,\n        id_token: str | bytes | IdToken | jwskate.JweCompact | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        if not token68_pattern.match(access_token):\n            raise InvalidDPoPAccessToken(access_token)\n\n        id_token = id_token_converter(id_token)\n\n        self.__attrs_init__(\n            access_token=access_token,\n            expires_at=expires_at,\n            scope=scope,\n            refresh_token=refresh_token,\n            token_type=token_type,\n            id_token=id_token,\n            dpop_key=_dpop_key,\n            kwargs=kwargs,\n        )\n\n    def _response_hook(self, response: requests.Response, **kwargs: Any) -&gt; requests.Response:\n        \"\"\"Handles a Resource Server provided DPoP nonce.\"\"\"\n        if response.status_code == codes.unauthorized and response.headers.get(\"WWW-Authenticate\", \"\").startswith(\n            \"DPoP\"\n        ):\n            self.dpop_key.handle_rs_provided_dpop_nonce(response)\n            new_request = response.request.copy()\n            # remove the previously registered hook to avoid registering it multiple times\n            new_request.deregister_hook(\"response\", self._response_hook)  # type: ignore[no-untyped-call]\n            new_request = self(new_request)  # another hook will be re-registered here in the __call__() method\n\n            return response.connection.send(new_request, **kwargs)\n\n        return response\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add a DPoP proof in each request.\"\"\"\n        request = super().__call__(request)\n        add_dpop_proof(request, dpop_key=self.dpop_key, access_token=self.access_token, header_name=self.DPOP_HEADER)\n        request.register_hook(\"response\", self._response_hook)  # type: ignore[no-untyped-call]\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.dpop.DPoPKey","title":"<code>DPoPKey</code>","text":"<p>Wrapper around a DPoP proof signature key.</p> <p>This handles DPoP proof generation. It also keeps track of a nonce, if provided by the Resource Server. Its behavior follows the standard DPoP specifications. You may subclass or otherwise customize this class to implement custom behavior, like adding or modifying claims to the proofs.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>Any</code> <p>the private key to use for DPoP proof signatures.</p> required <code>alg</code> <code>str | None</code> <p>the alg to use for signatures, if not specified of the <code>private_key</code>.</p> <code>None</code> <code>jti_generator</code> <code>Callable[[], str]</code> <p>a callable that generates unique JWT Token ID (jti) values to include in proofs.</p> <code>lambda: str(uuid4())</code> <code>iat_generator</code> <code>Callable[[], int]</code> <p>a callable that generates the Issuer Date (iat) to include in proofs.</p> <code>lambda: timestamp()</code> <code>jwt_typ</code> <code>str</code> <p>the token type (<code>typ</code>) header to include in the generated proofs.</p> <code>'dpop+jwt'</code> <code>dpop_token_class</code> <code>type[DPoPToken]</code> <p>the class to use to represent DPoP tokens.</p> <code>DPoPToken</code> <code>rs_nonce</code> <code>str | None</code> <p>an initial DPoP <code>nonce</code> to include in requests, for testing purposes. You should leave <code>None</code>.</p> <code>None</code> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>@define(init=False)\nclass DPoPKey:\n    \"\"\"Wrapper around a DPoP proof signature key.\n\n    This handles DPoP proof generation. It also keeps track of a nonce, if provided\n    by the Resource Server.\n    Its behavior follows the standard DPoP specifications.\n    You may subclass or otherwise customize this class to implement custom behavior,\n    like adding or modifying claims to the proofs.\n\n    Args:\n        private_key: the private key to use for DPoP proof signatures.\n        alg: the alg to use for signatures, if not specified of the `private_key`.\n        jti_generator: a callable that generates unique JWT Token ID (jti) values to include in proofs.\n        iat_generator: a callable that generates the Issuer Date (iat) to include in proofs.\n        jwt_typ: the token type (`typ`) header to include in the generated proofs.\n        dpop_token_class: the class to use to represent DPoP tokens.\n        rs_nonce: an initial DPoP `nonce` to include in requests, for testing purposes. You should leave `None`.\n\n    \"\"\"\n\n    alg: str = field(on_setattr=setters.frozen)\n    private_key: jwskate.Jwk = field(on_setattr=setters.frozen, repr=False)\n    jti_generator: Callable[[], str] = field(on_setattr=setters.frozen, repr=False)\n    iat_generator: Callable[[], int] = field(on_setattr=setters.frozen, repr=False)\n    jwt_typ: str = field(on_setattr=setters.frozen, repr=False)\n    dpop_token_class: type[DPoPToken] = field(on_setattr=setters.frozen, repr=False)\n    as_nonce: str | None\n    rs_nonce: str | None\n\n    def __init__(\n        self,\n        private_key: Any,\n        alg: str | None = None,\n        jti_generator: Callable[[], str] = lambda: str(uuid4()),\n        iat_generator: Callable[[], int] = lambda: jwskate.Jwt.timestamp(),\n        jwt_typ: str = \"dpop+jwt\",\n        dpop_token_class: type[DPoPToken] = DPoPToken,\n        as_nonce: str | None = None,\n        rs_nonce: str | None = None,\n    ) -&gt; None:\n        try:\n            private_key = jwskate.to_jwk(private_key).check(is_private=True, is_symmetric=False)\n        except ValueError as exc:\n            raise InvalidDPoPKey(private_key) from exc\n\n        alg_name = jwskate.select_alg_class(private_key.SIGNATURE_ALGORITHMS, jwk_alg=private_key.alg, alg=alg).name\n\n        self.__attrs_init__(\n            alg=alg_name,\n            private_key=private_key,\n            jti_generator=jti_generator,\n            iat_generator=iat_generator,\n            jwt_typ=jwt_typ,\n            dpop_token_class=dpop_token_class,\n            as_nonce=as_nonce,\n            rs_nonce=rs_nonce,\n        )\n\n    @classmethod\n    def generate(\n        cls,\n        alg: str = jwskate.SignatureAlgs.ES256,\n        jwt_typ: str = \"dpop+jwt\",\n        jti_generator: Callable[[], str] = lambda: str(uuid4()),\n        iat_generator: Callable[[], int] = lambda: jwskate.Jwt.timestamp(),\n        dpop_token_class: type[DPoPToken] = DPoPToken,\n        as_nonce: str | None = None,\n        rs_nonce: str | None = None,\n    ) -&gt; Self:\n        \"\"\"Generate a new DPoPKey with a new private key that is suitable for the given `alg`.\"\"\"\n        if alg not in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n            raise InvalidDPoPAlg(alg)\n        key = jwskate.Jwk.generate(alg=alg)\n        return cls(\n            private_key=key,\n            jti_generator=jti_generator,\n            iat_generator=iat_generator,\n            jwt_typ=jwt_typ,\n            dpop_token_class=dpop_token_class,\n            as_nonce=as_nonce,\n            rs_nonce=rs_nonce,\n        )\n\n    @cached_property\n    def public_jwk(self) -&gt; jwskate.Jwk:\n        \"\"\"The public JWK key that matches the private key.\"\"\"\n        return self.private_key.public_jwk()\n\n    @cached_property\n    def dpop_jkt(self) -&gt; str:\n        \"\"\"The key thumbprint, used for Authorization Code DPoP binding.\"\"\"\n        return self.private_key.thumbprint()\n\n    def proof(self, htm: str, htu: str, ath: str | None = None, nonce: str | None = None) -&gt; jwskate.SignedJwt:\n        \"\"\"Generate a DPoP proof.\n\n        Proof will contain the following claims:\n\n            - The HTTP method (`htm`), target URI (`htu`), and Access Token hash (`ath`) that are passed as parameters.\n            - The `iat` claim will be generated by the configured `iat_generator`, which defaults to current datetime.\n            - The `jti` claim will be generated by the configured `jti_generator`, which defaults to a random UUID4.\n            - The `nonce` claim will be the value stored in the `nonce` attribute. This attribute is updated\n              automatically when using a `DPoPToken` or one of the provided Authentication handlers as a `requests`\n              auth handler.\n\n        The proof will be signed with the private key of this DPoPKey, using the configured `alg` signature algorithm.\n\n        Args:\n            htm: The HTTP method value of the request to which the proof is attached.\n            htu: The HTTP target URI of the request to which the proof is attached. Query and Fragment parts will\n                be automatically removed before being used as `htu` value in the generated proof.\n            ath: The Access Token hash value.\n            nonce: A recent nonce provided via the DPoP-Nonce HTTP header, from either the AS or RS.  If `None`, the\n                value stored in `rs_nonce` will be used instead.\n                In typical cases, you should never have to use this parameter. It is only used internally when\n                requesting the AS token endpoint.\n\n        Returns:\n            the proof value (as a signed JWT)\n\n        \"\"\"\n        htu = furl(htu).remove(query=True, fragment=True).url\n        proof_claims = {\"jti\": self.jti_generator(), \"htm\": htm, \"htu\": htu, \"iat\": self.iat_generator()}\n        if nonce:\n            proof_claims[\"nonce\"] = nonce\n        elif self.rs_nonce:\n            proof_claims[\"nonce\"] = self.rs_nonce\n        if ath:\n            proof_claims[\"ath\"] = ath\n        return jwskate.SignedJwt.sign(\n            proof_claims,\n            key=self.private_key,\n            alg=self.alg,\n            typ=self.jwt_typ,\n            extra_headers={\"jwk\": self.public_jwk},\n        )\n\n    def handle_as_provided_dpop_nonce(self, response: requests.Response) -&gt; None:\n        \"\"\"Handle an Authorization Server response containing a `use_dpop_nonce` error.\n\n        Args:\n            response: the response from the AS.\n\n        \"\"\"\n        nonce = response.headers.get(\"DPoP-Nonce\")\n        if not nonce:\n            raise MissingDPoPNonce(response)\n        if self.as_nonce == nonce:\n            raise RepeatedDPoPNonce(response)\n        self.as_nonce = nonce\n\n    def handle_rs_provided_dpop_nonce(self, response: requests.Response) -&gt; None:\n        \"\"\"Handle a Resource Server response containing a `use_dpop_nonce` error.\n\n        Args:\n            response: the response from the AS.\n\n        \"\"\"\n        nonce = response.headers.get(\"DPoP-Nonce\")\n        if not nonce:\n            raise MissingDPoPNonce(response)\n        if self.rs_nonce == nonce:\n            raise RepeatedDPoPNonce(response)\n        self.rs_nonce = nonce\n</code></pre>"},{"location":"api/#requests_oauth2client.dpop.DPoPKey.public_jwk","title":"<code>public_jwk</code>  <code>cached</code> <code>property</code>","text":"<p>The public JWK key that matches the private key.</p>"},{"location":"api/#requests_oauth2client.dpop.DPoPKey.dpop_jkt","title":"<code>dpop_jkt</code>  <code>cached</code> <code>property</code>","text":"<p>The key thumbprint, used for Authorization Code DPoP binding.</p>"},{"location":"api/#requests_oauth2client.dpop.DPoPKey.generate","title":"<code>generate(alg=jwskate.SignatureAlgs.ES256, jwt_typ='dpop+jwt', jti_generator=lambda: str(uuid4()), iat_generator=lambda: jwskate.Jwt.timestamp(), dpop_token_class=DPoPToken, as_nonce=None, rs_nonce=None)</code>  <code>classmethod</code>","text":"<p>Generate a new DPoPKey with a new private key that is suitable for the given <code>alg</code>.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>@classmethod\ndef generate(\n    cls,\n    alg: str = jwskate.SignatureAlgs.ES256,\n    jwt_typ: str = \"dpop+jwt\",\n    jti_generator: Callable[[], str] = lambda: str(uuid4()),\n    iat_generator: Callable[[], int] = lambda: jwskate.Jwt.timestamp(),\n    dpop_token_class: type[DPoPToken] = DPoPToken,\n    as_nonce: str | None = None,\n    rs_nonce: str | None = None,\n) -&gt; Self:\n    \"\"\"Generate a new DPoPKey with a new private key that is suitable for the given `alg`.\"\"\"\n    if alg not in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n        raise InvalidDPoPAlg(alg)\n    key = jwskate.Jwk.generate(alg=alg)\n    return cls(\n        private_key=key,\n        jti_generator=jti_generator,\n        iat_generator=iat_generator,\n        jwt_typ=jwt_typ,\n        dpop_token_class=dpop_token_class,\n        as_nonce=as_nonce,\n        rs_nonce=rs_nonce,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.dpop.DPoPKey.proof","title":"<code>proof(htm, htu, ath=None, nonce=None)</code>","text":"<p>Generate a DPoP proof.</p> <p>Proof will contain the following claims:</p> <pre><code>- The HTTP method (`htm`), target URI (`htu`), and Access Token hash (`ath`) that are passed as parameters.\n- The `iat` claim will be generated by the configured `iat_generator`, which defaults to current datetime.\n- The `jti` claim will be generated by the configured `jti_generator`, which defaults to a random UUID4.\n- The `nonce` claim will be the value stored in the `nonce` attribute. This attribute is updated\n  automatically when using a `DPoPToken` or one of the provided Authentication handlers as a `requests`\n  auth handler.\n</code></pre> <p>The proof will be signed with the private key of this DPoPKey, using the configured <code>alg</code> signature algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>htm</code> <code>str</code> <p>The HTTP method value of the request to which the proof is attached.</p> required <code>htu</code> <code>str</code> <p>The HTTP target URI of the request to which the proof is attached. Query and Fragment parts will be automatically removed before being used as <code>htu</code> value in the generated proof.</p> required <code>ath</code> <code>str | None</code> <p>The Access Token hash value.</p> <code>None</code> <code>nonce</code> <code>str | None</code> <p>A recent nonce provided via the DPoP-Nonce HTTP header, from either the AS or RS.  If <code>None</code>, the value stored in <code>rs_nonce</code> will be used instead. In typical cases, you should never have to use this parameter. It is only used internally when requesting the AS token endpoint.</p> <code>None</code> <p>Returns:</p> Type Description <code>SignedJwt</code> <p>the proof value (as a signed JWT)</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>def proof(self, htm: str, htu: str, ath: str | None = None, nonce: str | None = None) -&gt; jwskate.SignedJwt:\n    \"\"\"Generate a DPoP proof.\n\n    Proof will contain the following claims:\n\n        - The HTTP method (`htm`), target URI (`htu`), and Access Token hash (`ath`) that are passed as parameters.\n        - The `iat` claim will be generated by the configured `iat_generator`, which defaults to current datetime.\n        - The `jti` claim will be generated by the configured `jti_generator`, which defaults to a random UUID4.\n        - The `nonce` claim will be the value stored in the `nonce` attribute. This attribute is updated\n          automatically when using a `DPoPToken` or one of the provided Authentication handlers as a `requests`\n          auth handler.\n\n    The proof will be signed with the private key of this DPoPKey, using the configured `alg` signature algorithm.\n\n    Args:\n        htm: The HTTP method value of the request to which the proof is attached.\n        htu: The HTTP target URI of the request to which the proof is attached. Query and Fragment parts will\n            be automatically removed before being used as `htu` value in the generated proof.\n        ath: The Access Token hash value.\n        nonce: A recent nonce provided via the DPoP-Nonce HTTP header, from either the AS or RS.  If `None`, the\n            value stored in `rs_nonce` will be used instead.\n            In typical cases, you should never have to use this parameter. It is only used internally when\n            requesting the AS token endpoint.\n\n    Returns:\n        the proof value (as a signed JWT)\n\n    \"\"\"\n    htu = furl(htu).remove(query=True, fragment=True).url\n    proof_claims = {\"jti\": self.jti_generator(), \"htm\": htm, \"htu\": htu, \"iat\": self.iat_generator()}\n    if nonce:\n        proof_claims[\"nonce\"] = nonce\n    elif self.rs_nonce:\n        proof_claims[\"nonce\"] = self.rs_nonce\n    if ath:\n        proof_claims[\"ath\"] = ath\n    return jwskate.SignedJwt.sign(\n        proof_claims,\n        key=self.private_key,\n        alg=self.alg,\n        typ=self.jwt_typ,\n        extra_headers={\"jwk\": self.public_jwk},\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.dpop.DPoPKey.handle_as_provided_dpop_nonce","title":"<code>handle_as_provided_dpop_nonce(response)</code>","text":"<p>Handle an Authorization Server response containing a <code>use_dpop_nonce</code> error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response from the AS.</p> required Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>def handle_as_provided_dpop_nonce(self, response: requests.Response) -&gt; None:\n    \"\"\"Handle an Authorization Server response containing a `use_dpop_nonce` error.\n\n    Args:\n        response: the response from the AS.\n\n    \"\"\"\n    nonce = response.headers.get(\"DPoP-Nonce\")\n    if not nonce:\n        raise MissingDPoPNonce(response)\n    if self.as_nonce == nonce:\n        raise RepeatedDPoPNonce(response)\n    self.as_nonce = nonce\n</code></pre>"},{"location":"api/#requests_oauth2client.dpop.DPoPKey.handle_rs_provided_dpop_nonce","title":"<code>handle_rs_provided_dpop_nonce(response)</code>","text":"<p>Handle a Resource Server response containing a <code>use_dpop_nonce</code> error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response from the AS.</p> required Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>def handle_rs_provided_dpop_nonce(self, response: requests.Response) -&gt; None:\n    \"\"\"Handle a Resource Server response containing a `use_dpop_nonce` error.\n\n    Args:\n        response: the response from the AS.\n\n    \"\"\"\n    nonce = response.headers.get(\"DPoP-Nonce\")\n    if not nonce:\n        raise MissingDPoPNonce(response)\n    if self.rs_nonce == nonce:\n        raise RepeatedDPoPNonce(response)\n    self.rs_nonce = nonce\n</code></pre>"},{"location":"api/#requests_oauth2client.dpop.add_dpop_proof","title":"<code>add_dpop_proof(request, dpop_key, access_token, header_name='DPoP')</code>","text":"<p>Add a valid DPoP proof to a request, in-place.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>PreparedRequest</code> <p>the request to add the proof to.</p> required <code>dpop_key</code> <code>DPoPKey</code> <p>the DPoP key to use for the proof.</p> required <code>access_token</code> <code>str</code> <p>the access token to hash in the proof.</p> required <code>header_name</code> <code>str</code> <p>the name of the header to add the proof to.</p> <code>'DPoP'</code> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>def add_dpop_proof(\n    request: requests.PreparedRequest,\n    dpop_key: DPoPKey,\n    access_token: str,\n    header_name: str = \"DPoP\",\n) -&gt; None:\n    \"\"\"Add a valid DPoP proof to a request, in-place.\n\n    Args:\n        request: the request to add the proof to.\n        dpop_key: the DPoP key to use for the proof.\n        access_token: the access token to hash in the proof.\n        header_name: the name of the header to add the proof to.\n\n    \"\"\"\n    htu = request.url\n    htm = request.method\n    ath = BinaPy(access_token).to(\"sha256\").to(\"b64u\").decode()\n    if htu is None or htm is None:  # pragma: no cover\n        msg = \"Request has no 'method' or 'url'! This should not happen.\"\n        raise RuntimeError(msg)\n    proof = dpop_key.proof(htm=htm, htu=htu, ath=ath)\n    request.headers[header_name] = str(proof)\n</code></pre>"},{"location":"api/#requests_oauth2client.dpop.validate_dpop_proof","title":"<code>validate_dpop_proof(proof, *, htm, htu, ath=None, nonce=None, leeway=60, alg=None, algs=())</code>","text":"<p>Validate a DPoP proof.</p> <p>Parameters:</p> Name Type Description Default <code>proof</code> <code>str | bytes</code> <p>The serialized DPoP proof.</p> required <code>htm</code> <code>str</code> <p>The value of the HTTP method of the request to which the JWT is attached.</p> required <code>htu</code> <code>str</code> <p>The HTTP target URI of the request to which the JWT is attached, without query and fragment parts.</p> required <code>ath</code> <code>str | None</code> <p>The Hash of the access token.</p> <code>None</code> <code>nonce</code> <code>str | None</code> <p>A recent nonce provided via the DPoP-Nonce HTTP header, from either the AS or RS.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>A leeway, in number of seconds, to validate the proof <code>iat</code> claim.</p> <code>60</code> <code>alg</code> <code>str | None</code> <p>Allowed signature alg, if there is only one. Use this or <code>algs</code>.</p> <code>None</code> <code>algs</code> <code>Sequence[str]</code> <p>Allowed signature algs, if there is several. Use this or <code>alg</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>SignedJwt</code> <p>The validated DPoP proof, as a <code>SignedJwt</code>.</p> Source code in <code>requests_oauth2client/dpop.py</code> <pre><code>def validate_dpop_proof(  # noqa: C901\n    proof: str | bytes,\n    *,\n    htm: str,\n    htu: str,\n    ath: str | None = None,\n    nonce: str | None = None,\n    leeway: int = 60,\n    alg: str | None = None,\n    algs: Sequence[str] = (),\n) -&gt; jwskate.SignedJwt:\n    \"\"\"Validate a DPoP proof.\n\n    Args:\n        proof: The serialized DPoP proof.\n        htm: The value of the HTTP method of the request to which the JWT is attached.\n        htu: The HTTP target URI of the request to which the JWT is attached, without query and fragment parts.\n        ath: The Hash of the access token.\n        nonce: A recent nonce provided via the DPoP-Nonce HTTP header, from either the AS or RS.\n        leeway: A leeway, in number of seconds, to validate the proof `iat` claim.\n        alg: Allowed signature alg, if there is only one. Use this or `algs`.\n        algs: Allowed signature algs, if there is several. Use this or `alg`.\n\n    Returns:\n        The validated DPoP proof, as a `SignedJwt`.\n\n    \"\"\"\n    if not isinstance(proof, bytes):\n        proof = proof.encode()\n    try:\n        proof_jwt = jwskate.SignedJwt(proof)\n    except jwskate.InvalidJwt as exc:\n        raise InvalidDPoPProof(proof, \"not a syntactically valid JWT\") from exc\n    if proof_jwt.typ != \"dpop+jwt\":\n        raise InvalidDPoPProof(proof, f\"typ '{proof_jwt.typ}' is not the expected 'dpop+jwt'.\")\n    if \"jwk\" not in proof_jwt.headers:\n        raise InvalidDPoPProof(proof, \"'jwk' header is missing\")\n    try:\n        public_jwk = jwskate.Jwk(proof_jwt.headers[\"jwk\"])\n    except jwskate.InvalidJwk as exc:\n        raise InvalidDPoPProof(proof, \"'jwk' header is not a valid JWK key.\") from exc\n    if public_jwk.is_private or public_jwk.is_symmetric:\n        raise InvalidDPoPProof(proof, \"'jwk' header is a private or symmetric key.\")\n\n    if not proof_jwt.verify_signature(public_jwk, alg=alg, algs=algs):\n        raise InvalidDPoPProof(proof, \"signature does not verify.\")\n\n    if proof_jwt.issued_at is None:\n        raise InvalidDPoPProof(proof, \"a Issued At (iat) claim is missing.\")\n    now = datetime.now(tz=timezone.utc)\n    if not now - timedelta(seconds=leeway) &lt; proof_jwt.issued_at &lt; now + timedelta(seconds=leeway):\n        msg = f\"\"\"\\\nIssued At timestamp (iat) is too far away in the past or future (received: {proof_jwt.issued_at}, now: {now}).\"\"\"\n        raise InvalidDPoPProof(\n            proof,\n            msg,\n        )\n    if proof_jwt.jwt_token_id is None:\n        raise InvalidDPoPProof(proof, \"a Unique Identifier (jti) claim is missing.\")\n    if \"htm\" not in proof_jwt.claims:\n        raise InvalidDPoPProof(proof, \"the HTTP method (htm) claim is missing.\")\n    if proof_jwt.htm != htm:\n        raise InvalidDPoPProof(proof, f\"HTTP Method (htm) '{proof_jwt.htm}' does not matches expected '{htm}'.\")\n    if \"htu\" not in proof_jwt.claims:\n        raise InvalidDPoPProof(proof, \"the HTTP URI (htu) claim is missing.\")\n    if proof_jwt.htu != htu:\n        raise InvalidDPoPProof(proof, f\"HTTP URI (htu) '{proof_jwt.htu}' does not matches expected '{htu}'.\")\n    if ath:\n        if \"ath\" not in proof_jwt.claims:\n            raise InvalidDPoPProof(proof, \"the Access Token hash (ath) claim is missing.\")\n        if proof_jwt.ath != ath:\n            raise InvalidDPoPProof(\n                proof, f\"Access Token Hash (ath) value '{proof_jwt.ath}' does not match expected '{ath}'.\"\n            )\n    if nonce:\n        if \"nonce\" not in proof_jwt.claims:\n            raise InvalidDPoPProof(proof, \"the DPoP Nonce (nonce) claim is missing.\")\n        if proof_jwt.nonce != nonce:\n            raise InvalidDPoPProof(\n                proof, f\"DPoP Nonce (nonce) value '{proof_jwt.nonce}' does not match expected '{nonce}'.\"\n            )\n\n    return proof_jwt\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions","title":"<code>exceptions</code>","text":"<p>This module contains all exception classes from <code>requests_oauth2client</code>.</p>"},{"location":"api/#requests_oauth2client.exceptions.OAuth2Error","title":"<code>OAuth2Error</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for Exceptions raised when a backend endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the HTTP response containing the error</p> required <code>client</code> <p>the OAuth2Client used to send the request</p> required <code>description</code> <code>str | None</code> <p>description of the error</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class OAuth2Error(Exception):\n    \"\"\"Base class for Exceptions raised when a backend endpoint returns an error.\n\n    Args:\n        response: the HTTP response containing the error\n        client : the OAuth2Client used to send the request\n        description: description of the error\n\n    \"\"\"\n\n    def __init__(self, response: requests.Response, client: OAuth2Client, description: str | None = None) -&gt; None:\n        super().__init__(f\"The remote endpoint returned an error: {description or 'no description provided'}\")\n        self.response = response\n        self.client = client\n        self.description = description\n\n    @property\n    def request(self) -&gt; requests.PreparedRequest:\n        \"\"\"The request leading to the error.\"\"\"\n        return self.response.request\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.OAuth2Error.request","title":"<code>request</code>  <code>property</code>","text":"<p>The request leading to the error.</p>"},{"location":"api/#requests_oauth2client.exceptions.EndpointError","title":"<code>EndpointError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Base class for exceptions raised from backend endpoint errors.</p> <p>This contains the error message, description and uri that are returned by the AS in the OAuth 2.0 standardised way.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the raw response containing the error.</p> required <code>error</code> <code>str</code> <p>the <code>error</code> identifier as returned by the AS.</p> required <code>description</code> <code>str | None</code> <p>the <code>error_description</code> as returned by the AS.</p> <code>None</code> <code>uri</code> <code>str | None</code> <p>the <code>error_uri</code> as returned by the AS.</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class EndpointError(OAuth2Error):\n    \"\"\"Base class for exceptions raised from backend endpoint errors.\n\n    This contains the error message, description and uri that are returned\n    by the AS in the OAuth 2.0 standardised way.\n\n    Args:\n        response: the raw response containing the error.\n        error: the `error` identifier as returned by the AS.\n        description: the `error_description` as returned by the AS.\n        uri: the `error_uri` as returned by the AS.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        response: requests.Response,\n        client: OAuth2Client,\n        error: str,\n        description: str | None = None,\n        uri: str | None = None,\n    ) -&gt; None:\n        super().__init__(response=response, client=client, description=description)\n        self.error = error\n        self.uri = uri\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidTokenResponse","title":"<code>InvalidTokenResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Token Endpoint returns a non-standard response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidTokenResponse(OAuth2Error):\n    \"\"\"Raised when the Token Endpoint returns a non-standard response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnknownTokenEndpointError","title":"<code>UnknownTokenEndpointError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when the token endpoint returns an otherwise unknown error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnknownTokenEndpointError(EndpointError):\n    \"\"\"Raised when the token endpoint returns an otherwise unknown error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ServerError","title":"<code>ServerError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when the token endpoint returns <code>error = server_error</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ServerError(EndpointError):\n    \"\"\"Raised when the token endpoint returns `error = server_error`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.TokenEndpointError","title":"<code>TokenEndpointError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for errors that are specific to the token endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class TokenEndpointError(EndpointError):\n    \"\"\"Base class for errors that are specific to the token endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidRequest","title":"<code>InvalidRequest</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_request</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidRequest(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_request`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidClient","title":"<code>InvalidClient</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_client</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidClient(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_client`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidScope","title":"<code>InvalidScope</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_scope</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidScope(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_scope`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidTarget","title":"<code>InvalidTarget</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_target</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidTarget(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_target`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidGrant","title":"<code>InvalidGrant</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_grant</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidGrant(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_grant`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UseDPoPNonce","title":"<code>UseDPoPNonce</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint raises error = use_dpop_nonce`.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UseDPoPNonce(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint raises error = use_dpop_nonce`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AccessDenied","title":"<code>AccessDenied</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when the Authorization Server returns <code>error = access_denied</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AccessDenied(EndpointError):\n    \"\"\"Raised when the Authorization Server returns `error = access_denied`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnauthorizedClient","title":"<code>UnauthorizedClient</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when the Authorization Server returns <code>error = unauthorized_client</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnauthorizedClient(EndpointError):\n    \"\"\"Raised when the Authorization Server returns `error = unauthorized_client`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.RevocationError","title":"<code>RevocationError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for Revocation Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class RevocationError(EndpointError):\n    \"\"\"Base class for Revocation Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnsupportedTokenType","title":"<code>UnsupportedTokenType</code>","text":"<p>               Bases: <code>RevocationError</code></p> <p>Raised when the Revocation endpoint returns <code>error = unsupported_token_type</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnsupportedTokenType(RevocationError):\n    \"\"\"Raised when the Revocation endpoint returns `error = unsupported_token_type`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.IntrospectionError","title":"<code>IntrospectionError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for Introspection Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class IntrospectionError(EndpointError):\n    \"\"\"Base class for Introspection Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnknownIntrospectionError","title":"<code>UnknownIntrospectionError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Introspection Endpoint returns a non-standard error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnknownIntrospectionError(OAuth2Error):\n    \"\"\"Raised when the Introspection Endpoint returns a non-standard error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.DeviceAuthorizationError","title":"<code>DeviceAuthorizationError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for Device Authorization Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class DeviceAuthorizationError(EndpointError):\n    \"\"\"Base class for Device Authorization Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AuthorizationPending","title":"<code>AuthorizationPending</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = authorization_pending</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AuthorizationPending(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = authorization_pending`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.SlowDown","title":"<code>SlowDown</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = slow_down</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class SlowDown(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = slow_down`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ExpiredToken","title":"<code>ExpiredToken</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = expired_token</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ExpiredToken(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = expired_token`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidDeviceAuthorizationResponse","title":"<code>InvalidDeviceAuthorizationResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Device Authorization Endpoint returns a non-standard error response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidDeviceAuthorizationResponse(OAuth2Error):\n    \"\"\"Raised when the Device Authorization Endpoint returns a non-standard error response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AuthorizationResponseError","title":"<code>AuthorizationResponseError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for error responses returned by the Authorization endpoint.</p> <p>An <code>AuthorizationResponseError</code> contains the error message, description and uri that are returned by the AS.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>str</code> <p>the <code>error</code> identifier as returned by the AS</p> required <code>description</code> <code>str | None</code> <p>the <code>error_description</code> as returned by the AS</p> <code>None</code> <code>uri</code> <code>str | None</code> <p>the <code>error_uri</code> as returned by the AS</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AuthorizationResponseError(Exception):\n    \"\"\"Base class for error responses returned by the Authorization endpoint.\n\n    An `AuthorizationResponseError` contains the error message, description and uri that are\n    returned by the AS.\n\n    Args:\n        error: the `error` identifier as returned by the AS\n        description: the `error_description` as returned by the AS\n        uri: the `error_uri` as returned by the AS\n\n    \"\"\"\n\n    def __init__(\n        self,\n        request: AuthorizationRequest,\n        response: str,\n        error: str,\n        description: str | None = None,\n        uri: str | None = None,\n    ) -&gt; None:\n        self.error = error\n        self.description = description\n        self.uri = uri\n        self.request = request\n        self.response = response\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InteractionRequired","title":"<code>InteractionRequired</code>","text":"<p>               Bases: <code>AuthorizationResponseError</code></p> <p>Raised when the Authorization Endpoint returns <code>error = interaction_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InteractionRequired(AuthorizationResponseError):\n    \"\"\"Raised when the Authorization Endpoint returns `error = interaction_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.LoginRequired","title":"<code>LoginRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = login_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class LoginRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = login_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AccountSelectionRequired","title":"<code>AccountSelectionRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = account_selection_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AccountSelectionRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = account_selection_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.SessionSelectionRequired","title":"<code>SessionSelectionRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = session_selection_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class SessionSelectionRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = session_selection_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ConsentRequired","title":"<code>ConsentRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = consent_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ConsentRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = consent_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidAuthResponse","title":"<code>InvalidAuthResponse</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when the Authorization Endpoint returns an invalid response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidAuthResponse(ValueError):\n    \"\"\"Raised when the Authorization Endpoint returns an invalid response.\"\"\"\n\n    def __init__(self, message: str, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(f\"The Authorization Response is invalid: {message}\")\n        self.request = request\n        self.response = response\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MissingAuthCode","title":"<code>MissingAuthCode</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return the mandatory <code>code</code>.</p> <p>This happens when the Authorization Endpoint does not return an error, but does not return an authorization <code>code</code> either.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingAuthCode(InvalidAuthResponse):\n    \"\"\"Raised when the Authorization Endpoint does not return the mandatory `code`.\n\n    This happens when the Authorization Endpoint does not return an error, but does not return an\n    authorization `code` either.\n\n    \"\"\"\n\n    def __init__(self, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(\"missing `code` query parameter in response\", request, response)\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MissingIssuer","title":"<code>MissingIssuer</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return an <code>iss</code> parameter as expected.</p> <p>The Authorization Server advertises its support with a flag <code>authorization_response_iss_parameter_supported</code> in its discovery document. If it is set to <code>true</code>, it must include an <code>iss</code> parameter in its authorization responses, containing its issuer identifier.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingIssuer(InvalidAuthResponse):\n    \"\"\"Raised when the Authorization Endpoint does not return an `iss` parameter as expected.\n\n    The Authorization Server advertises its support with a flag\n    `authorization_response_iss_parameter_supported` in its discovery document. If it is set to\n    `true`, it must include an `iss` parameter in its authorization responses, containing its issuer\n    identifier.\n\n    \"\"\"\n\n    def __init__(self, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(\"missing `iss` query parameter in response\", request, response)\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingState","title":"<code>MismatchingState</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised on mismatching <code>state</code> value.</p> <p>This happens when the Authorization Endpoints returns a 'state' parameter that doesn't match the value passed in the Authorization Request.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingState(InvalidAuthResponse):\n    \"\"\"Raised on mismatching `state` value.\n\n    This happens when the Authorization Endpoints returns a 'state' parameter that doesn't match the value passed in the\n    Authorization Request.\n\n    \"\"\"\n\n    def __init__(self, received: str, expected: str, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(f\"mismatching `state` (received '{received}', expected '{expected}')\", request, response)\n        self.received = received\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingIssuer","title":"<code>MismatchingIssuer</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised on mismatching <code>iss</code> value.</p> <p>This happens when the Authorization Endpoints returns an 'iss' that doesn't match the expected value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingIssuer(InvalidAuthResponse):\n    \"\"\"Raised on mismatching `iss` value.\n\n    This happens when the Authorization Endpoints returns an 'iss' that doesn't match the expected value.\n\n    \"\"\"\n\n    def __init__(self, received: str, expected: str, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(f\"mismatching `iss` (received '{received}', expected '{expected}')\", request, response)\n        self.received = received\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.BackChannelAuthenticationError","title":"<code>BackChannelAuthenticationError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for errors returned by the BackChannel Authentication endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class BackChannelAuthenticationError(EndpointError):\n    \"\"\"Base class for errors returned by the BackChannel Authentication endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidBackChannelAuthenticationResponse","title":"<code>InvalidBackChannelAuthenticationResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the BackChannel Authentication endpoint returns a non-standard response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidBackChannelAuthenticationResponse(OAuth2Error):\n    \"\"\"Raised when the BackChannel Authentication endpoint returns a non-standard response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidPushedAuthorizationResponse","title":"<code>InvalidPushedAuthorizationResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Pushed Authorization Endpoint returns an error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidPushedAuthorizationResponse(OAuth2Error):\n    \"\"\"Raised when the Pushed Authorization Endpoint returns an error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.flask","title":"<code>flask</code>","text":"<p>This module contains helper classes for the Flask Framework.</p> <p>See Flask framework.</p>"},{"location":"api/#requests_oauth2client.flask.FlaskOAuth2ClientCredentialsAuth","title":"<code>FlaskOAuth2ClientCredentialsAuth</code>","text":"<p>               Bases: <code>FlaskSessionAuthMixin</code>, <code>OAuth2ClientCredentialsAuth</code></p> <p>A <code>requests</code> Auth handler for CC grant that stores its token in Flask session.</p> <p>It will automatically get Access Tokens from an OAuth 2.x AS with the Client Credentials grant (and can get a new one once the first one is expired), and stores the retrieved token, serialized in Flask <code>session</code>, so that each user has a different access token.</p> Source code in <code>requests_oauth2client/flask/auth.py</code> <pre><code>class FlaskOAuth2ClientCredentialsAuth(FlaskSessionAuthMixin, OAuth2ClientCredentialsAuth):  # type: ignore[misc]\n    \"\"\"A `requests` Auth handler for CC grant that stores its token in Flask session.\n\n    It will automatically get Access Tokens from an OAuth 2.x AS with the Client Credentials grant\n    (and can get a new one once the first one is expired), and stores the retrieved token,\n    serialized in Flask `session`, so that each user has a different access token.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.flask.auth","title":"<code>auth</code>","text":"<p>Helper classes for the Flask framework.</p>"},{"location":"api/#requests_oauth2client.flask.auth.FlaskSessionAuthMixin","title":"<code>FlaskSessionAuthMixin</code>","text":"<p>A Mixin for auth handlers to store their tokens in Flask session.</p> <p>Storing tokens in Flask session does ensure that each user of a Flask application has a different access token, and that tokens used for backend API access will be persisted between multiple requests to the front-end Flask app.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>the key that will be used to store the access token in session.</p> required <code>serializer</code> <code>BearerTokenSerializer | None</code> <p>the serializer that will be used to store the access token in session.</p> <code>None</code> Source code in <code>requests_oauth2client/flask/auth.py</code> <pre><code>class FlaskSessionAuthMixin:\n    \"\"\"A Mixin for auth handlers to store their tokens in Flask session.\n\n    Storing tokens in Flask session does ensure that each user of a Flask application has a\n    different access token, and that tokens used for backend API access will be persisted between\n    multiple requests to the front-end Flask app.\n\n    Args:\n        session_key: the key that will be used to store the access token in session.\n        serializer: the serializer that will be used to store the access token in session.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        session_key: str,\n        serializer: BearerTokenSerializer | None = None,\n        *args: Any,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        self.serializer = serializer or BearerTokenSerializer()\n        self.session_key = session_key\n        super().__init__(*args, **token_kwargs)\n\n    @property\n    def token(self) -&gt; BearerToken | None:\n        \"\"\"Return the Access Token stored in session.\n\n        Returns:\n            The current `BearerToken` for this session, if any.\n\n        \"\"\"\n        serialized_token = session.get(self.session_key)\n        if serialized_token is None:\n            return None\n        return self.serializer.loads(serialized_token)\n\n    @token.setter\n    def token(self, token: BearerToken | str | None) -&gt; None:\n        \"\"\"Store an Access Token in session.\n\n        Args:\n            token: the token to store\n\n        \"\"\"\n        if isinstance(token, str):\n            token = BearerToken(token)  # pragma: no cover\n        if token:\n            serialized_token = self.serializer.dumps(token)\n            session[self.session_key] = serialized_token\n        elif session and self.session_key in session:\n            session.pop(self.session_key, None)\n</code></pre>"},{"location":"api/#requests_oauth2client.flask.auth.FlaskSessionAuthMixin.token","title":"<code>token</code>  <code>property</code> <code>writable</code>","text":"<p>Return the Access Token stored in session.</p> <p>Returns:</p> Type Description <code>BearerToken | None</code> <p>The current <code>BearerToken</code> for this session, if any.</p>"},{"location":"api/#requests_oauth2client.flask.auth.FlaskOAuth2ClientCredentialsAuth","title":"<code>FlaskOAuth2ClientCredentialsAuth</code>","text":"<p>               Bases: <code>FlaskSessionAuthMixin</code>, <code>OAuth2ClientCredentialsAuth</code></p> <p>A <code>requests</code> Auth handler for CC grant that stores its token in Flask session.</p> <p>It will automatically get Access Tokens from an OAuth 2.x AS with the Client Credentials grant (and can get a new one once the first one is expired), and stores the retrieved token, serialized in Flask <code>session</code>, so that each user has a different access token.</p> Source code in <code>requests_oauth2client/flask/auth.py</code> <pre><code>class FlaskOAuth2ClientCredentialsAuth(FlaskSessionAuthMixin, OAuth2ClientCredentialsAuth):  # type: ignore[misc]\n    \"\"\"A `requests` Auth handler for CC grant that stores its token in Flask session.\n\n    It will automatically get Access Tokens from an OAuth 2.x AS with the Client Credentials grant\n    (and can get a new one once the first one is expired), and stores the retrieved token,\n    serialized in Flask `session`, so that each user has a different access token.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.pooling","title":"<code>pooling</code>","text":"<p>Contains base classes for pooling jobs.</p>"},{"location":"api/#requests_oauth2client.pooling.BaseTokenEndpointPoolingJob","title":"<code>BaseTokenEndpointPoolingJob</code>","text":"<p>Base class for Token Endpoint pooling jobs.</p> <p>This is used for decoupled flows like CIBA or Device Authorization.</p> <p>This class must be subclassed to implement actual BackChannel flows. This needs an OAuth2Client that will be used to pool the token endpoint. The initial pooling <code>interval</code> is configurable.</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>@define\nclass BaseTokenEndpointPoolingJob:\n    \"\"\"Base class for Token Endpoint pooling jobs.\n\n    This is used for decoupled flows like CIBA or Device Authorization.\n\n    This class must be subclassed to implement actual BackChannel flows. This needs an\n    [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token\n    endpoint. The initial pooling `interval` is configurable.\n\n    \"\"\"\n\n    client: OAuth2Client = field(on_setattr=setters.frozen)\n    requests_kwargs: dict[str, Any] = field(on_setattr=setters.frozen)\n    token_kwargs: dict[str, Any] = field(on_setattr=setters.frozen)\n    slow_down_interval: int = field(on_setattr=setters.frozen)\n    interval: int\n\n    def __call__(self) -&gt; BearerToken | None:\n        \"\"\"Wrap the actual Token Endpoint call with a pooling interval.\n\n        Everytime this method is called, it will wait for the entire duration of the pooling\n        interval before calling\n        [token_request()][requests_oauth2client.pooling.TokenEndpointPoolingJob.token_request]. So\n        you can call it immediately after initiating the BackChannel flow, and it will wait before\n        initiating the first call.\n\n        This implements the logic to handle\n        [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] or\n        [SlowDown][requests_oauth2client.exceptions.SlowDown] requests by the AS.\n\n        Returns:\n            a `BearerToken` if the AS returns one, or `None` if the Authorization is still pending.\n\n        \"\"\"\n        self.sleep()\n        try:\n            return self.token_request()\n        except SlowDown:\n            self.slow_down()\n        except AuthorizationPending:\n            self.authorization_pending()\n        return None\n\n    def sleep(self) -&gt; None:\n        \"\"\"Implement the wait between two requests of the token endpoint.\n\n        By default, relies on time.sleep().\n\n        \"\"\"\n        time.sleep(self.interval)\n\n    def slow_down(self) -&gt; None:\n        \"\"\"Implement the behavior when receiving a 'slow_down' response from the AS.\n\n        By default, it increases the pooling interval by the slow down interval.\n\n        \"\"\"\n        self.interval += self.slow_down_interval\n\n    def authorization_pending(self) -&gt; None:\n        \"\"\"Implement the behavior when receiving an 'authorization_pending' response from the AS.\n\n        By default, it does nothing.\n\n        \"\"\"\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Abstract method for the token endpoint call.\n\n        Subclasses must implement this. This method must raise\n        [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after\n        the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase\n        the pooling interval by `slow_down_interval` seconds.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.pooling.BaseTokenEndpointPoolingJob.sleep","title":"<code>sleep()</code>","text":"<p>Implement the wait between two requests of the token endpoint.</p> <p>By default, relies on time.sleep().</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def sleep(self) -&gt; None:\n    \"\"\"Implement the wait between two requests of the token endpoint.\n\n    By default, relies on time.sleep().\n\n    \"\"\"\n    time.sleep(self.interval)\n</code></pre>"},{"location":"api/#requests_oauth2client.pooling.BaseTokenEndpointPoolingJob.slow_down","title":"<code>slow_down()</code>","text":"<p>Implement the behavior when receiving a 'slow_down' response from the AS.</p> <p>By default, it increases the pooling interval by the slow down interval.</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def slow_down(self) -&gt; None:\n    \"\"\"Implement the behavior when receiving a 'slow_down' response from the AS.\n\n    By default, it increases the pooling interval by the slow down interval.\n\n    \"\"\"\n    self.interval += self.slow_down_interval\n</code></pre>"},{"location":"api/#requests_oauth2client.pooling.BaseTokenEndpointPoolingJob.authorization_pending","title":"<code>authorization_pending()</code>","text":"<p>Implement the behavior when receiving an 'authorization_pending' response from the AS.</p> <p>By default, it does nothing.</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def authorization_pending(self) -&gt; None:\n    \"\"\"Implement the behavior when receiving an 'authorization_pending' response from the AS.\n\n    By default, it does nothing.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.pooling.BaseTokenEndpointPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Abstract method for the token endpoint call.</p> <p>Subclasses must implement this. This method must raise AuthorizationPending to retry after the pooling interval, or SlowDown to increase the pooling interval by <code>slow_down_interval</code> seconds.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Abstract method for the token endpoint call.\n\n    Subclasses must implement this. This method must raise\n    [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after\n    the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase\n    the pooling interval by `slow_down_interval` seconds.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens","title":"<code>tokens</code>","text":"<p>This module contains classes that represent Tokens used in OAuth2.0 / OIDC.</p>"},{"location":"api/#requests_oauth2client.tokens.TokenType","title":"<code>TokenType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum of standardised <code>token_type</code> values.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class TokenType(str, Enum):\n    \"\"\"An enum of standardised `token_type` values.\"\"\"\n\n    ACCESS_TOKEN = \"access_token\"\n    REFRESH_TOKEN = \"refresh_token\"\n    ID_TOKEN = \"id_token\"\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.AccessTokenTypes","title":"<code>AccessTokenTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum of standardised <code>access_token</code> types.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class AccessTokenTypes(str, Enum):\n    \"\"\"An enum of standardised `access_token` types.\"\"\"\n\n    BEARER = \"Bearer\"\n    DPOP = \"DPoP\"\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.UnsupportedTokenType","title":"<code>UnsupportedTokenType</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an unsupported token_type is provided.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class UnsupportedTokenType(ValueError):\n    \"\"\"Raised when an unsupported token_type is provided.\"\"\"\n\n    def __init__(self, token_type: str) -&gt; None:\n        super().__init__(f\"Unsupported token_type: {token_type}\")\n        self.token_type = token_type\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.IdToken","title":"<code>IdToken</code>","text":"<p>               Bases: <code>SignedJwt</code></p> <p>Represent an ID Token.</p> <p>An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be decoded beforehand.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class IdToken(jwskate.SignedJwt):\n    \"\"\"Represent an ID Token.\n\n    An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be decoded beforehand.\n\n    \"\"\"\n\n    @property\n    def authorized_party(self) -&gt; str | None:\n        \"\"\"The Authorized Party (azp).\"\"\"\n        azp = self.claims.get(\"azp\")\n        if azp is None or isinstance(azp, str):\n            return azp\n        msg = \"`azp` attribute must be a string.\"\n        raise AttributeError(msg)\n\n    @property\n    def auth_datetime(self) -&gt; datetime | None:\n        \"\"\"The last user authentication time (auth_time).\"\"\"\n        auth_time = self.claims.get(\"auth_time\")\n        if auth_time is None:\n            return None\n        if isinstance(auth_time, int) and auth_time &gt; 0:\n            return self.timestamp_to_datetime(auth_time)\n        msg = \"`auth_time` must be a positive integer\"\n        raise AttributeError(msg)\n\n    @classmethod\n    def hash_method(cls, key: jwskate.Jwk, alg: str | None = None) -&gt; Callable[[str], str]:\n        \"\"\"Returns a callable that generates valid OIDC hashes, such as `at_hash`, `c_hash`, etc.\n\n        Args:\n            key: the ID token signature verification public key\n            alg: the ID token signature algorithm\n\n        Returns:\n            a callable that takes a string as input and produces a valid hash as a str output\n\n        \"\"\"\n        alg_class = jwskate.select_alg_class(key.SIGNATURE_ALGORITHMS, jwk_alg=key.alg, alg=alg)\n        if alg_class == jwskate.EdDsa:\n            if key.crv == \"Ed25519\":\n\n                def hash_method(token: str) -&gt; str:\n                    return BinaPy(token).to(\"sha512\")[:32].to(\"b64u\").decode()\n\n            elif key.crv == \"Ed448\":\n\n                def hash_method(token: str) -&gt; str:\n                    return BinaPy(token).to(\"shake256\", 456).to(\"b64u\").decode()\n\n        else:\n            hash_alg = alg_class.hashing_alg.name\n            hash_size = alg_class.hashing_alg.digest_size\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(hash_alg)[: hash_size // 2].to(\"b64u\").decode()\n\n        return hash_method\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.IdToken.authorized_party","title":"<code>authorized_party</code>  <code>property</code>","text":"<p>The Authorized Party (azp).</p>"},{"location":"api/#requests_oauth2client.tokens.IdToken.auth_datetime","title":"<code>auth_datetime</code>  <code>property</code>","text":"<p>The last user authentication time (auth_time).</p>"},{"location":"api/#requests_oauth2client.tokens.IdToken.hash_method","title":"<code>hash_method(key, alg=None)</code>  <code>classmethod</code>","text":"<p>Returns a callable that generates valid OIDC hashes, such as <code>at_hash</code>, <code>c_hash</code>, etc.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Jwk</code> <p>the ID token signature verification public key</p> required <code>alg</code> <code>str | None</code> <p>the ID token signature algorithm</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[str], str]</code> <p>a callable that takes a string as input and produces a valid hash as a str output</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@classmethod\ndef hash_method(cls, key: jwskate.Jwk, alg: str | None = None) -&gt; Callable[[str], str]:\n    \"\"\"Returns a callable that generates valid OIDC hashes, such as `at_hash`, `c_hash`, etc.\n\n    Args:\n        key: the ID token signature verification public key\n        alg: the ID token signature algorithm\n\n    Returns:\n        a callable that takes a string as input and produces a valid hash as a str output\n\n    \"\"\"\n    alg_class = jwskate.select_alg_class(key.SIGNATURE_ALGORITHMS, jwk_alg=key.alg, alg=alg)\n    if alg_class == jwskate.EdDsa:\n        if key.crv == \"Ed25519\":\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(\"sha512\")[:32].to(\"b64u\").decode()\n\n        elif key.crv == \"Ed448\":\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(\"shake256\", 456).to(\"b64u\").decode()\n\n    else:\n        hash_alg = alg_class.hashing_alg.name\n        hash_size = alg_class.hashing_alg.digest_size\n\n        def hash_method(token: str) -&gt; str:\n            return BinaPy(token).to(hash_alg)[: hash_size // 2].to(\"b64u\").decode()\n\n    return hash_method\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.InvalidIdToken","title":"<code>InvalidIdToken</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when trying to validate an invalid ID Token value.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class InvalidIdToken(ValueError):\n    \"\"\"Raised when trying to validate an invalid ID Token value.\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        id_token: IdToken | jwskate.JweCompact | object | None = None,\n        token_resp: TokenResponse | None = None,\n    ) -&gt; None:\n        super().__init__(f\"Invalid ID Token: {message}\")\n        self.id_token = id_token\n        self.token_resp = token_resp\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.MissingIdToken","title":"<code>MissingIdToken</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the Authorization Endpoint does not return a mandatory ID Token.</p> <p>This happens when the Authorization Endpoint does not return an error, but does not return an ID Token either.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MissingIdToken(InvalidIdToken):\n    \"\"\"Raised when the Authorization Endpoint does not return a mandatory ID Token.\n\n    This happens when the Authorization Endpoint does not return an error, but does not return an ID Token either.\n\n    \"\"\"\n\n    def __init__(self, token: TokenResponse) -&gt; None:\n        super().__init__(\"An expected `id_token` is missing in the response.\", token, None)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.MismatchingIdTokenIssuer","title":"<code>MismatchingIdTokenIssuer</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised on mismatching <code>iss</code> value in an ID Token.</p> <p>This happens when the expected <code>issuer</code> value is different from the <code>iss</code> value in an obtained ID Token.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenIssuer(InvalidIdToken):\n    \"\"\"Raised on mismatching `iss` value in an ID Token.\n\n    This happens when the expected `issuer` value is different from the `iss` value in an obtained ID Token.\n\n    \"\"\"\n\n    def __init__(self, iss: str | None, expected: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"`iss` from token '{iss}' does not match expected value '{expected}'\", id_token, token)\n        self.received = iss\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.MismatchingIdTokenNonce","title":"<code>MismatchingIdTokenNonce</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised on mismatching <code>nonce</code> value in an ID Token.</p> <p>This happens when the authorization request includes a <code>nonce</code> but the returned ID Token include a different value.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenNonce(InvalidIdToken):\n    \"\"\"Raised on mismatching `nonce` value in an ID Token.\n\n    This happens when the authorization request includes a `nonce` but the returned ID Token include\n    a different value.\n\n    \"\"\"\n\n    def __init__(self, nonce: str, expected: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"nonce from token '{nonce}' does not match expected value '{expected}'\", id_token, token)\n        self.received = nonce\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.MismatchingIdTokenAcr","title":"<code>MismatchingIdTokenAcr</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token doesn't contain one of the requested ACR Values.</p> <p>This happens when the authorization request includes an <code>acr_values</code> parameter but the returned ID Token includes a different value.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAcr(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token doesn't contain one of the requested ACR Values.\n\n    This happens when the authorization request includes an `acr_values` parameter but the returned\n    ID Token includes a different value.\n\n    \"\"\"\n\n    def __init__(self, acr: str, expected: Sequence[str], token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"token contains acr '{acr}' while client expects one of '{expected}'\", id_token, token)\n        self.received = acr\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.MismatchingIdTokenAudience","title":"<code>MismatchingIdTokenAudience</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the ID Token audience does not include the requesting Client ID.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAudience(InvalidIdToken):\n    \"\"\"Raised when the ID Token audience does not include the requesting Client ID.\"\"\"\n\n    def __init__(self, audiences: Sequence[str], client_id: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(\n            f\"token audience (`aud`) '{audiences}' does not match client_id '{client_id}'\",\n            id_token,\n            token,\n        )\n        self.received = audiences\n        self.expected = client_id\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.MismatchingIdTokenAzp","title":"<code>MismatchingIdTokenAzp</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the ID Token Authorized Presenter (azp) claim is not the Client ID.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAzp(InvalidIdToken):\n    \"\"\"Raised when the ID Token Authorized Presenter (azp) claim is not the Client ID.\"\"\"\n\n    def __init__(self, azp: str, client_id: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(\n            f\"token Authorized Presenter (`azp`) claim '{azp}' does not match client_id '{client_id}'\", id_token, token\n        )\n        self.received = azp\n        self.expected = client_id\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.MismatchingIdTokenAlg","title":"<code>MismatchingIdTokenAlg</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token is signed with an unexpected alg.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAlg(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token is signed with an unexpected alg.\"\"\"\n\n    def __init__(self, token_alg: str, client_alg: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"token is signed with alg {token_alg}, client expects {client_alg}\", id_token, token)\n        self.received = token_alg\n        self.expected = client_alg\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.ExpiredIdToken","title":"<code>ExpiredIdToken</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token is expired.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class ExpiredIdToken(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token is expired.\"\"\"\n\n    def __init__(self, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(\"token is expired\", id_token, token)\n        self.received = id_token.expires_at\n        self.expected = datetime.now(tz=timezone.utc)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.UnsupportedIdTokenAlg","title":"<code>UnsupportedIdTokenAlg</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the return ID Token is signed with an unsupported alg.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class UnsupportedIdTokenAlg(InvalidIdToken):\n    \"\"\"Raised when the return ID Token is signed with an unsupported alg.\"\"\"\n\n    def __init__(self, token: TokenResponse, id_token: IdToken, alg: str) -&gt; None:\n        super().__init__(f\"token is signed with an unsupported alg {alg}\", id_token, token)\n        self.alg = alg\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.TokenResponse","title":"<code>TokenResponse</code>","text":"<p>Base class for Token Endpoint Responses.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class TokenResponse:\n    \"\"\"Base class for Token Endpoint Responses.\"\"\"\n\n    TOKEN_TYPE: ClassVar[str]\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.ExpiredAccessToken","title":"<code>ExpiredAccessToken</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Raised when an expired access token is used.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class ExpiredAccessToken(RuntimeError):\n    \"\"\"Raised when an expired access token is used.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken","title":"<code>BearerToken</code>","text":"<p>               Bases: <code>TokenResponse</code>, <code>AuthBase</code></p> <p>Represents a Bearer Token as returned by a Token Endpoint.</p> <p>This is a wrapper around a Bearer Token and associated parameters, such as expiration date and refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint.</p> <p>All parameters are as returned by a Token Endpoint. The token expiration date can be passed as datetime in the <code>expires_at</code> parameter, or an <code>expires_in</code> parameter, as number of seconds in the future, can be passed instead.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>str</code> <p>an <code>access_token</code>, as returned by the AS.</p> required <code>expires_at</code> <code>datetime | None</code> <p>an expiration date. This method also accepts an <code>expires_in</code> hint as returned by the AS, if any.</p> <code>None</code> <code>scope</code> <code>str | None</code> <p>a <code>scope</code>, as returned by the AS, if any.</p> <code>None</code> <code>refresh_token</code> <code>str | None</code> <p>a <code>refresh_token</code>, as returned by the AS, if any.</p> <code>None</code> <code>token_type</code> <code>str</code> <p>a <code>token_type</code>, as returned by the AS.</p> <code>TOKEN_TYPE</code> <code>id_token</code> <code>str | bytes | IdToken | JweCompact | None</code> <p>an <code>id_token</code>, as returned by the AS, if any.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters as returned by the AS, if any.</p> <code>{}</code> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@frozen(init=False)\nclass BearerToken(TokenResponse, requests.auth.AuthBase):\n    \"\"\"Represents a Bearer Token as returned by a Token Endpoint.\n\n    This is a wrapper around a Bearer Token and associated parameters, such as expiration date and\n    refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint.\n\n    All parameters are as returned by a Token Endpoint. The token expiration date can be passed as\n    datetime in the `expires_at` parameter, or an `expires_in` parameter, as number of seconds in\n    the future, can be passed instead.\n\n    Args:\n        access_token: an `access_token`, as returned by the AS.\n        expires_at: an expiration date. This method also accepts an `expires_in` hint as\n            returned by the AS, if any.\n        scope: a `scope`, as returned by the AS, if any.\n        refresh_token: a `refresh_token`, as returned by the AS, if any.\n        token_type: a `token_type`, as returned by the AS.\n        id_token: an `id_token`, as returned by the AS, if any.\n        **kwargs: additional parameters as returned by the AS, if any.\n\n    \"\"\"\n\n    TOKEN_TYPE: ClassVar[str] = AccessTokenTypes.BEARER.value\n    AUTHORIZATION_HEADER: ClassVar[str] = \"Authorization\"\n    AUTHORIZATION_SCHEME: ClassVar[str] = AccessTokenTypes.BEARER.value\n\n    access_token: str\n    expires_at: datetime | None\n    scope: str | None\n    refresh_token: str | None\n    token_type: str\n    id_token: IdToken | jwskate.JweCompact | None\n    kwargs: dict[str, Any]\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        access_token: str,\n        *,\n        expires_at: datetime | None = None,\n        scope: str | None = None,\n        refresh_token: str | None = None,\n        token_type: str = TOKEN_TYPE,\n        id_token: str | bytes | IdToken | jwskate.JweCompact | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        if token_type.title() != self.TOKEN_TYPE.title():\n            raise UnsupportedTokenType(token_type)\n\n        id_token = id_token_converter(id_token)\n\n        self.__attrs_init__(\n            access_token=access_token,\n            expires_at=expires_at,\n            scope=scope,\n            refresh_token=refresh_token,\n            token_type=token_type,\n            id_token=id_token,\n            kwargs=kwargs,\n        )\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Check if the access token is expired.\n\n        Args:\n            leeway: If the token expires in the next given number of seconds,\n                then consider it expired already.\n\n        Returns:\n            One of:\n\n            - `True` if the access token is expired\n            - `False` if it is still valid\n            - `None` if there is no expires_in hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) + timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n\n    def authorization_header(self) -&gt; str:\n        \"\"\"Return the appropriate Authorization Header value for this token.\n\n        The value is formatted correctly according to RFC6750.\n\n        Returns:\n            the value to use in an HTTP Authorization Header\n\n        \"\"\"\n        return f\"{self.AUTHORIZATION_SCHEME} {self.access_token}\"\n\n    def validate_id_token(  # noqa: PLR0915, C901\n        self, client: OAuth2Client, azr: AuthorizationResponse, exp_leeway: int = 0, auth_time_leeway: int = 10\n    ) -&gt; Self:\n        \"\"\"Validate the ID Token, and return a new instance with the decrypted ID Token.\n\n        If the ID Token was not encrypted, the returned instance will contain the same ID Token.\n\n        This will validate the id_token as described in [OIDC 1.0\n        $3.1.3.7](https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation).\n\n        Args:\n            client: the `OAuth2Client` that was used to obtain this token\n            azr: the `AuthorizationResponse`, as obtained by a call to `AuthorizationRequest.validate()`\n            exp_leeway: a leeway, in seconds, applied to the ID Token expiration date\n            auth_time_leeway: a leeway, in seconds, applied to the `auth_time` validation\n\n        Raises:\n            MissingIdToken: if the ID Token is missing\n            InvalidIdToken: this is a base exception class, which is raised:\n\n                - if the ID Token is not a JWT\n                - or is encrypted while a clear-text token is expected\n                - or is clear-text while an encrypted token is expected\n                - if token is encrypted but client does not have a decryption key\n                - if the token does not contain an `alg` header\n            MismatchingIdTokenAlg: if the `alg` header from the ID Token does not match\n                the expected `client.id_token_signed_response_alg`.\n            MismatchingIdTokenIssuer: if the `iss` claim from the ID Token does not match\n                the expected `azr.issuer`.\n            MismatchingIdTokenAcr: if the `acr` claim from the ID Token does not match\n                on of the expected `azr.acr_values`.\n            MismatchingIdTokenAudience: if the `aud` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenAzp: if the `azp` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenNonce: if the `nonce` claim from the ID Token does not match\n                the expected `azr.nonce`.\n            ExpiredIdToken: if the ID Token is expired at the time of the check.\n            UnsupportedIdTokenAlg: if the signature alg for the ID Token is not supported.\n\n        \"\"\"\n        if not self.id_token:\n            raise MissingIdToken(self)\n\n        raw_id_token = self.id_token\n\n        if isinstance(raw_id_token, jwskate.JweCompact) and client.id_token_encrypted_response_alg is None:\n            msg = \"token is encrypted while it should be clear-text\"\n            raise InvalidIdToken(msg, raw_id_token, self)\n        if isinstance(raw_id_token, IdToken) and client.id_token_encrypted_response_alg is not None:\n            msg = \"token is clear-text while it should be encrypted\"\n            raise InvalidIdToken(msg, raw_id_token, self)\n\n        if isinstance(raw_id_token, jwskate.JweCompact):\n            enc_jwk = client.id_token_decryption_key\n            if enc_jwk is None:\n                msg = \"token is encrypted but client does not have a decryption key\"\n                raise InvalidIdToken(msg, raw_id_token, self)\n            nested_id_token = raw_id_token.decrypt(enc_jwk)\n            id_token = IdToken(nested_id_token)\n        else:\n            id_token = raw_id_token\n\n        id_token_alg = id_token.get_header(\"alg\")\n        if id_token_alg is None:\n            id_token_alg = client.id_token_signed_response_alg\n        if id_token_alg is None:\n            msg = \"\"\"\ntoken does not contain an `alg` parameter to specify the signature algorithm,\nand no algorithm has been configured for the client (using param `id_token_signed_response_alg`).\n\"\"\"\n            raise InvalidIdToken(msg, id_token, self)\n        if client.id_token_signed_response_alg is not None and id_token_alg != client.id_token_signed_response_alg:\n            raise MismatchingIdTokenAlg(id_token.alg, client.id_token_signed_response_alg, self, id_token)\n\n        verification_jwk: jwskate.Jwk\n\n        if id_token_alg in jwskate.SignatureAlgs.ALL_SYMMETRIC:\n            if not client.client_secret:\n                msg = \"token is symmetrically signed but this client does not have a Client Secret.\"\n                raise InvalidIdToken(msg, id_token, self)\n            verification_jwk = jwskate.SymmetricJwk.from_bytes(client.client_secret, alg=id_token_alg)\n            id_token.verify_signature(verification_jwk, alg=id_token_alg)\n        elif id_token_alg in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n            if not client.authorization_server_jwks:\n                msg = \"token is asymmetrically signed but the Authorization Server JWKS is not available.\"\n                raise InvalidIdToken(msg, id_token, self)\n\n            if id_token.get_header(\"kid\") is None:\n                msg = \"\"\"\ntoken does not contain a Key ID (kid) to specify the asymmetric key\nto use for signature verification.\"\"\"\n                raise InvalidIdToken(msg, id_token, self)\n            try:\n                verification_jwk = client.authorization_server_jwks.get_jwk_by_kid(id_token.kid)\n            except KeyError:\n                msg = f\"\"\"\\\ntoken is asymmetrically signed but there is no key\nwith kid='{id_token.kid}' in the Authorization Server JWKS.\"\"\"\n                raise InvalidIdToken(msg, id_token, self) from None\n\n            if id_token_alg not in verification_jwk.supported_signing_algorithms():\n                msg = \"token is asymmetrically signed but its algorithm is not supported by the verification key.\"\n                raise InvalidIdToken(msg, id_token, self)\n        else:\n            raise UnsupportedIdTokenAlg(self, id_token, id_token_alg)\n\n        id_token.verify(verification_jwk, alg=id_token_alg)\n\n        if azr.issuer and id_token.issuer != azr.issuer:\n            raise MismatchingIdTokenIssuer(id_token.issuer, azr.issuer, self, id_token)\n\n        if id_token.audiences and client.client_id not in id_token.audiences:\n            raise MismatchingIdTokenAudience(id_token.audiences, client.client_id, self, id_token)\n\n        if id_token.authorized_party is not None and id_token.authorized_party != client.client_id:\n            raise MismatchingIdTokenAzp(id_token.azp, client.client_id, self, id_token)\n\n        if id_token.is_expired(leeway=exp_leeway):\n            raise ExpiredIdToken(self, id_token)\n\n        if azr.nonce and id_token.nonce != azr.nonce:\n            raise MismatchingIdTokenNonce(id_token.nonce, azr.nonce, self, id_token)\n\n        if azr.acr_values and id_token.acr not in azr.acr_values:\n            raise MismatchingIdTokenAcr(id_token.acr, azr.acr_values, self, id_token)\n\n        hash_function = IdToken.hash_method(verification_jwk, id_token_alg)\n\n        at_hash = id_token.get_claim(\"at_hash\")\n        if at_hash is not None:\n            expected_at_hash = hash_function(self.access_token)\n            if expected_at_hash != at_hash:\n                msg = f\"mismatching 'at_hash' value (expected '{expected_at_hash}', got '{at_hash}')\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        c_hash = id_token.get_claim(\"c_hash\")\n        if c_hash is not None:\n            expected_c_hash = hash_function(azr.code)\n            if expected_c_hash != c_hash:\n                msg = f\"mismatching 'c_hash' value (expected '{expected_c_hash}', got '{c_hash}')\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        s_hash = id_token.get_claim(\"s_hash\")\n        if s_hash is not None:\n            if azr.state is None:\n                msg = \"token has a 's_hash' claim but no state was included in the request.\"\n                raise InvalidIdToken(msg, id_token, self)\n            expected_s_hash = hash_function(azr.state)\n            if expected_s_hash != s_hash:\n                msg = f\"mismatching 's_hash' value (expected '{expected_s_hash}', got '{s_hash}')\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        if azr.max_age is not None:\n            auth_time = id_token.auth_datetime\n            if auth_time is None:\n                msg = \"\"\"\na `max_age` parameter was included in the authorization request,\nbut the ID Token does not contain an `auth_time` claim.\n\"\"\"\n                raise InvalidIdToken(msg, id_token, self) from None\n            auth_age = datetime.now(tz=timezone.utc) - auth_time\n            if auth_age.total_seconds() &gt; azr.max_age + auth_time_leeway:\n                msg = f\"\"\"\nuser authentication happened too far in the past.\nThe `auth_time` parameter from the ID Token indicate that\nthe last Authentication Time was at {auth_time} ({auth_age.total_seconds()} sec ago),\nbut the authorization request `max_age` parameter specified that it must\nbe a maximum of {azr.max_age} sec ago.\n\"\"\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        return self.__class__(\n            access_token=self.access_token,\n            expires_at=self.expires_at,\n            scope=self.scope,\n            refresh_token=self.refresh_token,\n            token_type=self.token_type,\n            id_token=id_token,\n            **self.kwargs,\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the access token value, as a string.\n\n        Returns:\n            the access token string\n\n        \"\"\"\n        return self.access_token\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dict of parameters.\n\n        That is suitable for serialization or to init another BearerToken.\n\n        \"\"\"\n        d = asdict(self)\n        d.pop(\"expires_at\")\n        d[\"expires_in\"] = self.expires_in\n        d.update(**d.pop(\"kwargs\", {}))\n        return {key: val for key, val in d.items() if val is not None}\n\n    @property\n    def expires_in(self) -&gt; int | None:\n        \"\"\"Number of seconds until expiration.\"\"\"\n        if self.expires_at:\n            return ceil((self.expires_at - datetime.now(tz=timezone.utc)).total_seconds())\n        return None\n\n    def __getattr__(self, key: str) -&gt; Any:\n        \"\"\"Return custom attributes from this BearerToken.\n\n        Args:\n            key: a key\n\n        Returns:\n            the associated value in this token response\n\n        Raises:\n            AttributeError: if the attribute is not found in this response.\n\n        \"\"\"\n        return self.kwargs.get(key) or super().__getattribute__(key)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the usage of Bearer Tokens in requests.\n\n        This will add a properly formatted `Authorization: Bearer &lt;token&gt;` header in the request.\n\n        If the configured token is an instance of BearerToken with an expires_at attribute, raises\n        [ExpiredAccessToken][requests_oauth2client.exceptions.ExpiredAccessToken] once the access\n        token is expired.\n\n        Args:\n            request: the request\n\n        Returns:\n            the same request with an Access Token added in `Authorization` Header\n\n        Raises:\n            ExpiredAccessToken: if the token is expired\n\n        \"\"\"\n        if self.access_token is None:\n            return request  # pragma: no cover\n        if self.is_expired():\n            raise ExpiredAccessToken(self)\n        request.headers[self.AUTHORIZATION_HEADER] = self.authorization_header()\n        return request\n\n    @cached_property\n    def access_token_jwt(self) -&gt; jwskate.SignedJwt:\n        \"\"\"If the access token is a JWT, return it as an instance of `jwskate.SignedJwt`.\n\n        This method is just a helper for AS testing purposes. Note that, as an OAuth 2.0 Client, you should never have\n        to decode or analyze an access token, since it is simply an abstract string value. It is not even mandatory that\n        Access Tokens are JWTs, just an implementation choice. Only Resource Servers (APIs) should check for the\n        contents of Access Tokens they receive.\n\n        \"\"\"\n        return jwskate.SignedJwt(self.access_token)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.expires_in","title":"<code>expires_in</code>  <code>property</code>","text":"<p>Number of seconds until expiration.</p>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.access_token_jwt","title":"<code>access_token_jwt</code>  <code>cached</code> <code>property</code>","text":"<p>If the access token is a JWT, return it as an instance of <code>jwskate.SignedJwt</code>.</p> <p>This method is just a helper for AS testing purposes. Note that, as an OAuth 2.0 Client, you should never have to decode or analyze an access token, since it is simply an abstract string value. It is not even mandatory that Access Tokens are JWTs, just an implementation choice. Only Resource Servers (APIs) should check for the contents of Access Tokens they receive.</p>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Check if the access token is expired.</p> <p>Parameters:</p> Name Type Description Default <code>leeway</code> <code>int</code> <p>If the token expires in the next given number of seconds, then consider it expired already.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>One of:</p> <code>bool | None</code> <ul> <li><code>True</code> if the access token is expired</li> </ul> <code>bool | None</code> <ul> <li><code>False</code> if it is still valid</li> </ul> <code>bool | None</code> <ul> <li><code>None</code> if there is no expires_in hint.</li> </ul> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Check if the access token is expired.\n\n    Args:\n        leeway: If the token expires in the next given number of seconds,\n            then consider it expired already.\n\n    Returns:\n        One of:\n\n        - `True` if the access token is expired\n        - `False` if it is still valid\n        - `None` if there is no expires_in hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) + timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.authorization_header","title":"<code>authorization_header()</code>","text":"<p>Return the appropriate Authorization Header value for this token.</p> <p>The value is formatted correctly according to RFC6750.</p> <p>Returns:</p> Type Description <code>str</code> <p>the value to use in an HTTP Authorization Header</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def authorization_header(self) -&gt; str:\n    \"\"\"Return the appropriate Authorization Header value for this token.\n\n    The value is formatted correctly according to RFC6750.\n\n    Returns:\n        the value to use in an HTTP Authorization Header\n\n    \"\"\"\n    return f\"{self.AUTHORIZATION_SCHEME} {self.access_token}\"\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.validate_id_token","title":"<code>validate_id_token(client, azr, exp_leeway=0, auth_time_leeway=10)</code>","text":"<p>Validate the ID Token, and return a new instance with the decrypted ID Token.</p> <p>If the ID Token was not encrypted, the returned instance will contain the same ID Token.</p> <p>This will validate the id_token as described in OIDC 1.0 $3.1.3.7.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the <code>OAuth2Client</code> that was used to obtain this token</p> required <code>azr</code> <code>AuthorizationResponse</code> <p>the <code>AuthorizationResponse</code>, as obtained by a call to <code>AuthorizationRequest.validate()</code></p> required <code>exp_leeway</code> <code>int</code> <p>a leeway, in seconds, applied to the ID Token expiration date</p> <code>0</code> <code>auth_time_leeway</code> <code>int</code> <p>a leeway, in seconds, applied to the <code>auth_time</code> validation</p> <code>10</code> <p>Raises:</p> Type Description <code>MissingIdToken</code> <p>if the ID Token is missing</p> <code>InvalidIdToken</code> <p>this is a base exception class, which is raised:</p> <ul> <li>if the ID Token is not a JWT</li> <li>or is encrypted while a clear-text token is expected</li> <li>or is clear-text while an encrypted token is expected</li> <li>if token is encrypted but client does not have a decryption key</li> <li>if the token does not contain an <code>alg</code> header</li> </ul> <code>MismatchingIdTokenAlg</code> <p>if the <code>alg</code> header from the ID Token does not match the expected <code>client.id_token_signed_response_alg</code>.</p> <code>MismatchingIdTokenIssuer</code> <p>if the <code>iss</code> claim from the ID Token does not match the expected <code>azr.issuer</code>.</p> <code>MismatchingIdTokenAcr</code> <p>if the <code>acr</code> claim from the ID Token does not match on of the expected <code>azr.acr_values</code>.</p> <code>MismatchingIdTokenAudience</code> <p>if the <code>aud</code> claim from the ID Token does not match the expected <code>client.client_id</code>.</p> <code>MismatchingIdTokenAzp</code> <p>if the <code>azp</code> claim from the ID Token does not match the expected <code>client.client_id</code>.</p> <code>MismatchingIdTokenNonce</code> <p>if the <code>nonce</code> claim from the ID Token does not match the expected <code>azr.nonce</code>.</p> <code>ExpiredIdToken</code> <p>if the ID Token is expired at the time of the check.</p> <code>UnsupportedIdTokenAlg</code> <p>if the signature alg for the ID Token is not supported.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>    def validate_id_token(  # noqa: PLR0915, C901\n        self, client: OAuth2Client, azr: AuthorizationResponse, exp_leeway: int = 0, auth_time_leeway: int = 10\n    ) -&gt; Self:\n        \"\"\"Validate the ID Token, and return a new instance with the decrypted ID Token.\n\n        If the ID Token was not encrypted, the returned instance will contain the same ID Token.\n\n        This will validate the id_token as described in [OIDC 1.0\n        $3.1.3.7](https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation).\n\n        Args:\n            client: the `OAuth2Client` that was used to obtain this token\n            azr: the `AuthorizationResponse`, as obtained by a call to `AuthorizationRequest.validate()`\n            exp_leeway: a leeway, in seconds, applied to the ID Token expiration date\n            auth_time_leeway: a leeway, in seconds, applied to the `auth_time` validation\n\n        Raises:\n            MissingIdToken: if the ID Token is missing\n            InvalidIdToken: this is a base exception class, which is raised:\n\n                - if the ID Token is not a JWT\n                - or is encrypted while a clear-text token is expected\n                - or is clear-text while an encrypted token is expected\n                - if token is encrypted but client does not have a decryption key\n                - if the token does not contain an `alg` header\n            MismatchingIdTokenAlg: if the `alg` header from the ID Token does not match\n                the expected `client.id_token_signed_response_alg`.\n            MismatchingIdTokenIssuer: if the `iss` claim from the ID Token does not match\n                the expected `azr.issuer`.\n            MismatchingIdTokenAcr: if the `acr` claim from the ID Token does not match\n                on of the expected `azr.acr_values`.\n            MismatchingIdTokenAudience: if the `aud` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenAzp: if the `azp` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenNonce: if the `nonce` claim from the ID Token does not match\n                the expected `azr.nonce`.\n            ExpiredIdToken: if the ID Token is expired at the time of the check.\n            UnsupportedIdTokenAlg: if the signature alg for the ID Token is not supported.\n\n        \"\"\"\n        if not self.id_token:\n            raise MissingIdToken(self)\n\n        raw_id_token = self.id_token\n\n        if isinstance(raw_id_token, jwskate.JweCompact) and client.id_token_encrypted_response_alg is None:\n            msg = \"token is encrypted while it should be clear-text\"\n            raise InvalidIdToken(msg, raw_id_token, self)\n        if isinstance(raw_id_token, IdToken) and client.id_token_encrypted_response_alg is not None:\n            msg = \"token is clear-text while it should be encrypted\"\n            raise InvalidIdToken(msg, raw_id_token, self)\n\n        if isinstance(raw_id_token, jwskate.JweCompact):\n            enc_jwk = client.id_token_decryption_key\n            if enc_jwk is None:\n                msg = \"token is encrypted but client does not have a decryption key\"\n                raise InvalidIdToken(msg, raw_id_token, self)\n            nested_id_token = raw_id_token.decrypt(enc_jwk)\n            id_token = IdToken(nested_id_token)\n        else:\n            id_token = raw_id_token\n\n        id_token_alg = id_token.get_header(\"alg\")\n        if id_token_alg is None:\n            id_token_alg = client.id_token_signed_response_alg\n        if id_token_alg is None:\n            msg = \"\"\"\ntoken does not contain an `alg` parameter to specify the signature algorithm,\nand no algorithm has been configured for the client (using param `id_token_signed_response_alg`).\n\"\"\"\n            raise InvalidIdToken(msg, id_token, self)\n        if client.id_token_signed_response_alg is not None and id_token_alg != client.id_token_signed_response_alg:\n            raise MismatchingIdTokenAlg(id_token.alg, client.id_token_signed_response_alg, self, id_token)\n\n        verification_jwk: jwskate.Jwk\n\n        if id_token_alg in jwskate.SignatureAlgs.ALL_SYMMETRIC:\n            if not client.client_secret:\n                msg = \"token is symmetrically signed but this client does not have a Client Secret.\"\n                raise InvalidIdToken(msg, id_token, self)\n            verification_jwk = jwskate.SymmetricJwk.from_bytes(client.client_secret, alg=id_token_alg)\n            id_token.verify_signature(verification_jwk, alg=id_token_alg)\n        elif id_token_alg in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n            if not client.authorization_server_jwks:\n                msg = \"token is asymmetrically signed but the Authorization Server JWKS is not available.\"\n                raise InvalidIdToken(msg, id_token, self)\n\n            if id_token.get_header(\"kid\") is None:\n                msg = \"\"\"\ntoken does not contain a Key ID (kid) to specify the asymmetric key\nto use for signature verification.\"\"\"\n                raise InvalidIdToken(msg, id_token, self)\n            try:\n                verification_jwk = client.authorization_server_jwks.get_jwk_by_kid(id_token.kid)\n            except KeyError:\n                msg = f\"\"\"\\\ntoken is asymmetrically signed but there is no key\nwith kid='{id_token.kid}' in the Authorization Server JWKS.\"\"\"\n                raise InvalidIdToken(msg, id_token, self) from None\n\n            if id_token_alg not in verification_jwk.supported_signing_algorithms():\n                msg = \"token is asymmetrically signed but its algorithm is not supported by the verification key.\"\n                raise InvalidIdToken(msg, id_token, self)\n        else:\n            raise UnsupportedIdTokenAlg(self, id_token, id_token_alg)\n\n        id_token.verify(verification_jwk, alg=id_token_alg)\n\n        if azr.issuer and id_token.issuer != azr.issuer:\n            raise MismatchingIdTokenIssuer(id_token.issuer, azr.issuer, self, id_token)\n\n        if id_token.audiences and client.client_id not in id_token.audiences:\n            raise MismatchingIdTokenAudience(id_token.audiences, client.client_id, self, id_token)\n\n        if id_token.authorized_party is not None and id_token.authorized_party != client.client_id:\n            raise MismatchingIdTokenAzp(id_token.azp, client.client_id, self, id_token)\n\n        if id_token.is_expired(leeway=exp_leeway):\n            raise ExpiredIdToken(self, id_token)\n\n        if azr.nonce and id_token.nonce != azr.nonce:\n            raise MismatchingIdTokenNonce(id_token.nonce, azr.nonce, self, id_token)\n\n        if azr.acr_values and id_token.acr not in azr.acr_values:\n            raise MismatchingIdTokenAcr(id_token.acr, azr.acr_values, self, id_token)\n\n        hash_function = IdToken.hash_method(verification_jwk, id_token_alg)\n\n        at_hash = id_token.get_claim(\"at_hash\")\n        if at_hash is not None:\n            expected_at_hash = hash_function(self.access_token)\n            if expected_at_hash != at_hash:\n                msg = f\"mismatching 'at_hash' value (expected '{expected_at_hash}', got '{at_hash}')\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        c_hash = id_token.get_claim(\"c_hash\")\n        if c_hash is not None:\n            expected_c_hash = hash_function(azr.code)\n            if expected_c_hash != c_hash:\n                msg = f\"mismatching 'c_hash' value (expected '{expected_c_hash}', got '{c_hash}')\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        s_hash = id_token.get_claim(\"s_hash\")\n        if s_hash is not None:\n            if azr.state is None:\n                msg = \"token has a 's_hash' claim but no state was included in the request.\"\n                raise InvalidIdToken(msg, id_token, self)\n            expected_s_hash = hash_function(azr.state)\n            if expected_s_hash != s_hash:\n                msg = f\"mismatching 's_hash' value (expected '{expected_s_hash}', got '{s_hash}')\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        if azr.max_age is not None:\n            auth_time = id_token.auth_datetime\n            if auth_time is None:\n                msg = \"\"\"\na `max_age` parameter was included in the authorization request,\nbut the ID Token does not contain an `auth_time` claim.\n\"\"\"\n                raise InvalidIdToken(msg, id_token, self) from None\n            auth_age = datetime.now(tz=timezone.utc) - auth_time\n            if auth_age.total_seconds() &gt; azr.max_age + auth_time_leeway:\n                msg = f\"\"\"\nuser authentication happened too far in the past.\nThe `auth_time` parameter from the ID Token indicate that\nthe last Authentication Time was at {auth_time} ({auth_age.total_seconds()} sec ago),\nbut the authorization request `max_age` parameter specified that it must\nbe a maximum of {azr.max_age} sec ago.\n\"\"\"\n                raise InvalidIdToken(msg, id_token, self)\n\n        return self.__class__(\n            access_token=self.access_token,\n            expires_at=self.expires_at,\n            scope=self.scope,\n            refresh_token=self.refresh_token,\n            token_type=self.token_type,\n            id_token=id_token,\n            **self.kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.as_dict","title":"<code>as_dict()</code>","text":"<p>Return a dict of parameters.</p> <p>That is suitable for serialization or to init another BearerToken.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return a dict of parameters.\n\n    That is suitable for serialization or to init another BearerToken.\n\n    \"\"\"\n    d = asdict(self)\n    d.pop(\"expires_at\")\n    d[\"expires_in\"] = self.expires_in\n    d.update(**d.pop(\"kwargs\", {}))\n    return {key: val for key, val in d.items() if val is not None}\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer","title":"<code>BearerTokenSerializer</code>","text":"<p>A helper class to serialize Token Response returned by an AS.</p> <p>This may be used to store BearerTokens in session or cookies.</p> <p>It needs a <code>dumper</code> and a <code>loader</code> functions that will respectively serialize and deserialize BearerTokens. Default implementations are provided with use gzip and base64url on the serialized JSON representation.</p> <p>Parameters:</p> Name Type Description Default <code>dumper</code> <code>Callable[[BearerToken], str] | None</code> <p>a function to serialize a token into a <code>str</code>.</p> <code>None</code> <code>loader</code> <code>Callable[[str], BearerToken] | None</code> <p>a function to deserialize a serialized token representation.</p> <code>None</code> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class BearerTokenSerializer:\n    \"\"\"A helper class to serialize Token Response returned by an AS.\n\n    This may be used to store BearerTokens in session or cookies.\n\n    It needs a `dumper` and a `loader` functions that will respectively serialize and deserialize\n    BearerTokens. Default implementations are provided with use gzip and base64url on the serialized\n    JSON representation.\n\n    Args:\n        dumper: a function to serialize a token into a `str`.\n        loader: a function to deserialize a serialized token representation.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        dumper: Callable[[BearerToken], str] | None = None,\n        loader: Callable[[str], BearerToken] | None = None,\n    ) -&gt; None:\n        self.dumper = dumper or self.default_dumper\n        self.loader = loader or self.default_loader\n\n    @staticmethod\n    def default_dumper(token: BearerToken) -&gt; str:\n        \"\"\"Serialize a token as JSON, then compress with deflate, then encodes as base64url.\n\n        Args:\n            token: the `BearerToken` to serialize\n\n        Returns:\n            the serialized value\n\n        \"\"\"\n        d = asdict(token)\n        d.update(**d.pop(\"kwargs\", {}))\n        return (\n            BinaPy.serialize_to(\"json\", {k: w for k, w in d.items() if w is not None}).to(\"deflate\").to(\"b64u\").ascii()\n        )\n\n    def default_loader(self, serialized: str, token_class: type[BearerToken] = BearerToken) -&gt; BearerToken:\n        \"\"\"Deserialize a BearerToken.\n\n        This does the opposite operations than `default_dumper`.\n\n        Args:\n            serialized: the serialized token\n            token_class: class to use to deserialize the Token\n\n        Returns:\n            a BearerToken\n\n        \"\"\"\n        attrs = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n        expires_at = attrs.get(\"expires_at\")\n        if expires_at:\n            attrs[\"expires_at\"] = datetime.fromtimestamp(expires_at, tz=timezone.utc)\n        return token_class(**attrs)\n\n    def dumps(self, token: BearerToken) -&gt; str:\n        \"\"\"Serialize and compress a given token for easier storage.\n\n        Args:\n            token: a BearerToken to serialize\n\n        Returns:\n            the serialized token, as a str\n\n        \"\"\"\n        return self.dumper(token)\n\n    def loads(self, serialized: str) -&gt; BearerToken:\n        \"\"\"Deserialize a serialized token.\n\n        Args:\n            serialized: the serialized token\n\n        Returns:\n            the deserialized token\n\n        \"\"\"\n        return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.default_dumper","title":"<code>default_dumper(token)</code>  <code>staticmethod</code>","text":"<p>Serialize a token as JSON, then compress with deflate, then encodes as base64url.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BearerToken</code> <p>the <code>BearerToken</code> to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized value</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@staticmethod\ndef default_dumper(token: BearerToken) -&gt; str:\n    \"\"\"Serialize a token as JSON, then compress with deflate, then encodes as base64url.\n\n    Args:\n        token: the `BearerToken` to serialize\n\n    Returns:\n        the serialized value\n\n    \"\"\"\n    d = asdict(token)\n    d.update(**d.pop(\"kwargs\", {}))\n    return (\n        BinaPy.serialize_to(\"json\", {k: w for k, w in d.items() if w is not None}).to(\"deflate\").to(\"b64u\").ascii()\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.default_loader","title":"<code>default_loader(serialized, token_class=BearerToken)</code>","text":"<p>Deserialize a BearerToken.</p> <p>This does the opposite operations than <code>default_dumper</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized token</p> required <code>token_class</code> <code>type[BearerToken]</code> <p>class to use to deserialize the Token</p> <code>BearerToken</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def default_loader(self, serialized: str, token_class: type[BearerToken] = BearerToken) -&gt; BearerToken:\n    \"\"\"Deserialize a BearerToken.\n\n    This does the opposite operations than `default_dumper`.\n\n    Args:\n        serialized: the serialized token\n        token_class: class to use to deserialize the Token\n\n    Returns:\n        a BearerToken\n\n    \"\"\"\n    attrs = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n    expires_at = attrs.get(\"expires_at\")\n    if expires_at:\n        attrs[\"expires_at\"] = datetime.fromtimestamp(expires_at, tz=timezone.utc)\n    return token_class(**attrs)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.dumps","title":"<code>dumps(token)</code>","text":"<p>Serialize and compress a given token for easier storage.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BearerToken</code> <p>a BearerToken to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized token, as a str</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def dumps(self, token: BearerToken) -&gt; str:\n    \"\"\"Serialize and compress a given token for easier storage.\n\n    Args:\n        token: a BearerToken to serialize\n\n    Returns:\n        the serialized token, as a str\n\n    \"\"\"\n    return self.dumper(token)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.loads","title":"<code>loads(serialized)</code>","text":"<p>Deserialize a serialized token.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized token</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>the deserialized token</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def loads(self, serialized: str) -&gt; BearerToken:\n    \"\"\"Deserialize a serialized token.\n\n    Args:\n        serialized: the serialized token\n\n    Returns:\n        the deserialized token\n\n    \"\"\"\n    return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.id_token_converter","title":"<code>id_token_converter(id_token)</code>","text":"<p>Utility method that converts an ID Token, as <code>str | bytes</code>, to an <code>IdToken</code> or <code>JweCompact</code>.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def id_token_converter(\n    id_token: str | bytes | IdToken | jwskate.JweCompact | None,\n) -&gt; IdToken | jwskate.JweCompact | None:\n    \"\"\"Utility method that converts an ID Token, as `str | bytes`, to an `IdToken` or `JweCompact`.\"\"\"\n    if id_token is not None and not isinstance(id_token, (IdToken, jwskate.JweCompact)):\n        try:\n            id_token = IdToken(id_token)\n        except jwskate.InvalidJwt:\n            try:\n                id_token = jwskate.JweCompact(id_token)  # type: ignore[arg-type]\n            except jwskate.InvalidJwe:\n                msg = \"token is neither a JWT or a JWE.\"\n                raise InvalidIdToken(msg, id_token) from None\n    return id_token\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific","title":"<code>vendor_specific</code>","text":"<p>Vendor-specific utilities.</p> <p>This module contains vendor-specific subclasses of [requests_oauth2client] classes, that make it easier to work with specific OAuth 2.x providers and/or fix compatibility issues.</p>"},{"location":"api/#requests_oauth2client.vendor_specific.Auth0","title":"<code>Auth0</code>","text":"<p>Auth0-related utilities.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>class Auth0:\n    \"\"\"Auth0-related utilities.\"\"\"\n\n    @classmethod\n    def tenant(cls, tenant: str) -&gt; str:\n        \"\"\"Given a short tenant name, returns the full tenant FQDN.\"\"\"\n        if not tenant:\n            msg = \"You must specify a tenant name.\"\n            raise ValueError(msg)\n        if \".\" not in tenant or tenant.endswith((\".eu\", \".us\", \".au\", \".jp\")):\n            tenant = f\"{tenant}.auth0.com\"\n        if \"://\" in tenant:\n            if tenant.startswith(\"https://\"):\n                return tenant[8:]\n            msg = (\n                \"Invalid tenant name. \"\n                \"It must be a tenant name like 'mytenant.myregion' \"\n                \"or a full FQDN like 'mytenant.myregion.auth0.com'.\"\n                \"or an issuer like 'https://mytenant.myregion.auth0.com'\"\n            )\n            raise ValueError(msg)\n        return tenant\n\n    @classmethod\n    def client(\n        cls,\n        tenant: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any | None = None,\n        session: requests.Session | None = None,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialise an OAuth2Client for an Auth0 tenant.\"\"\"\n        tenant = cls.tenant(tenant)\n        issuer = f\"https://{tenant}\"\n        token_endpoint = f\"{issuer}/oauth/token\"\n        authorization_endpoint = f\"{issuer}/authorize\"\n        revocation_endpoint = f\"{issuer}/oauth/revoke\"\n        userinfo_endpoint = f\"{issuer}/userinfo\"\n        jwks_uri = f\"{issuer}/.well-known/jwks.json\"\n\n        return OAuth2Client(\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            issuer=issuer,\n            jwks_uri=jwks_uri,\n            **kwargs,\n        )\n\n    @classmethod\n    def management_api_client(\n        cls,\n        tenant: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any | None = None,\n        session: requests.Session | None = None,\n        **kwargs: Any,\n    ) -&gt; ApiClient:\n        \"\"\"Initialize a client for the Auth0 Management API.\n\n        See [Auth0 Management API v2](https://auth0.com/docs/api/management/v2). You must provide the\n        target tenant name and the credentials for a client that is allowed access to the Management\n        API.\n\n        Args:\n            tenant: the tenant name.\n                Same definition as for [Auth0.client][requests_oauth2client.vendor_specific.auth0.Auth0.client]\n            auth: client credentials.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            client_id: the Client ID.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            client_secret: the Client Secret.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            private_jwk: the private key to use for client authentication.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            session: requests session.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            **kwargs: additional kwargs to pass to the ApiClient base class\n\n        Example:\n            ```python\n            from requests_oauth2client.vendor_specific import Auth0\n\n            a0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\n            users = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n            ```\n\n        \"\"\"\n        tenant = cls.tenant(tenant)\n        client = cls.client(\n            tenant,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n        )\n        audience = f\"https://{tenant}/api/v2/\"\n        api_auth = OAuth2ClientCredentialsAuth(client, audience=audience)\n        return ApiClient(\n            base_url=audience,\n            auth=api_auth,\n            session=session,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.Auth0.tenant","title":"<code>tenant(tenant)</code>  <code>classmethod</code>","text":"<p>Given a short tenant name, returns the full tenant FQDN.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef tenant(cls, tenant: str) -&gt; str:\n    \"\"\"Given a short tenant name, returns the full tenant FQDN.\"\"\"\n    if not tenant:\n        msg = \"You must specify a tenant name.\"\n        raise ValueError(msg)\n    if \".\" not in tenant or tenant.endswith((\".eu\", \".us\", \".au\", \".jp\")):\n        tenant = f\"{tenant}.auth0.com\"\n    if \"://\" in tenant:\n        if tenant.startswith(\"https://\"):\n            return tenant[8:]\n        msg = (\n            \"Invalid tenant name. \"\n            \"It must be a tenant name like 'mytenant.myregion' \"\n            \"or a full FQDN like 'mytenant.myregion.auth0.com'.\"\n            \"or an issuer like 'https://mytenant.myregion.auth0.com'\"\n        )\n        raise ValueError(msg)\n    return tenant\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.Auth0.client","title":"<code>client(tenant, auth=None, *, client_id=None, client_secret=None, private_jwk=None, session=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialise an OAuth2Client for an Auth0 tenant.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef client(\n    cls,\n    tenant: str,\n    auth: (\n        requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n    ) = None,\n    *,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any | None = None,\n    session: requests.Session | None = None,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n    \"\"\"Initialise an OAuth2Client for an Auth0 tenant.\"\"\"\n    tenant = cls.tenant(tenant)\n    issuer = f\"https://{tenant}\"\n    token_endpoint = f\"{issuer}/oauth/token\"\n    authorization_endpoint = f\"{issuer}/authorize\"\n    revocation_endpoint = f\"{issuer}/oauth/revoke\"\n    userinfo_endpoint = f\"{issuer}/userinfo\"\n    jwks_uri = f\"{issuer}/.well-known/jwks.json\"\n\n    return OAuth2Client(\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n        token_endpoint=token_endpoint,\n        authorization_endpoint=authorization_endpoint,\n        revocation_endpoint=revocation_endpoint,\n        userinfo_endpoint=userinfo_endpoint,\n        issuer=issuer,\n        jwks_uri=jwks_uri,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.Auth0.management_api_client","title":"<code>management_api_client(tenant, auth=None, *, client_id=None, client_secret=None, private_jwk=None, session=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize a client for the Auth0 Management API.</p> <p>See Auth0 Management API v2. You must provide the target tenant name and the credentials for a client that is allowed access to the Management API.</p> <p>Parameters:</p> Name Type Description Default <code>tenant</code> <code>str</code> <p>the tenant name. Same definition as for Auth0.client</p> required <code>auth</code> <code>AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None</code> <p>client credentials. Same definition as for OAuth2Client</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>the Client ID. Same definition as for OAuth2Client</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>the Client Secret. Same definition as for OAuth2Client</p> <code>None</code> <code>private_jwk</code> <code>Any | None</code> <p>the private key to use for client authentication. Same definition as for OAuth2Client</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>requests session. Same definition as for OAuth2Client</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs to pass to the ApiClient base class</p> <code>{}</code> Example <pre><code>from requests_oauth2client.vendor_specific import Auth0\n\na0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\nusers = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n</code></pre> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef management_api_client(\n    cls,\n    tenant: str,\n    auth: (\n        requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n    ) = None,\n    *,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any | None = None,\n    session: requests.Session | None = None,\n    **kwargs: Any,\n) -&gt; ApiClient:\n    \"\"\"Initialize a client for the Auth0 Management API.\n\n    See [Auth0 Management API v2](https://auth0.com/docs/api/management/v2). You must provide the\n    target tenant name and the credentials for a client that is allowed access to the Management\n    API.\n\n    Args:\n        tenant: the tenant name.\n            Same definition as for [Auth0.client][requests_oauth2client.vendor_specific.auth0.Auth0.client]\n        auth: client credentials.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        client_id: the Client ID.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        client_secret: the Client Secret.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        private_jwk: the private key to use for client authentication.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        session: requests session.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        **kwargs: additional kwargs to pass to the ApiClient base class\n\n    Example:\n        ```python\n        from requests_oauth2client.vendor_specific import Auth0\n\n        a0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\n        users = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n        ```\n\n    \"\"\"\n    tenant = cls.tenant(tenant)\n    client = cls.client(\n        tenant,\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n    )\n    audience = f\"https://{tenant}/api/v2/\"\n    api_auth = OAuth2ClientCredentialsAuth(client, audience=audience)\n    return ApiClient(\n        base_url=audience,\n        auth=api_auth,\n        session=session,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.Ping","title":"<code>Ping</code>","text":"<p>Ping Identity related utilities.</p> Source code in <code>requests_oauth2client/vendor_specific/ping.py</code> <pre><code>class Ping:\n    \"\"\"Ping Identity related utilities.\"\"\"\n\n    @classmethod\n    def client(\n        cls,\n        issuer: str,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any = None,\n        session: requests.Session | None = None,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an OAuth2Client for PingFederate.\n\n        This will configure all endpoints with PingID specific urls, without using the metadata.\n        Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage\n        over using `OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")`.\n\n        \"\"\"\n        if not issuer.startswith(\"https://\"):\n            if \"://\" in issuer:\n                msg = \"Invalid issuer. It must be an https:// url or a domain name without a scheme.\"\n                raise ValueError(msg)\n            issuer = f\"https://{issuer}\"\n        if \".\" not in issuer:\n            msg = \"Invalid issuer. It must contain at least a dot in the domain name.\"\n            raise ValueError(msg)\n\n        return OAuth2Client(\n            authorization_endpoint=f\"{issuer}/as/authorization.oauth2\",\n            token_endpoint=f\"{issuer}/as/token.oauth2\",\n            revocation_endpoint=f\"{issuer}/as/revoke_token.oauth2\",\n            userinfo_endpoint=f\"{issuer}/idp/userinfo.openid\",\n            introspection_endpoint=f\"{issuer}/as/introspect.oauth2\",\n            jwks_uri=f\"{issuer}/pf/JWKS\",\n            registration_endpoint=f\"{issuer}/as/clients.oauth2\",\n            ping_revoked_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/revokedSris\",\n            ping_session_management_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/sessions\",\n            ping_session_management_users_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/users\",\n            ping_end_session_endpoint=f\"{issuer}/idp/startSLO.ping\",\n            device_authorization_endpoint=f\"{issuer}/as/device_authz.oauth2\",\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.Ping.client","title":"<code>client(issuer, auth=None, client_id=None, client_secret=None, private_jwk=None, session=None)</code>  <code>classmethod</code>","text":"<p>Initialize an OAuth2Client for PingFederate.</p> <p>This will configure all endpoints with PingID specific urls, without using the metadata. Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage over using <code>OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")</code>.</p> Source code in <code>requests_oauth2client/vendor_specific/ping.py</code> <pre><code>@classmethod\ndef client(\n    cls,\n    issuer: str,\n    auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any = None,\n    session: requests.Session | None = None,\n) -&gt; OAuth2Client:\n    \"\"\"Initialize an OAuth2Client for PingFederate.\n\n    This will configure all endpoints with PingID specific urls, without using the metadata.\n    Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage\n    over using `OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")`.\n\n    \"\"\"\n    if not issuer.startswith(\"https://\"):\n        if \"://\" in issuer:\n            msg = \"Invalid issuer. It must be an https:// url or a domain name without a scheme.\"\n            raise ValueError(msg)\n        issuer = f\"https://{issuer}\"\n    if \".\" not in issuer:\n        msg = \"Invalid issuer. It must contain at least a dot in the domain name.\"\n        raise ValueError(msg)\n\n    return OAuth2Client(\n        authorization_endpoint=f\"{issuer}/as/authorization.oauth2\",\n        token_endpoint=f\"{issuer}/as/token.oauth2\",\n        revocation_endpoint=f\"{issuer}/as/revoke_token.oauth2\",\n        userinfo_endpoint=f\"{issuer}/idp/userinfo.openid\",\n        introspection_endpoint=f\"{issuer}/as/introspect.oauth2\",\n        jwks_uri=f\"{issuer}/pf/JWKS\",\n        registration_endpoint=f\"{issuer}/as/clients.oauth2\",\n        ping_revoked_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/revokedSris\",\n        ping_session_management_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/sessions\",\n        ping_session_management_users_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/users\",\n        ping_end_session_endpoint=f\"{issuer}/idp/startSLO.ping\",\n        device_authorization_endpoint=f\"{issuer}/as/device_authz.oauth2\",\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0","title":"<code>auth0</code>","text":"<p>Implements subclasses for Auth0.</p>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0","title":"<code>Auth0</code>","text":"<p>Auth0-related utilities.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>class Auth0:\n    \"\"\"Auth0-related utilities.\"\"\"\n\n    @classmethod\n    def tenant(cls, tenant: str) -&gt; str:\n        \"\"\"Given a short tenant name, returns the full tenant FQDN.\"\"\"\n        if not tenant:\n            msg = \"You must specify a tenant name.\"\n            raise ValueError(msg)\n        if \".\" not in tenant or tenant.endswith((\".eu\", \".us\", \".au\", \".jp\")):\n            tenant = f\"{tenant}.auth0.com\"\n        if \"://\" in tenant:\n            if tenant.startswith(\"https://\"):\n                return tenant[8:]\n            msg = (\n                \"Invalid tenant name. \"\n                \"It must be a tenant name like 'mytenant.myregion' \"\n                \"or a full FQDN like 'mytenant.myregion.auth0.com'.\"\n                \"or an issuer like 'https://mytenant.myregion.auth0.com'\"\n            )\n            raise ValueError(msg)\n        return tenant\n\n    @classmethod\n    def client(\n        cls,\n        tenant: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any | None = None,\n        session: requests.Session | None = None,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialise an OAuth2Client for an Auth0 tenant.\"\"\"\n        tenant = cls.tenant(tenant)\n        issuer = f\"https://{tenant}\"\n        token_endpoint = f\"{issuer}/oauth/token\"\n        authorization_endpoint = f\"{issuer}/authorize\"\n        revocation_endpoint = f\"{issuer}/oauth/revoke\"\n        userinfo_endpoint = f\"{issuer}/userinfo\"\n        jwks_uri = f\"{issuer}/.well-known/jwks.json\"\n\n        return OAuth2Client(\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            issuer=issuer,\n            jwks_uri=jwks_uri,\n            **kwargs,\n        )\n\n    @classmethod\n    def management_api_client(\n        cls,\n        tenant: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any | None = None,\n        session: requests.Session | None = None,\n        **kwargs: Any,\n    ) -&gt; ApiClient:\n        \"\"\"Initialize a client for the Auth0 Management API.\n\n        See [Auth0 Management API v2](https://auth0.com/docs/api/management/v2). You must provide the\n        target tenant name and the credentials for a client that is allowed access to the Management\n        API.\n\n        Args:\n            tenant: the tenant name.\n                Same definition as for [Auth0.client][requests_oauth2client.vendor_specific.auth0.Auth0.client]\n            auth: client credentials.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            client_id: the Client ID.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            client_secret: the Client Secret.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            private_jwk: the private key to use for client authentication.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            session: requests session.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            **kwargs: additional kwargs to pass to the ApiClient base class\n\n        Example:\n            ```python\n            from requests_oauth2client.vendor_specific import Auth0\n\n            a0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\n            users = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n            ```\n\n        \"\"\"\n        tenant = cls.tenant(tenant)\n        client = cls.client(\n            tenant,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n        )\n        audience = f\"https://{tenant}/api/v2/\"\n        api_auth = OAuth2ClientCredentialsAuth(client, audience=audience)\n        return ApiClient(\n            base_url=audience,\n            auth=api_auth,\n            session=session,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0.tenant","title":"<code>tenant(tenant)</code>  <code>classmethod</code>","text":"<p>Given a short tenant name, returns the full tenant FQDN.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef tenant(cls, tenant: str) -&gt; str:\n    \"\"\"Given a short tenant name, returns the full tenant FQDN.\"\"\"\n    if not tenant:\n        msg = \"You must specify a tenant name.\"\n        raise ValueError(msg)\n    if \".\" not in tenant or tenant.endswith((\".eu\", \".us\", \".au\", \".jp\")):\n        tenant = f\"{tenant}.auth0.com\"\n    if \"://\" in tenant:\n        if tenant.startswith(\"https://\"):\n            return tenant[8:]\n        msg = (\n            \"Invalid tenant name. \"\n            \"It must be a tenant name like 'mytenant.myregion' \"\n            \"or a full FQDN like 'mytenant.myregion.auth0.com'.\"\n            \"or an issuer like 'https://mytenant.myregion.auth0.com'\"\n        )\n        raise ValueError(msg)\n    return tenant\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0.client","title":"<code>client(tenant, auth=None, *, client_id=None, client_secret=None, private_jwk=None, session=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialise an OAuth2Client for an Auth0 tenant.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef client(\n    cls,\n    tenant: str,\n    auth: (\n        requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n    ) = None,\n    *,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any | None = None,\n    session: requests.Session | None = None,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n    \"\"\"Initialise an OAuth2Client for an Auth0 tenant.\"\"\"\n    tenant = cls.tenant(tenant)\n    issuer = f\"https://{tenant}\"\n    token_endpoint = f\"{issuer}/oauth/token\"\n    authorization_endpoint = f\"{issuer}/authorize\"\n    revocation_endpoint = f\"{issuer}/oauth/revoke\"\n    userinfo_endpoint = f\"{issuer}/userinfo\"\n    jwks_uri = f\"{issuer}/.well-known/jwks.json\"\n\n    return OAuth2Client(\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n        token_endpoint=token_endpoint,\n        authorization_endpoint=authorization_endpoint,\n        revocation_endpoint=revocation_endpoint,\n        userinfo_endpoint=userinfo_endpoint,\n        issuer=issuer,\n        jwks_uri=jwks_uri,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0.management_api_client","title":"<code>management_api_client(tenant, auth=None, *, client_id=None, client_secret=None, private_jwk=None, session=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize a client for the Auth0 Management API.</p> <p>See Auth0 Management API v2. You must provide the target tenant name and the credentials for a client that is allowed access to the Management API.</p> <p>Parameters:</p> Name Type Description Default <code>tenant</code> <code>str</code> <p>the tenant name. Same definition as for Auth0.client</p> required <code>auth</code> <code>AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None</code> <p>client credentials. Same definition as for OAuth2Client</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>the Client ID. Same definition as for OAuth2Client</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>the Client Secret. Same definition as for OAuth2Client</p> <code>None</code> <code>private_jwk</code> <code>Any | None</code> <p>the private key to use for client authentication. Same definition as for OAuth2Client</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>requests session. Same definition as for OAuth2Client</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs to pass to the ApiClient base class</p> <code>{}</code> Example <pre><code>from requests_oauth2client.vendor_specific import Auth0\n\na0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\nusers = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n</code></pre> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef management_api_client(\n    cls,\n    tenant: str,\n    auth: (\n        requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n    ) = None,\n    *,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any | None = None,\n    session: requests.Session | None = None,\n    **kwargs: Any,\n) -&gt; ApiClient:\n    \"\"\"Initialize a client for the Auth0 Management API.\n\n    See [Auth0 Management API v2](https://auth0.com/docs/api/management/v2). You must provide the\n    target tenant name and the credentials for a client that is allowed access to the Management\n    API.\n\n    Args:\n        tenant: the tenant name.\n            Same definition as for [Auth0.client][requests_oauth2client.vendor_specific.auth0.Auth0.client]\n        auth: client credentials.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        client_id: the Client ID.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        client_secret: the Client Secret.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        private_jwk: the private key to use for client authentication.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        session: requests session.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        **kwargs: additional kwargs to pass to the ApiClient base class\n\n    Example:\n        ```python\n        from requests_oauth2client.vendor_specific import Auth0\n\n        a0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\n        users = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n        ```\n\n    \"\"\"\n    tenant = cls.tenant(tenant)\n    client = cls.client(\n        tenant,\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n    )\n    audience = f\"https://{tenant}/api/v2/\"\n    api_auth = OAuth2ClientCredentialsAuth(client, audience=audience)\n    return ApiClient(\n        base_url=audience,\n        auth=api_auth,\n        session=session,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.ping","title":"<code>ping</code>","text":"<p>PingID specific client.</p>"},{"location":"api/#requests_oauth2client.vendor_specific.ping.Ping","title":"<code>Ping</code>","text":"<p>Ping Identity related utilities.</p> Source code in <code>requests_oauth2client/vendor_specific/ping.py</code> <pre><code>class Ping:\n    \"\"\"Ping Identity related utilities.\"\"\"\n\n    @classmethod\n    def client(\n        cls,\n        issuer: str,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any = None,\n        session: requests.Session | None = None,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an OAuth2Client for PingFederate.\n\n        This will configure all endpoints with PingID specific urls, without using the metadata.\n        Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage\n        over using `OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")`.\n\n        \"\"\"\n        if not issuer.startswith(\"https://\"):\n            if \"://\" in issuer:\n                msg = \"Invalid issuer. It must be an https:// url or a domain name without a scheme.\"\n                raise ValueError(msg)\n            issuer = f\"https://{issuer}\"\n        if \".\" not in issuer:\n            msg = \"Invalid issuer. It must contain at least a dot in the domain name.\"\n            raise ValueError(msg)\n\n        return OAuth2Client(\n            authorization_endpoint=f\"{issuer}/as/authorization.oauth2\",\n            token_endpoint=f\"{issuer}/as/token.oauth2\",\n            revocation_endpoint=f\"{issuer}/as/revoke_token.oauth2\",\n            userinfo_endpoint=f\"{issuer}/idp/userinfo.openid\",\n            introspection_endpoint=f\"{issuer}/as/introspect.oauth2\",\n            jwks_uri=f\"{issuer}/pf/JWKS\",\n            registration_endpoint=f\"{issuer}/as/clients.oauth2\",\n            ping_revoked_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/revokedSris\",\n            ping_session_management_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/sessions\",\n            ping_session_management_users_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/users\",\n            ping_end_session_endpoint=f\"{issuer}/idp/startSLO.ping\",\n            device_authorization_endpoint=f\"{issuer}/as/device_authz.oauth2\",\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.ping.Ping.client","title":"<code>client(issuer, auth=None, client_id=None, client_secret=None, private_jwk=None, session=None)</code>  <code>classmethod</code>","text":"<p>Initialize an OAuth2Client for PingFederate.</p> <p>This will configure all endpoints with PingID specific urls, without using the metadata. Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage over using <code>OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")</code>.</p> Source code in <code>requests_oauth2client/vendor_specific/ping.py</code> <pre><code>@classmethod\ndef client(\n    cls,\n    issuer: str,\n    auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any = None,\n    session: requests.Session | None = None,\n) -&gt; OAuth2Client:\n    \"\"\"Initialize an OAuth2Client for PingFederate.\n\n    This will configure all endpoints with PingID specific urls, without using the metadata.\n    Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage\n    over using `OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")`.\n\n    \"\"\"\n    if not issuer.startswith(\"https://\"):\n        if \"://\" in issuer:\n            msg = \"Invalid issuer. It must be an https:// url or a domain name without a scheme.\"\n            raise ValueError(msg)\n        issuer = f\"https://{issuer}\"\n    if \".\" not in issuer:\n        msg = \"Invalid issuer. It must contain at least a dot in the domain name.\"\n        raise ValueError(msg)\n\n    return OAuth2Client(\n        authorization_endpoint=f\"{issuer}/as/authorization.oauth2\",\n        token_endpoint=f\"{issuer}/as/token.oauth2\",\n        revocation_endpoint=f\"{issuer}/as/revoke_token.oauth2\",\n        userinfo_endpoint=f\"{issuer}/idp/userinfo.openid\",\n        introspection_endpoint=f\"{issuer}/as/introspect.oauth2\",\n        jwks_uri=f\"{issuer}/pf/JWKS\",\n        registration_endpoint=f\"{issuer}/as/clients.oauth2\",\n        ping_revoked_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/revokedSris\",\n        ping_session_management_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/sessions\",\n        ping_session_management_users_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/users\",\n        ping_end_session_endpoint=f\"{issuer}/idp/startSLO.ping\",\n        device_authorization_endpoint=f\"{issuer}/as/device_authz.oauth2\",\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n    )\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/guillp/requests_oauth2client/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Detailed steps to reproduce the bug.</li> <li>Full error message whenever there is one</li> <li>Your Python version, operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p><code>requests_oauth2client</code> could always use more documentation, whether as part of the official requests_oauth2client docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/guillp/requests_oauth2client/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>requests_oauth2client</code> for local development.</p> <ol> <li>Fork the <code>requests_oauth2client</code> repo on GitHub.</li> <li>Clone your fork locally</li> </ol> <pre><code>$ git clone git@github.com:your_name_here/requests_oauth2client.git\n</code></pre> <ol> <li>Ensure poetry is installed.</li> <li>Install dependencies and start your virtualenv:</li> </ol> <pre><code>$ poetry install -E test -E doc -E dev\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</li> </ol> <pre><code>$ tox\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python 3.8+ and for PyPy. Check    https://github.com/guillp/requests_oauth2client/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<pre><code>$ pytest tests.test_client_credentials\n</code></pre> <p>To run a subset of tests.</p>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run:</p> <pre><code>$ poetry patch # possible: major / minor / patch\n$ git push\n$ git push --tags\n</code></pre> <p>Travis will then deploy to PyPI if tests pass.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install requests_oauth2client, run this command in your terminal:</p> <pre><code>$ pip install requests_oauth2client\n</code></pre> <p>This is the preferred method to install requests_oauth2client, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for requests_oauth2client can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>$ git clone git://github.com/guillp/requests_oauth2client\n</code></pre> <p>Or download the tarball:</p> <pre><code>$ curl -OJL https://github.com/guillp/requests_oauth2client/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>$ pip install .\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#usage","title":"Usage","text":"<p>To use requests_oauth2client in a project</p> <pre><code>from requests_oauth2client import *\n</code></pre>"}]}