{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p><code>requests_oauth2client</code> is an OAuth 2.x client for Python, able to obtain, refresh and revoke tokens from any OAuth2.x/OIDC compliant Authorization Server. It sits upon and extends the famous requests HTTP client module.</p> <p>It can act as an OAuth 2.0 / 2.1 client, to automatically get and renew Access Tokens, based on the Client Credentials, Authorization Code, Refresh token, Token Exchange, JWT Bearer, Device Authorization, Resource Owner Password or CIBA grants. Additional grant types are easy to add if needed.</p> <p>It also supports OpenID Connect 1.0, PKCE, Client Assertions, Token Revocation and Introspection, Resource Indicators, JWT-secured Authorization Requests, Pushed Authorization Requests, Authorization Server Issuer Identification, as well as using custom params to any endpoint, and other important features that are often overlooked in other client libraries.</p> <p>And it also includes a wrapper around requests.Session that makes it super easy to use REST-style APIs, with or without OAuth 2.x.</p> <p>Please note that despite the name, this library has no relationship with Google oauth2client library.</p> <p> </p>"},{"location":"#documentation","title":"Documentation","text":"<p>Full module documentation is available at https://guillp.github.io/requests_oauth2client/</p>"},{"location":"#installation","title":"Installation","text":"<p><code>requests_oauth2client</code> is available from PyPi, so installing it is as easy as:</p> <pre><code>pip install requests_oauth2client\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Everything from <code>requests_oauth2client</code> is available from the root module, so you can import it like this:</p> <pre><code>from requests_oauth2client import *\n</code></pre> <p>Or you can import individual objects from this package as usual. Note that importing <code>*</code> automatically imports <code>requests</code>, so no need to import it yourself.</p>"},{"location":"#calling-apis-with-access-tokens","title":"Calling APIs with Access Tokens","text":"<p>If you already managed to obtain an access token for the API you want to call, you can simply convert it to an instance of BearerToken. Instances of that class work as a <code>requests</code> compatible auth handler.</p> <pre><code>import requests\nfrom requests_oauth2client import BearerToken\n\ntoken = BearerToken(\"my_access_token\")\nresp = requests.get(\"https://my.protected.api/endpoint\", auth=token)\n</code></pre> <p>This authentication handler will add a <code>Authorization: Bearer &lt;access_token&gt;</code> header in the request, with your access token, properly formatted according to RFC6750.</p>"},{"location":"#using-an-oauth2client","title":"Using an OAuth2Client","text":"<p>OAuth2Client offers several methods that implement the communication to the various endpoints that are standardised by OAuth 2.0 and its extensions. Those endpoints include the Token Endpoint, the Revocation, Introspection, UserInfo, BackChannel Authentication and Device Authorization Endpoints.</p> <p>You have to provide the URLs for those endpoints if you intend to use them. Otherwise, only the Token Endpoint is mandatory to initialize an <code>OAuth2Client</code>.</p> <p>To initialize an instance of <code>OAuth2Client</code>, you only need a Token Endpoint URI from your AS, and the credentials for your application, which are typically a <code>client_id</code> and a <code>client_secret</code>, usually also provided by the AS:</p> <pre><code>from requests_oauth2client import OAuth2Client\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    client_id=\"my_client_id\",\n    client_secret=\"my_client_secret\",\n)\n</code></pre> <p>The Token Endpoint is the only endpoint that is mandatory to obtain tokens. Credentials are used to authenticate the client everytime it sends a request to its Authorization Server. Usually, those are a static Client ID and Secret, which are the direct equivalent of a username and a password, but meant for an application instead of for a human user. The default authentication method used by <code>OAuth2Client</code> is Client Secret Post, but other standardised methods such as Client Secret Basic, Client Secret JWT or Private Key JWT are supported as well. See more about client authentication methods below.</p> <p>Instead of providing each endpoint URL yourself, you may also use the AS metadata endpoint URI, or the document data itself, to initialize your OAuth 2.0 client with the appropriate endpoints.</p>"},{"location":"#obtaining-tokens","title":"Obtaining tokens","text":"<p>OAuth2Client has dedicated methods to send requests to the Token Endpoint using the different standardised (and/or custom) grants. Since the Token Endpoint URL and Client Authentication Method to use are already declared for the client at init time, the only required parameters for those methods are those that will be sent in the request to the Token Endpoint.</p> <p>Those methods directly return a BearerToken if the request is successful, or raise an exception if it fails. BearerToken contains all the data as returned by the Token Endpoint, including the Access Token. It will:</p> <ul> <li>keep track of the Access Token expiration date (based on the <code>expires_in</code> hint as returned by the AS). This date is   accessible with the <code>expires_at</code> attribute.</li> <li>contain the Refresh Token, if returned by the AS, accessible with the <code>refresh_token</code> attribute.</li> <li>contain the ID Token, if returned by the AS, accessible with the <code>\u00ecd_token</code> attribute (when using the Authorization   Code flow).</li> <li>keep track of other associated metadata as well, also accessible as attributes with the same name:   <code>token.custom_attr</code>, or with subscription syntax <code>token[\"my.custom.attr\"]</code>.</li> </ul> <p>You can create such a BearerToken yourself if you need:</p> <pre><code>from requests_oauth2client import BearerToken\n\nbearer_token = BearerToken(access_token=\"an_access_token\", expires_in=60)\nprint(bearer_token)\n# {'access_token': 'an_access_token',\n#  'expires_in': 55,\n#  'token_type': 'Bearer'}\nprint(bearer_token.expires_at)\n# datetime.datetime(2021, 8, 20, 9, 56, 59, 498793)\nassert not bearer_token.is_expired()\n\nprint(bearer_token.expires_in)\n# 40\n</code></pre> <p>Note that the <code>expires_in</code> indicator here is not static. It keeps track of the token lifetime, in seconds, and is calculated as the time flies. The actual static expiration date is accessible with the <code>expires_at</code> property. You can check if a token is expired with bearer_token.is_expired().</p> <p>You can use a BearerToken instance anywhere you can use an access_token as string.</p>"},{"location":"#using-oauth2client-as-a-requests-auth-handler","title":"Using OAuth2Client as a requests Auth Handler","text":"<p>While using OAuth2Client directly is great for testing or debugging OAuth2.x flows, it is not a viable option for actual applications where tokens must be obtained, used during their lifetime then obtained again or refreshed once they are expired. <code>requests_oauth2client</code> contains several requests compatible Auth Handlers (as subclasses of requests.auth.AuthBase), that will take care of obtaining tokens when required, then will cache those tokens until they are expired, and will obtain new ones (or refresh them, when possible), once the initial token is expired. Those are best used with a requests.Session, or an ApiClient, which is a wrapper around <code>Session</code> with a few enhancements as described below.</p>"},{"location":"#client-credentials-grant","title":"Client Credentials grant","text":"<p>To send a request using the Client Credentials grant, use the aptly named .client_credentials() method, with the parameters to send in the token request as keyword parameters:</p> <pre><code>from requests_oauth2client import OAuth2Client\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\ntoken = oauth2client.client_credentials(scope=\"myscope\")\n# or, if your AS uses resource indicator:\ntoken = oauth2client.client_credentials(scope=\"myscope\", resource=\"https://myapi.local\")\n# or, if your AS uses 'audience' as parameter to identify the requested API (Auth0 style):\ntoken = oauth2client.client_credentials(audience=\"https://myapi.local\")\n# or, if your AS uses custom parameters:\ntoken = oauth2client.client_credentials(scope=\"myscope\", custom_param=\"custom_value\")\n</code></pre> <p>Parameters such as <code>scope</code>, <code>resource</code> or <code>audience</code> or any other parameter that may be required by the AS can be passed as keyword parameters. Those will be included in the token request that is sent to the AS. <code>scope</code> is not mandatory at client level (but it might be required by your AS to serve your request).</p>"},{"location":"#as-auth-handler","title":"As Auth Handler","text":"<p>You can use the OAuth2ClientCredentialsAuth auth handler. It takes an <code>OAuth2Client</code> as parameter, and the additional kwargs to pass to the token endpoint:</p> <pre><code>import requests\nfrom requests_oauth2client import OAuth2Client, OAuth2ClientCredentialsAuth\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\nauth = OAuth2ClientCredentialsAuth(\n    oauth2client, scope=\"myscope\", resource=\"https://myapi.local\"\n)\n\n# use it like this:\nrequests.get(\"https://myapi.local/resource\", auth=auth)\n\n# or like this:\nsession = requests.Session()\nsession.auth = auth\n\nresp = session.get(\"https://myapi.local/resource\")\n</code></pre> <p>Once again, extra parameters such as <code>scope</code>, <code>resource</code> or <code>audience</code> are allowed if required.</p> <p>When you send your first request, OAuth2ClientCredentialsAuth will automatically retrieve an access token from the AS using the Client Credentials grant, then will include it in the request. Next requests will use the same token, as long as it is valid. A new token will be automatically retrieved once the previous one is expired.</p> <p>You can configure a leeway, which is a period of time before the actual expiration, in seconds, when a new token will be obtained. This may help getting continuous access to the API when the client and API clocks are slightly out of sync. Use the parameter <code>leeway</code> to <code>OAuth2ClientCredentialsAuth</code>:</p> <pre><code>from requests_oauth2client import OAuth2ClientCredentialsAuth\n\nauth = OAuth2ClientCredentialsAuth(\n    oauth2client,\n    scope=\"myscope\",\n    leeway=30,\n)\n</code></pre>"},{"location":"#authorization-code-grant","title":"Authorization Code Grant","text":"<p>Obtaining tokens using the Authorization code grant is made in 3 steps:</p> <ol> <li> <p>your application must open a specific url called the Authentication Request in a browser.</p> </li> <li> <p>your application must obtain and validate the Authorization Response, which is a redirection back to your    application that contains an Authorization Code as parameter. This redirect back (often called \"callback\") is    initiated by the Authorization Server after any necessary interaction with the user is complete (Registration, Login,    Profile completion, Multi-Factor Authentication, Authorization, Consent, etc.)</p> </li> <li> <p>your application must then exchange this Authorization Code for an Access Token, with a request to the Token    Endpoint.</p> </li> </ol> <p>Using an <code>OAuth2Client</code> will help you with all those steps, as described below.</p>"},{"location":"#generating-authorization-requests","title":"Generating Authorization Requests","text":"<p>To be able to use the Authorization Code grant, you need 2 (optionally 3) URIs:</p> <ul> <li>the URL for Authorization Endpoint, which is the url where you must send your Authorization Requests</li> <li>the Redirect URI, which is the url pointing to your application, where the Authorization Server will reply with   Authorization Response</li> <li>optionally, the issuer identifier, if your AS uses   Issuer Identification.</li> </ul> <p>You can declare those URIs when initializing your <code>OAuth2Client</code> instance, or you can use the AS discovery endpoint to initialize those URLs automatically. Then you can generate valid Authorization Requests by calling the method <code>.authorization_request()</code>, with the request specific parameters, such as <code>scope</code>, <code>state</code>, <code>nonce</code> as parameter:</p> <pre><code>from requests_oauth2client import OAuth2Client\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endoint\",\n    authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n    redirect_uri=\"https://url.to.my.application/redirect_uri\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\naz_request = client.authorization_request(scope=\"openid email profile\")\n\nprint(az_request)\n# this will look like this, with line feeds for display purposes only:\n# https://url.to.the.as/authorization_endpoint\n# ?client_id=client_id\n# &amp;redirect_uri=https%3A%2F%2Furl.to.my.application%2Fredirect_uri\n# &amp;response_type=code\n# &amp;scope=openid+email+profile\n# &amp;state=FBx9mWeLwoKGgG76vhi6v61-4mgxmgZhtWIa7aTffdY\n# &amp;nonce=iHZJokhkGOAojff1tdknRyz9mPZyy5vq9JDlVaUHyqk\n# &amp;code_challenge=TG7qgdyKnwUPuoQ6NNJRlLMoHbeVmJlB8g0VOcfQEkc\n# &amp;code_challenge_method=S256\n\n# you can send the user to that url with:\nimport webbrowser\n\nwebbrowser.open(az_request.uri)\n</code></pre> <p>Note that the <code>state</code>, <code>nonce</code> and <code>code_challenge</code> parameters are generated with secure random values by default. Should you wish to use your own values, you can pass them as parameters to <code>OAuth2Client.authorization_request()</code>. For PKCE, you need to pass your generated <code>code_verifier</code>, and the <code>code_challenge</code> will automatically be derived from it. If you want to disable PKCE, you can pass <code>code_challenge_method=None</code> when initializing your <code>OAuth2Client</code>.</p>"},{"location":"#validating-the-authorization-response","title":"Validating the Authorization Response","text":"<p>Once you have redirected the user browser to the Authorization Request URI, and after the user is successfully authenticated and authorized, plus any other extra interactive step is complete, the AS will respond with a redirection to your redirect_uri. That is the Authorization Response. It contains several parameters that must be retrieved by your client. The Authorization Code is one of those parameters, but you must also validate that the state matches your request; if using AS Issuer Identification, you must also validate that the issuer matches what is expected. You can do this with:</p> <pre><code># using the `az_request` as defined above\n\nresponse_uri = input(\n    \"Please enter the full url and/or params obtained on the redirect_uri: \"\n)\n# say the callback url is https://url.to.my.application/redirect_uri?code=an_az_code&amp;state=FBx9mWeLwoKGgG76vhi6v61-4mgxmgZhtWIa7aTffdY&amp;issuer=https://url.to.the.as\naz_response = az_request.validate_callback(response_uri)\n</code></pre> <p>This <code>auth_response</code> is an <code>AuthorizationResponse</code> instance and contains everything that is needed for your application to complete the authentication and get its tokens from the AS.</p>"},{"location":"#exchanging-code-for-tokens","title":"Exchanging code for tokens","text":"<p>Once you have obtained the AS response, containing an authorization code, your application must exchange it for actual Token(s).</p> <p>To exchange a code for Access and/or ID tokens, use the OAuth2Client.authorization_code() method. If you have obtained an AuthorizationResponse as described above, you can simply do:</p> <pre><code>token = oauth2client.authorization_code(az_response)\n</code></pre> <p>This will automatically include the <code>code</code>, <code>redirect_uri</code> and <code>code_verifier</code> parameters in the Token Request, as expected by the AS. You may include extra parameters if required, or you may pass your own parameters, without using an <code>AuthorizationResponse</code> instance, like this:</p> <pre><code>token = oauth2client.authorization_code(\n    code=code,\n    code_verifier=code_verifier,\n    redirect_uri=redirect_uri,\n    custom_param=custom_value,\n)\n</code></pre>"},{"location":"#as-auth-handler_1","title":"As Auth Handler","text":"<p>The OAuth2AuthorizationCodeAuth handler takes an OAuth2Client and an authorization code as parameter, plus whatever additional keyword parameters are required by your Authorization Server:</p> <pre><code>from requests_oauth2client import OAuth2Client, ApiClient, OAuth2AuthorizationCodeAuth\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\napi_client = ApiClient(\n    \"https://your.protected.api/endpoint\",\n    auth=OAuth2AuthorizationCodeAuth(\n        oauth2client,\n        \"my_authorization_code\",\n    ),\n)\n\n# any request using api_client will trigger exchanging the code for an access_token, which is then cached, and refreshed later if needed\nresp = api_client.post(data={...})\n</code></pre> <p>OAuth2AuthorizationCodeAuth will take care of refreshing the token automatically once it is expired, using the refresh token, if available.</p>"},{"location":"#note-on-authorizationrequest","title":"Note on AuthorizationRequest","text":"<p>Authorization Requests generated by <code>OAuth2Client.authorization_request()</code> are instance of the class <code>AuthorizationRequest</code>. You can also use that class directly to generate your requests, but in that case you need to supply your Authorization Endpoint URI, your <code>client_id</code>, <code>redirect_uri</code>, etc. You can access every parameter from an <code>AuthorizationRequest</code> instance, as well as the generated <code>code_verifier</code>, as attributes of this instance. Once an Authorization Request URL is generated, it your application responsibility to redirect or otherwise send the user to that URL. You may use the <code>webbrowser</code> module from Python standard library to do so. Here is an example for generating Authorization Requests:</p> <pre><code>from requests_oauth2client import AuthorizationRequest\n\naz_request = AuthorizationRequest(\n    \"https://url.to.the/authorization_endpoint\",\n    client_id=\"my_client_id\",\n    redirect_uri=\"http://localhost/callback\",  # this redirect_uri is specific to your app\n    scope=\"openid email profile\",\n    # extra parameters such as `resource` can be included as well if required by your AS\n    resource=\"https://my.resource.local/api\",\n)\nprint(\n    az_request\n)  # this request will look like this, with line breaks for display purposes only\n# https://url.to.the/authorization_endpoint\n# ?client_id=my_client_id\n# &amp;redirect_uri=http%3A%2F%2Flocalhost%callback\n# &amp;response_type=code\n# &amp;state=kHWL4VwcbUbtPR4mtht6yMAGG_S-ZcBh5RxI_IGDmJc\n# &amp;nonce=mSGOS1M3LYU9ncTvvutoqUR4n1EtmaC_sQ3db4dyMAc\n# &amp;scope=openid+email+profile\n# &amp;code_challenge=W3n02f6xUKoDVbmhWEWz3h780b-Ci6ucnBS_d7nogmQ\n# &amp;code_challenge_method=S256\n# &amp;resource=https%3A%2F%2Fmy.resource.local%2Fapi\n\nprint(az_request.code_verifier)\n# 'gYK-ZnQfoat2bghwed7oEz--wvn4D70ksJ5GuWO9sXXygZ7PMnUlSpBmMCcNRHxdgTS9m_roYwGxF6HQxIqZVwXmxRJUziFHUFxDrNuUIjCJCx6gBhPlpFbUXulB1fo2'\n</code></pre>"},{"location":"#device-authorization-grant","title":"Device Authorization Grant","text":"<p>Helpers for the Device Authorization Grant are also included. To get device and user codes, read the response attributes (including Device Code, User Code, Verification URI, etc.), then pooling the Token Endpoint:</p> <pre><code>from requests_oauth2client import (\n    OAuth2Client,\n    DeviceAuthorizationPoolingJob,\n    BearerToken,\n)\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    device_authorization_endpoint=\"https://url.to.the/device_authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\nda_resp = client.authorize_device()\n\n# `da_resp` contains the Device Code, User Code, Verification URI and other info returned by the AS:\nda_resp.device_code\nda_resp.user_code\nda_resp.verification_uri\nda_resp.verification_uri_complete\nda_resp.expires_at  # just like for BearerToken, expiration is tracked by requests_oauth2client\nda_resp.interval\n\n# Send/show the Verification Uri and User Code to the user. He must use a browser to visit that url, authenticate and\n# input the User Code.\n\n# You can then request the Token endpoint to check if the user successfully authorized your device like this:\npool_job = DeviceAuthorizationPoolingJob(client, da_resp)\n\nresp = None\nwhile resp is None:\n    resp = pool_job()\n\nassert isinstance(resp, BearerToken)\n</code></pre> <p>DeviceAuthorizationPoolingJob will automatically obey the pooling period. Everytime you call <code>pool_job()</code>, it will wait the appropriate number of seconds as indicated by the AS, and will apply slow_down requests.</p>"},{"location":"#as-auth-handler_2","title":"As Auth Handler","text":"<p>Use OAuth2DeviceCodeAuth as auth handler to exchange a device code for an access token:</p> <pre><code>from requests_oauth2client import ApiClient, OAuth2DeviceCodeAuth, OAuth2Client\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    device_authorization_endpoint=\"https://url.to.the/device_authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\ndevice_auth_resp = client.authorize_device()\n\n# expose user_code and verification_uri or verification_uri_complete to the user\ndevice_auth_resp.user_code\ndevice_auth_resp.verification_uri\ndevice_auth_resp.verification_uri_complete\n\n# then try to send your request with a OAuth2DeviceCodeAuth handler\n# this will pool the token endpoint until the user authorize the device\napi_client = ApiClient(\n    \"https://your.protected.api/endpoint\",\n    auth=OAuth2DeviceCodeAuth(client, device_auth_resp),\n)\n\nresp = api_client.post(\n    data={...}\n)  # first call will hang until the user authorizes your app and the token endpoint returns a token.\n</code></pre>"},{"location":"#client-initiated-backchannel-authentication-ciba","title":"Client-Initiated BackChannel Authentication (CIBA)","text":"<p>To initiate a BackChannel Authentication against the dedicated endpoint, read the response attributes, and pool the Token Endpoint until the end-user successfully authenticates:</p> <pre><code>from requests_oauth2client import (\n    OAuth2Client,\n    BearerToken,\n    BackChannelAuthenticationPoolingJob,\n)\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    backchannel_authentication_endpoint=\"https://url.to.the/backchannel_authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\nba_resp = client.backchannel_authentication_request(\n    scope=\"openid email profile\",\n    login_hint=\"user@example.net\",\n)\n\n# `ba_resp` will contain the response attributes as returned by the AS, including an `auth_req_id`:\nba_resp.auth_req_id\nba_resp.expires_in  # decreases as times fly\nba_resp.expires_at  # a datetime to keep track of the expiration date, based on the \"expires_in\" returned by the AS\nba_resp.interval  # the pooling interval indicated by the AS\nba_resp.custom  # if the AS respond with additional attributes, they are also accessible\n\npool_job = BackChannelAuthenticationPoolingJob(client, ba_resp)\n\nresp = None\nwhile resp is None:\n    resp = pool_job()\n\nassert isinstance(resp, BearerToken)\n</code></pre> <p>Hints by the AS to slow down pooling will automatically be obeyed.</p>"},{"location":"#token-exchange","title":"Token Exchange","text":"<p>To send a token exchange request, use the OAuth2Client.token_exchange() method:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\ntoken = client.token_exchange(\n    subject_token=\"your_token_value\",\n    subject_token_type=\"urn:ietf:params:oauth:token-type:access_token\",\n)\n</code></pre> <p>As with the other grant-type specific methods, you may specify additional keyword parameters, that will be passed to the token endpoint, including any standardised attribute like <code>actor_token</code> or <code>actor_token_type</code>, or any custom parameter. There are short names for token types, that will be automatically translated to standardised types:</p> <pre><code>token = client.token_exchange(\n    subject_token=\"your_token_value\",\n    subject_token_type=\"access_token\",  # will be automatically replaced by \"urn:ietf:params:oauth:token-type:access_token\"\n    actor_token=\"your_actor_token\",\n    actor_token_type=\"id_token\",  # will be automatically replaced by \"urn:ietf:params:oauth:token-type:id_token\"\n)\n</code></pre> <p>Or to make it even easier, types can be guessed based on the supplied subject or actor token:</p> <pre><code>from requests_oauth2client import BearerToken, ClientSecretJwt, IdToken, OAuth2Client\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\ntoken = client.token_exchange(\n    subject_token=BearerToken(\n        \"your_token_value\"\n    ),  # subject_token_type will be \"urn:ietf:params:oauth:token-type:access_token\"\n    actor_token=IdToken(\n        \"your_actor_token\"\n    ),  # actor_token_type will be \"urn:ietf:params:oauth:token-type:id_token\"\n)\n</code></pre>"},{"location":"#supported-client-authentication-methods","title":"Supported Client Authentication Methods","text":"<p><code>requests_oauth2client</code> supports several client authentication methods, as defined in multiple OAuth2.x standards. You select the appropriate method to use when initializing your OAuth2Client, with the <code>auth</code> parameter. Once initialized, a client will automatically use the configured authentication method every time it sends a requested to an endpoint that requires client authentication. You don't have anything else to do afterwards.</p>"},{"location":"#client-secret-basic","title":"Client Secret Basic","text":"<p>With client_secret_basic, <code>client_id</code> and <code>client_secret</code> are included in clear-text in the <code>Authorization</code> header when sending requests to the Token Endpoint. To use it, just pass a <code>ClientSecretBasic(client_id, client_secret)</code> as <code>auth</code> parameter:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretBasic\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretBasic(\"client_id\", \"client_secret\"),\n)\n</code></pre>"},{"location":"#client-secret-post","title":"Client Secret Post","text":"<p>With client_secret_post, <code>client_id</code> and <code>client_secret</code> are included as part of the body form data. To use it, pass a <code>ClientSecretPost(client_id, client_secret)</code> as <code>auth</code> parameter. This is the default when you pass a tuple <code>(client_id, client_secret)</code> as <code>auth</code> when initializing an <code>OAuth2Client</code>:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretPost\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretPost(\"client_id\", \"client_secret\"),\n)\n# or\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=(\"client_id\", \"client_secret\")\n)\n# or\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    client_id=\"my_client_id\",\n    client_secret=\"my_client_secret\",\n)\n</code></pre>"},{"location":"#client-secret-jwt","title":"Client Secret JWT","text":"<p>With client_secret_jwt, the client generates an ephemeral JWT assertion including information about itself (client_id), the AS (url of the endpoint), and an expiration date a few seconds in the future. To use it, pass a <code>ClientSecretJwt(client_id, client_secret)</code> as <code>auth</code> parameter. Assertion generation is entirely automatic, you don't have anything to do:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n</code></pre> <p>This method is more secure than the 2 previous, because only ephemeral credentials are transmitted, which limits the possibility for interception and replay of the Client Secret. But that Client Secret still needs to be shared between the AS and Client owner(s).</p>"},{"location":"#private-key-jwt","title":"Private Key JWT","text":"<p>With private_key_jwt, client uses a JWT assertion that is just like the one for client_secret_jwt, but it is signed with an asymmetric key. To use it, you need a private signing key, in a <code>dict</code> that matches the JWK format, or as an instance of <code>jwskate.Jwk</code>. The matching public key must be registered for your client on AS side. Once you have that, using this auth method is simple with the <code>PrivateKeyJwt(client_id, private_jwk)</code> auth handler:</p> <pre><code>from requests_oauth2client import OAuth2Client, PrivateKeyJwt\n\nprivate_jwk = {\n    \"kid\": \"mykid\",\n    \"kty\": \"RSA\",\n    \"e\": \"AQAB\",\n    \"n\": \"...\",\n    \"d\": \"...\",\n    \"p\": \"...\",\n    \"q\": \"...\",\n    \"dp\": \"...\",\n    \"dq\": \"...\",\n    \"qi\": \"...\",\n}\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=PrivateKeyJwt(\"client_id\", private_jwk)\n)\n# or\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=(\"client_id\", private_jwk)\n)\n# or\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", client_id=\"client_id\", private_jwk=private_jwk\n)\n</code></pre> <p>This method can be considered more secure than those relying on a client secret, because only ephemeral credentials are sent over the wire, and it uses asymmetric cryptography: the signing key is generated by the client, and only the public key is known by the AS. Transmitting that public key between owner(s) of the client and of the AS is much easier than transmitting the Client Secret, which is a shared key that must be considered as confidential.</p>"},{"location":"#none","title":"None","text":"<p>The latest Client Authentication Method, none, is for Public Clients which do not authenticate to the Token Endpoint. Those clients only include their <code>client_id</code> in body form data, without any authentication credentials. Use <code>PublicApp(client_id)</code>:</p> <pre><code>from requests_oauth2client import OAuth2Client, PublicApp\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=PublicApp(\"app_client_id\")\n)\n</code></pre>"},{"location":"#token-revocation","title":"Token Revocation","text":"<p>OAuth2Client can send revocation requests to a Revocation Endpoint. You need to provide a Revocation Endpoint URI when creating the OAuth2Client. The OAuth2Client.revoke_token() method and its specialized aliases .revoke_access_token() and .revoke_refresh_token() are then available:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    revocation_endpoint=\"https://url.to.the/revocation_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\noauth2client.revoke_token(\"mytoken\", token_type_hint=\"access_token\")\noauth2client.revoke_access_token(\n    \"mytoken\"\n)  # will automatically add token_type_hint=access_token\noauth2client.revoke_refresh_token(\n    \"mytoken\"\n)  # will automatically add token_type_hint=refresh_token\n</code></pre> <p>Because Revocation Endpoints usually don't return meaningful responses, those methods return a boolean. This boolean indicates that a request was successfully sent and no error was returned. If the Authorization Server returns a non-successful HTTP code, but no standardised error message, it will return <code>False</code>. If the Authorization Server actually returns a standardised error, an exception will be raised instead, like the other methods from <code>OAuth2Client</code>.</p>"},{"location":"#token-introspection","title":"Token Introspection","text":"<p>OAuth2Client can send requests to a Token Introspection Endpoint. You need to provide an Introspection Endpoint URI when creating the <code>OAuth2Client</code>. The OAuth2Client.introspect_token() method is then available:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    introspection_endpoint=\"https://url.to.the/introspection_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\nresp = oauth2client.introspect_token(\"mytoken\", token_type_hint=\"access_token\")\n</code></pre> <p>It returns whatever data is returned by the introspection endpoint (if it is a JSON, its content is returned decoded).</p>"},{"location":"#userinfo-requests","title":"UserInfo Requests","text":"<p>OAuth2Client can send requests to an UserInfo Endpoint. You need to provide an UserInfo Endpoint URI when creating the <code>OAuth2Client</code>. The OAuth2Client.userinfo()) method is then available:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    userinfo_endpoint=\"https://url.to.the/userinfo_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\nresp = oauth2client.userinfo(\"mytoken\")\n</code></pre> <p>It returns whatever data is returned by the userinfo endpoint (if it is a JSON, its content is returned decoded).</p>"},{"location":"#initializing-an-oauth2client-from-a-discovery-document","title":"Initializing an <code>OAuth2Client</code> from a discovery document","text":"<p>You can initialize an OAuth2Client with the endpoint URIs mentioned in a standardised discovery document with the OAuth2Client.from_discovery_endpoint() class method:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client.from_discovery_endpoint(\n    \"https://url.to.the.as/.well-known/openid-configuration\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\n# OR, if you know the issuer value\noauth2client = OAuth2Client.from_discovery_endpoint(\n    issuer=\"https://url.to.the.as\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n</code></pre> <p>This will fetch the document from the specified URI, then will decode it and initialize an OAuth2Client pointing to the appropriate endpoint URIs.</p> <p>If using the <code>issuer</code> keyword arg, the URI to the discovery endpoint will be deduced from that identifier, and a check will be made that the <code>issuer</code> from the retrieved metadata document matches that value.</p>"},{"location":"#specialized-api-client","title":"Specialized API Client","text":"<p>Using APIs usually involves multiple endpoints under the same root url, with a common authentication method. To make it easier, <code>requests_oauth2client</code> includes a requests.Session wrapper called ApiClient, which takes the root API url as parameter on initialization. You can then send requests to different endpoints by passing their relative path instead of the full url. ApiClient also accepts an <code>auth</code> parameter with an AuthHandler. You can pass any of the OAuth2 Auth Handler from this module, or any requests-compatible Authentication Handler. Which makes it very easy to call APIs that are protected with an OAuth2 Client Credentials Grant:</p> <pre><code>from requests_oauth2client import OAuth2Client, ApiClient, OAuth2ClientCredentialsAuth\n\noauth2client = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", (\"client_id\", \"client_secret\")\n)\napi = ApiClient(\n    \"https://myapi.local/root\", auth=OAuth2ClientCredentialsAuth(oauth2client)\n)\n\n# will actually send a GET to https://myapi.local/root/resource/foo\nresp = api.get(\"/resource/foo\")\n</code></pre> <p>Note that ApiClient will never send requests \"outside\" its configured root url. The leading <code>/</code> in <code>/resource</code> above is optional. A leading <code>/</code> will not \"reset\" the url path to root, which means that you can also write the relative path without the <code>/</code> and it will automatically be included:</p> <pre><code>api.get(\"resource/foo\")  # will also send a GET to https://myapi.local/root/resource/foo\n</code></pre> <p>You may also pass the path as an iterable of strings (or string-able objects), in which case they will be joined with a <code>/</code> and appended to the url path:</p> <pre><code># will send a GET to https://myapi.local/root/resource/foo\napi.get([\"resource\", \"foo\"])\n# will send a GET to https://myapi.local/root/users/1234/details\napi.get([\"users\", 1234, \"details\"])\n</code></pre> <p>You can also use a syntax based on <code>__getattr__</code> or <code>__getitem__</code>:</p> <pre><code>api.resource.get()  # will send a GET to https://myapi.local/root/resource\napi[\"my-resource\"].get()  # will send a GET to https://myapi.local/root/my-resource\n</code></pre> <p>Both <code>__getattr__</code> and <code>__getitem__</code> return a new <code>ApiClient</code> initialised on the new base_url. So you can easily call multiple sub-resources on the same API this way:</p> <pre><code>from requests_oauth2client import ApiClient\n\napi = ApiClient(\"https://myapi.local\")\nusers_api = api.users\nuser = users_api.get(\"userid\")  # GET https://myapi.local/users/userid\nother_user = users_api.get(\"other_userid\")  # GET https://myapi.local/users/other_userid\nresources_api = api.resources\nresources = resources_api.get()  # GET https://myapi.local/resources\n</code></pre> <p>ApiClient will, by default, raise exceptions whenever a request returns an error status. You can disable that by passing <code>raise_for_status=False</code> when initializing your ApiClient:</p> <pre><code>from requests_oauth2client import ApiClient\n\napi = ApiClient(\n    \"http://httpstat.us\", raise_for_status=False\n)  # raise_for_status defaults to True\nresp = api.get(\"500\")\nassert resp is not None\n# without raise_for_status=False, a requests.exceptions.HTTPError exception would be raised instead\n</code></pre> <p>You may override this at request time:</p> <pre><code># raise_for_status at request-time overrides the value defined at init-time\nresp = api.get(\"500\", raise_for_status=True)\n</code></pre> <p>You can access the underlying <code>requests.Session</code> with the session attribute, and you can provide an already existing and configured <code>Session</code> instance at init time:</p> <pre><code>import requests\nfrom requests_oauth2client import ApiClient\n\nsession = requests.Session()\nsession.proxies = {\"https\": \"http://localhost:3128\"}\napi = ApiClient(\"https://myapi.local/resource\", session=session)\nassert api.session == session\n</code></pre>"},{"location":"#vendor-specific-clients","title":"Vendor-Specific clients","text":"<p><code>requests_oauth2client</code> is flexible enough to handle most use cases, so you should be able to use any AS by any vendor as long as it supports OAuth 2.0.</p> <p>You can however create a subclass of OAuth2Client or ApiClient to make it easier to use with specific Authorization Servers or APIs. OAuth2Client has several extensibility points in the form of methods like <code>OAuth2Client.parse_token_response()</code>, <code>OAuth2Client.on_token_error()</code> that implement response parsing, error handling, etc.</p> <pre><code>from requests_oauth2client.vendor_specific import Auth0\n\na0client = Auth0.client(\n    \"mytenant.eu\", client_id=\"client_id\", client_secret=\"client_secret\"\n)\n# this will automatically initialize the token endpoint to https://mytenant.eu.auth0.com/oauth/token\n# and other endpoints accordingly\ntoken = a0client.client_credentials(audience=\"audience\")\n\n# this is a wrapper around Auth0 Management API\na0mgmt = Auth0.management_api_client(\n    \"mytenant.eu\", client_id=\"client_id\", client_secret=\"client_secret\"\n)\nmyusers = a0mgmt.get(\"users\")\n</code></pre>"},{"location":"api/","title":"API","text":""},{"location":"api/#requests_oauth2client","title":"<code>requests_oauth2client</code>","text":"<p>Main module for <code>requests_oauth2client</code>.</p> <p>You can import any class from any submodule directly from this main module.</p>"},{"location":"api/#requests_oauth2client.ApiClient","title":"<code>ApiClient</code>","text":"<p>A Wrapper around requests.Session with extra features for REST API calls.</p> <p>Additional features compared to using a requests.Session directly:</p> <ul> <li>You must set a root url at creation time, which then allows passing relative urls at request time.</li> <li>It may also raise exceptions instead of returning error responses.</li> <li>You can also pass additional kwargs at init time, which will be used to configure the Session, instead of setting them later.</li> <li>for parameters passed as <code>json</code>, <code>params</code> or <code>data</code>, values that are <code>None</code> can be automatically discarded from the request</li> <li>boolean values in <code>data</code> or <code>params</code> fields can be serialized to values that are suitable for the target API, like <code>\"true\"</code>  or <code>\"false\"</code>, or <code>\"1\"</code> / <code>\"0\"</code>, instead of the default values <code>\"True\"</code> or <code>\"False\"</code>.</li> </ul> <p><code>base_url</code> will serve as root for relative urls passed to ApiClient.request(), ApiClient.get(), etc.</p> <p>A requests.HTTPError will be raised everytime an API call returns an error code (&gt;= 400), unless you set <code>raise_for_status</code> to <code>False</code>. Additional parameters passed at init time, including <code>auth</code> will be used to configure the Session.</p> Example <pre><code>from requests_oauth2client import ApiClient\n\napi = ApiClient(\"https://myapi.local/resource\", timeout=10)\nresp = api.get(\"/myid\")  # this will send a GET request\n# to https://myapi.local/resource/myid\n\n# you can pass an underlying requests.Session at init time\nsession = requests.Session()\nsession.proxies = {\"https\": \"https://localhost:3128\"}\napi = ApiClient(\"https://myapi.local/resource\", session=session)\n\n# or you can let ApiClient init its own session and provide additional configuration\n# parameters:\napi = ApiClient(\n    \"https://myapi.local/resource\",\n    proxies={\"https\": \"https://localhost:3128\"},\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>the base api url, that is the root for all the target API endpoints.</p> required <code>auth</code> <code>AuthBase | None</code> <p>the requests.auth.AuthBase to use as authentication handler.</p> <code>None</code> <code>timeout</code> <code>int | None</code> <p>the default timeout, in seconds, to use for each request from this <code>ApiClient</code>. Can be set to <code>None</code> to disable timeout.</p> <code>60</code> <code>raise_for_status</code> <code>bool</code> <p>if <code>True</code>, exceptions will be raised everytime a request returns an error code (&gt;= 400).</p> <code>True</code> <code>none_fields</code> <code>Literal['include', 'exclude', 'empty']</code> <p>defines what to do with parameters with value <code>None</code> in <code>data</code> or <code>json</code> fields.</p> <ul> <li>if <code>\"exclude\"</code> (default), fields whose values are <code>None</code> are not included in the request.</li> <li>if <code>\"include\"</code>, they are included with string value <code>None</code>. This is the default behavior of <code>requests</code>. Note that they will be serialized to <code>null</code> in JSON.</li> <li>if <code>\"empty\"</code>, they are included with an empty value (as an empty string).</li> </ul> <code>'exclude'</code> <code>bool_fields</code> <code>tuple[Any, Any] | None</code> <p>a tuple of <code>(true_value, false_value)</code>. Fields from <code>data</code> or <code>params</code> with a boolean value (<code>True</code> or <code>False</code>) will be serialized to the corresponding value. This can be useful since some APIs expect a <code>'true'</code> or <code>'false'</code> value as boolean, and <code>requests</code> serializes <code>True</code> to <code>'True'</code> and <code>False</code> to <code>'False'</code>. Set it to <code>None</code> to restore default requests behaviour.</p> <code>('true', 'false')</code> <code>session</code> <code>Session | None</code> <p>a preconfigured <code>requests.Session</code> to use with this <code>ApiClient</code>.</p> <code>None</code> <code>**session_kwargs</code> <code>Any</code> <p>additional kwargs to configure the underlying <code>requests.Session</code>.</p> <code>{}</code> <p>Raises:</p> Type Description <code>InvalidBoolFieldsParam</code> <p>if the provided <code>bool_fields</code> parameter is invalid.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>@frozen(init=False)\nclass ApiClient:\n    \"\"\"A Wrapper around [requests.Session][] with extra features for REST API calls.\n\n    Additional features compared to using a [requests.Session][] directly:\n\n    - You must set a root url at creation time, which then allows passing relative urls at request time.\n    - It may also raise exceptions instead of returning error responses.\n    - You can also pass additional kwargs at init time, which will be used to configure the\n    [Session][requests.Session], instead of setting them later.\n    - for parameters passed as `json`, `params` or `data`, values that are `None` can be\n    automatically discarded from the request\n    - boolean values in `data` or `params` fields can be serialized to values that are suitable\n    for the target API, like `\"true\"`  or `\"false\"`, or `\"1\"` / `\"0\"`, instead of the default\n    values `\"True\"` or `\"False\"`.\n\n    `base_url` will serve as root for relative urls passed to\n    [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request],\n    [ApiClient.get()][requests_oauth2client.api_client.ApiClient.get], etc.\n\n    A [requests.HTTPError][] will be raised everytime an API call returns an error code (&gt;= 400), unless\n    you set `raise_for_status` to `False`. Additional parameters passed at init time, including\n    `auth` will be used to configure the [Session][requests.Session].\n\n    Example:\n        ```python\n        from requests_oauth2client import ApiClient\n\n        api = ApiClient(\"https://myapi.local/resource\", timeout=10)\n        resp = api.get(\"/myid\")  # this will send a GET request\n        # to https://myapi.local/resource/myid\n\n        # you can pass an underlying requests.Session at init time\n        session = requests.Session()\n        session.proxies = {\"https\": \"https://localhost:3128\"}\n        api = ApiClient(\"https://myapi.local/resource\", session=session)\n\n        # or you can let ApiClient init its own session and provide additional configuration\n        # parameters:\n        api = ApiClient(\n            \"https://myapi.local/resource\",\n            proxies={\"https\": \"https://localhost:3128\"},\n        )\n        ```\n\n    Args:\n        base_url: the base api url, that is the root for all the target API endpoints.\n        auth: the [requests.auth.AuthBase][] to use as authentication handler.\n        timeout: the default timeout, in seconds, to use for each request from this `ApiClient`.\n            Can be set to `None` to disable timeout.\n        raise_for_status: if `True`, exceptions will be raised everytime a request returns an\n            error code (&gt;= 400).\n        none_fields: defines what to do with parameters with value `None` in `data` or `json` fields.\n\n            - if `\"exclude\"` (default), fields whose values are `None` are not included in the request.\n            - if `\"include\"`, they are included with string value `None`. This is\n            the default behavior of `requests`. Note that they will be serialized to `null` in JSON.\n            - if `\"empty\"`, they are included with an empty value (as an empty string).\n        bool_fields: a tuple of `(true_value, false_value)`. Fields from `data` or `params` with\n            a boolean value (`True` or `False`) will be serialized to the corresponding value.\n            This can be useful since some APIs expect a `'true'` or `'false'` value as boolean,\n            and `requests` serializes `True` to `'True'` and `False` to `'False'`.\n            Set it to `None` to restore default requests behaviour.\n        session: a preconfigured `requests.Session` to use with this `ApiClient`.\n        **session_kwargs: additional kwargs to configure the underlying `requests.Session`.\n\n    Raises:\n        InvalidBoolFieldsParam: if the provided `bool_fields` parameter is invalid.\n\n    \"\"\"\n\n    base_url: str\n    auth: requests.auth.AuthBase | None = None\n    timeout: int | None = 60\n    raise_for_status: bool = True\n    none_fields: Literal[\"include\", \"exclude\", \"empty\"] = \"exclude\"\n    bool_fields: tuple[Any, Any] | None = \"true\", \"false\"\n    session: requests.Session = field(factory=requests.Session)\n\n    def __init__(\n        self,\n        base_url: str,\n        *,\n        auth: requests.auth.AuthBase | None = None,\n        timeout: int | None = 60,\n        raise_for_status: bool = True,\n        none_fields: Literal[\"include\", \"exclude\", \"empty\"] = \"exclude\",\n        bool_fields: tuple[Any, Any] | None = (\"true\", \"false\"),\n        session: requests.Session | None = None,\n        **session_kwargs: Any,\n    ) -&gt; None:\n        session = session or requests.Session()\n        for key, val in session_kwargs.items():\n            setattr(session, key, val)\n\n        if bool_fields is None:\n            bool_fields = (\"True\", \"False\")\n        else:\n            validate_bool_fields(bool_fields)\n\n        self.__attrs_init__(\n            base_url=base_url,\n            auth=auth,\n            raise_for_status=raise_for_status,\n            none_fields=none_fields,\n            bool_fields=bool_fields,\n            timeout=timeout,\n            session=session,\n        )\n\n    def request(  # noqa: C901, PLR0913, D417\n        self,\n        method: str,\n        path: None | str | bytes | Iterable[str | bytes | int] = None,\n        *,\n        params: None | bytes | MutableMapping[str, str] = None,\n        data: (\n            Iterable[bytes]\n            | str\n            | bytes\n            | list[tuple[Any, Any]]\n            | tuple[tuple[Any, Any], ...]\n            | Mapping[Any, Any]\n            | None\n        ) = None,\n        headers: MutableMapping[str, str] | None = None,\n        cookies: None | RequestsCookieJar | MutableMapping[str, str] = None,\n        files: MutableMapping[str, IO[Any]] | None = None,\n        auth: (\n            None\n            | tuple[str, str]\n            | requests.auth.AuthBase\n            | Callable[[requests.PreparedRequest], requests.PreparedRequest]\n        ) = None,\n        timeout: None | float | tuple[float, float] | tuple[float, None] = None,\n        allow_redirects: bool = False,\n        proxies: MutableMapping[str, str] | None = None,\n        hooks: None\n        | (\n            MutableMapping[\n                str,\n                (Iterable[Callable[[requests.Response], Any]] | Callable[[requests.Response], Any]),\n            ]\n        ) = None,\n        stream: bool | None = None,\n        verify: str | bool | None = None,\n        cert: str | tuple[str, str] | None = None,\n        json: Mapping[str, Any] | None = None,\n        raise_for_status: bool | None = None,\n        none_fields: Literal[\"include\", \"exclude\", \"empty\"] | None = None,\n        bool_fields: tuple[Any, Any] | None = None,\n    ) -&gt; requests.Response:\n        \"\"\"A wrapper around [requests.Session.request][] method with extra features.\n\n        Additional features are described in\n        [ApiClient][requests_oauth2client.api_client.ApiClient] documentation.\n\n        All parameters will be passed as-is to [requests.Session.request][], expected those\n        described below which have a special behavior.\n\n        Args:\n          path: the url where the request will be sent to. Can be:\n\n            - a path, as `str`: that path will be joined to the configured API url,\n            - an iterable of path segments: that will be joined to the root url.\n          raise_for_status: like the parameter of the same name from\n            [ApiClient][requests_oauth2client.api_client.ApiClient],\n            but this will be applied for this request only.\n          none_fields: like the parameter of the same name from\n            [ApiClient][requests_oauth2client.api_client.ApiClient],\n            but this will be applied for this request only.\n          bool_fields: like the parameter of the same name from\n            [ApiClient][requests_oauth2client.api_client.ApiClient],\n            but this will be applied for this request only.\n\n        Returns:\n          a Response as returned by requests\n\n        Raises:\n            InvalidBoolFieldsParam: if the provided `bool_fields` parameter is invalid.\n\n        \"\"\"\n        path = self.to_absolute_url(path)\n\n        if none_fields is None:\n            none_fields = self.none_fields\n\n        if none_fields == \"exclude\":\n            if isinstance(data, Mapping):\n                data = {key: val for key, val in data.items() if val is not None}\n            if isinstance(json, Mapping):\n                json = {key: val for key, val in json.items() if val is not None}\n        elif none_fields == \"empty\":\n            if isinstance(data, Mapping):\n                data = {key: val if val is not None else \"\" for key, val in data.items()}\n            if isinstance(json, Mapping):\n                json = {key: val if val is not None else \"\" for key, val in json.items()}\n\n        if bool_fields is None:\n            bool_fields = self.bool_fields\n\n        if bool_fields:\n            true_value, false_value = validate_bool_fields(bool_fields)\n            if isinstance(data, MutableMapping):\n                for key, val in data.items():\n                    if val is True:\n                        data[key] = true_value\n                    elif val is False:\n                        data[key] = false_value\n            if isinstance(params, MutableMapping):\n                for key, val in params.items():\n                    if val is True:\n                        params[key] = true_value\n                    elif val is False:\n                        params[key] = false_value\n\n        timeout = timeout or self.timeout\n\n        response = self.session.request(\n            method,\n            path,\n            params=params,\n            data=data,\n            headers=headers,\n            cookies=cookies,\n            files=files,\n            auth=auth or self.auth,\n            timeout=timeout,\n            allow_redirects=allow_redirects,\n            proxies=proxies,\n            hooks=hooks,\n            stream=stream,\n            verify=verify,\n            cert=cert,\n            json=json,\n        )\n\n        if raise_for_status is None:\n            raise_for_status = self.raise_for_status\n        if raise_for_status:\n            response.raise_for_status()\n        return response\n\n    def to_absolute_url(self, path: None | str | bytes | Iterable[str | bytes | int] = None) -&gt; str:\n        \"\"\"Convert a relative url to an absolute url.\n\n        Given a `path`, return the matching absolute url, based on the `base_url` that is\n        configured for this API.\n\n        The result of this method is different from a standard `urljoin()`, because a relative_url\n        that starts with a \"/\" will not override the path from the base url. You can also pass an\n        iterable of path parts as relative url, which will be properly joined with \"/\". Those parts\n        may be `str` (which will be urlencoded) or `bytes` (which will be decoded as UTF-8 first) or\n        any other type (which will be converted to `str` first, using the `str() function`). See the\n        table below for example results which would exhibit most cases:\n\n        | base_url | relative_url | result_url |\n        |---------------------------|-----------------------------|-------------------------------------------|\n        | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `b\"/path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `\"path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `None` | `\"https://myhost.com/root\"` |\n        | `\"https://myhost.com/root\"` |  `(\"user\", 1, \"resource\")` | `\"https://myhost.com/root/user/1/resource\"` |\n        | `\"https://myhost.com/root\"` | `\"https://otherhost.org/foo\"` | `ValueError` |\n\n        Args:\n          path: a relative url\n\n        Returns:\n          the resulting absolute url\n\n        Raises:\n            InvalidPathParam: if the provided path does not allow constructing a valid url\n\n        \"\"\"\n        url = path\n\n        if url is None:\n            url = self.base_url\n        else:\n            if not isinstance(url, (str, bytes)):\n                try:\n                    url = \"/\".join(\n                        [urlencode(part.decode() if isinstance(part, bytes) else str(part)) for part in url if part],\n                    )\n                except Exception as exc:\n                    raise InvalidPathParam(url) from exc\n\n            if isinstance(url, bytes):\n                url = url.decode()\n\n            if \"://\" in url:\n                raise InvalidPathParam(url)\n\n            url = urljoin(self.base_url + \"/\", url.lstrip(\"/\"))\n\n        if url is None or not isinstance(url, str):\n            raise InvalidPathParam(url)  # pragma: no cover\n\n        return url\n\n    def get(\n        self,\n        path: None | str | bytes | Iterable[str | bytes | int] = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a GET request and return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n            path: the path where the request will be sent.\n            raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n            **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n            a response object.\n\n        Raises:\n            requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"GET\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def post(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a POST request and return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n          a response object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"POST\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def patch(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a PATCH request. Return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"PATCH\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def put(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a PUT request. Return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"PUT\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def delete(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a DELETE request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time. It takes the same\n        parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`.\n\n        Returns:\n          a response object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"DELETE\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def __getattr__(self, item: str) -&gt; ApiClient:\n        \"\"\"Allow access sub resources with an attribute-based syntax.\n\n        Args:\n            item: a subpath\n\n        Returns:\n            a new `ApiClient` initialized on the new base url\n\n        Example:\n            ```python\n            from requests_oauth2client import ApiClient\n\n            api = ApiClient(\"https://myapi.local\")\n            resource1 = api.resource1.get()  # GET https://myapi.local/resource1\n            resource2 = api.resource2.get()  # GET https://myapi.local/resource2\n            ```\n\n        \"\"\"\n        return self[item]\n\n    def __getitem__(self, item: str) -&gt; ApiClient:\n        \"\"\"Allow access to sub resources with a subscription-based syntax.\n\n        Args:\n            item: a subpath\n\n        Returns:\n            a new `ApiClient` initialized on the new base url\n\n        Example:\n            ```python\n            from requests_oauth2client import ApiClient\n\n            api = ApiClient(\"https://myapi.local\")\n            resource1 = api[\"resource1\"].get()  # GET https://myapi.local/resource1\n            resource2 = api[\"resource2\"].get()  # GET https://myapi.local/resource2\n            ```\n\n        \"\"\"\n        new_base_uri = self.to_absolute_url(item)\n        return ApiClient(\n            new_base_uri,\n            session=self.session,\n            none_fields=self.none_fields,\n            bool_fields=self.bool_fields,\n            timeout=self.timeout,\n            raise_for_status=self.raise_for_status,\n        )\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Allow `ApiClient` to act as a context manager.\n\n        You can then use an `ApiClient` instance in a `with` clause, the same way as\n        `requests.Session`. The underlying request.Session will be closed on exit.\n\n        Example:\n            ```python\n            with ApiClient(\"https://myapi.com/path\") as client:\n                resp = client.get(\"resource\")\n            ```\n\n        \"\"\"\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Close the underlying requests.Session on exit.\"\"\"\n        self.session.close()\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.request","title":"<code>request(method, path=None, *, params=None, data=None, headers=None, cookies=None, files=None, auth=None, timeout=None, allow_redirects=False, proxies=None, hooks=None, stream=None, verify=None, cert=None, json=None, raise_for_status=None, none_fields=None, bool_fields=None)</code>","text":"<p>A wrapper around requests.Session.request method with extra features.</p> <p>Additional features are described in ApiClient documentation.</p> <p>All parameters will be passed as-is to requests.Session.request, expected those described below which have a special behavior.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>the url where the request will be sent to. Can be:</p> <ul> <li>a path, as <code>str</code>: that path will be joined to the configured API url,</li> <li>an iterable of path segments: that will be joined to the root url.</li> </ul> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>like the parameter of the same name from ApiClient, but this will be applied for this request only.</p> <code>None</code> <code>none_fields</code> <code>Literal['include', 'exclude', 'empty'] | None</code> <p>like the parameter of the same name from ApiClient, but this will be applied for this request only.</p> <code>None</code> <code>bool_fields</code> <code>tuple[Any, Any] | None</code> <p>like the parameter of the same name from ApiClient, but this will be applied for this request only.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response as returned by requests</p> <p>Raises:</p> Type Description <code>InvalidBoolFieldsParam</code> <p>if the provided <code>bool_fields</code> parameter is invalid.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def request(  # noqa: C901, PLR0913, D417\n    self,\n    method: str,\n    path: None | str | bytes | Iterable[str | bytes | int] = None,\n    *,\n    params: None | bytes | MutableMapping[str, str] = None,\n    data: (\n        Iterable[bytes]\n        | str\n        | bytes\n        | list[tuple[Any, Any]]\n        | tuple[tuple[Any, Any], ...]\n        | Mapping[Any, Any]\n        | None\n    ) = None,\n    headers: MutableMapping[str, str] | None = None,\n    cookies: None | RequestsCookieJar | MutableMapping[str, str] = None,\n    files: MutableMapping[str, IO[Any]] | None = None,\n    auth: (\n        None\n        | tuple[str, str]\n        | requests.auth.AuthBase\n        | Callable[[requests.PreparedRequest], requests.PreparedRequest]\n    ) = None,\n    timeout: None | float | tuple[float, float] | tuple[float, None] = None,\n    allow_redirects: bool = False,\n    proxies: MutableMapping[str, str] | None = None,\n    hooks: None\n    | (\n        MutableMapping[\n            str,\n            (Iterable[Callable[[requests.Response], Any]] | Callable[[requests.Response], Any]),\n        ]\n    ) = None,\n    stream: bool | None = None,\n    verify: str | bool | None = None,\n    cert: str | tuple[str, str] | None = None,\n    json: Mapping[str, Any] | None = None,\n    raise_for_status: bool | None = None,\n    none_fields: Literal[\"include\", \"exclude\", \"empty\"] | None = None,\n    bool_fields: tuple[Any, Any] | None = None,\n) -&gt; requests.Response:\n    \"\"\"A wrapper around [requests.Session.request][] method with extra features.\n\n    Additional features are described in\n    [ApiClient][requests_oauth2client.api_client.ApiClient] documentation.\n\n    All parameters will be passed as-is to [requests.Session.request][], expected those\n    described below which have a special behavior.\n\n    Args:\n      path: the url where the request will be sent to. Can be:\n\n        - a path, as `str`: that path will be joined to the configured API url,\n        - an iterable of path segments: that will be joined to the root url.\n      raise_for_status: like the parameter of the same name from\n        [ApiClient][requests_oauth2client.api_client.ApiClient],\n        but this will be applied for this request only.\n      none_fields: like the parameter of the same name from\n        [ApiClient][requests_oauth2client.api_client.ApiClient],\n        but this will be applied for this request only.\n      bool_fields: like the parameter of the same name from\n        [ApiClient][requests_oauth2client.api_client.ApiClient],\n        but this will be applied for this request only.\n\n    Returns:\n      a Response as returned by requests\n\n    Raises:\n        InvalidBoolFieldsParam: if the provided `bool_fields` parameter is invalid.\n\n    \"\"\"\n    path = self.to_absolute_url(path)\n\n    if none_fields is None:\n        none_fields = self.none_fields\n\n    if none_fields == \"exclude\":\n        if isinstance(data, Mapping):\n            data = {key: val for key, val in data.items() if val is not None}\n        if isinstance(json, Mapping):\n            json = {key: val for key, val in json.items() if val is not None}\n    elif none_fields == \"empty\":\n        if isinstance(data, Mapping):\n            data = {key: val if val is not None else \"\" for key, val in data.items()}\n        if isinstance(json, Mapping):\n            json = {key: val if val is not None else \"\" for key, val in json.items()}\n\n    if bool_fields is None:\n        bool_fields = self.bool_fields\n\n    if bool_fields:\n        true_value, false_value = validate_bool_fields(bool_fields)\n        if isinstance(data, MutableMapping):\n            for key, val in data.items():\n                if val is True:\n                    data[key] = true_value\n                elif val is False:\n                    data[key] = false_value\n        if isinstance(params, MutableMapping):\n            for key, val in params.items():\n                if val is True:\n                    params[key] = true_value\n                elif val is False:\n                    params[key] = false_value\n\n    timeout = timeout or self.timeout\n\n    response = self.session.request(\n        method,\n        path,\n        params=params,\n        data=data,\n        headers=headers,\n        cookies=cookies,\n        files=files,\n        auth=auth or self.auth,\n        timeout=timeout,\n        allow_redirects=allow_redirects,\n        proxies=proxies,\n        hooks=hooks,\n        stream=stream,\n        verify=verify,\n        cert=cert,\n        json=json,\n    )\n\n    if raise_for_status is None:\n        raise_for_status = self.raise_for_status\n    if raise_for_status:\n        response.raise_for_status()\n    return response\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.to_absolute_url","title":"<code>to_absolute_url(path=None)</code>","text":"<p>Convert a relative url to an absolute url.</p> <p>Given a <code>path</code>, return the matching absolute url, based on the <code>base_url</code> that is configured for this API.</p> <p>The result of this method is different from a standard <code>urljoin()</code>, because a relative_url that starts with a \"/\" will not override the path from the base url. You can also pass an iterable of path parts as relative url, which will be properly joined with \"/\". Those parts may be <code>str</code> (which will be urlencoded) or <code>bytes</code> (which will be decoded as UTF-8 first) or any other type (which will be converted to <code>str</code> first, using the <code>str() function</code>). See the table below for example results which would exhibit most cases:</p> base_url relative_url result_url <code>\"https://myhost.com/root\"</code> <code>\"/path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>\"/path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>b\"/path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>\"path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>None</code> <code>\"https://myhost.com/root\"</code> <code>\"https://myhost.com/root\"</code> <code>(\"user\", 1, \"resource\")</code> <code>\"https://myhost.com/root/user/1/resource\"</code> <code>\"https://myhost.com/root\"</code> <code>\"https://otherhost.org/foo\"</code> <code>ValueError</code> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>a relative url</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the resulting absolute url</p> <p>Raises:</p> Type Description <code>InvalidPathParam</code> <p>if the provided path does not allow constructing a valid url</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def to_absolute_url(self, path: None | str | bytes | Iterable[str | bytes | int] = None) -&gt; str:\n    \"\"\"Convert a relative url to an absolute url.\n\n    Given a `path`, return the matching absolute url, based on the `base_url` that is\n    configured for this API.\n\n    The result of this method is different from a standard `urljoin()`, because a relative_url\n    that starts with a \"/\" will not override the path from the base url. You can also pass an\n    iterable of path parts as relative url, which will be properly joined with \"/\". Those parts\n    may be `str` (which will be urlencoded) or `bytes` (which will be decoded as UTF-8 first) or\n    any other type (which will be converted to `str` first, using the `str() function`). See the\n    table below for example results which would exhibit most cases:\n\n    | base_url | relative_url | result_url |\n    |---------------------------|-----------------------------|-------------------------------------------|\n    | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `b\"/path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `\"path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `None` | `\"https://myhost.com/root\"` |\n    | `\"https://myhost.com/root\"` |  `(\"user\", 1, \"resource\")` | `\"https://myhost.com/root/user/1/resource\"` |\n    | `\"https://myhost.com/root\"` | `\"https://otherhost.org/foo\"` | `ValueError` |\n\n    Args:\n      path: a relative url\n\n    Returns:\n      the resulting absolute url\n\n    Raises:\n        InvalidPathParam: if the provided path does not allow constructing a valid url\n\n    \"\"\"\n    url = path\n\n    if url is None:\n        url = self.base_url\n    else:\n        if not isinstance(url, (str, bytes)):\n            try:\n                url = \"/\".join(\n                    [urlencode(part.decode() if isinstance(part, bytes) else str(part)) for part in url if part],\n                )\n            except Exception as exc:\n                raise InvalidPathParam(url) from exc\n\n        if isinstance(url, bytes):\n            url = url.decode()\n\n        if \"://\" in url:\n            raise InvalidPathParam(url)\n\n        url = urljoin(self.base_url + \"/\", url.lstrip(\"/\"))\n\n    if url is None or not isinstance(url, str):\n        raise InvalidPathParam(url)  # pragma: no cover\n\n    return url\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.get","title":"<code>get(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a GET request and return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def get(\n    self,\n    path: None | str | bytes | Iterable[str | bytes | int] = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a GET request and return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n        path: the path where the request will be sent.\n        raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n        **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n        a response object.\n\n    Raises:\n        requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"GET\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.post","title":"<code>post(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a POST request and return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def post(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a POST request and return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n      a response object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"POST\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.patch","title":"<code>patch(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a PATCH request. Return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def patch(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a PATCH request. Return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"PATCH\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.put","title":"<code>put(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a PUT request. Return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def put(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a PUT request. Return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"PUT\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.delete","title":"<code>delete(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a DELETE request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def delete(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a DELETE request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time. It takes the same\n    parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`.\n\n    Returns:\n      a response object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"DELETE\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidBoolFieldsParam","title":"<code>InvalidBoolFieldsParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an invalid value is passed as 'bool_fields' parameter.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>class InvalidBoolFieldsParam(ValueError):\n    \"\"\"Raised when an invalid value is passed as 'bool_fields' parameter.\"\"\"\n\n    def __init__(self, bool_fields: object) -&gt; None:\n        super().__init__(\"\"\"\\\nInvalid value for 'bool_fields' parameter. It must be an iterable of 2 str values:\n- first one for the True value\n- second one for the False value\nboolean fields in `data` or `params` with a boolean value (`True` or `False`)\nwill be serialized to the corresponding value.\nDefault is `('true', 'false')`\nUse this parameter when the target API expects some other values, e.g.:\n- ('on', 'off')\n- ('1', '0')\n- ('yes', 'no')\n\"\"\")\n        self.value = bool_fields\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidPathParam","title":"<code>InvalidPathParam</code>","text":"<p>               Bases: <code>TypeError</code>, <code>ValueError</code></p> <p>Raised when an unexpected path is passed as 'url' parameter.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>class InvalidPathParam(TypeError, ValueError):\n    \"\"\"Raised when an unexpected path is passed as 'url' parameter.\"\"\"\n\n    def __init__(self, path: None | str | bytes | Iterable[str | bytes | int]) -&gt; None:\n        super().__init__(\"\"\"\\\nUnexpected path. Please provide a path that is relative to the configured `base_url`:\n- `None` (default) to call the base_url\n- a `str` or `bytes`, that will be joined to the base_url (with a / separator, if required)\n- or an iterable of string-able objects, which will be joined to the base_url with / separators\n\"\"\")\n        self.url = path\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseOAuth2RenewableTokenAuth","title":"<code>BaseOAuth2RenewableTokenAuth</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Base class for BearerToken-based Auth Handlers, with an obtainable or renewable token.</p> <p>In addition to adding a properly formatted <code>Authorization</code> header, this will obtain a new token once the current token is expired. Expiration is detected based on the <code>expires_in</code> hint returned by the AS. A configurable <code>leeway</code>, in number of seconds, will make sure that a new token is obtained some seconds before the actual expiration is reached. This may help in situations where the client, AS and RS have slightly offset clocks.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass BaseOAuth2RenewableTokenAuth(requests.auth.AuthBase):\n    \"\"\"Base class for BearerToken-based Auth Handlers, with an obtainable or renewable token.\n\n    In addition to adding a properly formatted `Authorization` header, this will obtain a new token\n    once the current token is expired. Expiration is detected based on the `expires_in` hint\n    returned by the AS. A configurable `leeway`, in number of seconds, will make sure that a new\n    token is obtained some seconds before the actual expiration is reached. This may help in\n    situations where the client, AS and RS have slightly offset clocks.\n\n    \"\"\"\n\n    client: OAuth2Client = field(on_setattr=setters.frozen)\n    token: BearerToken | None\n    leeway: int = field(on_setattr=setters.frozen)\n    token_kwargs: dict[str, Any] = field(on_setattr=setters.frozen)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the Access Token to the request.\n\n        If Access Token is not specified or expired, obtain a new one first.\n\n        Raises:\n            NonRenewableTokenError: if the token is not renewable\n\n        \"\"\"\n        if self.token is None or self.token.is_expired(self.leeway):\n            self.renew_token()\n        if self.token is None:\n            raise NonRenewableTokenError  # pragma: no cover\n        return self.token(request)\n\n    def renew_token(self) -&gt; None:\n        \"\"\"Obtain a new Bearer Token.\n\n        Subclasses should implement this.\n\n        \"\"\"\n        raise NotImplementedError\n\n    def forget_token(self) -&gt; None:\n        \"\"\"Forget the current token, forcing a renewal on the next HTTP request.\"\"\"\n        self.token = None\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseOAuth2RenewableTokenAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new Bearer Token.</p> <p>Subclasses should implement this.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def renew_token(self) -&gt; None:\n    \"\"\"Obtain a new Bearer Token.\n\n    Subclasses should implement this.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseOAuth2RenewableTokenAuth.forget_token","title":"<code>forget_token()</code>","text":"<p>Forget the current token, forcing a renewal on the next HTTP request.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def forget_token(self) -&gt; None:\n    \"\"\"Forget the current token, forcing a renewal on the next HTTP request.\"\"\"\n    self.token = None\n</code></pre>"},{"location":"api/#requests_oauth2client.NonRenewableTokenError","title":"<code>NonRenewableTokenError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when attempting to renew a token non-interactively when missing renewing material.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class NonRenewableTokenError(Exception):\n    \"\"\"Raised when attempting to renew a token non-interactively when missing renewing material.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2AccessTokenAuth","title":"<code>OAuth2AccessTokenAuth</code>","text":"<p>               Bases: <code>BaseOAuth2RefreshTokenAuth</code></p> <p>Authentication Handler for OAuth 2.0 Access Tokens and (optional) Refresh Tokens.</p> <p>This Requests Auth handler implementation uses an access token as Bearer token, and can automatically refresh it when expired, if a refresh token is available.</p> <p>Token can be a simple <code>str</code> containing a raw access token value, or a BearerToken that can contain a <code>refresh_token</code>. If a <code>refresh_token</code> and an expiration date are available (based on <code>expires_in</code> hint), this Auth Handler will automatically refresh the access token once it is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the client to use to refresh tokens.</p> required <code>token</code> <code>str | BearerToken</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> required <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds.</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import BearerToken, OAuth2Client, OAuth2AccessTokenAuth, requests\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n# obtain a BearerToken any way you see fit, optionally including a refresh token\n# for this example, the token value is hardcoded\ntoken = BearerToken(access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\")\nauth = OAuth2AccessTokenAuth(client, token, scope=\"my_scope\")\nresp = requests.post(\"https://my.api.local/resource\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2AccessTokenAuth(BaseOAuth2RefreshTokenAuth):\n    \"\"\"Authentication Handler for OAuth 2.0 Access Tokens and (optional) Refresh Tokens.\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation uses an access token as\n    Bearer token, and can automatically refresh it when expired, if a refresh token is available.\n\n    Token can be a simple `str` containing a raw access token value, or a\n    [BearerToken][requests_oauth2client.tokens.BearerToken] that can contain a `refresh_token`.\n    If a `refresh_token` and an expiration date are available (based on `expires_in` hint),\n    this Auth Handler will automatically refresh the access token once it is expired.\n\n    Args:\n        client: the client to use to refresh tokens.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds.\n        **token_kwargs: additional kwargs to pass to the token endpoint.\n\n    Example:\n        ```python\n        from requests_oauth2client import BearerToken, OAuth2Client, OAuth2AccessTokenAuth, requests\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        # obtain a BearerToken any way you see fit, optionally including a refresh token\n        # for this example, the token value is hardcoded\n        token = BearerToken(access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\")\n        auth = OAuth2AccessTokenAuth(client, token, scope=\"my_scope\")\n        resp = requests.post(\"https://my.api.local/resource\", auth=auth)\n        ```\n\n    \"\"\"\n\n    def __init__(\n        self, client: OAuth2Client, token: str | BearerToken, *, leeway: int = 20, **token_kwargs: Any\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(client=client, token=token, leeway=leeway, token_kwargs=token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2AuthorizationCodeAuth","title":"<code>OAuth2AuthorizationCodeAuth</code>","text":"<p>               Bases: <code>BaseOAuth2RefreshTokenAuth</code></p> <p>Authentication handler for the Authorization Code grant.</p> <p>This Requests Auth handler implementation exchanges an Authorization Code for an access token, then automatically refreshes it once it is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the client to use to obtain Access Tokens.</p> required <code>code</code> <code>str | AuthorizationResponse | None</code> <p>an Authorization Code that has been obtained from the AS.</p> required <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds.</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import ApiClient, OAuth2Client, OAuth2AuthorizationCodeAuth\n\nclient = OAuth2Client(token_endpoint=\"https://myas.local/token\", auth=(\"client_id\", \"client_secret\"))\ncode = \"my_code\"  # you must obtain this code yourself\napi = ApiClient(\"https://my.api.local/resource\", auth=OAuth2AuthorizationCodeAuth(client, code))\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2AuthorizationCodeAuth(BaseOAuth2RefreshTokenAuth):  # type: ignore[override]\n    \"\"\"Authentication handler for the [Authorization Code grant](https://www.rfc-editor.org/rfc/rfc6749#section-4.1).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges an Authorization\n    Code for an access token, then automatically refreshes it once it is expired.\n\n    Args:\n        client: the client to use to obtain Access Tokens.\n        code: an Authorization Code that has been obtained from the AS.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds.\n        **token_kwargs: additional kwargs to pass to the token endpoint.\n\n    Example:\n        ```python\n        from requests_oauth2client import ApiClient, OAuth2Client, OAuth2AuthorizationCodeAuth\n\n        client = OAuth2Client(token_endpoint=\"https://myas.local/token\", auth=(\"client_id\", \"client_secret\"))\n        code = \"my_code\"  # you must obtain this code yourself\n        api = ApiClient(\"https://my.api.local/resource\", auth=OAuth2AuthorizationCodeAuth(client, code))\n        ```\n\n    \"\"\"\n\n    code: str | AuthorizationResponse | None\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        code: str | AuthorizationResponse | None,\n        *,\n        leeway: int = 20,\n        token: str | BearerToken | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(\n            client=client,\n            token=token,\n            code=code,\n            leeway=leeway,\n            token_kwargs=token_kwargs,\n        )\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the Authorization Code grant as an Authentication Handler.\n\n        This exchanges an Authorization Code for an access token and adds it in the request.\n\n        Args:\n            request: the request\n\n        Returns:\n            the request, with an Access Token added in Authorization Header\n\n        \"\"\"\n        if self.token is None or self.token.is_expired():\n            self.exchange_code_for_token()\n        return super().__call__(request)\n\n    def exchange_code_for_token(self) -&gt; None:\n        \"\"\"Exchange the authorization code for an access token.\"\"\"\n        if self.code:  # pragma: no branch\n            self.token = self.client.authorization_code(code=self.code, **self.token_kwargs)\n            self.code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2AuthorizationCodeAuth.exchange_code_for_token","title":"<code>exchange_code_for_token()</code>","text":"<p>Exchange the authorization code for an access token.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def exchange_code_for_token(self) -&gt; None:\n    \"\"\"Exchange the authorization code for an access token.\"\"\"\n    if self.code:  # pragma: no branch\n        self.token = self.client.authorization_code(code=self.code, **self.token_kwargs)\n        self.code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2ClientCredentialsAuth","title":"<code>OAuth2ClientCredentialsAuth</code>","text":"<p>               Bases: <code>BaseOAuth2RenewableTokenAuth</code></p> <p>An Auth Handler for the Client Credentials grant.</p> <p>This requests AuthBase automatically gets Access Tokens from an OAuth 2.0 Token Endpoint with the Client Credentials grant, and will get a new one once the current one is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>extra kw parameters to pass to the Token Endpoint. May include <code>scope</code>, <code>resource</code>, etc.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import OAuth2Client, OAuth2ClientCredentialsAuth, requests\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\noauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\")\nresp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2ClientCredentialsAuth(BaseOAuth2RenewableTokenAuth):\n    \"\"\"An Auth Handler for the [Client Credentials grant](https://www.rfc-editor.org/rfc/rfc6749#section-4.4).\n\n    This [requests AuthBase][requests.auth.AuthBase] automatically gets Access Tokens from an OAuth\n    2.0 Token Endpoint with the Client Credentials grant, and will get a new one once the current\n    one is expired.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds\n        **token_kwargs: extra kw parameters to pass to the Token Endpoint. May include `scope`, `resource`, etc.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, OAuth2ClientCredentialsAuth, requests\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        oauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\")\n        resp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc)\n        ```\n\n    \"\"\"\n\n    def __init__(\n        self, client: OAuth2Client, *, leeway: int = 20, token: str | BearerToken | None = None, **token_kwargs: Any\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(client=client, token=token, leeway=leeway, token_kwargs=token_kwargs)\n\n    @override\n    def renew_token(self) -&gt; None:\n        \"\"\"Obtain a new token for use within this Auth Handler.\"\"\"\n        self.token = self.client.client_credentials(**self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2ClientCredentialsAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new token for use within this Auth Handler.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@override\ndef renew_token(self) -&gt; None:\n    \"\"\"Obtain a new token for use within this Auth Handler.\"\"\"\n    self.token = self.client.client_credentials(**self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2DeviceCodeAuth","title":"<code>OAuth2DeviceCodeAuth</code>","text":"<p>               Bases: <code>BaseOAuth2RefreshTokenAuth</code></p> <p>Authentication Handler for the Device Code Flow.</p> <p>This Requests Auth handler implementation exchanges a Device Code for an Access Token, then automatically refreshes it once it is expired.</p> <p>It needs a Device Code and an OAuth2Client to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a Device Code obtained from the AS.</p> required <code>interval</code> <code>int</code> <p>the interval to use to pool the Token Endpoint, in seconds.</p> <code>5</code> <code>expires_in</code> <code>int</code> <p>the lifetime of the token, in seconds.</p> <code>360</code> <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds.</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import OAuth2Client, OAuth2DeviceCodeAuth, requests\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\ndevice_code = client.device_authorization()\nauth = OAuth2DeviceCodeAuth(client, device_code)\nresp = requests.post(\"https://my.api.local/resource\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2DeviceCodeAuth(BaseOAuth2RefreshTokenAuth):  # type: ignore[override]\n    \"\"\"Authentication Handler for the [Device Code Flow](https://www.rfc-editor.org/rfc/rfc8628).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges a Device Code for\n    an Access Token, then automatically refreshes it once it is expired.\n\n    It needs a Device Code and an [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be\n    able to get a token from the AS Token Endpoint just before the first request using this Auth\n    Handler is being sent.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        device_code: a Device Code obtained from the AS.\n        interval: the interval to use to pool the Token Endpoint, in seconds.\n        expires_in: the lifetime of the token, in seconds.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds.\n        **token_kwargs: additional kwargs to pass to the token endpoint.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, OAuth2DeviceCodeAuth, requests\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        device_code = client.device_authorization()\n        auth = OAuth2DeviceCodeAuth(client, device_code)\n        resp = requests.post(\"https://my.api.local/resource\", auth=auth)\n        ```\n\n    \"\"\"\n\n    device_code: str | DeviceAuthorizationResponse\n    interval: int\n    expires_in: int\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        *,\n        device_code: str | DeviceAuthorizationResponse,\n        leeway: int = 20,\n        interval: int = 5,\n        expires_in: int = 360,\n        token: str | BearerToken | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(\n            client=client,\n            token=token,\n            leeway=leeway,\n            token_kwargs=token_kwargs,\n            device_code=device_code,\n            interval=interval,\n            expires_in=expires_in,\n        )\n\n    @override\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the Device Code grant as a request Authentication Handler.\n\n        This exchanges a Device Code for an access token and adds it in HTTP requests.\n\n        Args:\n            request: a [requests.PreparedRequest][]\n\n        Returns:\n            a [requests.PreparedRequest][] with an Access Token added in Authorization Header\n\n        \"\"\"\n        if self.token is None:\n            self.exchange_device_code_for_token()\n        return super().__call__(request)\n\n    def exchange_device_code_for_token(self) -&gt; None:\n        \"\"\"Exchange the Device Code for an access token.\n\n        This will poll the Token Endpoint until the user finishes the authorization process.\n\n        \"\"\"\n        from .device_authorization import DeviceAuthorizationPoolingJob\n\n        if self.device_code:  # pragma: no branch\n            pooling_job = DeviceAuthorizationPoolingJob(\n                client=self.client,\n                device_code=self.device_code,\n                interval=self.interval,\n            )\n            token = None\n            while token is None:\n                token = pooling_job()\n            self.token = token\n            self.device_code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2DeviceCodeAuth.exchange_device_code_for_token","title":"<code>exchange_device_code_for_token()</code>","text":"<p>Exchange the Device Code for an access token.</p> <p>This will poll the Token Endpoint until the user finishes the authorization process.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def exchange_device_code_for_token(self) -&gt; None:\n    \"\"\"Exchange the Device Code for an access token.\n\n    This will poll the Token Endpoint until the user finishes the authorization process.\n\n    \"\"\"\n    from .device_authorization import DeviceAuthorizationPoolingJob\n\n    if self.device_code:  # pragma: no branch\n        pooling_job = DeviceAuthorizationPoolingJob(\n            client=self.client,\n            device_code=self.device_code,\n            interval=self.interval,\n        )\n        token = None\n        while token is None:\n            token = pooling_job()\n        self.token = token\n        self.device_code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2ResourceOwnerPasswordAuth","title":"<code>OAuth2ResourceOwnerPasswordAuth</code>","text":"<p>               Bases: <code>BaseOAuth2RenewableTokenAuth</code></p> <p>Authentication Handler for the Resource Owner Password Credentials Flow.</p> <p>This Requests Auth handler implementation exchanges the user credentials for an Access Token, then automatically repeats the process to get a new one once the current one is expired.</p> <p>Note that this flow is considered deprecated, and the Authorization Code flow should be used whenever possible. Among other bad things, ROPC:</p> <ul> <li>does not support SSO between multiple apps,</li> <li>does not support MFA or risk-based adaptative authentication,</li> <li>depends on the user typing its credentials directly inside the application, instead of on a dedicated, centralized login page managed by the AS, which makes it totally insecure for 3rd party apps.</li> </ul> <p>It needs the username and password and an OAuth2Client to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the client to use to obtain Access Tokens</p> required <code>username</code> <code>str</code> <p>the username</p> required <code>password</code> <code>str</code> <p>the user password</p> required <code>leeway</code> <code>int</code> <p>an amount of time, in seconds</p> <code>20</code> <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint</p> <code>{}</code> Example <pre><code>from requests_oauth2client import ApiClient, OAuth2Client, OAuth2ResourceOwnerPasswordAuth\n\nclient = OAuth2Client(\n    token_endpoint=\"https://myas.local/token\",\n    auth=(\"client_id\", \"client_secret\"),\n)\nusername = \"my_username\"\npassword = \"my_password\"  # you must obtain those credentials from the user\nauth = OAuth2ResourceOwnerPasswordAuth(client, username=username, password=password)\napi = ApiClient(\"https://myapi.local\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2ResourceOwnerPasswordAuth(BaseOAuth2RenewableTokenAuth):  # type: ignore[override]\n    \"\"\"Authentication Handler for the [Resource Owner Password Credentials Flow](https://www.rfc-editor.org/rfc/rfc6749#section-4.3).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges the user\n    credentials for an Access Token, then automatically repeats the process to get a new one\n    once the current one is expired.\n\n    Note that this flow is considered *deprecated*, and the Authorization Code flow should be\n    used whenever possible.\n    Among other bad things, ROPC:\n\n    - does not support SSO between multiple apps,\n    - does not support MFA or risk-based adaptative authentication,\n    - depends on the user typing its credentials directly inside the application, instead of on a\n    dedicated, centralized login page managed by the AS, which makes it totally insecure for 3rd party apps.\n\n    It needs the username and password and an\n    [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be able to get a token from\n    the AS Token Endpoint just before the first request using this Auth Handler is being sent.\n\n    Args:\n        client: the client to use to obtain Access Tokens\n        username: the username\n        password: the user password\n        leeway: an amount of time, in seconds\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        **token_kwargs: additional kwargs to pass to the token endpoint\n\n    Example:\n        ```python\n        from requests_oauth2client import ApiClient, OAuth2Client, OAuth2ResourceOwnerPasswordAuth\n\n        client = OAuth2Client(\n            token_endpoint=\"https://myas.local/token\",\n            auth=(\"client_id\", \"client_secret\"),\n        )\n        username = \"my_username\"\n        password = \"my_password\"  # you must obtain those credentials from the user\n        auth = OAuth2ResourceOwnerPasswordAuth(client, username=username, password=password)\n        api = ApiClient(\"https://myapi.local\", auth=auth)\n        ```\n    \"\"\"\n\n    username: str\n    password: str\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        *,\n        username: str,\n        password: str,\n        leeway: int = 20,\n        token: str | BearerToken | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(\n            client=client,\n            token=token,\n            leeway=leeway,\n            token_kwargs=token_kwargs,\n            username=username,\n            password=password,\n        )\n\n    @override\n    def renew_token(self) -&gt; None:\n        \"\"\"Exchange the user credentials for an Access Token.\"\"\"\n        self.token = self.client.resource_owner_password(\n            username=self.username,\n            password=self.password,\n            **self.token_kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2ResourceOwnerPasswordAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Exchange the user credentials for an Access Token.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@override\ndef renew_token(self) -&gt; None:\n    \"\"\"Exchange the user credentials for an Access Token.\"\"\"\n    self.token = self.client.resource_owner_password(\n        username=self.username,\n        password=self.password,\n        **self.token_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest","title":"<code>AuthorizationRequest</code>","text":"<p>Represent an Authorization Request.</p> <p>This class makes it easy to generate valid Authorization Request URI (possibly including a state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization Response.</p> <p>All parameters passed at init time will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour:</p> <ul> <li><code>state</code>: if <code>...</code> (default), a random <code>state</code> parameter will be generated for you.   You may pass your own <code>state</code> as <code>str</code>, or set it to <code>None</code> so that the <code>state</code> parameter   will not be included in the request. You may access that state in the <code>state</code> attribute   from this request.</li> <li><code>nonce</code>: if <code>...</code> (default) and <code>scope</code> includes 'openid', a random <code>nonce</code> will be   generated and included in the request. You may access that <code>nonce</code> in the <code>nonce</code> attribute   from this request.</li> <li><code>code_verifier</code>: if <code>None</code>, and <code>code_challenge_method</code> is <code>'S256'</code> or <code>'plain'</code>,   a valid <code>code_challenge</code> and <code>code_verifier</code> for PKCE will be automatically generated,   and the <code>code_challenge</code> will be included in the request.   You may pass your own <code>code_verifier</code> as a <code>str</code> parameter, in which case the   appropriate <code>code_challenge</code> will be included in the request, according to the   <code>code_challenge_method</code>.</li> <li> <p><code>authorization_response_iss_parameter_supported</code> and <code>issuer</code>:    those are used for Server Issuer Identification. By default:</p> <ul> <li>If <code>\u00ecssuer</code> is set and an issuer is included in the Authorization Response, then the consistency between those 2 values will be checked when using <code>validate_callback()</code>.</li> <li>If issuer is not included in the response, then no issuer check is performed.</li> </ul> <p>Set <code>authorization_response_iss_parameter_supported</code> to <code>True</code> to enforce server identification:</p> <ul> <li>an <code>issuer</code> must also be provided as parameter, and the AS must return that same value for the response to be considered valid by <code>validate_callback()</code>.</li> <li>if no issuer is included in the Authorization Response, then an error will be raised.</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the uri for the authorization endpoint.</p> required <code>client_id</code> <code>str</code> <p>the client_id to include in the request.</p> required <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri to include in the request. This is required in OAuth 2.0 and optional in OAuth 2.1. Pass <code>None</code> if you don't need any redirect_uri in the Authorization Request.</p> <code>None</code> <code>scope</code> <code>None | str | Iterable[str]</code> <p>the scope to include in the request, as an iterable of <code>str</code>, or a single space-separated <code>str</code>.</p> <code>'openid'</code> <code>response_type</code> <code>str</code> <p>the response type to include in the request.</p> <code>CODE</code> <code>state</code> <code>str | ellipsis | None</code> <p>the state to include in the request, or <code>...</code> to autogenerate one (default).</p> <code>...</code> <code>nonce</code> <code>str | ellipsis | None</code> <p>the nonce to include in the request, or <code>...</code> to autogenerate one (default).</p> <code>...</code> <code>code_verifier</code> <code>str | None</code> <p>the code verifier to include in the request. If left as <code>None</code> and <code>code_challenge_method</code> is set, a valid code_verifier will be generated.</p> <code>None</code> <code>code_challenge_method</code> <code>str | None</code> <p>the method to use to derive the <code>code_challenge</code> from the <code>code_verifier</code>.</p> <code>S256</code> <code>acr_values</code> <code>str | Iterable[str] | None</code> <p>requested Authentication Context Class Reference values.</p> <code>None</code> <code>issuer</code> <code>str | None</code> <p>Issuer Identifier value from the OAuth/OIDC Server, if using Server Issuer Identification.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>extra parameters to include in the request, as-is.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import AuthorizationRequest\n\nazr = AuthorizationRequest(\n    authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n    client_id=\"my_client_id\",\n    redirect_uri=\"http://localhost/callback\",\n    scope=\"openid email profile\",\n)\nprint(azr)\n</code></pre> <p>Raises:</p> Type Description <code>InvalidMaxAgeParam</code> <p>if the <code>max_age</code> parameter is invalid.</p> <code>MissingIssuerParam</code> <p>if <code>authorization_response_iss_parameter_supported</code> is set to <code>True</code> but the <code>issuer</code> parameter is not provided.</p> <code>UnsupportedResponseTypeParam</code> <p>if <code>response_type</code> is not supported.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False, repr=False)\nclass AuthorizationRequest:\n    \"\"\"Represent an Authorization Request.\n\n    This class makes it easy to generate valid Authorization Request URI (possibly including a\n    state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization\n    Response.\n\n    All parameters passed at init time will be included in the request query parameters as-is,\n    excepted for a few parameters which have a special behaviour:\n\n    - `state`: if `...` (default), a random `state` parameter will be generated for you.\n      You may pass your own `state` as `str`, or set it to `None` so that the `state` parameter\n      will not be included in the request. You may access that state in the `state` attribute\n      from this request.\n    - `nonce`: if `...` (default) and `scope` includes 'openid', a random `nonce` will be\n      generated and included in the request. You may access that `nonce` in the `nonce` attribute\n      from this request.\n    - `code_verifier`: if `None`, and `code_challenge_method` is `'S256'` or `'plain'`,\n      a valid `code_challenge` and `code_verifier` for PKCE will be automatically generated,\n      and the `code_challenge` will be included in the request.\n      You may pass your own `code_verifier` as a `str` parameter, in which case the\n      appropriate `code_challenge` will be included in the request, according to the\n      `code_challenge_method`.\n    - `authorization_response_iss_parameter_supported` and `issuer`:\n       those are used for Server Issuer Identification. By default:\n\n        - If `\u00ecssuer` is set and an issuer is included in the Authorization Response,\n        then the consistency between those 2 values will be checked when using `validate_callback()`.\n        - If issuer is not included in the response, then no issuer check is performed.\n\n        Set `authorization_response_iss_parameter_supported` to `True` to enforce server identification:\n\n        - an `issuer` must also be provided as parameter, and the AS must return that same value\n        for the response to be considered valid by `validate_callback()`.\n        - if no issuer is included in the Authorization Response, then an error will be raised.\n\n    Args:\n        authorization_endpoint: the uri for the authorization endpoint.\n        client_id: the client_id to include in the request.\n        redirect_uri: the redirect_uri to include in the request. This is required in OAuth 2.0 and optional\n            in OAuth 2.1. Pass `None` if you don't need any redirect_uri in the Authorization\n            Request.\n        scope: the scope to include in the request, as an iterable of `str`, or a single space-separated `str`.\n        response_type: the response type to include in the request.\n        state: the state to include in the request, or `...` to autogenerate one (default).\n        nonce: the nonce to include in the request, or `...` to autogenerate one (default).\n        code_verifier: the code verifier to include in the request.\n            If left as `None` and `code_challenge_method` is set, a valid code_verifier\n            will be generated.\n        code_challenge_method: the method to use to derive the `code_challenge` from the `code_verifier`.\n        acr_values: requested Authentication Context Class Reference values.\n        issuer: Issuer Identifier value from the OAuth/OIDC Server, if using Server Issuer Identification.\n        **kwargs: extra parameters to include in the request, as-is.\n\n    Example:\n        ```python\n        from requests_oauth2client import AuthorizationRequest\n\n        azr = AuthorizationRequest(\n            authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n            client_id=\"my_client_id\",\n            redirect_uri=\"http://localhost/callback\",\n            scope=\"openid email profile\",\n        )\n        print(azr)\n        ```\n\n    Raises:\n        InvalidMaxAgeParam: if the `max_age` parameter is invalid.\n        MissingIssuerParam: if `authorization_response_iss_parameter_supported` is set to `True`\n            but the `issuer` parameter is not provided.\n        UnsupportedResponseTypeParam: if `response_type` is not supported.\n\n    \"\"\"\n\n    authorization_endpoint: str\n\n    client_id: str = field(metadata={\"query\": True})\n    redirect_uri: str | None = field(metadata={\"query\": True}, default=None)\n    scope: tuple[str, ...] | None = field(metadata={\"query\": True}, default=(\"openid\",))\n    response_type: str = field(metadata={\"query\": True}, default=ResponseTypes.CODE)\n    state: str | None = field(metadata={\"query\": True}, default=None)\n    nonce: str | None = field(metadata={\"query\": True}, default=None)\n    code_challenge_method: str | None = field(metadata={\"query\": True}, default=CodeChallengeMethods.S256)\n    acr_values: tuple[str, ...] | None = field(metadata={\"query\": True}, default=None)\n    max_age: int | None = field(metadata={\"query\": True}, default=None)\n    kwargs: dict[str, Any] = Factory(dict)\n\n    code_verifier: str | None = None\n    code_challenge: str | None = field(init=False, metadata={\"query\": True})\n    authorization_response_iss_parameter_supported: bool = False\n    issuer: str | None = None\n\n    exception_classes: ClassVar[dict[str, type[AuthorizationResponseError]]] = {\n        \"interaction_required\": InteractionRequired,\n        \"login_required\": LoginRequired,\n        \"session_selection_required\": SessionSelectionRequired,\n        \"consent_required\": ConsentRequired,\n    }\n\n    @classmethod\n    def generate_state(cls) -&gt; str:\n        \"\"\"Generate a random `state` parameter.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    @classmethod\n    def generate_nonce(cls) -&gt; str:\n        \"\"\"Generate a random `nonce`.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    def __init__(  # noqa: PLR0913, C901\n        self,\n        authorization_endpoint: str,\n        *,\n        client_id: str,\n        redirect_uri: str | None = None,\n        scope: None | str | Iterable[str] = \"openid\",\n        response_type: str = ResponseTypes.CODE,\n        state: str | ellipsis | None = ...,  # noqa: F821\n        nonce: str | ellipsis | None = ...,  # noqa: F821\n        code_verifier: str | None = None,\n        code_challenge_method: str | None = CodeChallengeMethods.S256,\n        acr_values: str | Iterable[str] | None = None,\n        max_age: int | None = None,\n        issuer: str | None = None,\n        authorization_response_iss_parameter_supported: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        if response_type != ResponseTypes.CODE:\n            raise UnsupportedResponseTypeParam(response_type)\n\n        if authorization_response_iss_parameter_supported and not issuer:\n            raise MissingIssuerParam\n\n        if state is ...:\n            state = self.generate_state()\n        if state is not None and not isinstance(state, str):\n            state = str(state)  # pragma: no cover\n\n        if nonce is ...:\n            nonce = self.generate_nonce() if scope is not None and \"openid\" in scope else None\n        if nonce is not None and not isinstance(nonce, str):\n            nonce = str(nonce)  # pragma: no cover\n\n        if not scope:\n            scope = None\n\n        if scope is not None:\n            scope = tuple(scope.split(\" \")) if isinstance(scope, str) else tuple(scope)\n\n        if acr_values is not None:\n            acr_values = tuple(acr_values.split()) if isinstance(acr_values, str) else tuple(acr_values)\n\n        if max_age is not None and max_age &lt; 0:\n            raise InvalidMaxAgeParam\n\n        if \"code_challenge\" in kwargs:\n            msg = (\n                \"A `code_challenge` must not be passed as parameter. Pass the `code_verifier`\"\n                \" instead, and the appropriate `code_challenge` will automatically be derived\"\n                \" from it and included in the request, based on `code_challenge_method`.\"\n            )\n            raise ValueError(msg)\n\n        code_challenge: str | None = None\n        if code_challenge_method:\n            if not code_verifier:\n                code_verifier = PkceUtils.generate_code_verifier()\n            code_challenge = PkceUtils.derive_challenge(code_verifier, code_challenge_method)\n        else:\n            code_verifier = None\n\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            redirect_uri=redirect_uri,\n            issuer=issuer,\n            response_type=response_type,\n            scope=scope,\n            state=state,\n            nonce=nonce,\n            code_verifier=code_verifier,\n            code_challenge_method=code_challenge_method,\n            acr_values=acr_values,\n            max_age=max_age,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            kwargs=kwargs,\n        )\n        object.__setattr__(self, \"code_challenge\", code_challenge)\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the full argument dict.\n\n        This can be used to serialize this request and/or to initialize a similar request.\n\n        \"\"\"\n        d = asdict(self)\n        d.update(**d.pop(\"kwargs\", {}))\n        d.pop(\"code_challenge\")\n        return d\n\n    @property\n    def args(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dict with all the query parameters from this AuthorizationRequest.\n\n        Returns:\n            a dict of parameters\n\n        \"\"\"\n        d = {field.name: getattr(self, field.name) for field in fields(type(self)) if field.metadata.get(\"query\")}\n        if d[\"scope\"]:\n            d[\"scope\"] = \" \".join(d[\"scope\"])\n        d.update(self.kwargs)\n\n        return {key: val for key, val in d.items() if val is not None}\n\n    def validate_callback(self, response: str) -&gt; AuthorizationResponse:\n        \"\"\"Validate an Authorization Response against this Request.\n\n        Validate a given Authorization Response URI against this Authorization Request, and return\n        an\n        [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse].\n\n        This includes matching the `state` parameter, checking for returned errors, and extracting\n        the returned `code` and other parameters.\n\n        Args:\n            response: the Authorization Response URI. This can be the full URL, or just the\n                query parameters (still encoded as x-www-form-urlencoded).\n\n        Returns:\n            the extracted code, if all checks are successful\n\n        Raises:\n            MissingAuthCode: if the `code` is missing in the response\n            MissingIssuer: if Server Issuer verification is active and the response does\n                not contain an `iss`.\n            MismatchingIssuer: if the 'iss' received from the response does not match the\n                expected value.\n            MismatchingState: if the response `state` does not match the expected value.\n            OAuth2Error: if the response includes an error.\n            MissingAuthCode: if the response does not contain a `code`.\n            UnsupportedResponseTypeParam: if response_type anything else than 'code'.\n\n        \"\"\"\n        try:\n            response_url = furl(response)\n        except ValueError:\n            return self.on_response_error(response)\n\n        # validate 'iss' according to RFC9207\n        received_issuer = response_url.args.get(\"iss\")\n        if self.authorization_response_iss_parameter_supported or received_issuer:\n            if received_issuer is None:\n                raise MissingIssuer(self, response)\n            if self.issuer and received_issuer != self.issuer:\n                raise MismatchingIssuer(self.issuer, received_issuer, self, response)\n\n        # validate state\n        requested_state = self.state\n        if requested_state:\n            received_state = response_url.args.get(\"state\")\n            if requested_state != received_state:\n                raise MismatchingState(requested_state, received_state, self, response)\n\n        error = response_url.args.get(\"error\")\n        if error:\n            return self.on_response_error(response)\n\n        if self.response_type == ResponseTypes.CODE:\n            code: str = response_url.args.get(\"code\")\n            if code is None:\n                raise MissingAuthCode(self, response)\n        else:\n            raise UnsupportedResponseTypeParam(self.response_type)  # pragma: no cover\n\n        return AuthorizationResponse(\n            code_verifier=self.code_verifier,\n            redirect_uri=self.redirect_uri,\n            nonce=self.nonce,\n            acr_values=self.acr_values,\n            max_age=self.max_age,\n            **response_url.args,\n        )\n\n    def sign_request_jwt(\n        self,\n        jwk: Jwk | dict[str, Any],\n        alg: str | None = None,\n        lifetime: int | None = None,\n    ) -&gt; SignedJwt:\n        \"\"\"Sign the `request` object that matches this Authorization Request parameters.\n\n        Args:\n            jwk: the JWK to use to sign the request\n            alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n            lifetime: an optional number of seconds of validity for the signed request.\n                If present, `iat` an `exp` claims will be included in the signed JWT.\n\n        Returns:\n            a `Jwt` that contains the signed request object.\n\n        \"\"\"\n        claims = self.args\n        if lifetime:\n            claims[\"iat\"] = Jwt.timestamp()\n            claims[\"exp\"] = Jwt.timestamp(lifetime)\n        return Jwt.sign(\n            claims,\n            key=jwk,\n            alg=alg,\n        )\n\n    def sign(\n        self,\n        jwk: Jwk | dict[str, Any],\n        alg: str | None = None,\n        lifetime: int | None = None,\n        **kwargs: Any,\n    ) -&gt; RequestParameterAuthorizationRequest:\n        \"\"\"Sign this Authorization Request and return a new one.\n\n        This replaces all parameters with a signed `request` JWT.\n\n        Args:\n            jwk: the JWK to use to sign the request\n            alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, don't use an 'exp' claim.\n            kwargs: additional query parameters to include in the signed authorization request\n\n        Returns:\n            the signed Authorization Request\n\n        \"\"\"\n        request_jwt = self.sign_request_jwt(jwk, alg, lifetime)\n        return RequestParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request=str(request_jwt),\n            expires_at=request_jwt.expires_at,\n            **kwargs,\n        )\n\n    def sign_and_encrypt_request_jwt(\n        self,\n        sign_jwk: Jwk | dict[str, Any],\n        enc_jwk: Jwk | dict[str, Any],\n        sign_alg: str | None = None,\n        enc_alg: str | None = None,\n        enc: str = \"A128CBC-HS256\",\n        lifetime: int | None = None,\n    ) -&gt; JweCompact:\n        \"\"\"Sign and encrypt a `request` object for this Authorization Request.\n\n        The signed `request` will contain the same parameters as this AuthorizationRequest.\n\n        Args:\n            sign_jwk: the JWK to use to sign the request\n            enc_jwk: the JWK to use to encrypt the request\n            sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n            enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n            enc: the encoding to use to encrypt the request.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, do not include an 'exp' claim.\n\n        Returns:\n            the signed and encrypted request object, as a `jwskate.Jwt`\n\n        \"\"\"\n        claims = self.args\n        if lifetime:\n            claims[\"iat\"] = Jwt.timestamp()\n            claims[\"exp\"] = Jwt.timestamp(lifetime)\n        return Jwt.sign_and_encrypt(\n            claims=claims,\n            sign_key=sign_jwk,\n            sign_alg=sign_alg,\n            enc_key=enc_jwk,\n            enc_alg=enc_alg,\n            enc=enc,\n        )\n\n    def sign_and_encrypt(\n        self,\n        sign_jwk: Jwk | dict[str, Any],\n        enc_jwk: Jwk | dict[str, Any],\n        sign_alg: str | None = None,\n        enc_alg: str | None = None,\n        enc: str = \"A128CBC-HS256\",\n        lifetime: int | None = None,\n    ) -&gt; RequestParameterAuthorizationRequest:\n        \"\"\"Sign and encrypt the current Authorization Request.\n\n        This replaces all parameters with a matching `request` object.\n\n        Args:\n            sign_jwk: the JWK to use to sign the request\n            enc_jwk: the JWK to use to encrypt the request\n            sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n            enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n            enc: the encoding to use to encrypt the request.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, do not include an 'exp' claim.\n\n        Returns:\n            a `RequestParameterAuthorizationRequest`, with a request object as parameter\n\n        \"\"\"\n        request_jwt = self.sign_and_encrypt_request_jwt(\n            sign_jwk=sign_jwk,\n            enc_jwk=enc_jwk,\n            sign_alg=sign_alg,\n            enc_alg=enc_alg,\n            enc=enc,\n            lifetime=lifetime,\n        )\n        return RequestParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request=str(request_jwt),\n        )\n\n    def on_response_error(self, response: str) -&gt; AuthorizationResponse:\n        \"\"\"Error handler for Authorization Response errors.\n\n        Triggered by\n        [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback]\n        if the response uri contains an error.\n\n        Args:\n            response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n        Returns:\n            may return a default code that will be returned by `validate_callback`. But this method\n            will most likely raise exceptions instead.\n\n        Raises:\n            AuthorizationResponseError: if the response contains an `error`. The raised exception may be a subclass\n\n        \"\"\"\n        response_url = furl(response)\n        error = response_url.args.get(\"error\")\n        error_description = response_url.args.get(\"error_description\")\n        error_uri = response_url.args.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, AuthorizationResponseError)\n        raise exception_class(\n            request=self, response=response, error=error, description=error_description, uri=error_uri\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl`.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args=self.args,\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.args","title":"<code>args: dict[str, Any]</code>  <code>property</code>","text":"<p>Return a dict with all the query parameters from this AuthorizationRequest.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>a dict of parameters</p>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.furl","title":"<code>furl: furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code>.</p>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.uri","title":"<code>uri: str</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.generate_state","title":"<code>generate_state()</code>  <code>classmethod</code>","text":"<p>Generate a random <code>state</code> parameter.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_state(cls) -&gt; str:\n    \"\"\"Generate a random `state` parameter.\"\"\"\n    return secrets.token_urlsafe(32)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.generate_nonce","title":"<code>generate_nonce()</code>  <code>classmethod</code>","text":"<p>Generate a random <code>nonce</code>.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_nonce(cls) -&gt; str:\n    \"\"\"Generate a random `nonce`.\"\"\"\n    return secrets.token_urlsafe(32)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the full argument dict.</p> <p>This can be used to serialize this request and/or to initialize a similar request.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the full argument dict.\n\n    This can be used to serialize this request and/or to initialize a similar request.\n\n    \"\"\"\n    d = asdict(self)\n    d.update(**d.pop(\"kwargs\", {}))\n    d.pop(\"code_challenge\")\n    return d\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.validate_callback","title":"<code>validate_callback(response)</code>","text":"<p>Validate an Authorization Response against this Request.</p> <p>Validate a given Authorization Response URI against this Authorization Request, and return an AuthorizationResponse.</p> <p>This includes matching the <code>state</code> parameter, checking for returned errors, and extracting the returned <code>code</code> and other parameters.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>the Authorization Response URI. This can be the full URL, or just the query parameters (still encoded as x-www-form-urlencoded).</p> required <p>Returns:</p> Type Description <code>AuthorizationResponse</code> <p>the extracted code, if all checks are successful</p> <p>Raises:</p> Type Description <code>MissingAuthCode</code> <p>if the <code>code</code> is missing in the response</p> <code>MissingIssuer</code> <p>if Server Issuer verification is active and the response does not contain an <code>iss</code>.</p> <code>MismatchingIssuer</code> <p>if the 'iss' received from the response does not match the expected value.</p> <code>MismatchingState</code> <p>if the response <code>state</code> does not match the expected value.</p> <code>OAuth2Error</code> <p>if the response includes an error.</p> <code>MissingAuthCode</code> <p>if the response does not contain a <code>code</code>.</p> <code>UnsupportedResponseTypeParam</code> <p>if response_type anything else than 'code'.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def validate_callback(self, response: str) -&gt; AuthorizationResponse:\n    \"\"\"Validate an Authorization Response against this Request.\n\n    Validate a given Authorization Response URI against this Authorization Request, and return\n    an\n    [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse].\n\n    This includes matching the `state` parameter, checking for returned errors, and extracting\n    the returned `code` and other parameters.\n\n    Args:\n        response: the Authorization Response URI. This can be the full URL, or just the\n            query parameters (still encoded as x-www-form-urlencoded).\n\n    Returns:\n        the extracted code, if all checks are successful\n\n    Raises:\n        MissingAuthCode: if the `code` is missing in the response\n        MissingIssuer: if Server Issuer verification is active and the response does\n            not contain an `iss`.\n        MismatchingIssuer: if the 'iss' received from the response does not match the\n            expected value.\n        MismatchingState: if the response `state` does not match the expected value.\n        OAuth2Error: if the response includes an error.\n        MissingAuthCode: if the response does not contain a `code`.\n        UnsupportedResponseTypeParam: if response_type anything else than 'code'.\n\n    \"\"\"\n    try:\n        response_url = furl(response)\n    except ValueError:\n        return self.on_response_error(response)\n\n    # validate 'iss' according to RFC9207\n    received_issuer = response_url.args.get(\"iss\")\n    if self.authorization_response_iss_parameter_supported or received_issuer:\n        if received_issuer is None:\n            raise MissingIssuer(self, response)\n        if self.issuer and received_issuer != self.issuer:\n            raise MismatchingIssuer(self.issuer, received_issuer, self, response)\n\n    # validate state\n    requested_state = self.state\n    if requested_state:\n        received_state = response_url.args.get(\"state\")\n        if requested_state != received_state:\n            raise MismatchingState(requested_state, received_state, self, response)\n\n    error = response_url.args.get(\"error\")\n    if error:\n        return self.on_response_error(response)\n\n    if self.response_type == ResponseTypes.CODE:\n        code: str = response_url.args.get(\"code\")\n        if code is None:\n            raise MissingAuthCode(self, response)\n    else:\n        raise UnsupportedResponseTypeParam(self.response_type)  # pragma: no cover\n\n    return AuthorizationResponse(\n        code_verifier=self.code_verifier,\n        redirect_uri=self.redirect_uri,\n        nonce=self.nonce,\n        acr_values=self.acr_values,\n        max_age=self.max_age,\n        **response_url.args,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.sign_request_jwt","title":"<code>sign_request_jwt(jwk, alg=None, lifetime=None)</code>","text":"<p>Sign the <code>request</code> object that matches this Authorization Request parameters.</p> <p>Parameters:</p> Name Type Description Default <code>jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>lifetime</code> <code>int | None</code> <p>an optional number of seconds of validity for the signed request. If present, <code>iat</code> an <code>exp</code> claims will be included in the signed JWT.</p> <code>None</code> <p>Returns:</p> Type Description <code>SignedJwt</code> <p>a <code>Jwt</code> that contains the signed request object.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_request_jwt(\n    self,\n    jwk: Jwk | dict[str, Any],\n    alg: str | None = None,\n    lifetime: int | None = None,\n) -&gt; SignedJwt:\n    \"\"\"Sign the `request` object that matches this Authorization Request parameters.\n\n    Args:\n        jwk: the JWK to use to sign the request\n        alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n        lifetime: an optional number of seconds of validity for the signed request.\n            If present, `iat` an `exp` claims will be included in the signed JWT.\n\n    Returns:\n        a `Jwt` that contains the signed request object.\n\n    \"\"\"\n    claims = self.args\n    if lifetime:\n        claims[\"iat\"] = Jwt.timestamp()\n        claims[\"exp\"] = Jwt.timestamp(lifetime)\n    return Jwt.sign(\n        claims,\n        key=jwk,\n        alg=alg,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.sign","title":"<code>sign(jwk, alg=None, lifetime=None, **kwargs)</code>","text":"<p>Sign this Authorization Request and return a new one.</p> <p>This replaces all parameters with a signed <code>request</code> JWT.</p> <p>Parameters:</p> Name Type Description Default <code>jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, don't use an 'exp' claim.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>additional query parameters to include in the signed authorization request</p> <code>{}</code> <p>Returns:</p> Type Description <code>RequestParameterAuthorizationRequest</code> <p>the signed Authorization Request</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign(\n    self,\n    jwk: Jwk | dict[str, Any],\n    alg: str | None = None,\n    lifetime: int | None = None,\n    **kwargs: Any,\n) -&gt; RequestParameterAuthorizationRequest:\n    \"\"\"Sign this Authorization Request and return a new one.\n\n    This replaces all parameters with a signed `request` JWT.\n\n    Args:\n        jwk: the JWK to use to sign the request\n        alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, don't use an 'exp' claim.\n        kwargs: additional query parameters to include in the signed authorization request\n\n    Returns:\n        the signed Authorization Request\n\n    \"\"\"\n    request_jwt = self.sign_request_jwt(jwk, alg, lifetime)\n    return RequestParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request=str(request_jwt),\n        expires_at=request_jwt.expires_at,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.sign_and_encrypt_request_jwt","title":"<code>sign_and_encrypt_request_jwt(sign_jwk, enc_jwk, sign_alg=None, enc_alg=None, enc='A128CBC-HS256', lifetime=None)</code>","text":"<p>Sign and encrypt a <code>request</code> object for this Authorization Request.</p> <p>The signed <code>request</code> will contain the same parameters as this AuthorizationRequest.</p> <p>Parameters:</p> Name Type Description Default <code>sign_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>enc_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to encrypt the request</p> required <code>sign_alg</code> <code>str | None</code> <p>the alg to use to sign the request, if <code>sign_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc_alg</code> <code>str | None</code> <p>the alg to use to encrypt the request, if <code>enc_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc</code> <code>str</code> <p>the encoding to use to encrypt the request.</p> <code>'A128CBC-HS256'</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.</p> <code>None</code> <p>Returns:</p> Type Description <code>JweCompact</code> <p>the signed and encrypted request object, as a <code>jwskate.Jwt</code></p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_and_encrypt_request_jwt(\n    self,\n    sign_jwk: Jwk | dict[str, Any],\n    enc_jwk: Jwk | dict[str, Any],\n    sign_alg: str | None = None,\n    enc_alg: str | None = None,\n    enc: str = \"A128CBC-HS256\",\n    lifetime: int | None = None,\n) -&gt; JweCompact:\n    \"\"\"Sign and encrypt a `request` object for this Authorization Request.\n\n    The signed `request` will contain the same parameters as this AuthorizationRequest.\n\n    Args:\n        sign_jwk: the JWK to use to sign the request\n        enc_jwk: the JWK to use to encrypt the request\n        sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n        enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n        enc: the encoding to use to encrypt the request.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, do not include an 'exp' claim.\n\n    Returns:\n        the signed and encrypted request object, as a `jwskate.Jwt`\n\n    \"\"\"\n    claims = self.args\n    if lifetime:\n        claims[\"iat\"] = Jwt.timestamp()\n        claims[\"exp\"] = Jwt.timestamp(lifetime)\n    return Jwt.sign_and_encrypt(\n        claims=claims,\n        sign_key=sign_jwk,\n        sign_alg=sign_alg,\n        enc_key=enc_jwk,\n        enc_alg=enc_alg,\n        enc=enc,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.sign_and_encrypt","title":"<code>sign_and_encrypt(sign_jwk, enc_jwk, sign_alg=None, enc_alg=None, enc='A128CBC-HS256', lifetime=None)</code>","text":"<p>Sign and encrypt the current Authorization Request.</p> <p>This replaces all parameters with a matching <code>request</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>sign_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>enc_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to encrypt the request</p> required <code>sign_alg</code> <code>str | None</code> <p>the alg to use to sign the request, if <code>sign_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc_alg</code> <code>str | None</code> <p>the alg to use to encrypt the request, if <code>enc_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc</code> <code>str</code> <p>the encoding to use to encrypt the request.</p> <code>'A128CBC-HS256'</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.</p> <code>None</code> <p>Returns:</p> Type Description <code>RequestParameterAuthorizationRequest</code> <p>a <code>RequestParameterAuthorizationRequest</code>, with a request object as parameter</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_and_encrypt(\n    self,\n    sign_jwk: Jwk | dict[str, Any],\n    enc_jwk: Jwk | dict[str, Any],\n    sign_alg: str | None = None,\n    enc_alg: str | None = None,\n    enc: str = \"A128CBC-HS256\",\n    lifetime: int | None = None,\n) -&gt; RequestParameterAuthorizationRequest:\n    \"\"\"Sign and encrypt the current Authorization Request.\n\n    This replaces all parameters with a matching `request` object.\n\n    Args:\n        sign_jwk: the JWK to use to sign the request\n        enc_jwk: the JWK to use to encrypt the request\n        sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n        enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n        enc: the encoding to use to encrypt the request.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, do not include an 'exp' claim.\n\n    Returns:\n        a `RequestParameterAuthorizationRequest`, with a request object as parameter\n\n    \"\"\"\n    request_jwt = self.sign_and_encrypt_request_jwt(\n        sign_jwk=sign_jwk,\n        enc_jwk=enc_jwk,\n        sign_alg=sign_alg,\n        enc_alg=enc_alg,\n        enc=enc,\n        lifetime=lifetime,\n    )\n    return RequestParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request=str(request_jwt),\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.on_response_error","title":"<code>on_response_error(response)</code>","text":"<p>Error handler for Authorization Response errors.</p> <p>Triggered by validate_callback() if the response uri contains an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>the Authorization Response URI. This can be the full URL, or just the query parameters.</p> required <p>Returns:</p> Type Description <code>AuthorizationResponse</code> <p>may return a default code that will be returned by <code>validate_callback</code>. But this method</p> <code>AuthorizationResponse</code> <p>will most likely raise exceptions instead.</p> <p>Raises:</p> Type Description <code>AuthorizationResponseError</code> <p>if the response contains an <code>error</code>. The raised exception may be a subclass</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def on_response_error(self, response: str) -&gt; AuthorizationResponse:\n    \"\"\"Error handler for Authorization Response errors.\n\n    Triggered by\n    [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback]\n    if the response uri contains an error.\n\n    Args:\n        response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n    Returns:\n        may return a default code that will be returned by `validate_callback`. But this method\n        will most likely raise exceptions instead.\n\n    Raises:\n        AuthorizationResponseError: if the response contains an `error`. The raised exception may be a subclass\n\n    \"\"\"\n    response_url = furl(response)\n    error = response_url.args.get(\"error\")\n    error_description = response_url.args.get(\"error_description\")\n    error_uri = response_url.args.get(\"error_uri\")\n    exception_class = self.exception_classes.get(error, AuthorizationResponseError)\n    raise exception_class(\n        request=self, response=response, error=error, description=error_description, uri=error_uri\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequestSerializer","title":"<code>AuthorizationRequestSerializer</code>","text":"<p>(De)Serializer for <code>AuthorizationRequest</code> instances.</p> <p>You might need to store pending authorization requests in session, either server-side or client- side. This class is here to help you do that.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class AuthorizationRequestSerializer:\n    \"\"\"(De)Serializer for `AuthorizationRequest` instances.\n\n    You might need to store pending authorization requests in session, either server-side or client-\n    side. This class is here to help you do that.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        dumper: Callable[[AuthorizationRequest], str] | None = None,\n        loader: Callable[[str], AuthorizationRequest] | None = None,\n    ) -&gt; None:\n        self.dumper = dumper or self.default_dumper\n        self.loader = loader or self.default_loader\n\n    @staticmethod\n    def default_dumper(azr: AuthorizationRequest) -&gt; str:\n        \"\"\"Provide a default dumper implementation.\n\n        Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as\n        base64url.\n\n        Args:\n            azr: the `AuthorizationRequest` to serialize\n\n        Returns:\n            the serialized value\n\n        \"\"\"\n        d = asdict(azr)\n        d.update(**d.pop(\"kwargs\", {}))\n        d.pop(\"code_challenge\")\n        return BinaPy.serialize_to(\"json\", d).to(\"deflate\").to(\"b64u\").ascii()\n\n    @staticmethod\n    def default_loader(\n        serialized: str,\n        azr_class: type[AuthorizationRequest] = AuthorizationRequest,\n    ) -&gt; AuthorizationRequest:\n        \"\"\"Provide a default deserializer implementation.\n\n        This does the opposite operations than `default_dumper`.\n\n        Args:\n            serialized: the serialized AuthorizationRequest\n            azr_class: the class to deserialize the Authorization Request to\n\n        Returns:\n            an AuthorizationRequest\n\n        \"\"\"\n        args = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n        return azr_class(**args)\n\n    def dumps(self, azr: AuthorizationRequest) -&gt; str:\n        \"\"\"Serialize and compress a given AuthorizationRequest for easier storage.\n\n        Args:\n            azr: an AuthorizationRequest to serialize\n\n        Returns:\n            the serialized AuthorizationRequest, as a str\n\n        \"\"\"\n        return self.dumper(azr)\n\n    def loads(self, serialized: str) -&gt; AuthorizationRequest:\n        \"\"\"Deserialize a serialized AuthorizationRequest.\n\n        Args:\n            serialized: the serialized AuthorizationRequest\n\n        Returns:\n            the deserialized AuthorizationRequest\n\n        \"\"\"\n        return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequestSerializer.default_dumper","title":"<code>default_dumper(azr)</code>  <code>staticmethod</code>","text":"<p>Provide a default dumper implementation.</p> <p>Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as base64url.</p> <p>Parameters:</p> Name Type Description Default <code>azr</code> <code>AuthorizationRequest</code> <p>the <code>AuthorizationRequest</code> to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized value</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@staticmethod\ndef default_dumper(azr: AuthorizationRequest) -&gt; str:\n    \"\"\"Provide a default dumper implementation.\n\n    Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as\n    base64url.\n\n    Args:\n        azr: the `AuthorizationRequest` to serialize\n\n    Returns:\n        the serialized value\n\n    \"\"\"\n    d = asdict(azr)\n    d.update(**d.pop(\"kwargs\", {}))\n    d.pop(\"code_challenge\")\n    return BinaPy.serialize_to(\"json\", d).to(\"deflate\").to(\"b64u\").ascii()\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequestSerializer.default_loader","title":"<code>default_loader(serialized, azr_class=AuthorizationRequest)</code>  <code>staticmethod</code>","text":"<p>Provide a default deserializer implementation.</p> <p>This does the opposite operations than <code>default_dumper</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized AuthorizationRequest</p> required <code>azr_class</code> <code>type[AuthorizationRequest]</code> <p>the class to deserialize the Authorization Request to</p> <code>AuthorizationRequest</code> <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>an AuthorizationRequest</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@staticmethod\ndef default_loader(\n    serialized: str,\n    azr_class: type[AuthorizationRequest] = AuthorizationRequest,\n) -&gt; AuthorizationRequest:\n    \"\"\"Provide a default deserializer implementation.\n\n    This does the opposite operations than `default_dumper`.\n\n    Args:\n        serialized: the serialized AuthorizationRequest\n        azr_class: the class to deserialize the Authorization Request to\n\n    Returns:\n        an AuthorizationRequest\n\n    \"\"\"\n    args = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n    return azr_class(**args)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequestSerializer.dumps","title":"<code>dumps(azr)</code>","text":"<p>Serialize and compress a given AuthorizationRequest for easier storage.</p> <p>Parameters:</p> Name Type Description Default <code>azr</code> <code>AuthorizationRequest</code> <p>an AuthorizationRequest to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized AuthorizationRequest, as a str</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def dumps(self, azr: AuthorizationRequest) -&gt; str:\n    \"\"\"Serialize and compress a given AuthorizationRequest for easier storage.\n\n    Args:\n        azr: an AuthorizationRequest to serialize\n\n    Returns:\n        the serialized AuthorizationRequest, as a str\n\n    \"\"\"\n    return self.dumper(azr)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequestSerializer.loads","title":"<code>loads(serialized)</code>","text":"<p>Deserialize a serialized AuthorizationRequest.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized AuthorizationRequest</p> required <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>the deserialized AuthorizationRequest</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def loads(self, serialized: str) -&gt; AuthorizationRequest:\n    \"\"\"Deserialize a serialized AuthorizationRequest.\n\n    Args:\n        serialized: the serialized AuthorizationRequest\n\n    Returns:\n        the deserialized AuthorizationRequest\n\n    \"\"\"\n    return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationResponse","title":"<code>AuthorizationResponse</code>","text":"<p>Represent a successful Authorization Response.</p> <p>An Authorization Response is the redirection initiated by the AS to the client's redirection endpoint (redirect_uri) after an Authorization Request. This Response is typically created with a call to <code>AuthorizationRequest.validate_callback()</code> once the call to the client Redirection Endpoint is made. AuthorizationResponse contains the following, all accessible as attributes:</p> <ul> <li>all the parameters that have been returned by the AS, most notably the <code>code</code>, and optional    parameters such as <code>state</code>.</li> <li>the redirect_uri that was used for the Authorization Request</li> <li>the code_verifier matching the code_challenge that was used for the Authorization Request</li> </ul> <p>Parameters <code>redirect_uri</code> and <code>code_verifier</code> must be those from the matching <code>AuthorizationRequest</code>. All other parameters including <code>code</code> and <code>state</code> must be those extracted from the Authorization Response parameters.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>the authorization code returned by the AS</p> required <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri that was passed as parameter in the AuthorizationRequest</p> <code>None</code> <code>code_verifier</code> <code>str | None</code> <p>the code_verifier matching the code_challenge that was passed as parameter in the AuthorizationRequest</p> <code>None</code> <code>state</code> <code>str | None</code> <p>the state returned by the AS</p> <code>None</code> <code>**kwargs</code> <code>str</code> <p>other parameters as returned by the AS</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass AuthorizationResponse:\n    \"\"\"Represent a successful Authorization Response.\n\n    An Authorization Response is the redirection initiated by the AS to the client's redirection\n    endpoint (redirect_uri) after an Authorization Request. This Response is typically created with\n    a call to `AuthorizationRequest.validate_callback()` once the call to the client Redirection\n    Endpoint is made. AuthorizationResponse contains the following, all accessible as attributes:\n\n     - all the parameters that have been returned by the AS, most notably the `code`, and optional\n       parameters such as `state`.\n     - the redirect_uri that was used for the Authorization Request\n     - the code_verifier matching the code_challenge that was used for the Authorization Request\n\n    Parameters `redirect_uri` and `code_verifier` must be those from the matching\n    `AuthorizationRequest`. All other parameters including `code` and `state` must be those\n    extracted from the Authorization Response parameters.\n\n    Args:\n        code: the authorization code returned by the AS\n        redirect_uri: the redirect_uri that was passed as parameter in the AuthorizationRequest\n        code_verifier: the code_verifier matching the code_challenge that was passed as\n            parameter in the AuthorizationRequest\n        state: the state returned by the AS\n        **kwargs: other parameters as returned by the AS\n\n    \"\"\"\n\n    code: str\n    redirect_uri: str | None = None\n    code_verifier: str | None = None\n    state: str | None = None\n    nonce: str | None = None\n    acr_values: tuple[str, ...] | None = None\n    max_age: int | None = None\n    issuer: str | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    def __init__(\n        self,\n        *,\n        code: str,\n        redirect_uri: str | None = None,\n        code_verifier: str | None = None,\n        state: str | None = None,\n        nonce: str | None = None,\n        acr_values: str | Sequence[str] | None = None,\n        max_age: int | None = None,\n        issuer: str | None = None,\n        **kwargs: str,\n    ) -&gt; None:\n        if not acr_values:\n            acr_values = None\n        elif isinstance(acr_values, str):\n            acr_values = tuple(acr_values.split(\" \"))\n        else:\n            acr_values = tuple(acr_values)\n\n        self.__attrs_init__(\n            code=code,\n            redirect_uri=redirect_uri,\n            code_verifier=code_verifier,\n            state=state,\n            nonce=nonce,\n            acr_values=acr_values,\n            max_age=max_age,\n            issuer=issuer,\n            kwargs=kwargs,\n        )\n\n    def __getattr__(self, item: str) -&gt; str | None:\n        \"\"\"Make additional parameters available as attributes.\n\n        Args:\n            item: the attribute name\n\n        Returns:\n            the attribute value, or None if it isn't part of the returned attributes\n\n        \"\"\"\n        return self.kwargs.get(item)\n</code></pre>"},{"location":"api/#requests_oauth2client.CodeChallengeMethods","title":"<code>CodeChallengeMethods</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>All standardised <code>code_challenge</code> values.</p> <p>You should always use <code>S256</code>.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class CodeChallengeMethods(str, Enum):\n    \"\"\"All standardised `code_challenge` values.\n\n    You should always use `S256`.\n\n    \"\"\"\n\n    S256 = \"S256\"\n    plain = \"plain\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidCodeVerifierParam","title":"<code>InvalidCodeVerifierParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an invalid code_verifier is supplied.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class InvalidCodeVerifierParam(ValueError):\n    \"\"\"Raised when an invalid code_verifier is supplied.\"\"\"\n\n    def __init__(self, code_verifier: str) -&gt; None:\n        super().__init__(\"\"\"\\\nInvalid 'code_verifier'. It must be a 43 to 128 characters long string, with:\n- lowercase letters\n- uppercase letters\n- digits\n- underscore, dash, tilde, or dot (_-~.)\n\"\"\")\n        self.code_verifier = code_verifier\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidMaxAgeParam","title":"<code>InvalidMaxAgeParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an invalid 'max_age' parameter is provided.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class InvalidMaxAgeParam(ValueError):\n    \"\"\"Raised when an invalid 'max_age' parameter is provided.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"\"\"\\\nInvalid 'max_age' parameter. It must be a positive number of seconds.\nThis specifies the allowable elapsed time in seconds since the last time\nthe End-User was actively authenticated by the OP.\n\"\"\")\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingIssuerParam","title":"<code>MissingIssuerParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when the 'issuer' parameter is required but not provided.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class MissingIssuerParam(ValueError):\n    \"\"\"Raised when the 'issuer' parameter is required but not provided.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"\"\"\\\nWhen 'authorization_response_iss_parameter_supported' is `True`, you must\nprovide the expected `issuer` as parameter.\n\"\"\")\n</code></pre>"},{"location":"api/#requests_oauth2client.PkceUtils","title":"<code>PkceUtils</code>","text":"<p>Contains helper methods for PKCE, as described in RFC7636.</p> <p>See RFC7636.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class PkceUtils:\n    \"\"\"Contains helper methods for PKCE, as described in RFC7636.\n\n    See [RFC7636](https://tools.ietf.org/html/rfc7636).\n\n    \"\"\"\n\n    code_verifier_pattern = re.compile(r\"^[a-zA-Z0-9_\\-~.]{43,128}$\")\n    \"\"\"A regex that matches valid code verifiers.\"\"\"\n\n    @classmethod\n    def generate_code_verifier(cls) -&gt; str:\n        \"\"\"Generate a valid `code_verifier`.\n\n        Returns:\n            a `code_verifier` ready to use for PKCE\n\n        \"\"\"\n        return secrets.token_urlsafe(96)\n\n    @classmethod\n    def derive_challenge(cls, verifier: str | bytes, method: str = CodeChallengeMethods.S256) -&gt; str:\n        \"\"\"Derive the `code_challenge` from a given `code_verifier`.\n\n        Args:\n            verifier: a code verifier\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            a `code_challenge` derived from the given verifier\n\n        Raises:\n            InvalidCodeVerifierParam: if the `verifier` does not match `code_verifier_pattern`\n            UnsupportedCodeChallengeMethod: if the method is not supported\n\n        \"\"\"\n        if isinstance(verifier, bytes):\n            verifier = verifier.decode()\n\n        if not cls.code_verifier_pattern.match(verifier):\n            raise InvalidCodeVerifierParam(verifier)\n\n        if method == CodeChallengeMethods.S256:\n            return BinaPy(verifier).to(\"sha256\").to(\"b64u\").ascii()\n        if method == CodeChallengeMethods.plain:\n            return verifier\n\n        raise UnsupportedCodeChallengeMethod(method)\n\n    @classmethod\n    def generate_code_verifier_and_challenge(cls, method: str = CodeChallengeMethods.S256) -&gt; tuple[str, str]:\n        \"\"\"Generate a valid `code_verifier` and derive its `code_challenge`.\n\n        Args:\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            a `(code_verifier, code_challenge)` tuple.\n\n        \"\"\"\n        verifier = cls.generate_code_verifier()\n        challenge = cls.derive_challenge(verifier, method)\n        return verifier, challenge\n\n    @classmethod\n    def validate_code_verifier(cls, verifier: str, challenge: str, method: str = CodeChallengeMethods.S256) -&gt; bool:\n        \"\"\"Validate a `code_verifier` against a `code_challenge`.\n\n        Args:\n            verifier: the `code_verifier`, exactly as submitted by the client on token request.\n            challenge: the `code_challenge`, exactly as submitted by the client on authorization request.\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            `True` if verifier is valid, or `False` otherwise\n\n        \"\"\"\n        return (\n            cls.code_verifier_pattern.match(verifier) is not None\n            and cls.derive_challenge(verifier, method) == challenge\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.PkceUtils.code_verifier_pattern","title":"<code>code_verifier_pattern = re.compile('^[a-zA-Z0-9_\\\\-~.]{43,128}$')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A regex that matches valid code verifiers.</p>"},{"location":"api/#requests_oauth2client.PkceUtils.generate_code_verifier","title":"<code>generate_code_verifier()</code>  <code>classmethod</code>","text":"<p>Generate a valid <code>code_verifier</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>a <code>code_verifier</code> ready to use for PKCE</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_code_verifier(cls) -&gt; str:\n    \"\"\"Generate a valid `code_verifier`.\n\n    Returns:\n        a `code_verifier` ready to use for PKCE\n\n    \"\"\"\n    return secrets.token_urlsafe(96)\n</code></pre>"},{"location":"api/#requests_oauth2client.PkceUtils.derive_challenge","title":"<code>derive_challenge(verifier, method=CodeChallengeMethods.S256)</code>  <code>classmethod</code>","text":"<p>Derive the <code>code_challenge</code> from a given <code>code_verifier</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>str | bytes</code> <p>a code verifier</p> required <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>S256</code> <p>Returns:</p> Type Description <code>str</code> <p>a <code>code_challenge</code> derived from the given verifier</p> <p>Raises:</p> Type Description <code>InvalidCodeVerifierParam</code> <p>if the <code>verifier</code> does not match <code>code_verifier_pattern</code></p> <code>UnsupportedCodeChallengeMethod</code> <p>if the method is not supported</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef derive_challenge(cls, verifier: str | bytes, method: str = CodeChallengeMethods.S256) -&gt; str:\n    \"\"\"Derive the `code_challenge` from a given `code_verifier`.\n\n    Args:\n        verifier: a code verifier\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        a `code_challenge` derived from the given verifier\n\n    Raises:\n        InvalidCodeVerifierParam: if the `verifier` does not match `code_verifier_pattern`\n        UnsupportedCodeChallengeMethod: if the method is not supported\n\n    \"\"\"\n    if isinstance(verifier, bytes):\n        verifier = verifier.decode()\n\n    if not cls.code_verifier_pattern.match(verifier):\n        raise InvalidCodeVerifierParam(verifier)\n\n    if method == CodeChallengeMethods.S256:\n        return BinaPy(verifier).to(\"sha256\").to(\"b64u\").ascii()\n    if method == CodeChallengeMethods.plain:\n        return verifier\n\n    raise UnsupportedCodeChallengeMethod(method)\n</code></pre>"},{"location":"api/#requests_oauth2client.PkceUtils.generate_code_verifier_and_challenge","title":"<code>generate_code_verifier_and_challenge(method=CodeChallengeMethods.S256)</code>  <code>classmethod</code>","text":"<p>Generate a valid <code>code_verifier</code> and derive its <code>code_challenge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>S256</code> <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>a <code>(code_verifier, code_challenge)</code> tuple.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_code_verifier_and_challenge(cls, method: str = CodeChallengeMethods.S256) -&gt; tuple[str, str]:\n    \"\"\"Generate a valid `code_verifier` and derive its `code_challenge`.\n\n    Args:\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        a `(code_verifier, code_challenge)` tuple.\n\n    \"\"\"\n    verifier = cls.generate_code_verifier()\n    challenge = cls.derive_challenge(verifier, method)\n    return verifier, challenge\n</code></pre>"},{"location":"api/#requests_oauth2client.PkceUtils.validate_code_verifier","title":"<code>validate_code_verifier(verifier, challenge, method=CodeChallengeMethods.S256)</code>  <code>classmethod</code>","text":"<p>Validate a <code>code_verifier</code> against a <code>code_challenge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>str</code> <p>the <code>code_verifier</code>, exactly as submitted by the client on token request.</p> required <code>challenge</code> <code>str</code> <p>the <code>code_challenge</code>, exactly as submitted by the client on authorization request.</p> required <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>S256</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if verifier is valid, or <code>False</code> otherwise</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef validate_code_verifier(cls, verifier: str, challenge: str, method: str = CodeChallengeMethods.S256) -&gt; bool:\n    \"\"\"Validate a `code_verifier` against a `code_challenge`.\n\n    Args:\n        verifier: the `code_verifier`, exactly as submitted by the client on token request.\n        challenge: the `code_challenge`, exactly as submitted by the client on authorization request.\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        `True` if verifier is valid, or `False` otherwise\n\n    \"\"\"\n    return (\n        cls.code_verifier_pattern.match(verifier) is not None\n        and cls.derive_challenge(verifier, method) == challenge\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.RequestParameterAuthorizationRequest","title":"<code>RequestParameterAuthorizationRequest</code>","text":"<p>Represent an Authorization Request that includes a <code>request</code> JWT.</p> <p>To construct such a request yourself, the easiest way is to initialize an <code>AuthorizationRequest</code> then sign it with <code>AuthorizationRequest.sign()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the Authorization Endpoint uri</p> required <code>client_id</code> <code>str</code> <p>the client_id</p> required <code>request</code> <code>Jwt | str</code> <p>the request JWT</p> required <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for this request</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>extra parameters to include in the request</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False, repr=False)\nclass RequestParameterAuthorizationRequest:\n    \"\"\"Represent an Authorization Request that includes a `request` JWT.\n\n    To construct such a request yourself, the easiest way is to initialize\n    an [`AuthorizationRequest`][requests_oauth2client.authorization_request.AuthorizationRequest]\n    then sign it with\n    [`AuthorizationRequest.sign()`][requests_oauth2client.authorization_request.AuthorizationRequest.sign].\n\n    Args:\n        authorization_endpoint: the Authorization Endpoint uri\n        client_id: the client_id\n        request: the request JWT\n        expires_at: the expiration date for this request\n        kwargs: extra parameters to include in the request\n\n    \"\"\"\n\n    authorization_endpoint: str\n    client_id: str\n    request: Jwt\n    expires_at: datetime | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        authorization_endpoint: str,\n        client_id: str,\n        request: Jwt | str,\n        expires_at: datetime | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        if isinstance(request, str):\n            request = Jwt(request)\n\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            request=request,\n            expires_at=expires_at,\n            kwargs=kwargs,\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl` instance.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args={\"client_id\": self.client_id, \"request\": str(self.request), **self.kwargs},\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\n\n        Returns:\n             the Authorization Request URI\n\n        \"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.RequestParameterAuthorizationRequest.furl","title":"<code>furl: furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code> instance.</p>"},{"location":"api/#requests_oauth2client.RequestParameterAuthorizationRequest.uri","title":"<code>uri: str</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.RequestUriParameterAuthorizationRequest","title":"<code>RequestUriParameterAuthorizationRequest</code>","text":"<p>Represent an Authorization Request that includes a <code>request_uri</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the Authorization Endpoint uri</p> required <code>client_id</code> <code>str</code> <p>the client_id</p> required <code>request_uri</code> <code>str</code> <p>the request_uri</p> required <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for this request</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>extra parameters to include in the request</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass RequestUriParameterAuthorizationRequest:\n    \"\"\"Represent an Authorization Request that includes a `request_uri` parameter.\n\n    Args:\n        authorization_endpoint: the Authorization Endpoint uri\n        client_id: the client_id\n        request_uri: the request_uri\n        expires_at: the expiration date for this request\n        kwargs: extra parameters to include in the request\n\n    \"\"\"\n\n    authorization_endpoint: str\n    client_id: str\n    request_uri: str\n    expires_at: datetime | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        authorization_endpoint: str,\n        client_id: str,\n        request_uri: str,\n        expires_at: datetime | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            request_uri=request_uri,\n            expires_at=expires_at,\n            kwargs=kwargs,\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl` instance.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args={\"client_id\": self.client_id, \"request_uri\": self.request_uri, **self.kwargs},\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.RequestUriParameterAuthorizationRequest.furl","title":"<code>furl: furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code> instance.</p>"},{"location":"api/#requests_oauth2client.RequestUriParameterAuthorizationRequest.uri","title":"<code>uri: str</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.ResponseTypes","title":"<code>ResponseTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>All standardised <code>response_type</code> values.</p> <p>Note that you should always use <code>code</code>. All other values are deprecated.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class ResponseTypes(str, Enum):\n    \"\"\"All standardised `response_type` values.\n\n    Note that you should always use `code`. All other values are deprecated.\n\n    \"\"\"\n\n    CODE = \"code\"\n    NONE = \"none\"\n    TOKEN = \"token\"\n    IDTOKEN = \"id_token\"\n    CODE_IDTOKEN = \"code id_token\"\n    CODE_TOKEN = \"code token\"\n    CODE_IDTOKEN_TOKEN = \"code id_token token\"\n    IDTOKEN_TOKEN = \"id_token token\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnsupportedCodeChallengeMethod","title":"<code>UnsupportedCodeChallengeMethod</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an unsupported code_challenge_method is provided.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class UnsupportedCodeChallengeMethod(ValueError):\n    \"\"\"Raised when an unsupported code_challenge_method is provided.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnsupportedResponseTypeParam","title":"<code>UnsupportedResponseTypeParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an unsupported response_type is passed as parameter.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class UnsupportedResponseTypeParam(ValueError):\n    \"\"\"Raised when an unsupported response_type is passed as parameter.\"\"\"\n\n    def __init__(self, response_type: str) -&gt; None:\n        super().__init__(\"\"\"The only supported response type is 'code'.\"\"\", response_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationPoolingJob","title":"<code>BackChannelAuthenticationPoolingJob</code>","text":"<p>               Bases: <code>BaseTokenEndpointPoolingJob</code></p> <p>A pooling job for the BackChannel Authentication flow.</p> <p>This will poll the Token Endpoint until the user finishes with its authentication.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client that will be used to pool the token endpoint.</p> required <code>auth_req_id</code> <code>str | BackChannelAuthenticationResponse</code> <p>an <code>auth_req_id</code> as <code>str</code> or a <code>BackChannelAuthenticationResponse</code>.</p> required <code>interval</code> <code>int | None</code> <p>The pooling interval, in seconds, to use. This overrides the one in <code>auth_req_id</code> if it is a <code>BackChannelAuthenticationResponse</code>. Defaults to 5 seconds.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>Number of seconds to add to the pooling interval when the AS returns a slow down request.</p> <code>5</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the underlying calls to requests.request.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token request.</p> <code>{}</code> Example <pre><code>client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\npool_job = BackChannelAuthenticationPoolingJob(\n    client=client,\n    auth_req_id=\"my_auth_req_id\",\n)\n\ntoken = None\nwhile token is None:\n    token = pool_job()\n</code></pre> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>@define(init=False)\nclass BackChannelAuthenticationPoolingJob(BaseTokenEndpointPoolingJob):\n    \"\"\"A pooling job for the BackChannel Authentication flow.\n\n    This will poll the Token Endpoint until the user finishes with its authentication.\n\n    Args:\n        client: an OAuth2Client that will be used to pool the token endpoint.\n        auth_req_id: an `auth_req_id` as `str` or a `BackChannelAuthenticationResponse`.\n        interval: The pooling interval, in seconds, to use. This overrides\n            the one in `auth_req_id` if it is a `BackChannelAuthenticationResponse`.\n            Defaults to 5 seconds.\n        slow_down_interval: Number of seconds to add to the pooling interval when the AS returns\n            a slow down request.\n        requests_kwargs: Additional parameters for the underlying calls to [requests.request][].\n        **token_kwargs: Additional parameters for the token request.\n\n    Example:\n        ```python\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        pool_job = BackChannelAuthenticationPoolingJob(\n            client=client,\n            auth_req_id=\"my_auth_req_id\",\n        )\n\n        token = None\n        while token is None:\n            token = pool_job()\n        ```\n\n    \"\"\"\n\n    auth_req_id: str\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        auth_req_id: str | BackChannelAuthenticationResponse,\n        *,\n        interval: int | None = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n            interval = interval or auth_req_id.interval\n            auth_req_id = auth_req_id.auth_req_id\n\n        self.__attrs_init__(\n            client=client,\n            auth_req_id=auth_req_id,\n            interval=interval or 5,\n            slow_down_interval=slow_down_interval,\n            requests_kwargs=requests_kwargs or {},\n            token_kwargs=token_kwargs,\n        )\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Implement the CIBA token request.\n\n        This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        return self.client.ciba(self.auth_req_id, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Implement the CIBA token request.</p> <p>This actually calls [OAuth2Client.ciba(auth_req_id)] on <code>client</code>.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Implement the CIBA token request.\n\n    This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    return self.client.ciba(self.auth_req_id, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationResponse","title":"<code>BackChannelAuthenticationResponse</code>","text":"<p>Represent a BackChannel Authentication Response.</p> <p>This contains all the parameters that are returned by the AS as a result of a BackChannel Authentication Request, such as <code>auth_req_id</code> (required), and the optional <code>expires_at</code>, <code>interval</code>, and/or any custom parameters.</p> <p>Parameters:</p> Name Type Description Default <code>auth_req_id</code> <code>str</code> <p>the <code>auth_req_id</code> as returned by the AS.</p> required <code>expires_at</code> <code>datetime | None</code> <p>the date when the <code>auth_req_id</code> expires. Note that this request also accepts an <code>expires_in</code> parameter, in seconds.</p> <code>None</code> <code>interval</code> <code>int | None</code> <p>the Token Endpoint pooling interval, in seconds, as returned by the AS.</p> <code>20</code> <code>**kwargs</code> <code>Any</code> <p>any additional custom parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>class BackChannelAuthenticationResponse:\n    \"\"\"Represent a BackChannel Authentication Response.\n\n    This contains all the parameters that are returned by the AS as a result of a BackChannel\n    Authentication Request, such as `auth_req_id` (required), and the optional `expires_at`,\n    `interval`, and/or any custom parameters.\n\n    Args:\n        auth_req_id: the `auth_req_id` as returned by the AS.\n        expires_at: the date when the `auth_req_id` expires.\n            Note that this request also accepts an `expires_in` parameter, in seconds.\n        interval: the Token Endpoint pooling interval, in seconds, as returned by the AS.\n        **kwargs: any additional custom parameters as returned by the AS.\n\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        auth_req_id: str,\n        expires_at: datetime | None = None,\n        interval: int | None = 20,\n        **kwargs: Any,\n    ) -&gt; None:\n        self.auth_req_id = auth_req_id\n        self.expires_at = expires_at\n        self.interval = interval\n        self.other = kwargs\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Return `True` if the `auth_req_id` within this response is expired.\n\n        Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is\n        derived from the `expires_in` hint returned by the AS BackChannel Authentication endpoint),\n        this will return `None`.\n\n        Returns:\n            `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is\n            no `expires_in` hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n\n    @property\n    def expires_in(self) -&gt; int | None:\n        \"\"\"Number of seconds until expiration.\"\"\"\n        if self.expires_at:\n            return ceil((self.expires_at - datetime.now(tz=timezone.utc)).total_seconds())\n        return None\n\n    def __getattr__(self, key: str) -&gt; Any:\n        \"\"\"Return attributes from this `BackChannelAuthenticationResponse`.\n\n        Allows accessing response parameters with `token_response.expires_in` or\n        `token_response.any_custom_attribute`.\n\n        Args:\n            key: a key\n\n        Returns:\n            the associated value in this token response\n\n        Raises:\n            AttributeError: if the attribute is not present in the response\n\n        \"\"\"\n        return self.other.get(key) or super().__getattribute__(key)\n</code></pre>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationResponse.expires_in","title":"<code>expires_in: int | None</code>  <code>property</code>","text":"<p>Number of seconds until expiration.</p>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationResponse.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Return <code>True</code> if the <code>auth_req_id</code> within this response is expired.</p> <p>Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is derived from the <code>expires_in</code> hint returned by the AS BackChannel Authentication endpoint), this will return <code>None</code>.</p> <p>Returns:</p> Type Description <code>bool | None</code> <p><code>True</code> if the auth_req_id is expired, <code>False</code> if it is still valid, <code>None</code> if there is</p> <code>bool | None</code> <p>no <code>expires_in</code> hint.</p> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Return `True` if the `auth_req_id` within this response is expired.\n\n    Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is\n    derived from the `expires_in` hint returned by the AS BackChannel Authentication endpoint),\n    this will return `None`.\n\n    Returns:\n        `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is\n        no `expires_in` hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.Endpoints","title":"<code>Endpoints</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>All standardised OAuth 2.0 and extensions endpoints.</p> <p>If an endpoint is not mentioned here, then its usage is not supported by OAuth2Client.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class Endpoints(str, Enum):\n    \"\"\"All standardised OAuth 2.0 and extensions endpoints.\n\n    If an endpoint is not mentioned here, then its usage is not supported by OAuth2Client.\n\n    \"\"\"\n\n    TOKEN = \"token_endpoint\"\n    AUTHORIZATION = \"authorization_endpoint\"\n    BACKCHANNEL_AUTHENTICATION = \"backchannel_authentication_endpoint\"\n    DEVICE_AUTHORIZATION = \"device_authorization_endpoint\"\n    INSTROSPECTION = \"introspection_endpoint\"\n    REVOCATION = \"revocation_endpoint\"\n    PUSHED_AUTHORIZATION_REQUEST = \"pushed_authorization_request_endpoint\"\n    JWKS = \"jwks_uri\"\n    USER_INFO = \"userinfo_endpoint\"\n</code></pre>"},{"location":"api/#requests_oauth2client.GrantTypes","title":"<code>GrantTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum of standardized <code>grant_type</code> values.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class GrantTypes(str, Enum):\n    \"\"\"An enum of standardized `grant_type` values.\"\"\"\n\n    CLIENT_CREDENTIALS = \"client_credentials\"\n    AUTHORIZATION_CODE = \"authorization_code\"\n    REFRESH_TOKEN = \"refresh_token\"\n    RESOURCE_OWNER_PASSWORD = \"password\"\n    TOKEN_EXCHANGE = \"urn:ietf:params:oauth:grant-type:token-exchange\"\n    JWT_BEARER = \"urn:ietf:params:oauth:grant-type:jwt-bearer\"\n    CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION = \"urn:openid:params:grant-type:ciba\"\n    DEVICE_CODE = \"urn:ietf:params:oauth:grant-type:device_code\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidAcrValuesParam","title":"<code>InvalidAcrValuesParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid 'acr_values' parameter is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidAcrValuesParam(InvalidParam):\n    \"\"\"Raised when an invalid 'acr_values' parameter is provided.\"\"\"\n\n    def __init__(self, acr_values: object) -&gt; None:\n        super().__init__(f\"Invalid 'acr_values' parameter: {acr_values}\")\n        self.acr_values = acr_values\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidBackchannelAuthenticationRequestHintParam","title":"<code>InvalidBackchannelAuthenticationRequestHintParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid hint is provided in a backchannel authentication request.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidBackchannelAuthenticationRequestHintParam(InvalidParam):\n    \"\"\"Raised when an invalid hint is provided in a backchannel authentication request.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidDiscoveryDocument","title":"<code>InvalidDiscoveryDocument</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when handling an invalid Discovery Document.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidDiscoveryDocument(ValueError):\n    \"\"\"Raised when handling an invalid Discovery Document.\"\"\"\n\n    def __init__(self, message: str, discovery_document: dict[str, Any]) -&gt; None:\n        super().__init__(f\"Invalid discovery document: {message}\")\n        self.discovery_document = discovery_document\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidEndpointUri","title":"<code>InvalidEndpointUri</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid endpoint uri is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidEndpointUri(InvalidParam):\n    \"\"\"Raised when an invalid endpoint uri is provided.\"\"\"\n\n    def __init__(self, endpoint: str, uri: str, exc: InvalidUri) -&gt; None:\n        super().__init__(f\"Invalid endpoint uri '{uri}' for '{endpoint}': {exc}\")\n        self.endpoint = endpoint\n        self.uri = uri\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidIssuer","title":"<code>InvalidIssuer</code>","text":"<p>               Bases: <code>InvalidEndpointUri</code></p> <p>Raised when an invalid issuer parameter is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidIssuer(InvalidEndpointUri):\n    \"\"\"Raised when an invalid issuer parameter is provided.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidParam","title":"<code>InvalidParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Base class for invalid parameters errors.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidParam(ValueError):\n    \"\"\"Base class for invalid parameters errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidScopeParam","title":"<code>InvalidScopeParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid scope parameter is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidScopeParam(InvalidParam):\n    \"\"\"Raised when an invalid scope parameter is provided.\"\"\"\n\n    def __init__(self, scope: object) -&gt; None:\n        super().__init__(\"\"\"\\\nUnsupported scope value. It must be one of:\n- a space separated `str` of scopes names\n- an iterable of scope names as `str`\n\"\"\")\n        self.scope = scope\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingAuthRequestId","title":"<code>MissingAuthRequestId</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an 'auth_req_id' is missing in a BackChannelAuthenticationResponse.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingAuthRequestId(ValueError):\n    \"\"\"Raised when an 'auth_req_id' is missing in a BackChannelAuthenticationResponse.\"\"\"\n\n    def __init__(self, bcar: BackChannelAuthenticationResponse) -&gt; None:\n        super().__init__(\"An 'auth_req_id' is required but is missing from this BackChannelAuthenticationResponse.\")\n        self.backchannel_authentication_response = bcar\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingDeviceCode","title":"<code>MissingDeviceCode</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a device_code is required but not provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingDeviceCode(ValueError):\n    \"\"\"Raised when a device_code is required but not provided.\"\"\"\n\n    def __init__(self, dar: DeviceAuthorizationResponse) -&gt; None:\n        super().__init__(\"A device_code is missing in this DeviceAuthorizationResponse\")\n        self.device_authorization_response = dar\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingEndpointUri","title":"<code>MissingEndpointUri</code>","text":"<p>               Bases: <code>AttributeError</code></p> <p>Raised when a required endpoint uri is not known.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingEndpointUri(AttributeError):\n    \"\"\"Raised when a required endpoint uri is not known.\"\"\"\n\n    def __init__(self, endpoint: str) -&gt; None:\n        super().__init__(f\"No '{endpoint}' defined for this client.\")\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingIdTokenEncryptedResponseAlgParam","title":"<code>MissingIdTokenEncryptedResponseAlgParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an ID Token encryption is required but not provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingIdTokenEncryptedResponseAlgParam(InvalidParam):\n    \"\"\"Raised when an ID Token encryption is required but not provided.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"\"\"\\\nAn ID Token decryption key has been provided but no decryption algorithm is defined.\nYou can either pass an `id_token_encrypted_response_alg` parameter with the alg identifier,\nor include an `alg` attribute in the decryption key, if it is in Jwk format.\n\"\"\")\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingRefreshToken","title":"<code>MissingRefreshToken</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a refresh token is required but not present.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingRefreshToken(ValueError):\n    \"\"\"Raised when a refresh token is required but not present.\"\"\"\n\n    def __init__(self, token: TokenResponse) -&gt; None:\n        super().__init__(\"A refresh_token is required but is not present in this Access Token.\")\n        self.token = token\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client","title":"<code>OAuth2Client</code>","text":"<p>An OAuth 2.x Client, that can send requests to an OAuth 2.x Authorization Server.</p> <p><code>OAuth2Client</code> is able to obtain tokens from the Token Endpoint using any of the standardised Grant Types, and to communicate with the various backend endpoints like the Revocation, Introspection, and UserInfo Endpoint.</p> <p>To init an OAuth2Client, you only need the url to the Token Endpoint and the Credentials (a client_id and one of a secret or private_key) that will be used to authenticate to that endpoint. Other endpoint urls, such as the Authorization Endpoint, Revocation Endpoint, etc. can be passed as parameter as well if you intend to use them.</p> <p>This class is not intended to help with the end-user authentication or any request that goes in a browser. For authentication requests, see AuthorizationRequest. You may use the method <code>authorization_request()</code> to generate <code>AuthorizationRequest</code>s with the preconfigured <code>authorization_endpoint</code>, <code>client_id</code> and `redirect_uri' from this client.</p> <p>Parameters:</p> Name Type Description Default <code>token_endpoint</code> <code>str</code> <p>the Token Endpoint URI where this client will get access tokens</p> required <code>auth</code> <code>AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None</code> <p>the authentication handler to use for client authentication on the token endpoint. Can be:</p> <ul> <li>a requests.auth.AuthBase instance (which will be used as-is)</li> <li>a tuple of <code>(client_id, client_secret)</code> which will initialize an instance of ClientSecretPost</li> <li>a <code>(client_id, jwk)</code> to initialize a PrivateKeyJwt,</li> <li>or a <code>client_id</code> which will use PublicApp authentication.</li> </ul> <code>None</code> <code>client_id</code> <code>str | None</code> <p>client ID (use either this or <code>auth</code>)</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>client secret (use either this or <code>auth</code>)</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>private_key to use for client authentication (use either this or <code>auth</code>)</p> <code>None</code> <code>revocation_endpoint</code> <code>str | None</code> <p>the Revocation Endpoint URI to use for revoking tokens</p> <code>None</code> <code>introspection_endpoint</code> <code>str | None</code> <p>the Introspection Endpoint URI to use to get info about tokens</p> <code>None</code> <code>userinfo_endpoint</code> <code>str | None</code> <p>the Userinfo Endpoint URI to use to get information about the user</p> <code>None</code> <code>authorization_endpoint</code> <code>str | None</code> <p>the Authorization Endpoint URI, used for initializing Authorization Requests</p> <code>None</code> <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri for this client</p> <code>None</code> <code>backchannel_authentication_endpoint</code> <code>str | None</code> <p>the BackChannel Authentication URI</p> <code>None</code> <code>device_authorization_endpoint</code> <code>str | None</code> <p>the Device Authorization Endpoint URI to use to authorize devices</p> <code>None</code> <code>jwks_uri</code> <code>str | None</code> <p>the JWKS URI to use to obtain the AS public keys</p> <code>None</code> <code>code_challenge_method</code> <code>str</code> <p>challenge method to use for PKCE (should always be 'S256')</p> <code>S256</code> <code>session</code> <code>Session | None</code> <p>a requests Session to use when sending HTTP requests. Useful if some extra parameters such as proxy or client certificate must be used to connect to the AS.</p> <code>None</code> <code>testing</code> <code>bool</code> <p>if <code>True</code>, don't verify the validity of the endpoint urls that are passed as parameter.</p> <code>False</code> <code>**extra_metadata</code> <code>Any</code> <p>additional metadata for this client, unused by this class, but may be used by subclasses. Those will be accessible with the <code>extra_metadata</code> attribute.</p> <code>{}</code> Example <pre><code>client = OAuth2Client(\n    token_endpoint=\"https://my.as.local/token\",\n    revocation_endpoint=\"https://my.as.local/revoke\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\n# once initialized, a client can send requests to its configured endpoints\ncc_token = client.client_credentials(scope=\"my_scope\")\nac_token = client.authorization_code(code=\"my_code\")\nclient.revoke_access_token(cc_token)\n</code></pre> <p>Raises:</p> Type Description <code>MissingIDTokenEncryptedResponseAlgParam</code> <p>if an <code>id_token_decryption_key</code> is provided but no decryption alg is provided, either:</p> <ul> <li>using <code>id_token_encrypted_response_alg</code>,</li> <li>or in the <code>alg</code> parameter of the <code>Jwk</code> key</li> </ul> <code>MissingIssuerParam</code> <p>if <code>authorization_response_iss_parameter_supported</code> is set to <code>True</code> but the <code>issuer</code> is not provided.</p> <code>InvalidEndpointUri</code> <p>if a provided endpoint uri is not considered valid. For the rare cases where those checks must be disabled, you can use <code>testing=True</code>.</p> <code>InvalidIssuer</code> <p>if the <code>issuer</code> value is not considered valid.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@frozen(init=False)\nclass OAuth2Client:\n    \"\"\"An OAuth 2.x Client, that can send requests to an OAuth 2.x Authorization Server.\n\n    `OAuth2Client` is able to obtain tokens from the Token Endpoint using any of the standardised\n    Grant Types, and to communicate with the various backend endpoints like the Revocation,\n    Introspection, and UserInfo Endpoint.\n\n    To init an OAuth2Client, you only need the url to the Token Endpoint and the Credentials\n    (a client_id and one of a secret or private_key) that will be used to authenticate to that endpoint.\n    Other endpoint urls, such as the Authorization Endpoint, Revocation Endpoint, etc. can be passed as\n    parameter as well if you intend to use them.\n\n\n    This class is not intended to help with the end-user authentication or any request that goes in\n    a browser. For authentication requests, see\n    [AuthorizationRequest][requests_oauth2client.authorization_request.AuthorizationRequest]. You\n    may use the method `authorization_request()` to generate `AuthorizationRequest`s with the\n    preconfigured `authorization_endpoint`, `client_id` and `redirect_uri' from this client.\n\n    Args:\n        token_endpoint: the Token Endpoint URI where this client will get access tokens\n        auth: the authentication handler to use for client authentication on the token endpoint.\n            Can be:\n\n            - a [requests.auth.AuthBase][] instance (which will be used as-is)\n            - a tuple of `(client_id, client_secret)` which will initialize an instance\n            of [ClientSecretPost][requests_oauth2client.client_authentication.ClientSecretPost]\n            - a `(client_id, jwk)` to initialize\n            a [PrivateKeyJwt][requests_oauth2client.client_authentication.PrivateKeyJwt],\n            - or a `client_id` which will\n            use [PublicApp][requests_oauth2client.client_authentication.PublicApp] authentication.\n\n        client_id: client ID (use either this or `auth`)\n        client_secret: client secret (use either this or `auth`)\n        private_key: private_key to use for client authentication (use either this or `auth`)\n        revocation_endpoint: the Revocation Endpoint URI to use for revoking tokens\n        introspection_endpoint: the Introspection Endpoint URI to use to get info about tokens\n        userinfo_endpoint: the Userinfo Endpoint URI to use to get information about the user\n        authorization_endpoint: the Authorization Endpoint URI, used for initializing Authorization Requests\n        redirect_uri: the redirect_uri for this client\n        backchannel_authentication_endpoint: the BackChannel Authentication URI\n        device_authorization_endpoint: the Device Authorization Endpoint URI to use to authorize devices\n        jwks_uri: the JWKS URI to use to obtain the AS public keys\n        code_challenge_method: challenge method to use for PKCE (should always be 'S256')\n        session: a requests Session to use when sending HTTP requests.\n            Useful if some extra parameters such as proxy or client certificate must be used\n            to connect to the AS.\n        testing: if `True`, don't verify the validity of the endpoint urls that are passed as parameter.\n        **extra_metadata: additional metadata for this client, unused by this class, but may be\n            used by subclasses. Those will be accessible with the `extra_metadata` attribute.\n\n    Example:\n        ```python\n        client = OAuth2Client(\n            token_endpoint=\"https://my.as.local/token\",\n            revocation_endpoint=\"https://my.as.local/revoke\",\n            client_id=\"client_id\",\n            client_secret=\"client_secret\",\n        )\n\n        # once initialized, a client can send requests to its configured endpoints\n        cc_token = client.client_credentials(scope=\"my_scope\")\n        ac_token = client.authorization_code(code=\"my_code\")\n        client.revoke_access_token(cc_token)\n        ```\n\n    Raises:\n        MissingIDTokenEncryptedResponseAlgParam: if an `id_token_decryption_key` is provided\n            but no decryption alg is provided, either:\n\n            - using `id_token_encrypted_response_alg`,\n            - or in the `alg` parameter of the `Jwk` key\n        MissingIssuerParam: if `authorization_response_iss_parameter_supported` is set to `True`\n            but the `issuer` is not provided.\n        InvalidEndpointUri: if a provided endpoint uri is not considered valid. For the rare cases\n            where those checks must be disabled, you can use `testing=True`.\n        InvalidIssuer: if the `issuer` value is not considered valid.\n\n    \"\"\"\n\n    auth: requests.auth.AuthBase = field(converter=client_auth_factory)\n    token_endpoint: str = field()\n    revocation_endpoint: str | None = field()\n    introspection_endpoint: str | None = field()\n    userinfo_endpoint: str | None = field()\n    authorization_endpoint: str | None = field()\n    redirect_uri: str | None = field()\n    backchannel_authentication_endpoint: str | None = field()\n    device_authorization_endpoint: str | None = field()\n    pushed_authorization_request_endpoint: str | None = field()\n    jwks_uri: str | None = field()\n    authorization_server_jwks: JwkSet\n    issuer: str | None = field()\n    id_token_signed_response_alg: str | None = SignatureAlgs.RS256\n    id_token_encrypted_response_alg: str | None = None\n    id_token_decryption_key: Jwk | None = None\n    code_challenge_method: str | None = CodeChallengeMethods.S256\n    authorization_response_iss_parameter_supported: bool = False\n    session: requests.Session = field(factory=requests.Session)\n    extra_metadata: dict[str, Any] = field(factory=dict)\n    testing: bool = False\n\n    token_class: type[BearerToken] = BearerToken\n\n    exception_classes: ClassVar[dict[str, type[EndpointError]]] = {\n        \"server_error\": ServerError,\n        \"invalid_request\": InvalidRequest,\n        \"invalid_client\": InvalidClient,\n        \"invalid_scope\": InvalidScope,\n        \"invalid_target\": InvalidTarget,\n        \"invalid_grant\": InvalidGrant,\n        \"access_denied\": AccessDenied,\n        \"unauthorized_client\": UnauthorizedClient,\n        \"authorization_pending\": AuthorizationPending,\n        \"slow_down\": SlowDown,\n        \"expired_token\": ExpiredToken,\n        \"unsupported_token_type\": UnsupportedTokenType,\n    }\n\n    def __init__(  # noqa: PLR0913\n        self,\n        token_endpoint: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        revocation_endpoint: str | None = None,\n        introspection_endpoint: str | None = None,\n        userinfo_endpoint: str | None = None,\n        authorization_endpoint: str | None = None,\n        redirect_uri: str | None = None,\n        backchannel_authentication_endpoint: str | None = None,\n        device_authorization_endpoint: str | None = None,\n        pushed_authorization_request_endpoint: str | None = None,\n        jwks_uri: str | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        issuer: str | None = None,\n        id_token_signed_response_alg: str | None = SignatureAlgs.RS256,\n        id_token_encrypted_response_alg: str | None = None,\n        id_token_decryption_key: Jwk | dict[str, Any] | None = None,\n        code_challenge_method: str = CodeChallengeMethods.S256,\n        authorization_response_iss_parameter_supported: bool = False,\n        token_class: type[BearerToken] = BearerToken,\n        session: requests.Session | None = None,\n        testing: bool = False,\n        **extra_metadata: Any,\n    ) -&gt; None:\n        if authorization_response_iss_parameter_supported and not issuer:\n            raise MissingIssuerParam\n\n        auth = client_auth_factory(\n            auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            default_auth_handler=ClientSecretPost,\n        )\n\n        if authorization_server_jwks is None:\n            authorization_server_jwks = JwkSet()\n        elif not isinstance(authorization_server_jwks, JwkSet):\n            authorization_server_jwks = JwkSet(authorization_server_jwks)\n\n        if id_token_decryption_key is not None and not isinstance(id_token_decryption_key, Jwk):\n            id_token_decryption_key = Jwk(id_token_decryption_key)\n\n        if id_token_decryption_key is not None and id_token_encrypted_response_alg is None:\n            if id_token_decryption_key.alg:\n                id_token_encrypted_response_alg = id_token_decryption_key.alg\n            else:\n                raise MissingIdTokenEncryptedResponseAlgParam\n\n        if session is None:\n            session = requests.Session()\n\n        self.__attrs_init__(\n            testing=testing,\n            token_endpoint=token_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            redirect_uri=redirect_uri,\n            backchannel_authentication_endpoint=backchannel_authentication_endpoint,\n            device_authorization_endpoint=device_authorization_endpoint,\n            pushed_authorization_request_endpoint=pushed_authorization_request_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            issuer=issuer,\n            session=session,\n            auth=auth,\n            id_token_signed_response_alg=id_token_signed_response_alg,\n            id_token_encrypted_response_alg=id_token_encrypted_response_alg,\n            id_token_decryption_key=id_token_decryption_key,\n            code_challenge_method=code_challenge_method,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            extra_metadata=extra_metadata,\n            token_class=token_class,\n        )\n\n    @token_endpoint.validator\n    @revocation_endpoint.validator\n    @introspection_endpoint.validator\n    @userinfo_endpoint.validator\n    @authorization_endpoint.validator\n    @backchannel_authentication_endpoint.validator\n    @device_authorization_endpoint.validator\n    @pushed_authorization_request_endpoint.validator\n    @jwks_uri.validator\n    def validate_endpoint_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n        \"\"\"Validate that an endpoint URI is suitable for use.\n\n        If you need to disable some checks (for AS testing purposes only!), provide a different\n        method here.\n\n        \"\"\"\n        if self.testing or uri is None:\n            return uri\n        try:\n            return validate_endpoint_uri(uri)\n        except InvalidUri as exc:\n            raise InvalidEndpointUri(endpoint=attribute.name, uri=uri, exc=exc) from exc\n\n    @issuer.validator\n    def validate_issuer_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n        \"\"\"Validate that an Issuer identifier is suitable for use.\n\n        This is the same check as an endpoint URI, but the path may be (and usually is) empty.\n\n        \"\"\"\n        if self.testing or uri is None:\n            return uri\n        try:\n            return validate_issuer_uri(uri)\n        except InvalidUri as exc:\n            raise InvalidIssuer(attribute.name, uri, exc) from exc\n\n    @property\n    def client_id(self) -&gt; str:\n        \"\"\"Client ID.\"\"\"\n        if hasattr(self.auth, \"client_id\"):\n            return self.auth.client_id  # type: ignore[no-any-return]\n        msg = \"This client uses a custom authentication method without client_id.\"\n        raise AttributeError(msg)  # pragma: no cover\n\n    @property\n    def client_secret(self) -&gt; str | None:\n        \"\"\"Client Secret.\"\"\"\n        if hasattr(self.auth, \"client_secret\"):\n            return self.auth.client_secret  # type: ignore[no-any-return]\n        return None\n\n    @property\n    def client_jwks(self) -&gt; JwkSet:\n        \"\"\"A `JwkSet` containing the public keys for this client.\n\n        Keys are:\n\n        - the public key for client assertion signature verification (if using private_key_jwt)\n        - the ID Token encryption key\n\n        \"\"\"\n        jwks = JwkSet()\n        if isinstance(self.auth, PrivateKeyJwt):\n            jwks.add_jwk(self.auth.private_jwk.public_jwk().with_usage_parameters())\n        if self.id_token_decryption_key:\n            jwks.add_jwk(self.id_token_decryption_key.public_jwk().with_usage_parameters())\n        return jwks\n\n    def _request(\n        self,\n        endpoint: str,\n        on_success: Callable[[requests.Response], T],\n        on_failure: Callable[[requests.Response], T],\n        accept: str = \"application/json\",\n        method: str = \"POST\",\n        **requests_kwargs: Any,\n    ) -&gt; T:\n        \"\"\"Send a request to one of the endpoints.\n\n        This is a helper method that takes care of the following tasks:\n\n        - make sure the endpoint as been configured\n        - set `Accept: application/json` header\n        - send the HTTP POST request, then\n            - apply `on_success` to a successful response\n            - or apply `on_failure` otherwise\n        - return the result\n\n        Args:\n            endpoint: name of the endpoint to use\n            on_success: a callable to apply to successful responses\n            on_failure: a callable to apply to error responses\n            accept: the Accept header to include in the request\n            method: the HTTP method to use\n            **requests_kwargs: keyword arguments for the request\n\n        \"\"\"\n        endpoint_uri = self._require_endpoint(endpoint)\n        requests_kwargs.setdefault(\"headers\", {})\n        requests_kwargs[\"headers\"][\"Accept\"] = accept\n\n        response = self.session.request(\n            method,\n            endpoint_uri,\n            **requests_kwargs,\n        )\n        if response.ok:\n            return on_success(response)\n\n        return on_failure(response)\n\n    def token_request(\n        self,\n        data: dict[str, Any],\n        timeout: int = 10,\n        **requests_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint.\n\n        Authentication will be added automatically based on the defined `auth` for this client.\n\n        Args:\n          data: parameters to send to the token endpoint. Items with a `None`\n               or empty value will not be sent in the request.\n          timeout: a timeout value for the call\n          **requests_kwargs: additional parameters for requests.post()\n\n        Returns:\n            the token endpoint response, as\n            [`BearerToken`][requests_oauth2client.tokens.BearerToken] instance.\n\n        \"\"\"\n        return self._request(\n            Endpoints.TOKEN,\n            auth=self.auth,\n            data=data,\n            timeout=timeout,\n            on_success=self.parse_token_response,\n            on_failure=self.on_token_error,\n            **requests_kwargs,\n        )\n\n    def parse_token_response(self, response: requests.Response) -&gt; BearerToken:\n        \"\"\"Parse a Response returned by the Token Endpoint.\n\n        Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse\n        responses returned by the Token Endpoint. Those responses contain an `access_token` and\n        additional attributes.\n\n        Args:\n            response: the [Response][requests.Response] returned by the Token Endpoint.\n\n        Returns:\n            a [`BearerToken`][requests_oauth2client.tokens.BearerToken] based on the response\n            contents.\n\n        \"\"\"\n        try:\n            token_response = self.token_class(**response.json())\n        except Exception:  # noqa: BLE001\n            return self.on_token_error(response)\n        else:\n            return token_response\n\n    def on_token_error(self, response: requests.Response) -&gt; BearerToken:\n        \"\"\"Error handler for `token_request()`.\n\n        Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the\n        Token Endpoint returns an error.\n\n        Args:\n            response: the [Response][requests.Response] returned by the Token Endpoint.\n\n        Returns:\n            nothing, and raises an exception instead. But a subclass may return a\n            [`BearerToken`][requests_oauth2client.tokens.BearerToken] to implement a default\n            behaviour if needed.\n\n        Raises:\n            InvalidTokenResponse: if the error response does not contain an OAuth 2.0 standard\n                error response.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidTokenResponse(response=response, client=self) from exc\n        raise exception\n\n    def client_credentials(\n        self,\n        scope: str | Iterable[str] | None = None,\n        *,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint using the `client_credentials` grant.\n\n        Args:\n            scope: the scope to send with the request. Can be a str, or an iterable of str.\n                to pass that way include `scope`, `audience`, `resource`, etc.\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`. Common parameters\n\n        Returns:\n            a BearerToken\n\n        Raises:\n            InvalidScopeParam: if the `scope` parameter is not suitable\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if scope and not isinstance(scope, str):\n            try:\n                scope = \" \".join(scope)\n            except Exception as exc:\n                raise InvalidScopeParam(scope) from exc\n\n        data = dict(grant_type=GrantTypes.CLIENT_CREDENTIALS, scope=scope, **token_kwargs)\n        return self.token_request(data, **requests_kwargs)\n\n    def authorization_code(\n        self,\n        code: str | AuthorizationResponse,\n        *,\n        validate: bool = True,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint with the `authorization_code` grant.\n\n        Args:\n             code: an authorization code or an `AuthorizationResponse` to exchange for tokens\n             validate: if `True`, validate the received ID Token (this works only if `code` is an AuthorizationResponse)\n             requests_kwargs: additional parameters for the call to requests\n             **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `code`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        \"\"\"\n        azr: AuthorizationResponse | None = None\n        if isinstance(code, AuthorizationResponse):\n            token_kwargs.setdefault(\"code_verifier\", code.code_verifier)\n            token_kwargs.setdefault(\"redirect_uri\", code.redirect_uri)\n            azr = code\n            code = code.code\n\n        requests_kwargs = requests_kwargs or {}\n\n        data = dict(grant_type=GrantTypes.AUTHORIZATION_CODE, code=code, **token_kwargs)\n        token = self.token_request(data, **requests_kwargs)\n        if validate and token.id_token and isinstance(azr, AuthorizationResponse):\n            return token.validate_id_token(self, azr)\n        return token\n\n    def refresh_token(\n        self,\n        refresh_token: str | BearerToken,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint with the `refresh_token` grant.\n\n        Args:\n            refresh_token: a refresh_token, as a string, or as a `BearerToken`.\n                That `BearerToken` must have a `refresh_token`.\n            requests_kwargs: additional parameters for the call to `requests`\n            **token_kwargs: additional parameters for the token endpoint,\n                alongside `grant_type`, `refresh_token`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        Raises:\n            MissingRefreshToken: if `refresh_token` is a BearerToken instance but does not\n                contain a `refresh_token`\n\n        \"\"\"\n        if isinstance(refresh_token, BearerToken):\n            if refresh_token.refresh_token is None or not isinstance(refresh_token.refresh_token, str):\n                raise MissingRefreshToken(refresh_token)\n            refresh_token = refresh_token.refresh_token\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(grant_type=GrantTypes.REFRESH_TOKEN, refresh_token=refresh_token, **token_kwargs)\n        return self.token_request(data, **requests_kwargs)\n\n    def device_code(\n        self,\n        device_code: str | DeviceAuthorizationResponse,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint using the Device Code grant.\n\n        The grant_type is `urn:ietf:params:oauth:grant-type:device_code`. This needs a Device Code,\n        or a `DeviceAuthorizationResponse` as parameter.\n\n        Args:\n            device_code: a device code, or a `DeviceAuthorizationResponse`\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        Raises:\n            MissingDeviceCode: if `device_code` is a DeviceAuthorizationResponse but does not\n                contain a `device_code`.\n\n        \"\"\"\n        if isinstance(device_code, DeviceAuthorizationResponse):\n            if device_code.device_code is None or not isinstance(device_code.device_code, str):\n                raise MissingDeviceCode(device_code)\n            device_code = device_code.device_code\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantTypes.DEVICE_CODE,\n            device_code=device_code,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def ciba(\n        self,\n        auth_req_id: str | BackChannelAuthenticationResponse,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a CIBA request to the Token Endpoint.\n\n        A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant.\n\n        Args:\n            auth_req_id: an authentication request ID, as returned by the AS\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        Raises:\n            MissingAuthRequestId: if `auth_req_id` is a BackChannelAuthenticationResponse but does not contain\n                an `auth_req_id`.\n\n        \"\"\"\n        if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n            if auth_req_id.auth_req_id is None or not isinstance(auth_req_id.auth_req_id, str):\n                raise MissingAuthRequestId(auth_req_id)\n            auth_req_id = auth_req_id.auth_req_id\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantTypes.CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION,\n            auth_req_id=auth_req_id,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def token_exchange(\n        self,\n        subject_token: str | BearerToken | IdToken,\n        subject_token_type: str | None = None,\n        actor_token: None | str | BearerToken | IdToken = None,\n        actor_token_type: str | None = None,\n        requested_token_type: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a Token Exchange request.\n\n        A Token Exchange request is actually a request to the Token Endpoint with a grant_type\n        `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n        Args:\n            subject_token: the subject token to exchange for a new token.\n            subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based\n                on `type(subject_token)`.\n            actor_token: the actor token to include in the request, if any.\n            actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based\n                on `type(actor_token)`.\n            requested_token_type: a token type identifier for the requested token.\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            a `BearerToken` as returned by the Authorization Server.\n\n        Raises:\n            UnknownSubjectTokenType: if the type of `subject_token` cannot be determined automatically.\n            UnknownActorTokenType: if the type of `actor_token` cannot be determined automaticatlly.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        try:\n            subject_token_type = self.get_token_type(subject_token_type, subject_token)\n        except ValueError as exc:\n            raise UnknownSubjectTokenType(subject_token, subject_token_type) from exc\n        if actor_token:  # pragma: no branch\n            try:\n                actor_token_type = self.get_token_type(actor_token_type, actor_token)\n            except ValueError as exc:\n                raise UnknownActorTokenType(actor_token, actor_token_type) from exc\n\n        data = dict(\n            grant_type=GrantTypes.TOKEN_EXCHANGE,\n            subject_token=subject_token,\n            subject_token_type=subject_token_type,\n            actor_token=actor_token,\n            actor_token_type=actor_token_type,\n            requested_token_type=requested_token_type,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def jwt_bearer(\n        self,\n        assertion: Jwt | str,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request using a JWT as authorization grant.\n\n        This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).\n\n        Args:\n            assertion: a JWT (as an instance of `jwskate.Jwt` or as a `str`) to use as authorization grant.\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            a `BearerToken` as returned by the Authorization Server.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if not isinstance(assertion, Jwt):\n            assertion = Jwt(assertion)\n\n        data = dict(\n            grant_type=GrantTypes.JWT_BEARER,\n            assertion=assertion,\n            **token_kwargs,\n        )\n\n        return self.token_request(data, **requests_kwargs)\n\n    def resource_owner_password(\n        self,\n        username: str,\n        password: str,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request using the Resource Owner Password Grant.\n\n        This Grant Type is deprecated and should only be used when there is no other choice.\n\n        Args:\n            username: the resource owner user name\n            password: the resource owner password\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            a `BearerToken` as returned by the Authorization Server\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantTypes.RESOURCE_OWNER_PASSWORD,\n            username=username,\n            password=password,\n            **token_kwargs,\n        )\n\n        return self.token_request(data, **requests_kwargs)\n\n    def authorization_request(\n        self,\n        *,\n        scope: None | str | Iterable[str] = \"openid\",\n        response_type: str = ResponseTypes.CODE,\n        redirect_uri: str | None = None,\n        state: str | ellipsis | None = ...,  # noqa: F821\n        nonce: str | ellipsis | None = ...,  # noqa: F821\n        code_verifier: str | None = None,\n        **kwargs: Any,\n    ) -&gt; AuthorizationRequest:\n        \"\"\"Generate an Authorization Request for this client.\n\n        Args:\n            scope: the `scope` to use\n            response_type: the `response_type` to use\n            redirect_uri: the `redirect_uri` to include in the request. By default,\n                the `redirect_uri` defined at init time is used.\n            state: the `state` parameter to use. Leave default to generate a random value.\n            nonce: a `nonce`. Leave default to generate a random value.\n            code_verifier: the PKCE `code_verifier` to use. Leave default to generate a random value.\n            **kwargs: additional parameters to include in the auth request\n\n        Returns:\n            an AuthorizationRequest with the supplied parameters\n\n        \"\"\"\n        authorization_endpoint = self._require_endpoint(\"authorization_endpoint\")\n\n        redirect_uri = redirect_uri or self.redirect_uri\n\n        return AuthorizationRequest(\n            authorization_endpoint=authorization_endpoint,\n            client_id=self.client_id,\n            redirect_uri=redirect_uri,\n            issuer=self.issuer,\n            response_type=response_type,\n            scope=scope,\n            state=state,\n            nonce=nonce,\n            code_verifier=code_verifier,\n            code_challenge_method=self.code_challenge_method,\n            **kwargs,\n        )\n\n    def pushed_authorization_request(\n        self,\n        authorization_request: AuthorizationRequest,\n        requests_kwargs: dict[str, Any] | None = None,\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Send a Pushed Authorization Request.\n\n        This sends a request to the Pushed Authorization Request Endpoint, and returns a\n        `RequestUriParameterAuthorizationRequest` initialized with the AS response.\n\n        Args:\n            authorization_request: the authorization request to send\n            requests_kwargs: additional parameters for `requests.request()`\n\n        Returns:\n            the `RequestUriParameterAuthorizationRequest` initialized based on the AS response\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n        return self._request(\n            Endpoints.PUSHED_AUTHORIZATION_REQUEST,\n            data=authorization_request.args,\n            auth=self.auth,\n            on_success=self.parse_pushed_authorization_response,\n            on_failure=self.on_pushed_authorization_request_error,\n            **requests_kwargs,\n        )\n\n    def parse_pushed_authorization_response(\n        self,\n        response: requests.Response,\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Parse the response obtained by `pushed_authorization_request()`.\n\n        Args:\n            response: the `requests.Response` returned by the PAR endpoint\n\n        Returns:\n            a RequestUriParameterAuthorizationRequest instance\n\n        \"\"\"\n        response_json = response.json()\n        request_uri = response_json.get(\"request_uri\")\n        expires_in = response_json.get(\"expires_in\")\n\n        return RequestUriParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request_uri=request_uri,\n            expires_in=expires_in,\n        )\n\n    def on_pushed_authorization_request_error(\n        self,\n        response: requests.Response,\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Error Handler for Pushed Authorization Endpoint errors.\n\n        Args:\n            response: the HTTP response as returned by the AS PAR endpoint.\n\n        Returns:\n            a RequestUriParameterAuthorizationRequest, if the error is recoverable\n\n        Raises:\n            EndpointError: a subclass of this error depending on the error returned by the AS\n            InvalidPushedAuthorizationResponse: if the returned response is not following the\n                specifications\n            UnknownTokenEndpointError: for unknown/unhandled errors\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidPushedAuthorizationResponse(response=response, client=self) from exc\n        raise exception\n\n    def userinfo(self, access_token: BearerToken | str) -&gt; Any:\n        \"\"\"Call the UserInfo endpoint.\n\n        This sends a request to the UserInfo endpoint, with the specified access_token, and returns\n        the parsed result.\n\n        Args:\n            access_token: the access token to use\n\n        Returns:\n            the [Response][requests.Response] returned by the userinfo endpoint.\n\n        \"\"\"\n        if isinstance(access_token, str):\n            access_token = BearerToken(access_token)\n        return self._request(\n            Endpoints.USER_INFO,\n            auth=access_token,\n            on_success=self.parse_userinfo_response,\n            on_failure=self.on_userinfo_error,\n        )\n\n    def parse_userinfo_response(self, resp: requests.Response) -&gt; Any:\n        \"\"\"Parse the response obtained by `userinfo()`.\n\n        Invoked by [userinfo()][requests_oauth2client.client.OAuth2Client.userinfo] to parse the\n        response from the UserInfo endpoint, this will extract and return its JSON content.\n\n        Args:\n            resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n        Returns:\n            the parsed JSON content from this response.\n\n        \"\"\"\n        return resp.json()\n\n    def on_userinfo_error(self, resp: requests.Response) -&gt; Any:\n        \"\"\"Parse UserInfo error response.\n\n        Args:\n            resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n        Returns:\n            nothing, raises exception instead.\n\n        \"\"\"\n        resp.raise_for_status()\n\n    @classmethod\n    def get_token_type(  # noqa: C901\n        cls,\n        token_type: str | None = None,\n        token: None | str | BearerToken | IdToken = None,\n    ) -&gt; str:\n        \"\"\"Get standardized token type identifiers.\n\n        Return a standardized token type identifier, based on a short `token_type` hint and/or a\n        token value.\n\n        Args:\n            token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\"\n                or \"id_token\"\n            token: a token value, as an instance of `BearerToken` or IdToken, or as a `str`.\n\n        Returns:\n            the token_type as defined in the Token Exchange RFC8693.\n\n        Raises:\n            UnknownTokenType: if the type of token cannot be determined\n\n        \"\"\"\n        if not (token_type or token):\n            msg = \"Cannot determine type of an empty token without a token_type hint\"\n            raise UnknownTokenType(msg, token, token_type)\n\n        if token_type is None:\n            if isinstance(token, str):\n                msg = \"\"\"\\\nCannot determine the type of provided token when it is a bare `str`. Please specify a 'token_type'.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            if isinstance(token, BearerToken):\n                return \"urn:ietf:params:oauth:token-type:access_token\"\n            if isinstance(token, IdToken):\n                return \"urn:ietf:params:oauth:token-type:id_token\"\n            msg = f\"Unknown token type {type(token)}\"\n            raise UnknownTokenType(msg, token, token_type)\n        if token_type == TokenType.ACCESS_TOKEN:\n            if token is not None and not isinstance(token, (str, BearerToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nA BearerToken or an access_token as a `str` is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:access_token\"\n        if token_type == TokenType.REFRESH_TOKEN:\n            if token is not None and isinstance(token, BearerToken) and not token.refresh_token:\n                msg = f\"\"\"\\\nThe supplied BearerToken does not contain a refresh_token, which is inconsistent with token_type '{token_type}'.\nA BearerToken containing a refresh_token is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:refresh_token\"\n        if token_type == TokenType.ID_TOKEN:\n            if token is not None and not isinstance(token, (str, IdToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nAn IdToken or a string representation of it is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:id_token\"\n\n        return {\n            \"saml1\": \"urn:ietf:params:oauth:token-type:saml1\",\n            \"saml2\": \"urn:ietf:params:oauth:token-type:saml2\",\n            \"jwt\": \"urn:ietf:params:oauth:token-type:jwt\",\n        }.get(token_type, token_type)\n\n    def revoke_access_token(\n        self,\n        access_token: BearerToken | str,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a request to the Revocation Endpoint to revoke an access token.\n\n        Args:\n            access_token: the access token to revoke\n            requests_kwargs: additional parameters for the underlying requests.post() call\n            **revoke_kwargs: additional parameters to pass to the revocation endpoint\n\n        \"\"\"\n        return self.revoke_token(\n            access_token,\n            token_type_hint=TokenType.ACCESS_TOKEN,\n            requests_kwargs=requests_kwargs,\n            **revoke_kwargs,\n        )\n\n    def revoke_refresh_token(\n        self,\n        refresh_token: str | BearerToken,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a request to the Revocation Endpoint to revoke a refresh token.\n\n        Args:\n            refresh_token: the refresh token to revoke.\n            requests_kwargs: additional parameters to pass to the revocation endpoint.\n            **revoke_kwargs: additional parameters to pass to the revocation endpoint.\n\n        Returns:\n            `True` if the revocation request is successful, `False` if this client has no configured\n            revocation endpoint.\n\n        Raises:\n            MissingRefreshToken: when `refresh_token` is a [BearerToken][requests_oauth2client.tokens.BearerToken]\n                but does not contain a `refresh_token`.\n\n        \"\"\"\n        if isinstance(refresh_token, BearerToken):\n            if refresh_token.refresh_token is None:\n                raise MissingRefreshToken(refresh_token)\n            refresh_token = refresh_token.refresh_token\n\n        return self.revoke_token(\n            refresh_token,\n            token_type_hint=TokenType.REFRESH_TOKEN,\n            requests_kwargs=requests_kwargs,\n            **revoke_kwargs,\n        )\n\n    def revoke_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a Token Revocation request.\n\n        By default, authentication will be the same than the one used for the Token Endpoint.\n\n        Args:\n            token: the token to revoke.\n            token_type_hint: a token_type_hint to send to the revocation endpoint.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **revoke_kwargs: additional parameters to send to the revocation endpoint.\n\n        Returns:\n            `True` if the revocation succeeds, `False` if no revocation endpoint is present or a\n            non-standardised error is returned.\n\n        Raises:\n            MissingEndpointUri: if the Revocation Endpoint URI is not configured.\n            MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n                but does not contain a `refresh_token`.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if token_type_hint == TokenType.REFRESH_TOKEN and isinstance(token, BearerToken):\n            if token.refresh_token is None:\n                raise MissingRefreshToken(token)\n            token = token.refresh_token\n\n        data = dict(revoke_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            Endpoints.REVOCATION,\n            data=data,\n            auth=self.auth,\n            on_success=lambda _: True,\n            on_failure=self.on_revocation_error,\n            **requests_kwargs,\n        )\n\n    def on_revocation_error(self, response: requests.Response) -&gt; bool:\n        \"\"\"Error handler for `revoke_token()`.\n\n        Invoked by [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token] when the\n        revocation endpoint returns an error.\n\n        Args:\n            response: the [Response][requests.Response] as returned by the Revocation Endpoint\n\n        Returns:\n            `False` to signal that an error occurred. May raise exceptions instead depending on the\n            revocation response.\n\n        Raises:\n            EndpointError: if the response contains a standardised OAuth 2.0 error.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, RevocationError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception:  # noqa: BLE001\n            return False\n        raise exception\n\n    def introspect_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **introspect_kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"Send a request to the Introspection Endpoint.\n\n        Parameter `token` can be:\n\n        - a `str`\n        - a `BearerToken` instance\n\n        You may pass any arbitrary `token` and `token_type_hint` values as `str`. Those will\n        be included in the request, as-is.\n        If `token` is a `BearerToken`, then `token_type_hint` must be either:\n\n        - `None`: the access_token will be instrospected and no token_type_hint will be included\n        in the request\n        - `access_token`: same as `None`, but the token_type_hint will be included\n        - or `refresh_token`: only available if a Refresh Token is present in the BearerToken.\n\n        Args:\n            token: the token to instrospect\n            token_type_hint: the `token_type_hint` to include in the request.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **introspect_kwargs: additional parameters to send to the introspection endpoint.\n\n        Returns:\n            the response as returned by the Introspection Endpoint.\n\n        Raises:\n            MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n                but does not contain a `refresh_token`.\n            UnknownTokenType: if `token_type_hint` is neither `None`, `\"access_token\"` or `\"refresh_token\"`.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if isinstance(token, BearerToken):\n            if token_type_hint is None or token_type_hint == TokenType.ACCESS_TOKEN:\n                token = token.access_token\n            elif token_type_hint == TokenType.REFRESH_TOKEN:\n                if token.refresh_token is None:\n                    raise MissingRefreshToken(token)\n\n                token = token.refresh_token\n            else:\n                msg = \"\"\"\\\nInvalid `token_type_hint`. To test arbitrary `token_type_hint` values, you must provide `token` as a `str`.\"\"\"\n                raise UnknownTokenType(msg, token, token_type_hint)\n\n        data = dict(introspect_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            Endpoints.INSTROSPECTION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_introspection_response,\n            on_failure=self.on_introspection_error,\n            **requests_kwargs,\n        )\n\n    def parse_introspection_response(self, response: requests.Response) -&gt; Any:\n        \"\"\"Parse Token Introspection Responses received by `introspect_token()`.\n\n        Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n        to parse the returned response. This decodes the JSON content if possible, otherwise it\n        returns the response as a string.\n\n        Args:\n            response: the [Response][requests.Response] as returned by the Introspection Endpoint.\n\n        Returns:\n            the decoded JSON content, or a `str` with the content.\n\n        \"\"\"\n        try:\n            return response.json()\n        except ValueError:\n            return response.text\n\n    def on_introspection_error(self, response: requests.Response) -&gt; Any:\n        \"\"\"Error handler for `introspect_token()`.\n\n        Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n        to parse the returned response in the case an error is returned.\n\n        Args:\n            response: the response as returned by the Introspection Endpoint.\n\n        Returns:\n            usually raises exceptions. A subclass can return a default response instead.\n\n        Raises:\n            EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n            UnknownIntrospectionError: if the response is not a standard error response.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, IntrospectionError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise UnknownIntrospectionError(response=response, client=self) from exc\n        raise exception\n\n    def backchannel_authentication_request(  # noqa: PLR0913\n        self,\n        scope: None | str | Iterable[str] = \"openid\",\n        *,\n        client_notification_token: str | None = None,\n        acr_values: None | str | Iterable[str] = None,\n        login_hint_token: str | None = None,\n        id_token_hint: str | None = None,\n        login_hint: str | None = None,\n        binding_message: str | None = None,\n        user_code: str | None = None,\n        requested_expiry: int | None = None,\n        private_jwk: Jwk | dict[str, Any] | None = None,\n        alg: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **ciba_kwargs: Any,\n    ) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Send a CIBA Authentication Request.\n\n        Args:\n             scope: the scope to include in the request.\n             client_notification_token: the Client Notification Token to include in the request.\n             acr_values: the acr values to include in the request.\n             login_hint_token: the Login Hint Token to include in the request.\n             id_token_hint: the ID Token Hint to include in the request.\n             login_hint: the Login Hint to include in the request.\n             binding_message: the Binding Message to include in the request.\n             user_code: the User Code to include in the request\n             requested_expiry: the Requested Expiry, in seconds, to include in the request.\n             private_jwk: the JWK to use to sign the request (optional)\n             alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.\n             requests_kwargs: additional parameters for\n             **ciba_kwargs: additional parameters to include in the request.\n\n        Returns:\n            a BackChannelAuthenticationResponse as returned by AS\n\n        Raises:\n            InvalidBackchannelAuthenticationRequestHintParam: if none of `login_hint`, `login_hint_token`\n                or `id_token_hint` is provided, or more than one of them is provided.\n            InvalidScopeParam: if the `scope` parameter is invalid.\n            InvalidAcrValuesParam: if the `acr_values` parameter is invalid.\n\n        \"\"\"\n        if not (login_hint or login_hint_token or id_token_hint):\n            msg = \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n            raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n        if (login_hint_token and id_token_hint) or (login_hint and id_token_hint) or (login_hint_token and login_hint):\n            msg = \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n            raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n        requests_kwargs = requests_kwargs or {}\n\n        if scope is not None and not isinstance(scope, str):\n            try:\n                scope = \" \".join(scope)\n            except Exception as exc:\n                raise InvalidScopeParam(scope) from exc\n\n        if acr_values is not None and not isinstance(acr_values, str):\n            try:\n                acr_values = \" \".join(acr_values)\n            except Exception as exc:\n                raise InvalidAcrValuesParam(acr_values) from exc\n\n        data = dict(\n            ciba_kwargs,\n            scope=scope,\n            client_notification_token=client_notification_token,\n            acr_values=acr_values,\n            login_hint_token=login_hint_token,\n            id_token_hint=id_token_hint,\n            login_hint=login_hint,\n            binding_message=binding_message,\n            user_code=user_code,\n            requested_expiry=requested_expiry,\n        )\n\n        if private_jwk is not None:\n            data = {\"request\": str(Jwt.sign(data, key=private_jwk, alg=alg))}\n\n        return self._request(\n            Endpoints.BACKCHANNEL_AUTHENTICATION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_backchannel_authentication_response,\n            on_failure=self.on_backchannel_authentication_error,\n            **requests_kwargs,\n        )\n\n    def parse_backchannel_authentication_response(\n        self,\n        response: requests.Response,\n    ) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Parse a response received by `backchannel_authentication_request()`.\n\n        Invoked by\n        [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n        to parse the response returned by the BackChannel Authentication Endpoint.\n\n        Args:\n            response: the response returned by the BackChannel Authentication Endpoint.\n\n        Returns:\n            a `BackChannelAuthenticationResponse`\n\n        Raises:\n            InvalidBackChannelAuthenticationResponse: if the response does not contain a standard\n                BackChannel Authentication response.\n\n        \"\"\"\n        try:\n            return BackChannelAuthenticationResponse(**response.json())\n        except TypeError as exc:\n            raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n\n    def on_backchannel_authentication_error(self, response: requests.Response) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Error handler for `backchannel_authentication_request()`.\n\n        Invoked by\n        [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n        to parse the response returned by the BackChannel Authentication Endpoint, when it is an\n        error.\n\n        Args:\n            response: the response returned by the BackChannel Authentication Endpoint.\n\n        Returns:\n            usually raises an exception. But a subclass can return a default response instead.\n\n        Raises:\n            EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n            InvalidBackChannelAuthenticationResponse: for non-standard error responses.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, BackChannelAuthenticationError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n        raise exception\n\n    def authorize_device(\n        self,\n        requests_kwargs: dict[str, Any] | None = None,\n        **data: Any,\n    ) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Send a Device Authorization Request.\n\n        Args:\n            **data: additional data to send to the Device Authorization Endpoint\n            requests_kwargs: additional parameters for `requests.request()`\n\n        Returns:\n            a Device Authorization Response\n\n        Raises:\n            MissingEndpointUri: if the Device Authorization URI is not configured\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        return self._request(\n            Endpoints.DEVICE_AUTHORIZATION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_device_authorization_response,\n            on_failure=self.on_device_authorization_error,\n            **requests_kwargs,\n        )\n\n    def parse_device_authorization_response(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Parse a Device Authorization Response received by `authorize_device()`.\n\n        Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n        to parse the response returned by the Device Authorization Endpoint.\n\n        Args:\n            response: the response returned by the Device Authorization Endpoint.\n\n        Returns:\n            a `DeviceAuthorizationResponse` as returned by AS\n\n        \"\"\"\n        return DeviceAuthorizationResponse(**response.json())\n\n    def on_device_authorization_error(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Error handler for `authorize_device()`.\n\n        Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n        to parse the response returned by the Device Authorization Endpoint, when that response is\n        an error.\n\n        Args:\n            response: the response returned by the Device Authorization Endpoint.\n\n        Returns:\n            usually raises an Exception. But a subclass may return a default response instead.\n\n        Raises:\n            EndpointError: for standard OAuth 2.0 errors\n            InvalidDeviceAuthorizationResponse: for non-standard error responses.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, DeviceAuthorizationError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidDeviceAuthorizationResponse(response=response, client=self) from exc\n        raise exception\n\n    def update_authorization_server_public_keys(self, requests_kwargs: dict[str, Any] | None = None) -&gt; JwkSet:\n        \"\"\"Update the cached AS public keys by retrieving them from its `jwks_uri`.\n\n        Public keys are returned by this method, as a `jwskate.JwkSet`. They are also\n        available in attribute `authorization_server_jwks`.\n\n        Returns:\n            the retrieved public keys\n\n        Raises:\n            ValueError: if no `jwks_uri` is configured\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        jwks = self._request(\n            Endpoints.JWKS,\n            auth=None,\n            method=\"GET\",\n            on_success=lambda resp: resp.json(),\n            on_failure=lambda resp: resp.raise_for_status(),\n            **requests_kwargs,\n        )\n        self.authorization_server_jwks.update(jwks)\n        return self.authorization_server_jwks\n\n    @classmethod\n    def from_discovery_endpoint(\n        cls,\n        url: str | None = None,\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        session: requests.Session | None = None,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialise an OAuth2Client based on Authorization Server Metadata.\n\n        This will retrieve the standardised metadata document available at `url`, and will extract\n        all Endpoint Uris from that document, will fetch the current public keys from its\n        `jwks_uri`, then will initialise an OAuth2Client based on those endpoints.\n\n        Args:\n             url: the url where the server metadata will be retrieved\n             auth: the authentication handler to use for client authentication\n             client_id: client ID\n             client_secret: client secret to use to authenticate the client\n             private_key: private key to sign client assertions\n             session: a `requests.Session` to use to retrieve the document and initialise the client with\n             issuer: if an issuer is given, check that it matches the one from the retrieved document\n             testing: if True, don't try to validate the endpoint urls that are part of the document\n             **kwargs: additional keyword parameters to pass to OAuth2Client\n\n        Returns:\n            an OAuth2Client with endpoint initialised based on the obtained metadata\n\n        Raises:\n            InvalidParam: if neither `url` nor `issuer` are suitable urls\n            requests.HTTPError: if an error happens while fetching the documents\n\n        Example:\n            ```python\n            from requests_oauth2client import OAuth2Client\n\n            client = OAuth2Client.from_discovery_endpoint(\n                issuer=\"https://myserver.net\",\n                client_id=\"my_client_id,\n                client_secret=\"my_client_secret\"\n            )\n            ```\n\n        \"\"\"\n        if url is None and issuer is not None:\n            url = oidc_discovery_document_url(issuer)\n        if url is None:\n            msg = \"Please specify at least one of `issuer` or `url`\"\n            raise InvalidParam(msg)\n\n        validate_endpoint_uri(url, path=False)\n\n        session = session or requests.Session()\n        discovery = session.get(url).json()\n\n        jwks_uri = discovery.get(\"jwks_uri\")\n        if jwks_uri:\n            jwks = JwkSet(session.get(jwks_uri).json())\n\n        return cls.from_discovery_document(\n            discovery,\n            issuer=issuer,\n            auth=auth,\n            session=session,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            authorization_server_jwks=jwks,\n            testing=testing,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_discovery_document(\n        cls,\n        discovery: dict[str, Any],\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        session: requests.Session | None = None,\n        https: bool = True,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an OAuth2Client, based on the server metadata from `discovery`.\n\n        Args:\n             discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint.\n             issuer: if an issuer is given, check that it matches the one mentioned in the document\n             auth: the authentication handler to use for client authentication\n             client_id: client ID\n             client_secret: client secret to use to authenticate the client\n             private_key: private key to sign client assertions\n             authorization_server_jwks: the current authorization server JWKS keys\n             session: a requests Session to use to retrieve the document and initialise the client with\n             https: (deprecated) if `True`, validates that urls in the discovery document use the https scheme\n             testing: if True, don't try to validate the endpoint urls that are part of the document\n             **kwargs: additional args that will be passed to OAuth2Client\n\n        Returns:\n            an `OAuth2Client` initialized with the endpoints from the discovery document\n\n        Raises:\n            InvalidDiscoveryDocument: if the document does not contain at least a `\"token_endpoint\"`.\n\n        \"\"\"\n        if not https:\n            warnings.warn(\n                \"\"\"\\\nThe https parameter is deprecated.\nTo disable endpoint uri validation, set `testing=True` when initializing your `OAuth2Client`.\"\"\",\n                stacklevel=1,\n            )\n            testing = True\n        if issuer and discovery.get(\"issuer\") != issuer:\n            msg = (\n                f\"Mismatching `issuer` value in discovery document\"\n                f\" (received '{discovery.get('issuer')}', expected '{issuer}')\"\n            )\n            raise InvalidParam(\n                msg,\n                issuer,\n                discovery.get(\"issuer\"),\n            )\n        if issuer is None:\n            issuer = discovery.get(\"issuer\")\n\n        token_endpoint = discovery.get(Endpoints.TOKEN)\n        if token_endpoint is None:\n            msg = \"token_endpoint not found in that discovery document\"\n            raise InvalidDiscoveryDocument(msg, discovery)\n        authorization_endpoint = discovery.get(Endpoints.AUTHORIZATION)\n        revocation_endpoint = discovery.get(Endpoints.REVOCATION)\n        introspection_endpoint = discovery.get(Endpoints.INSTROSPECTION)\n        userinfo_endpoint = discovery.get(Endpoints.USER_INFO)\n        jwks_uri = discovery.get(Endpoints.JWKS)\n        if jwks_uri is not None:\n            validate_endpoint_uri(jwks_uri, https=https)\n        authorization_response_iss_parameter_supported = discovery.get(\n            \"authorization_response_iss_parameter_supported\",\n            False,\n        )\n\n        return cls(\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            session=session,\n            issuer=issuer,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            testing=testing,\n            **kwargs,\n        )\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Allow using `OAuth2Client` as a context-manager.\n\n        The Authorization Server public keys are retrieved on `__enter__`.\n\n        \"\"\"\n        self.update_authorization_server_public_keys()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; bool:\n        return True\n\n    def _require_endpoint(self, endpoint: str) -&gt; str:\n        \"\"\"Check that a required endpoint url is set.\"\"\"\n        url = getattr(self, endpoint, None)\n        if not url:\n            raise MissingEndpointUri(endpoint)\n\n        return str(url)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.client_id","title":"<code>client_id: str</code>  <code>property</code>","text":"<p>Client ID.</p>"},{"location":"api/#requests_oauth2client.OAuth2Client.client_secret","title":"<code>client_secret: str | None</code>  <code>property</code>","text":"<p>Client Secret.</p>"},{"location":"api/#requests_oauth2client.OAuth2Client.client_jwks","title":"<code>client_jwks: JwkSet</code>  <code>property</code>","text":"<p>A <code>JwkSet</code> containing the public keys for this client.</p> <p>Keys are:</p> <ul> <li>the public key for client assertion signature verification (if using private_key_jwt)</li> <li>the ID Token encryption key</li> </ul>"},{"location":"api/#requests_oauth2client.OAuth2Client.validate_endpoint_uri","title":"<code>validate_endpoint_uri(attribute, uri)</code>","text":"<p>Validate that an endpoint URI is suitable for use.</p> <p>If you need to disable some checks (for AS testing purposes only!), provide a different method here.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@token_endpoint.validator\n@revocation_endpoint.validator\n@introspection_endpoint.validator\n@userinfo_endpoint.validator\n@authorization_endpoint.validator\n@backchannel_authentication_endpoint.validator\n@device_authorization_endpoint.validator\n@pushed_authorization_request_endpoint.validator\n@jwks_uri.validator\ndef validate_endpoint_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n    \"\"\"Validate that an endpoint URI is suitable for use.\n\n    If you need to disable some checks (for AS testing purposes only!), provide a different\n    method here.\n\n    \"\"\"\n    if self.testing or uri is None:\n        return uri\n    try:\n        return validate_endpoint_uri(uri)\n    except InvalidUri as exc:\n        raise InvalidEndpointUri(endpoint=attribute.name, uri=uri, exc=exc) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.validate_issuer_uri","title":"<code>validate_issuer_uri(attribute, uri)</code>","text":"<p>Validate that an Issuer identifier is suitable for use.</p> <p>This is the same check as an endpoint URI, but the path may be (and usually is) empty.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@issuer.validator\ndef validate_issuer_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n    \"\"\"Validate that an Issuer identifier is suitable for use.\n\n    This is the same check as an endpoint URI, but the path may be (and usually is) empty.\n\n    \"\"\"\n    if self.testing or uri is None:\n        return uri\n    try:\n        return validate_issuer_uri(uri)\n    except InvalidUri as exc:\n        raise InvalidIssuer(attribute.name, uri, exc) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.token_request","title":"<code>token_request(data, timeout=10, **requests_kwargs)</code>","text":"<p>Send a request to the token endpoint.</p> <p>Authentication will be added automatically based on the defined <code>auth</code> for this client.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>parameters to send to the token endpoint. Items with a <code>None</code>    or empty value will not be sent in the request.</p> required <code>timeout</code> <code>int</code> <p>a timeout value for the call</p> <code>10</code> <code>**requests_kwargs</code> <code>Any</code> <p>additional parameters for requests.post()</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>the token endpoint response, as</p> <code>BearerToken</code> <p><code>BearerToken</code> instance.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def token_request(\n    self,\n    data: dict[str, Any],\n    timeout: int = 10,\n    **requests_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint.\n\n    Authentication will be added automatically based on the defined `auth` for this client.\n\n    Args:\n      data: parameters to send to the token endpoint. Items with a `None`\n           or empty value will not be sent in the request.\n      timeout: a timeout value for the call\n      **requests_kwargs: additional parameters for requests.post()\n\n    Returns:\n        the token endpoint response, as\n        [`BearerToken`][requests_oauth2client.tokens.BearerToken] instance.\n\n    \"\"\"\n    return self._request(\n        Endpoints.TOKEN,\n        auth=self.auth,\n        data=data,\n        timeout=timeout,\n        on_success=self.parse_token_response,\n        on_failure=self.on_token_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_token_response","title":"<code>parse_token_response(response)</code>","text":"<p>Parse a Response returned by the Token Endpoint.</p> <p>Invoked by token_request to parse responses returned by the Token Endpoint. Those responses contain an <code>access_token</code> and additional attributes.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response returned by the Token Endpoint.</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> based on the response</p> <code>BearerToken</code> <p>contents.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_token_response(self, response: requests.Response) -&gt; BearerToken:\n    \"\"\"Parse a Response returned by the Token Endpoint.\n\n    Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse\n    responses returned by the Token Endpoint. Those responses contain an `access_token` and\n    additional attributes.\n\n    Args:\n        response: the [Response][requests.Response] returned by the Token Endpoint.\n\n    Returns:\n        a [`BearerToken`][requests_oauth2client.tokens.BearerToken] based on the response\n        contents.\n\n    \"\"\"\n    try:\n        token_response = self.token_class(**response.json())\n    except Exception:  # noqa: BLE001\n        return self.on_token_error(response)\n    else:\n        return token_response\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_token_error","title":"<code>on_token_error(response)</code>","text":"<p>Error handler for <code>token_request()</code>.</p> <p>Invoked by token_request when the Token Endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response returned by the Token Endpoint.</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>nothing, and raises an exception instead. But a subclass may return a</p> <code>BearerToken</code> <p><code>BearerToken</code> to implement a default</p> <code>BearerToken</code> <p>behaviour if needed.</p> <p>Raises:</p> Type Description <code>InvalidTokenResponse</code> <p>if the error response does not contain an OAuth 2.0 standard error response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_token_error(self, response: requests.Response) -&gt; BearerToken:\n    \"\"\"Error handler for `token_request()`.\n\n    Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the\n    Token Endpoint returns an error.\n\n    Args:\n        response: the [Response][requests.Response] returned by the Token Endpoint.\n\n    Returns:\n        nothing, and raises an exception instead. But a subclass may return a\n        [`BearerToken`][requests_oauth2client.tokens.BearerToken] to implement a default\n        behaviour if needed.\n\n    Raises:\n        InvalidTokenResponse: if the error response does not contain an OAuth 2.0 standard\n            error response.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidTokenResponse(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.client_credentials","title":"<code>client_credentials(scope=None, *, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint using the <code>client_credentials</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>str | Iterable[str] | None</code> <p>the scope to send with the request. Can be a str, or an iterable of str. to pass that way include <code>scope</code>, <code>audience</code>, <code>resource</code>, etc.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>. Common parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> <p>Raises:</p> Type Description <code>InvalidScopeParam</code> <p>if the <code>scope</code> parameter is not suitable</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def client_credentials(\n    self,\n    scope: str | Iterable[str] | None = None,\n    *,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint using the `client_credentials` grant.\n\n    Args:\n        scope: the scope to send with the request. Can be a str, or an iterable of str.\n            to pass that way include `scope`, `audience`, `resource`, etc.\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`. Common parameters\n\n    Returns:\n        a BearerToken\n\n    Raises:\n        InvalidScopeParam: if the `scope` parameter is not suitable\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if scope and not isinstance(scope, str):\n        try:\n            scope = \" \".join(scope)\n        except Exception as exc:\n            raise InvalidScopeParam(scope) from exc\n\n    data = dict(grant_type=GrantTypes.CLIENT_CREDENTIALS, scope=scope, **token_kwargs)\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.authorization_code","title":"<code>authorization_code(code, *, validate=True, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint with the <code>authorization_code</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str | AuthorizationResponse</code> <p>an authorization code or an <code>AuthorizationResponse</code> to exchange for tokens</p> required <code>validate</code> <code>bool</code> <p>if <code>True</code>, validate the received ID Token (this works only if <code>code</code> is an AuthorizationResponse)</p> <code>True</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>code</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorization_code(\n    self,\n    code: str | AuthorizationResponse,\n    *,\n    validate: bool = True,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint with the `authorization_code` grant.\n\n    Args:\n         code: an authorization code or an `AuthorizationResponse` to exchange for tokens\n         validate: if `True`, validate the received ID Token (this works only if `code` is an AuthorizationResponse)\n         requests_kwargs: additional parameters for the call to requests\n         **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `code`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    \"\"\"\n    azr: AuthorizationResponse | None = None\n    if isinstance(code, AuthorizationResponse):\n        token_kwargs.setdefault(\"code_verifier\", code.code_verifier)\n        token_kwargs.setdefault(\"redirect_uri\", code.redirect_uri)\n        azr = code\n        code = code.code\n\n    requests_kwargs = requests_kwargs or {}\n\n    data = dict(grant_type=GrantTypes.AUTHORIZATION_CODE, code=code, **token_kwargs)\n    token = self.token_request(data, **requests_kwargs)\n    if validate and token.id_token and isinstance(azr, AuthorizationResponse):\n        return token.validate_id_token(self, azr)\n    return token\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.refresh_token","title":"<code>refresh_token(refresh_token, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint with the <code>refresh_token</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str | BearerToken</code> <p>a refresh_token, as a string, or as a <code>BearerToken</code>. That <code>BearerToken</code> must have a <code>refresh_token</code>.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to <code>requests</code></p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>refresh_token</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> <p>Raises:</p> Type Description <code>MissingRefreshToken</code> <p>if <code>refresh_token</code> is a BearerToken instance but does not contain a <code>refresh_token</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def refresh_token(\n    self,\n    refresh_token: str | BearerToken,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint with the `refresh_token` grant.\n\n    Args:\n        refresh_token: a refresh_token, as a string, or as a `BearerToken`.\n            That `BearerToken` must have a `refresh_token`.\n        requests_kwargs: additional parameters for the call to `requests`\n        **token_kwargs: additional parameters for the token endpoint,\n            alongside `grant_type`, `refresh_token`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    Raises:\n        MissingRefreshToken: if `refresh_token` is a BearerToken instance but does not\n            contain a `refresh_token`\n\n    \"\"\"\n    if isinstance(refresh_token, BearerToken):\n        if refresh_token.refresh_token is None or not isinstance(refresh_token.refresh_token, str):\n            raise MissingRefreshToken(refresh_token)\n        refresh_token = refresh_token.refresh_token\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(grant_type=GrantTypes.REFRESH_TOKEN, refresh_token=refresh_token, **token_kwargs)\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.device_code","title":"<code>device_code(device_code, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint using the Device Code grant.</p> <p>The grant_type is <code>urn:ietf:params:oauth:grant-type:device_code</code>. This needs a Device Code, or a <code>DeviceAuthorizationResponse</code> as parameter.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a device code, or a <code>DeviceAuthorizationResponse</code></p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>device_code</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> <p>Raises:</p> Type Description <code>MissingDeviceCode</code> <p>if <code>device_code</code> is a DeviceAuthorizationResponse but does not contain a <code>device_code</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def device_code(\n    self,\n    device_code: str | DeviceAuthorizationResponse,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint using the Device Code grant.\n\n    The grant_type is `urn:ietf:params:oauth:grant-type:device_code`. This needs a Device Code,\n    or a `DeviceAuthorizationResponse` as parameter.\n\n    Args:\n        device_code: a device code, or a `DeviceAuthorizationResponse`\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    Raises:\n        MissingDeviceCode: if `device_code` is a DeviceAuthorizationResponse but does not\n            contain a `device_code`.\n\n    \"\"\"\n    if isinstance(device_code, DeviceAuthorizationResponse):\n        if device_code.device_code is None or not isinstance(device_code.device_code, str):\n            raise MissingDeviceCode(device_code)\n        device_code = device_code.device_code\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantTypes.DEVICE_CODE,\n        device_code=device_code,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.ciba","title":"<code>ciba(auth_req_id, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a CIBA request to the Token Endpoint.</p> <p>A CIBA request is a Token Request using the <code>urn:openid:params:grant-type:ciba</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>auth_req_id</code> <code>str | BackChannelAuthenticationResponse</code> <p>an authentication request ID, as returned by the AS</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>auth_req_id</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> <p>Raises:</p> Type Description <code>MissingAuthRequestId</code> <p>if <code>auth_req_id</code> is a BackChannelAuthenticationResponse but does not contain an <code>auth_req_id</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def ciba(\n    self,\n    auth_req_id: str | BackChannelAuthenticationResponse,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a CIBA request to the Token Endpoint.\n\n    A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant.\n\n    Args:\n        auth_req_id: an authentication request ID, as returned by the AS\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    Raises:\n        MissingAuthRequestId: if `auth_req_id` is a BackChannelAuthenticationResponse but does not contain\n            an `auth_req_id`.\n\n    \"\"\"\n    if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n        if auth_req_id.auth_req_id is None or not isinstance(auth_req_id.auth_req_id, str):\n            raise MissingAuthRequestId(auth_req_id)\n        auth_req_id = auth_req_id.auth_req_id\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantTypes.CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION,\n        auth_req_id=auth_req_id,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.token_exchange","title":"<code>token_exchange(subject_token, subject_token_type=None, actor_token=None, actor_token_type=None, requested_token_type=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a Token Exchange request.</p> <p>A Token Exchange request is actually a request to the Token Endpoint with a grant_type <code>urn:ietf:params:oauth:grant-type:token-exchange</code>.</p> <p>Parameters:</p> Name Type Description Default <code>subject_token</code> <code>str | BearerToken | IdToken</code> <p>the subject token to exchange for a new token.</p> required <code>subject_token_type</code> <code>str | None</code> <p>a token type identifier for the subject_token, mandatory if it cannot be guessed based on <code>type(subject_token)</code>.</p> <code>None</code> <code>actor_token</code> <code>None | str | BearerToken | IdToken</code> <p>the actor token to include in the request, if any.</p> <code>None</code> <code>actor_token_type</code> <code>str | None</code> <p>a token type identifier for the actor_token, mandatory if it cannot be guessed based on <code>type(actor_token)</code>.</p> <code>None</code> <code>requested_token_type</code> <code>str | None</code> <p>a token type identifier for the requested token.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> as returned by the Authorization Server.</p> <p>Raises:</p> Type Description <code>UnknownSubjectTokenType</code> <p>if the type of <code>subject_token</code> cannot be determined automatically.</p> <code>UnknownActorTokenType</code> <p>if the type of <code>actor_token</code> cannot be determined automaticatlly.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def token_exchange(\n    self,\n    subject_token: str | BearerToken | IdToken,\n    subject_token_type: str | None = None,\n    actor_token: None | str | BearerToken | IdToken = None,\n    actor_token_type: str | None = None,\n    requested_token_type: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a Token Exchange request.\n\n    A Token Exchange request is actually a request to the Token Endpoint with a grant_type\n    `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n    Args:\n        subject_token: the subject token to exchange for a new token.\n        subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based\n            on `type(subject_token)`.\n        actor_token: the actor token to include in the request, if any.\n        actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based\n            on `type(actor_token)`.\n        requested_token_type: a token type identifier for the requested token.\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        a `BearerToken` as returned by the Authorization Server.\n\n    Raises:\n        UnknownSubjectTokenType: if the type of `subject_token` cannot be determined automatically.\n        UnknownActorTokenType: if the type of `actor_token` cannot be determined automaticatlly.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    try:\n        subject_token_type = self.get_token_type(subject_token_type, subject_token)\n    except ValueError as exc:\n        raise UnknownSubjectTokenType(subject_token, subject_token_type) from exc\n    if actor_token:  # pragma: no branch\n        try:\n            actor_token_type = self.get_token_type(actor_token_type, actor_token)\n        except ValueError as exc:\n            raise UnknownActorTokenType(actor_token, actor_token_type) from exc\n\n    data = dict(\n        grant_type=GrantTypes.TOKEN_EXCHANGE,\n        subject_token=subject_token,\n        subject_token_type=subject_token_type,\n        actor_token=actor_token,\n        actor_token_type=actor_token_type,\n        requested_token_type=requested_token_type,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.jwt_bearer","title":"<code>jwt_bearer(assertion, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request using a JWT as authorization grant.</p> <p>This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).</p> <p>Parameters:</p> Name Type Description Default <code>assertion</code> <code>Jwt | str</code> <p>a JWT (as an instance of <code>jwskate.Jwt</code> or as a <code>str</code>) to use as authorization grant.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> as returned by the Authorization Server.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def jwt_bearer(\n    self,\n    assertion: Jwt | str,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request using a JWT as authorization grant.\n\n    This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).\n\n    Args:\n        assertion: a JWT (as an instance of `jwskate.Jwt` or as a `str`) to use as authorization grant.\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        a `BearerToken` as returned by the Authorization Server.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if not isinstance(assertion, Jwt):\n        assertion = Jwt(assertion)\n\n    data = dict(\n        grant_type=GrantTypes.JWT_BEARER,\n        assertion=assertion,\n        **token_kwargs,\n    )\n\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.resource_owner_password","title":"<code>resource_owner_password(username, password, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request using the Resource Owner Password Grant.</p> <p>This Grant Type is deprecated and should only be used when there is no other choice.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>the resource owner user name</p> required <code>password</code> <code>str</code> <p>the resource owner password</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> as returned by the Authorization Server</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def resource_owner_password(\n    self,\n    username: str,\n    password: str,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request using the Resource Owner Password Grant.\n\n    This Grant Type is deprecated and should only be used when there is no other choice.\n\n    Args:\n        username: the resource owner user name\n        password: the resource owner password\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        a `BearerToken` as returned by the Authorization Server\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantTypes.RESOURCE_OWNER_PASSWORD,\n        username=username,\n        password=password,\n        **token_kwargs,\n    )\n\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.authorization_request","title":"<code>authorization_request(*, scope='openid', response_type=ResponseTypes.CODE, redirect_uri=None, state=..., nonce=..., code_verifier=None, **kwargs)</code>","text":"<p>Generate an Authorization Request for this client.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>None | str | Iterable[str]</code> <p>the <code>scope</code> to use</p> <code>'openid'</code> <code>response_type</code> <code>str</code> <p>the <code>response_type</code> to use</p> <code>CODE</code> <code>redirect_uri</code> <code>str | None</code> <p>the <code>redirect_uri</code> to include in the request. By default, the <code>redirect_uri</code> defined at init time is used.</p> <code>None</code> <code>state</code> <code>str | ellipsis | None</code> <p>the <code>state</code> parameter to use. Leave default to generate a random value.</p> <code>...</code> <code>nonce</code> <code>str | ellipsis | None</code> <p>a <code>nonce</code>. Leave default to generate a random value.</p> <code>...</code> <code>code_verifier</code> <code>str | None</code> <p>the PKCE <code>code_verifier</code> to use. Leave default to generate a random value.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters to include in the auth request</p> <code>{}</code> <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>an AuthorizationRequest with the supplied parameters</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorization_request(\n    self,\n    *,\n    scope: None | str | Iterable[str] = \"openid\",\n    response_type: str = ResponseTypes.CODE,\n    redirect_uri: str | None = None,\n    state: str | ellipsis | None = ...,  # noqa: F821\n    nonce: str | ellipsis | None = ...,  # noqa: F821\n    code_verifier: str | None = None,\n    **kwargs: Any,\n) -&gt; AuthorizationRequest:\n    \"\"\"Generate an Authorization Request for this client.\n\n    Args:\n        scope: the `scope` to use\n        response_type: the `response_type` to use\n        redirect_uri: the `redirect_uri` to include in the request. By default,\n            the `redirect_uri` defined at init time is used.\n        state: the `state` parameter to use. Leave default to generate a random value.\n        nonce: a `nonce`. Leave default to generate a random value.\n        code_verifier: the PKCE `code_verifier` to use. Leave default to generate a random value.\n        **kwargs: additional parameters to include in the auth request\n\n    Returns:\n        an AuthorizationRequest with the supplied parameters\n\n    \"\"\"\n    authorization_endpoint = self._require_endpoint(\"authorization_endpoint\")\n\n    redirect_uri = redirect_uri or self.redirect_uri\n\n    return AuthorizationRequest(\n        authorization_endpoint=authorization_endpoint,\n        client_id=self.client_id,\n        redirect_uri=redirect_uri,\n        issuer=self.issuer,\n        response_type=response_type,\n        scope=scope,\n        state=state,\n        nonce=nonce,\n        code_verifier=code_verifier,\n        code_challenge_method=self.code_challenge_method,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.pushed_authorization_request","title":"<code>pushed_authorization_request(authorization_request, requests_kwargs=None)</code>","text":"<p>Send a Pushed Authorization Request.</p> <p>This sends a request to the Pushed Authorization Request Endpoint, and returns a <code>RequestUriParameterAuthorizationRequest</code> initialized with the AS response.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_request</code> <code>AuthorizationRequest</code> <p>the authorization request to send</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for <code>requests.request()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>the <code>RequestUriParameterAuthorizationRequest</code> initialized based on the AS response</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def pushed_authorization_request(\n    self,\n    authorization_request: AuthorizationRequest,\n    requests_kwargs: dict[str, Any] | None = None,\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Send a Pushed Authorization Request.\n\n    This sends a request to the Pushed Authorization Request Endpoint, and returns a\n    `RequestUriParameterAuthorizationRequest` initialized with the AS response.\n\n    Args:\n        authorization_request: the authorization request to send\n        requests_kwargs: additional parameters for `requests.request()`\n\n    Returns:\n        the `RequestUriParameterAuthorizationRequest` initialized based on the AS response\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n    return self._request(\n        Endpoints.PUSHED_AUTHORIZATION_REQUEST,\n        data=authorization_request.args,\n        auth=self.auth,\n        on_success=self.parse_pushed_authorization_response,\n        on_failure=self.on_pushed_authorization_request_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_pushed_authorization_response","title":"<code>parse_pushed_authorization_response(response)</code>","text":"<p>Parse the response obtained by <code>pushed_authorization_request()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the <code>requests.Response</code> returned by the PAR endpoint</p> required <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>a RequestUriParameterAuthorizationRequest instance</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_pushed_authorization_response(\n    self,\n    response: requests.Response,\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Parse the response obtained by `pushed_authorization_request()`.\n\n    Args:\n        response: the `requests.Response` returned by the PAR endpoint\n\n    Returns:\n        a RequestUriParameterAuthorizationRequest instance\n\n    \"\"\"\n    response_json = response.json()\n    request_uri = response_json.get(\"request_uri\")\n    expires_in = response_json.get(\"expires_in\")\n\n    return RequestUriParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request_uri=request_uri,\n        expires_in=expires_in,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_pushed_authorization_request_error","title":"<code>on_pushed_authorization_request_error(response)</code>","text":"<p>Error Handler for Pushed Authorization Endpoint errors.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the HTTP response as returned by the AS PAR endpoint.</p> required <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>a RequestUriParameterAuthorizationRequest, if the error is recoverable</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>a subclass of this error depending on the error returned by the AS</p> <code>InvalidPushedAuthorizationResponse</code> <p>if the returned response is not following the specifications</p> <code>UnknownTokenEndpointError</code> <p>for unknown/unhandled errors</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_pushed_authorization_request_error(\n    self,\n    response: requests.Response,\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Error Handler for Pushed Authorization Endpoint errors.\n\n    Args:\n        response: the HTTP response as returned by the AS PAR endpoint.\n\n    Returns:\n        a RequestUriParameterAuthorizationRequest, if the error is recoverable\n\n    Raises:\n        EndpointError: a subclass of this error depending on the error returned by the AS\n        InvalidPushedAuthorizationResponse: if the returned response is not following the\n            specifications\n        UnknownTokenEndpointError: for unknown/unhandled errors\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidPushedAuthorizationResponse(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.userinfo","title":"<code>userinfo(access_token)</code>","text":"<p>Call the UserInfo endpoint.</p> <p>This sends a request to the UserInfo endpoint, with the specified access_token, and returns the parsed result.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>BearerToken | str</code> <p>the access token to use</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the Response returned by the userinfo endpoint.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def userinfo(self, access_token: BearerToken | str) -&gt; Any:\n    \"\"\"Call the UserInfo endpoint.\n\n    This sends a request to the UserInfo endpoint, with the specified access_token, and returns\n    the parsed result.\n\n    Args:\n        access_token: the access token to use\n\n    Returns:\n        the [Response][requests.Response] returned by the userinfo endpoint.\n\n    \"\"\"\n    if isinstance(access_token, str):\n        access_token = BearerToken(access_token)\n    return self._request(\n        Endpoints.USER_INFO,\n        auth=access_token,\n        on_success=self.parse_userinfo_response,\n        on_failure=self.on_userinfo_error,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_userinfo_response","title":"<code>parse_userinfo_response(resp)</code>","text":"<p>Parse the response obtained by <code>userinfo()</code>.</p> <p>Invoked by userinfo() to parse the response from the UserInfo endpoint, this will extract and return its JSON content.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>a Response returned from the UserInfo endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the parsed JSON content from this response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_userinfo_response(self, resp: requests.Response) -&gt; Any:\n    \"\"\"Parse the response obtained by `userinfo()`.\n\n    Invoked by [userinfo()][requests_oauth2client.client.OAuth2Client.userinfo] to parse the\n    response from the UserInfo endpoint, this will extract and return its JSON content.\n\n    Args:\n        resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n    Returns:\n        the parsed JSON content from this response.\n\n    \"\"\"\n    return resp.json()\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_userinfo_error","title":"<code>on_userinfo_error(resp)</code>","text":"<p>Parse UserInfo error response.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>a Response returned from the UserInfo endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>nothing, raises exception instead.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_userinfo_error(self, resp: requests.Response) -&gt; Any:\n    \"\"\"Parse UserInfo error response.\n\n    Args:\n        resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n    Returns:\n        nothing, raises exception instead.\n\n    \"\"\"\n    resp.raise_for_status()\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.get_token_type","title":"<code>get_token_type(token_type=None, token=None)</code>  <code>classmethod</code>","text":"<p>Get standardized token type identifiers.</p> <p>Return a standardized token type identifier, based on a short <code>token_type</code> hint and/or a token value.</p> <p>Parameters:</p> Name Type Description Default <code>token_type</code> <code>str | None</code> <p>a token_type hint, as <code>str</code>. May be \"access_token\", \"refresh_token\" or \"id_token\"</p> <code>None</code> <code>token</code> <code>None | str | BearerToken | IdToken</code> <p>a token value, as an instance of <code>BearerToken</code> or IdToken, or as a <code>str</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the token_type as defined in the Token Exchange RFC8693.</p> <p>Raises:</p> Type Description <code>UnknownTokenType</code> <p>if the type of token cannot be determined</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>    @classmethod\n    def get_token_type(  # noqa: C901\n        cls,\n        token_type: str | None = None,\n        token: None | str | BearerToken | IdToken = None,\n    ) -&gt; str:\n        \"\"\"Get standardized token type identifiers.\n\n        Return a standardized token type identifier, based on a short `token_type` hint and/or a\n        token value.\n\n        Args:\n            token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\"\n                or \"id_token\"\n            token: a token value, as an instance of `BearerToken` or IdToken, or as a `str`.\n\n        Returns:\n            the token_type as defined in the Token Exchange RFC8693.\n\n        Raises:\n            UnknownTokenType: if the type of token cannot be determined\n\n        \"\"\"\n        if not (token_type or token):\n            msg = \"Cannot determine type of an empty token without a token_type hint\"\n            raise UnknownTokenType(msg, token, token_type)\n\n        if token_type is None:\n            if isinstance(token, str):\n                msg = \"\"\"\\\nCannot determine the type of provided token when it is a bare `str`. Please specify a 'token_type'.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            if isinstance(token, BearerToken):\n                return \"urn:ietf:params:oauth:token-type:access_token\"\n            if isinstance(token, IdToken):\n                return \"urn:ietf:params:oauth:token-type:id_token\"\n            msg = f\"Unknown token type {type(token)}\"\n            raise UnknownTokenType(msg, token, token_type)\n        if token_type == TokenType.ACCESS_TOKEN:\n            if token is not None and not isinstance(token, (str, BearerToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nA BearerToken or an access_token as a `str` is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:access_token\"\n        if token_type == TokenType.REFRESH_TOKEN:\n            if token is not None and isinstance(token, BearerToken) and not token.refresh_token:\n                msg = f\"\"\"\\\nThe supplied BearerToken does not contain a refresh_token, which is inconsistent with token_type '{token_type}'.\nA BearerToken containing a refresh_token is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:refresh_token\"\n        if token_type == TokenType.ID_TOKEN:\n            if token is not None and not isinstance(token, (str, IdToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nAn IdToken or a string representation of it is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:id_token\"\n\n        return {\n            \"saml1\": \"urn:ietf:params:oauth:token-type:saml1\",\n            \"saml2\": \"urn:ietf:params:oauth:token-type:saml2\",\n            \"jwt\": \"urn:ietf:params:oauth:token-type:jwt\",\n        }.get(token_type, token_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.revoke_access_token","title":"<code>revoke_access_token(access_token, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a request to the Revocation Endpoint to revoke an access token.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>BearerToken | str</code> <p>the access token to revoke</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the underlying requests.post() call</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to pass to the revocation endpoint</p> <code>{}</code> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_access_token(\n    self,\n    access_token: BearerToken | str,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a request to the Revocation Endpoint to revoke an access token.\n\n    Args:\n        access_token: the access token to revoke\n        requests_kwargs: additional parameters for the underlying requests.post() call\n        **revoke_kwargs: additional parameters to pass to the revocation endpoint\n\n    \"\"\"\n    return self.revoke_token(\n        access_token,\n        token_type_hint=TokenType.ACCESS_TOKEN,\n        requests_kwargs=requests_kwargs,\n        **revoke_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.revoke_refresh_token","title":"<code>revoke_refresh_token(refresh_token, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a request to the Revocation Endpoint to revoke a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str | BearerToken</code> <p>the refresh token to revoke.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the revocation endpoint.</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to pass to the revocation endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the revocation request is successful, <code>False</code> if this client has no configured</p> <code>bool</code> <p>revocation endpoint.</p> <p>Raises:</p> Type Description <code>MissingRefreshToken</code> <p>when <code>refresh_token</code> is a BearerToken but does not contain a <code>refresh_token</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_refresh_token(\n    self,\n    refresh_token: str | BearerToken,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a request to the Revocation Endpoint to revoke a refresh token.\n\n    Args:\n        refresh_token: the refresh token to revoke.\n        requests_kwargs: additional parameters to pass to the revocation endpoint.\n        **revoke_kwargs: additional parameters to pass to the revocation endpoint.\n\n    Returns:\n        `True` if the revocation request is successful, `False` if this client has no configured\n        revocation endpoint.\n\n    Raises:\n        MissingRefreshToken: when `refresh_token` is a [BearerToken][requests_oauth2client.tokens.BearerToken]\n            but does not contain a `refresh_token`.\n\n    \"\"\"\n    if isinstance(refresh_token, BearerToken):\n        if refresh_token.refresh_token is None:\n            raise MissingRefreshToken(refresh_token)\n        refresh_token = refresh_token.refresh_token\n\n    return self.revoke_token(\n        refresh_token,\n        token_type_hint=TokenType.REFRESH_TOKEN,\n        requests_kwargs=requests_kwargs,\n        **revoke_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.revoke_token","title":"<code>revoke_token(token, token_type_hint=None, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a Token Revocation request.</p> <p>By default, authentication will be the same than the one used for the Token Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str | BearerToken</code> <p>the token to revoke.</p> required <code>token_type_hint</code> <code>str | None</code> <p>a token_type_hint to send to the revocation endpoint.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to the underling call to requests.post()</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to send to the revocation endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the revocation succeeds, <code>False</code> if no revocation endpoint is present or a</p> <code>bool</code> <p>non-standardised error is returned.</p> <p>Raises:</p> Type Description <code>MissingEndpointUri</code> <p>if the Revocation Endpoint URI is not configured.</p> <code>MissingRefreshToken</code> <p>if <code>token_type_hint</code> is <code>\"refresh_token\"</code> and <code>token</code> is a BearerToken but does not contain a <code>refresh_token</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_token(\n    self,\n    token: str | BearerToken,\n    token_type_hint: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a Token Revocation request.\n\n    By default, authentication will be the same than the one used for the Token Endpoint.\n\n    Args:\n        token: the token to revoke.\n        token_type_hint: a token_type_hint to send to the revocation endpoint.\n        requests_kwargs: additional parameters to the underling call to requests.post()\n        **revoke_kwargs: additional parameters to send to the revocation endpoint.\n\n    Returns:\n        `True` if the revocation succeeds, `False` if no revocation endpoint is present or a\n        non-standardised error is returned.\n\n    Raises:\n        MissingEndpointUri: if the Revocation Endpoint URI is not configured.\n        MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n            but does not contain a `refresh_token`.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if token_type_hint == TokenType.REFRESH_TOKEN and isinstance(token, BearerToken):\n        if token.refresh_token is None:\n            raise MissingRefreshToken(token)\n        token = token.refresh_token\n\n    data = dict(revoke_kwargs, token=str(token))\n    if token_type_hint:\n        data[\"token_type_hint\"] = token_type_hint\n\n    return self._request(\n        Endpoints.REVOCATION,\n        data=data,\n        auth=self.auth,\n        on_success=lambda _: True,\n        on_failure=self.on_revocation_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_revocation_error","title":"<code>on_revocation_error(response)</code>","text":"<p>Error handler for <code>revoke_token()</code>.</p> <p>Invoked by revoke_token() when the revocation endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response as returned by the Revocation Endpoint</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>False</code> to signal that an error occurred. May raise exceptions instead depending on the</p> <code>bool</code> <p>revocation response.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>if the response contains a standardised OAuth 2.0 error.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_revocation_error(self, response: requests.Response) -&gt; bool:\n    \"\"\"Error handler for `revoke_token()`.\n\n    Invoked by [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token] when the\n    revocation endpoint returns an error.\n\n    Args:\n        response: the [Response][requests.Response] as returned by the Revocation Endpoint\n\n    Returns:\n        `False` to signal that an error occurred. May raise exceptions instead depending on the\n        revocation response.\n\n    Raises:\n        EndpointError: if the response contains a standardised OAuth 2.0 error.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, RevocationError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception:  # noqa: BLE001\n        return False\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.introspect_token","title":"<code>introspect_token(token, token_type_hint=None, requests_kwargs=None, **introspect_kwargs)</code>","text":"<p>Send a request to the Introspection Endpoint.</p> <p>Parameter <code>token</code> can be:</p> <ul> <li>a <code>str</code></li> <li>a <code>BearerToken</code> instance</li> </ul> <p>You may pass any arbitrary <code>token</code> and <code>token_type_hint</code> values as <code>str</code>. Those will be included in the request, as-is. If <code>token</code> is a <code>BearerToken</code>, then <code>token_type_hint</code> must be either:</p> <ul> <li><code>None</code>: the access_token will be instrospected and no token_type_hint will be included in the request</li> <li><code>access_token</code>: same as <code>None</code>, but the token_type_hint will be included</li> <li>or <code>refresh_token</code>: only available if a Refresh Token is present in the BearerToken.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str | BearerToken</code> <p>the token to instrospect</p> required <code>token_type_hint</code> <code>str | None</code> <p>the <code>token_type_hint</code> to include in the request.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to the underling call to requests.post()</p> <code>None</code> <code>**introspect_kwargs</code> <code>Any</code> <p>additional parameters to send to the introspection endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>the response as returned by the Introspection Endpoint.</p> <p>Raises:</p> Type Description <code>MissingRefreshToken</code> <p>if <code>token_type_hint</code> is <code>\"refresh_token\"</code> and <code>token</code> is a BearerToken but does not contain a <code>refresh_token</code>.</p> <code>UnknownTokenType</code> <p>if <code>token_type_hint</code> is neither <code>None</code>, <code>\"access_token\"</code> or <code>\"refresh_token\"</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>    def introspect_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **introspect_kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"Send a request to the Introspection Endpoint.\n\n        Parameter `token` can be:\n\n        - a `str`\n        - a `BearerToken` instance\n\n        You may pass any arbitrary `token` and `token_type_hint` values as `str`. Those will\n        be included in the request, as-is.\n        If `token` is a `BearerToken`, then `token_type_hint` must be either:\n\n        - `None`: the access_token will be instrospected and no token_type_hint will be included\n        in the request\n        - `access_token`: same as `None`, but the token_type_hint will be included\n        - or `refresh_token`: only available if a Refresh Token is present in the BearerToken.\n\n        Args:\n            token: the token to instrospect\n            token_type_hint: the `token_type_hint` to include in the request.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **introspect_kwargs: additional parameters to send to the introspection endpoint.\n\n        Returns:\n            the response as returned by the Introspection Endpoint.\n\n        Raises:\n            MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n                but does not contain a `refresh_token`.\n            UnknownTokenType: if `token_type_hint` is neither `None`, `\"access_token\"` or `\"refresh_token\"`.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if isinstance(token, BearerToken):\n            if token_type_hint is None or token_type_hint == TokenType.ACCESS_TOKEN:\n                token = token.access_token\n            elif token_type_hint == TokenType.REFRESH_TOKEN:\n                if token.refresh_token is None:\n                    raise MissingRefreshToken(token)\n\n                token = token.refresh_token\n            else:\n                msg = \"\"\"\\\nInvalid `token_type_hint`. To test arbitrary `token_type_hint` values, you must provide `token` as a `str`.\"\"\"\n                raise UnknownTokenType(msg, token, token_type_hint)\n\n        data = dict(introspect_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            Endpoints.INSTROSPECTION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_introspection_response,\n            on_failure=self.on_introspection_error,\n            **requests_kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_introspection_response","title":"<code>parse_introspection_response(response)</code>","text":"<p>Parse Token Introspection Responses received by <code>introspect_token()</code>.</p> <p>Invoked by introspect_token() to parse the returned response. This decodes the JSON content if possible, otherwise it returns the response as a string.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response as returned by the Introspection Endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the decoded JSON content, or a <code>str</code> with the content.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_introspection_response(self, response: requests.Response) -&gt; Any:\n    \"\"\"Parse Token Introspection Responses received by `introspect_token()`.\n\n    Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n    to parse the returned response. This decodes the JSON content if possible, otherwise it\n    returns the response as a string.\n\n    Args:\n        response: the [Response][requests.Response] as returned by the Introspection Endpoint.\n\n    Returns:\n        the decoded JSON content, or a `str` with the content.\n\n    \"\"\"\n    try:\n        return response.json()\n    except ValueError:\n        return response.text\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_introspection_error","title":"<code>on_introspection_error(response)</code>","text":"<p>Error handler for <code>introspect_token()</code>.</p> <p>Invoked by introspect_token() to parse the returned response in the case an error is returned.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response as returned by the Introspection Endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>usually raises exceptions. A subclass can return a default response instead.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>(or one of its subclasses) if the response contains a standard OAuth 2.0 error.</p> <code>UnknownIntrospectionError</code> <p>if the response is not a standard error response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_introspection_error(self, response: requests.Response) -&gt; Any:\n    \"\"\"Error handler for `introspect_token()`.\n\n    Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n    to parse the returned response in the case an error is returned.\n\n    Args:\n        response: the response as returned by the Introspection Endpoint.\n\n    Returns:\n        usually raises exceptions. A subclass can return a default response instead.\n\n    Raises:\n        EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n        UnknownIntrospectionError: if the response is not a standard error response.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, IntrospectionError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise UnknownIntrospectionError(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.backchannel_authentication_request","title":"<code>backchannel_authentication_request(scope='openid', *, client_notification_token=None, acr_values=None, login_hint_token=None, id_token_hint=None, login_hint=None, binding_message=None, user_code=None, requested_expiry=None, private_jwk=None, alg=None, requests_kwargs=None, **ciba_kwargs)</code>","text":"<p>Send a CIBA Authentication Request.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>None | str | Iterable[str]</code> <p>the scope to include in the request.</p> <code>'openid'</code> <code>client_notification_token</code> <code>str | None</code> <p>the Client Notification Token to include in the request.</p> <code>None</code> <code>acr_values</code> <code>None | str | Iterable[str]</code> <p>the acr values to include in the request.</p> <code>None</code> <code>login_hint_token</code> <code>str | None</code> <p>the Login Hint Token to include in the request.</p> <code>None</code> <code>id_token_hint</code> <code>str | None</code> <p>the ID Token Hint to include in the request.</p> <code>None</code> <code>login_hint</code> <code>str | None</code> <p>the Login Hint to include in the request.</p> <code>None</code> <code>binding_message</code> <code>str | None</code> <p>the Binding Message to include in the request.</p> <code>None</code> <code>user_code</code> <code>str | None</code> <p>the User Code to include in the request</p> <code>None</code> <code>requested_expiry</code> <code>int | None</code> <p>the Requested Expiry, in seconds, to include in the request.</p> <code>None</code> <code>private_jwk</code> <code>Jwk | dict[str, Any] | None</code> <p>the JWK to use to sign the request (optional)</p> <code>None</code> <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for</p> <code>None</code> <code>**ciba_kwargs</code> <code>Any</code> <p>additional parameters to include in the request.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>a BackChannelAuthenticationResponse as returned by AS</p> <p>Raises:</p> Type Description <code>InvalidBackchannelAuthenticationRequestHintParam</code> <p>if none of <code>login_hint</code>, <code>login_hint_token</code> or <code>id_token_hint</code> is provided, or more than one of them is provided.</p> <code>InvalidScopeParam</code> <p>if the <code>scope</code> parameter is invalid.</p> <code>InvalidAcrValuesParam</code> <p>if the <code>acr_values</code> parameter is invalid.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def backchannel_authentication_request(  # noqa: PLR0913\n    self,\n    scope: None | str | Iterable[str] = \"openid\",\n    *,\n    client_notification_token: str | None = None,\n    acr_values: None | str | Iterable[str] = None,\n    login_hint_token: str | None = None,\n    id_token_hint: str | None = None,\n    login_hint: str | None = None,\n    binding_message: str | None = None,\n    user_code: str | None = None,\n    requested_expiry: int | None = None,\n    private_jwk: Jwk | dict[str, Any] | None = None,\n    alg: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **ciba_kwargs: Any,\n) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Send a CIBA Authentication Request.\n\n    Args:\n         scope: the scope to include in the request.\n         client_notification_token: the Client Notification Token to include in the request.\n         acr_values: the acr values to include in the request.\n         login_hint_token: the Login Hint Token to include in the request.\n         id_token_hint: the ID Token Hint to include in the request.\n         login_hint: the Login Hint to include in the request.\n         binding_message: the Binding Message to include in the request.\n         user_code: the User Code to include in the request\n         requested_expiry: the Requested Expiry, in seconds, to include in the request.\n         private_jwk: the JWK to use to sign the request (optional)\n         alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.\n         requests_kwargs: additional parameters for\n         **ciba_kwargs: additional parameters to include in the request.\n\n    Returns:\n        a BackChannelAuthenticationResponse as returned by AS\n\n    Raises:\n        InvalidBackchannelAuthenticationRequestHintParam: if none of `login_hint`, `login_hint_token`\n            or `id_token_hint` is provided, or more than one of them is provided.\n        InvalidScopeParam: if the `scope` parameter is invalid.\n        InvalidAcrValuesParam: if the `acr_values` parameter is invalid.\n\n    \"\"\"\n    if not (login_hint or login_hint_token or id_token_hint):\n        msg = \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n        raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n    if (login_hint_token and id_token_hint) or (login_hint and id_token_hint) or (login_hint_token and login_hint):\n        msg = \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n        raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n    requests_kwargs = requests_kwargs or {}\n\n    if scope is not None and not isinstance(scope, str):\n        try:\n            scope = \" \".join(scope)\n        except Exception as exc:\n            raise InvalidScopeParam(scope) from exc\n\n    if acr_values is not None and not isinstance(acr_values, str):\n        try:\n            acr_values = \" \".join(acr_values)\n        except Exception as exc:\n            raise InvalidAcrValuesParam(acr_values) from exc\n\n    data = dict(\n        ciba_kwargs,\n        scope=scope,\n        client_notification_token=client_notification_token,\n        acr_values=acr_values,\n        login_hint_token=login_hint_token,\n        id_token_hint=id_token_hint,\n        login_hint=login_hint,\n        binding_message=binding_message,\n        user_code=user_code,\n        requested_expiry=requested_expiry,\n    )\n\n    if private_jwk is not None:\n        data = {\"request\": str(Jwt.sign(data, key=private_jwk, alg=alg))}\n\n    return self._request(\n        Endpoints.BACKCHANNEL_AUTHENTICATION,\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_backchannel_authentication_response,\n        on_failure=self.on_backchannel_authentication_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_backchannel_authentication_response","title":"<code>parse_backchannel_authentication_response(response)</code>","text":"<p>Parse a response received by <code>backchannel_authentication_request()</code>.</p> <p>Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the BackChannel Authentication Endpoint.</p> required <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>a <code>BackChannelAuthenticationResponse</code></p> <p>Raises:</p> Type Description <code>InvalidBackChannelAuthenticationResponse</code> <p>if the response does not contain a standard BackChannel Authentication response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_backchannel_authentication_response(\n    self,\n    response: requests.Response,\n) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Parse a response received by `backchannel_authentication_request()`.\n\n    Invoked by\n    [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n    to parse the response returned by the BackChannel Authentication Endpoint.\n\n    Args:\n        response: the response returned by the BackChannel Authentication Endpoint.\n\n    Returns:\n        a `BackChannelAuthenticationResponse`\n\n    Raises:\n        InvalidBackChannelAuthenticationResponse: if the response does not contain a standard\n            BackChannel Authentication response.\n\n    \"\"\"\n    try:\n        return BackChannelAuthenticationResponse(**response.json())\n    except TypeError as exc:\n        raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_backchannel_authentication_error","title":"<code>on_backchannel_authentication_error(response)</code>","text":"<p>Error handler for <code>backchannel_authentication_request()</code>.</p> <p>Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint, when it is an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the BackChannel Authentication Endpoint.</p> required <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>usually raises an exception. But a subclass can return a default response instead.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>(or one of its subclasses) if the response contains a standard OAuth 2.0 error.</p> <code>InvalidBackChannelAuthenticationResponse</code> <p>for non-standard error responses.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_backchannel_authentication_error(self, response: requests.Response) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Error handler for `backchannel_authentication_request()`.\n\n    Invoked by\n    [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n    to parse the response returned by the BackChannel Authentication Endpoint, when it is an\n    error.\n\n    Args:\n        response: the response returned by the BackChannel Authentication Endpoint.\n\n    Returns:\n        usually raises an exception. But a subclass can return a default response instead.\n\n    Raises:\n        EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n        InvalidBackChannelAuthenticationResponse: for non-standard error responses.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, BackChannelAuthenticationError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.authorize_device","title":"<code>authorize_device(requests_kwargs=None, **data)</code>","text":"<p>Send a Device Authorization Request.</p> <p>Parameters:</p> Name Type Description Default <code>**data</code> <code>Any</code> <p>additional data to send to the Device Authorization Endpoint</p> <code>{}</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for <code>requests.request()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>a Device Authorization Response</p> <p>Raises:</p> Type Description <code>MissingEndpointUri</code> <p>if the Device Authorization URI is not configured</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorize_device(\n    self,\n    requests_kwargs: dict[str, Any] | None = None,\n    **data: Any,\n) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Send a Device Authorization Request.\n\n    Args:\n        **data: additional data to send to the Device Authorization Endpoint\n        requests_kwargs: additional parameters for `requests.request()`\n\n    Returns:\n        a Device Authorization Response\n\n    Raises:\n        MissingEndpointUri: if the Device Authorization URI is not configured\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    return self._request(\n        Endpoints.DEVICE_AUTHORIZATION,\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_device_authorization_response,\n        on_failure=self.on_device_authorization_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_device_authorization_response","title":"<code>parse_device_authorization_response(response)</code>","text":"<p>Parse a Device Authorization Response received by <code>authorize_device()</code>.</p> <p>Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the Device Authorization Endpoint.</p> required <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>a <code>DeviceAuthorizationResponse</code> as returned by AS</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_device_authorization_response(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Parse a Device Authorization Response received by `authorize_device()`.\n\n    Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n    to parse the response returned by the Device Authorization Endpoint.\n\n    Args:\n        response: the response returned by the Device Authorization Endpoint.\n\n    Returns:\n        a `DeviceAuthorizationResponse` as returned by AS\n\n    \"\"\"\n    return DeviceAuthorizationResponse(**response.json())\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_device_authorization_error","title":"<code>on_device_authorization_error(response)</code>","text":"<p>Error handler for <code>authorize_device()</code>.</p> <p>Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint, when that response is an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the Device Authorization Endpoint.</p> required <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>usually raises an Exception. But a subclass may return a default response instead.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>for standard OAuth 2.0 errors</p> <code>InvalidDeviceAuthorizationResponse</code> <p>for non-standard error responses.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_device_authorization_error(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Error handler for `authorize_device()`.\n\n    Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n    to parse the response returned by the Device Authorization Endpoint, when that response is\n    an error.\n\n    Args:\n        response: the response returned by the Device Authorization Endpoint.\n\n    Returns:\n        usually raises an Exception. But a subclass may return a default response instead.\n\n    Raises:\n        EndpointError: for standard OAuth 2.0 errors\n        InvalidDeviceAuthorizationResponse: for non-standard error responses.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, DeviceAuthorizationError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidDeviceAuthorizationResponse(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.update_authorization_server_public_keys","title":"<code>update_authorization_server_public_keys(requests_kwargs=None)</code>","text":"<p>Update the cached AS public keys by retrieving them from its <code>jwks_uri</code>.</p> <p>Public keys are returned by this method, as a <code>jwskate.JwkSet</code>. They are also available in attribute <code>authorization_server_jwks</code>.</p> <p>Returns:</p> Type Description <code>JwkSet</code> <p>the retrieved public keys</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if no <code>jwks_uri</code> is configured</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def update_authorization_server_public_keys(self, requests_kwargs: dict[str, Any] | None = None) -&gt; JwkSet:\n    \"\"\"Update the cached AS public keys by retrieving them from its `jwks_uri`.\n\n    Public keys are returned by this method, as a `jwskate.JwkSet`. They are also\n    available in attribute `authorization_server_jwks`.\n\n    Returns:\n        the retrieved public keys\n\n    Raises:\n        ValueError: if no `jwks_uri` is configured\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    jwks = self._request(\n        Endpoints.JWKS,\n        auth=None,\n        method=\"GET\",\n        on_success=lambda resp: resp.json(),\n        on_failure=lambda resp: resp.raise_for_status(),\n        **requests_kwargs,\n    )\n    self.authorization_server_jwks.update(jwks)\n    return self.authorization_server_jwks\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.from_discovery_endpoint","title":"<code>from_discovery_endpoint(url=None, issuer=None, *, auth=None, client_id=None, client_secret=None, private_key=None, session=None, testing=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialise an OAuth2Client based on Authorization Server Metadata.</p> <p>This will retrieve the standardised metadata document available at <code>url</code>, and will extract all Endpoint Uris from that document, will fetch the current public keys from its <code>jwks_uri</code>, then will initialise an OAuth2Client based on those endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | None</code> <p>the url where the server metadata will be retrieved</p> <code>None</code> <code>auth</code> <code>AuthBase | tuple[str, str] | str | None</code> <p>the authentication handler to use for client authentication</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>client ID</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>client secret to use to authenticate the client</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>private key to sign client assertions</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>a <code>requests.Session</code> to use to retrieve the document and initialise the client with</p> <code>None</code> <code>issuer</code> <code>str | None</code> <p>if an issuer is given, check that it matches the one from the retrieved document</p> <code>None</code> <code>testing</code> <code>bool</code> <p>if True, don't try to validate the endpoint urls that are part of the document</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>additional keyword parameters to pass to OAuth2Client</p> <code>{}</code> <p>Returns:</p> Type Description <code>OAuth2Client</code> <p>an OAuth2Client with endpoint initialised based on the obtained metadata</p> <p>Raises:</p> Type Description <code>InvalidParam</code> <p>if neither <code>url</code> nor <code>issuer</code> are suitable urls</p> <code>HTTPError</code> <p>if an error happens while fetching the documents</p> Example <pre><code>from requests_oauth2client import OAuth2Client\n\nclient = OAuth2Client.from_discovery_endpoint(\n    issuer=\"https://myserver.net\",\n    client_id=\"my_client_id,\n    client_secret=\"my_client_secret\"\n)\n</code></pre> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@classmethod\ndef from_discovery_endpoint(\n    cls,\n    url: str | None = None,\n    issuer: str | None = None,\n    *,\n    auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_key: Jwk | dict[str, Any] | None = None,\n    session: requests.Session | None = None,\n    testing: bool = False,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n    \"\"\"Initialise an OAuth2Client based on Authorization Server Metadata.\n\n    This will retrieve the standardised metadata document available at `url`, and will extract\n    all Endpoint Uris from that document, will fetch the current public keys from its\n    `jwks_uri`, then will initialise an OAuth2Client based on those endpoints.\n\n    Args:\n         url: the url where the server metadata will be retrieved\n         auth: the authentication handler to use for client authentication\n         client_id: client ID\n         client_secret: client secret to use to authenticate the client\n         private_key: private key to sign client assertions\n         session: a `requests.Session` to use to retrieve the document and initialise the client with\n         issuer: if an issuer is given, check that it matches the one from the retrieved document\n         testing: if True, don't try to validate the endpoint urls that are part of the document\n         **kwargs: additional keyword parameters to pass to OAuth2Client\n\n    Returns:\n        an OAuth2Client with endpoint initialised based on the obtained metadata\n\n    Raises:\n        InvalidParam: if neither `url` nor `issuer` are suitable urls\n        requests.HTTPError: if an error happens while fetching the documents\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client\n\n        client = OAuth2Client.from_discovery_endpoint(\n            issuer=\"https://myserver.net\",\n            client_id=\"my_client_id,\n            client_secret=\"my_client_secret\"\n        )\n        ```\n\n    \"\"\"\n    if url is None and issuer is not None:\n        url = oidc_discovery_document_url(issuer)\n    if url is None:\n        msg = \"Please specify at least one of `issuer` or `url`\"\n        raise InvalidParam(msg)\n\n    validate_endpoint_uri(url, path=False)\n\n    session = session or requests.Session()\n    discovery = session.get(url).json()\n\n    jwks_uri = discovery.get(\"jwks_uri\")\n    if jwks_uri:\n        jwks = JwkSet(session.get(jwks_uri).json())\n\n    return cls.from_discovery_document(\n        discovery,\n        issuer=issuer,\n        auth=auth,\n        session=session,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_key=private_key,\n        authorization_server_jwks=jwks,\n        testing=testing,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.from_discovery_document","title":"<code>from_discovery_document(discovery, issuer=None, *, auth=None, client_id=None, client_secret=None, private_key=None, authorization_server_jwks=None, session=None, https=True, testing=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize an OAuth2Client, based on the server metadata from <code>discovery</code>.</p> <p>Parameters:</p> Name Type Description Default <code>discovery</code> <code>dict[str, Any]</code> <p>a dict of server metadata, in the same format as retrieved from a discovery endpoint.</p> required <code>issuer</code> <code>str | None</code> <p>if an issuer is given, check that it matches the one mentioned in the document</p> <code>None</code> <code>auth</code> <code>AuthBase | tuple[str, str] | str | None</code> <p>the authentication handler to use for client authentication</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>client ID</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>client secret to use to authenticate the client</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>private key to sign client assertions</p> <code>None</code> <code>authorization_server_jwks</code> <code>JwkSet | dict[str, Any] | None</code> <p>the current authorization server JWKS keys</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>a requests Session to use to retrieve the document and initialise the client with</p> <code>None</code> <code>https</code> <code>bool</code> <p>(deprecated) if <code>True</code>, validates that urls in the discovery document use the https scheme</p> <code>True</code> <code>testing</code> <code>bool</code> <p>if True, don't try to validate the endpoint urls that are part of the document</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>additional args that will be passed to OAuth2Client</p> <code>{}</code> <p>Returns:</p> Type Description <code>OAuth2Client</code> <p>an <code>OAuth2Client</code> initialized with the endpoints from the discovery document</p> <p>Raises:</p> Type Description <code>InvalidDiscoveryDocument</code> <p>if the document does not contain at least a <code>\"token_endpoint\"</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>    @classmethod\n    def from_discovery_document(\n        cls,\n        discovery: dict[str, Any],\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        session: requests.Session | None = None,\n        https: bool = True,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an OAuth2Client, based on the server metadata from `discovery`.\n\n        Args:\n             discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint.\n             issuer: if an issuer is given, check that it matches the one mentioned in the document\n             auth: the authentication handler to use for client authentication\n             client_id: client ID\n             client_secret: client secret to use to authenticate the client\n             private_key: private key to sign client assertions\n             authorization_server_jwks: the current authorization server JWKS keys\n             session: a requests Session to use to retrieve the document and initialise the client with\n             https: (deprecated) if `True`, validates that urls in the discovery document use the https scheme\n             testing: if True, don't try to validate the endpoint urls that are part of the document\n             **kwargs: additional args that will be passed to OAuth2Client\n\n        Returns:\n            an `OAuth2Client` initialized with the endpoints from the discovery document\n\n        Raises:\n            InvalidDiscoveryDocument: if the document does not contain at least a `\"token_endpoint\"`.\n\n        \"\"\"\n        if not https:\n            warnings.warn(\n                \"\"\"\\\nThe https parameter is deprecated.\nTo disable endpoint uri validation, set `testing=True` when initializing your `OAuth2Client`.\"\"\",\n                stacklevel=1,\n            )\n            testing = True\n        if issuer and discovery.get(\"issuer\") != issuer:\n            msg = (\n                f\"Mismatching `issuer` value in discovery document\"\n                f\" (received '{discovery.get('issuer')}', expected '{issuer}')\"\n            )\n            raise InvalidParam(\n                msg,\n                issuer,\n                discovery.get(\"issuer\"),\n            )\n        if issuer is None:\n            issuer = discovery.get(\"issuer\")\n\n        token_endpoint = discovery.get(Endpoints.TOKEN)\n        if token_endpoint is None:\n            msg = \"token_endpoint not found in that discovery document\"\n            raise InvalidDiscoveryDocument(msg, discovery)\n        authorization_endpoint = discovery.get(Endpoints.AUTHORIZATION)\n        revocation_endpoint = discovery.get(Endpoints.REVOCATION)\n        introspection_endpoint = discovery.get(Endpoints.INSTROSPECTION)\n        userinfo_endpoint = discovery.get(Endpoints.USER_INFO)\n        jwks_uri = discovery.get(Endpoints.JWKS)\n        if jwks_uri is not None:\n            validate_endpoint_uri(jwks_uri, https=https)\n        authorization_response_iss_parameter_supported = discovery.get(\n            \"authorization_response_iss_parameter_supported\",\n            False,\n        )\n\n        return cls(\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            session=session,\n            issuer=issuer,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            testing=testing,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.UnknownActorTokenType","title":"<code>UnknownActorTokenType</code>","text":"<p>               Bases: <code>UnknownTokenType</code></p> <p>Raised when the type of actor_token cannot be determined automatically.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class UnknownActorTokenType(UnknownTokenType):\n    \"\"\"Raised when the type of actor_token cannot be determined automatically.\"\"\"\n\n    def __init__(self, actor_token: object, actor_token_type: str | None) -&gt; None:\n        super().__init__(\"actor_token\", token=actor_token, token_type=actor_token_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.UnknownSubjectTokenType","title":"<code>UnknownSubjectTokenType</code>","text":"<p>               Bases: <code>UnknownTokenType</code></p> <p>Raised when the type of subject_token cannot be determined automatically.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class UnknownSubjectTokenType(UnknownTokenType):\n    \"\"\"Raised when the type of subject_token cannot be determined automatically.\"\"\"\n\n    def __init__(self, subject_token: object, subject_token_type: str | None) -&gt; None:\n        super().__init__(\"subject_token\", subject_token, subject_token_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.UnknownTokenType","title":"<code>UnknownTokenType</code>","text":"<p>               Bases: <code>InvalidParam</code>, <code>TypeError</code></p> <p>Raised when the type of a token cannot be determined automatically.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class UnknownTokenType(InvalidParam, TypeError):\n    \"\"\"Raised when the type of a token cannot be determined automatically.\"\"\"\n\n    def __init__(self, message: str, token: object, token_type: str | None) -&gt; None:\n        super().__init__(f\"Unable to determine the type of token provided: {message}\")\n        self.token = token\n        self.token_type = token_type\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseClientAssertionAuthenticationMethod","title":"<code>BaseClientAssertionAuthenticationMethod</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Base class for assertion-based client authentication methods.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen\nclass BaseClientAssertionAuthenticationMethod(BaseClientAuthenticationMethod):\n    \"\"\"Base class for assertion-based client authentication methods.\"\"\"\n\n    lifetime: int\n    jti_gen: Callable[[], str]\n    aud: str | None\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a Client Assertion for a specific audience.\n\n        Args:\n            audience: the audience to use for the `aud` claim of the generated Client Assertion.\n\n        Returns:\n            a Client Assertion, as `str`.\n\n        \"\"\"\n        raise NotImplementedError\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add a `client_assertion` field in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added `client_assertion` field.\n\n        \"\"\"\n        request = super().__call__(request)\n        audience = self.aud or request.url\n        if audience is None:\n            raise InvalidRequestForClientAuthentication(request)  # pragma: no cover\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if request.body\n            else {}\n        )\n        client_assertion = self.client_assertion(audience)\n        params[b\"client_id\"] = [self.client_id.encode()]\n        params[b\"client_assertion\"] = [client_assertion.encode()]\n        params[b\"client_assertion_type\"] = [b\"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseClientAssertionAuthenticationMethod.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a Client Assertion for a specific audience.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the <code>aud</code> claim of the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion, as <code>str</code>.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a Client Assertion for a specific audience.\n\n    Args:\n        audience: the audience to use for the `aud` claim of the generated Client Assertion.\n\n    Returns:\n        a Client Assertion, as `str`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseClientAuthenticationMethod","title":"<code>BaseClientAuthenticationMethod</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Base class for all Client Authentication methods. This extends requests.auth.AuthBase.</p> <p>This base class checks that requests are suitable to add Client Authentication parameters to, and does not modify the request.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen\nclass BaseClientAuthenticationMethod(requests.auth.AuthBase):\n    \"\"\"Base class for all Client Authentication methods. This extends [requests.auth.AuthBase][].\n\n    This base class checks that requests are suitable to add Client Authentication parameters to,\n    and does not modify the request.\n\n    \"\"\"\n\n    client_id: str\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Check that the request is suitable for Client Authentication.\n\n        It checks:\n\n        * that the method is `POST`\n        * that the Content-Type is \"application/x-www-form-urlencoded\" or None\n\n        Args:\n            request: a [requests.PreparedRequest][]\n\n        Returns:\n            a [requests.PreparedRequest][], unmodified\n\n        Raises:\n            RuntimeError: if the request is not suitable for OAuth 2.0 Client Authentication\n\n        \"\"\"\n        if request.method != \"POST\" or request.headers.get(\"Content-Type\") not in (\n            \"application/x-www-form-urlencoded\",\n            None,\n        ):\n            raise InvalidRequestForClientAuthentication(request)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.ClientSecretBasic","title":"<code>ClientSecretBasic</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement <code>client_secret_basic</code> authentication.</p> <p>With this method, the client sends its Client ID and Secret, in the HTTP <code>Authorization</code> header, with the <code>Basic</code> scheme, in each authenticated request to the Authorization Server.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>client_secret</code> <code>str</code> <p>Client Secret</p> required Example <pre><code>from requests_oauth2client import ClientSecretBasic, OAuth2Client\n\nauth = ClientSecretBasic(\"my_client_id\", \"my_client_secret\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass ClientSecretBasic(BaseClientAuthenticationMethod):\n    \"\"\"Implement `client_secret_basic` authentication.\n\n    With this method, the client sends its Client ID and Secret, in the HTTP `Authorization` header, with\n    the `Basic` scheme, in each authenticated request to the Authorization Server.\n\n    Args:\n        client_id: Client ID\n        client_secret: Client Secret\n\n    Example:\n        ```python\n        from requests_oauth2client import ClientSecretBasic, OAuth2Client\n\n        auth = ClientSecretBasic(\"my_client_id\", \"my_client_secret\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    client_secret: str\n\n    def __init__(self, client_id: str, client_secret: str) -&gt; None:\n        self.__attrs_init__(\n            client_id=client_id,\n            client_secret=client_secret,\n        )\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the appropriate `Authorization` header in each request.\n\n        The Authorization header is formatted as such:\n        `Authorization: Basic BASE64('&lt;client_id:client_secret&gt;')`\n\n        Args:\n            request: the request\n\n        Returns:\n            a [requests.PreparedRequest][] with the added Authorization header.\n\n        \"\"\"\n        request = super().__call__(request)\n        b64encoded_credentials = BinaPy(f\"{self.client_id}:{self.client_secret}\").to(\"b64\").ascii()\n        request.headers[\"Authorization\"] = f\"Basic {b64encoded_credentials}\"\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.ClientSecretJwt","title":"<code>ClientSecretJwt</code>","text":"<p>               Bases: <code>BaseClientAssertionAuthenticationMethod</code></p> <p>Implement <code>client_secret_jwt</code> client authentication method.</p> <p>With this method, the client generates a client assertion, then symmetrically signs it with its Client Secret. The assertion is then sent to the AS in a <code>client_assertion</code> field with each authenticated request.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the <code>client_id</code> to use.</p> required <code>client_secret</code> <code>str</code> <p>the <code>client_secret</code> to use to sign generated Client Assertions.</p> required <code>alg</code> <code>str</code> <p>the alg to use to sign generated Client Assertions.</p> <code>HS256</code> <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> <code>60</code> <code>jti_gen</code> <code>Callable[[], str]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> <code>lambda: str(uuid4())</code> <code>aud</code> <code>str | None</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.</p> <code>None</code> Example <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\nauth = ClientSecretJwt(\"my_client_id\", \"my_client_secret\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass ClientSecretJwt(BaseClientAssertionAuthenticationMethod):\n    \"\"\"Implement `client_secret_jwt` client authentication method.\n\n    With this method, the client generates a client assertion, then symmetrically signs it with its Client Secret.\n    The assertion is then sent to the AS in a `client_assertion` field with each authenticated request.\n\n    Args:\n        client_id: the `client_id` to use.\n        client_secret: the `client_secret` to use to sign generated Client Assertions.\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\n        auth = ClientSecretJwt(\"my_client_id\", \"my_client_secret\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    client_secret: str\n    alg: str\n\n    def __init__(\n        self,\n        client_id: str,\n        client_secret: str,\n        lifetime: int = 60,\n        alg: str = SignatureAlgs.HS256,\n        jti_gen: Callable[[], str] = lambda: str(uuid4()),\n        aud: str | None = None,\n    ) -&gt; None:\n        self.__attrs_init__(\n            client_id=client_id,\n            client_secret=client_secret,\n            lifetime=lifetime,\n            alg=alg,\n            jti_gen=jti_gen,\n            aud=aud,\n        )\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a symmetrically signed Client Assertion.\n\n        Assertion is signed with the `client_secret` as key and the `alg` passed at init time.\n\n        Args:\n            audience: the audience to use for the generated Client Assertion.\n\n        Returns:\n            a Client Assertion, as `str`.\n\n        \"\"\"\n        iat = int(datetime.now(tz=timezone.utc).timestamp())\n        exp = iat + self.lifetime\n        jti = str(self.jti_gen())\n\n        jwk = SymmetricJwk.from_bytes(self.client_secret.encode())\n\n        jwt = Jwt.sign(\n            claims={\n                \"iss\": self.client_id,\n                \"sub\": self.client_id,\n                \"aud\": audience,\n                \"iat\": iat,\n                \"exp\": exp,\n                \"jti\": jti,\n            },\n            key=jwk,\n            alg=self.alg,\n        )\n        return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.ClientSecretJwt.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a symmetrically signed Client Assertion.</p> <p>Assertion is signed with the <code>client_secret</code> as key and the <code>alg</code> passed at init time.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion, as <code>str</code>.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a symmetrically signed Client Assertion.\n\n    Assertion is signed with the `client_secret` as key and the `alg` passed at init time.\n\n    Args:\n        audience: the audience to use for the generated Client Assertion.\n\n    Returns:\n        a Client Assertion, as `str`.\n\n    \"\"\"\n    iat = int(datetime.now(tz=timezone.utc).timestamp())\n    exp = iat + self.lifetime\n    jti = str(self.jti_gen())\n\n    jwk = SymmetricJwk.from_bytes(self.client_secret.encode())\n\n    jwt = Jwt.sign(\n        claims={\n            \"iss\": self.client_id,\n            \"sub\": self.client_id,\n            \"aud\": audience,\n            \"iat\": iat,\n            \"exp\": exp,\n            \"jti\": jti,\n        },\n        key=jwk,\n        alg=self.alg,\n    )\n    return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.ClientSecretPost","title":"<code>ClientSecretPost</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement <code>client_secret_post</code> client authentication method.</p> <p>With this method, the client inserts its client_id and client_secret in each authenticated request to the AS.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>client_secret</code> <code>str</code> <p>Client Secret</p> required Example <pre><code>from requests_oauth2client import ClientSecretPost, OAuth2Client\n\nauth = ClientSecretPost(\"my_client_id\", \"my_client_secret\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass ClientSecretPost(BaseClientAuthenticationMethod):\n    \"\"\"Implement `client_secret_post` client authentication method.\n\n    With this method, the client inserts its client_id and client_secret in each authenticated\n    request to the AS.\n\n    Args:\n        client_id: Client ID\n        client_secret: Client Secret\n\n    Example:\n        ```python\n        from requests_oauth2client import ClientSecretPost, OAuth2Client\n\n        auth = ClientSecretPost(\"my_client_id\", \"my_client_secret\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    client_secret: str\n\n    def __init__(self, client_id: str, client_secret: str) -&gt; None:\n        self.__attrs_init__(\n            client_id=client_id,\n            client_secret=client_secret,\n        )\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the `client_id` and `client_secret` parameters in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added client credentials fields.\n\n        \"\"\"\n        request = super().__call__(request)\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if isinstance(request.body, (str, bytes))\n            else {}\n        )\n        params[b\"client_id\"] = [self.client_id.encode()]\n        params[b\"client_secret\"] = [self.client_secret.encode()]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidClientAssertionSigningKeyOrAlg","title":"<code>InvalidClientAssertionSigningKeyOrAlg</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when the client assertion signing alg is not specified or invalid.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class InvalidClientAssertionSigningKeyOrAlg(ValueError):\n    \"\"\"Raised when the client assertion signing alg is not specified or invalid.\"\"\"\n\n    def __init__(self, alg: str | None) -&gt; None:\n        super().__init__(\"\"\"\\\nAn asymmetric private signing key, and an alg that is supported by the signing key is required.\nIt can be provided either:\n- as part of the private `Jwk`, in the parameter 'alg'\n- or passed as parameter `alg` when initializing a `PrivateKeyJwt`.\nExamples of valid `alg` values and matching key type:\n- 'RS256', 'RS512' (with a key of type RSA)\n- 'ES256', 'ES512' (with a key of type EC)\nThe private key must include a Key ID (in its 'kid' parameter).\n\"\"\")\n        self.alg = alg\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidRequestForClientAuthentication","title":"<code>InvalidRequestForClientAuthentication</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Raised when a request is not suitable for OAuth 2.0 client authentication.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class InvalidRequestForClientAuthentication(RuntimeError):\n    \"\"\"Raised when a request is not suitable for OAuth 2.0 client authentication.\"\"\"\n\n    def __init__(self, request: requests.PreparedRequest) -&gt; None:\n        super().__init__(\"This request is not suitabe for OAuth 2.0 client authentication.\")\n        self.request = request\n</code></pre>"},{"location":"api/#requests_oauth2client.PrivateKeyJwt","title":"<code>PrivateKeyJwt</code>","text":"<p>               Bases: <code>BaseClientAssertionAuthenticationMethod</code></p> <p>Implement <code>private_key_jwt</code> client authentication method.</p> <p>With this method, the client generates and sends a client_assertion, that is asymmetrically signed with a private key, on each direct request to the Authorization Server.</p> <p>The private key must be supplied as a <code>jwskate.Jwk</code> instance, or any key material that can be used to initialize one.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the <code>client_id</code> to use.</p> required <code>private_jwk</code> <code>Jwk | dict[str, Any] | Any</code> <p>the private key to use to sign generated Client Assertions.</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign generated Client Assertions.</p> <code>None</code> <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> <code>60</code> <code>jti_gen</code> <code>Callable[[], str]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> <code>lambda: str(uuid4())</code> <code>aud</code> <code>str | None</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.k</p> <code>None</code> Example <pre><code>from jwskate import Jwk\nfrom requests_oauth2client import OAuth2Client, PrivateKeyJwt\n\n# load your private key from wherever it is stored:\nwith open(\"my_private_key.pem\") as f:\n    my_private_key = Jwk.from_pem(f.read(), password=\"my_private_key_password\")\n\nauth = PrivateKeyJwt(\"my_client_id\", my_private_key, alg=\"RS256\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass PrivateKeyJwt(BaseClientAssertionAuthenticationMethod):\n    \"\"\"Implement `private_key_jwt` client authentication method.\n\n    With this method, the client generates and sends a client_assertion, that is asymmetrically\n    signed with a private key, on each direct request to the Authorization Server.\n\n    The private key must be supplied as a [`jwskate.Jwk`][jwskate.jwk.Jwk] instance,\n    or any key material that can be used to initialize one.\n\n    Args:\n        client_id: the `client_id` to use.\n        private_jwk: the private key to use to sign generated Client Assertions.\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.k\n\n    Example:\n        ```python\n        from jwskate import Jwk\n        from requests_oauth2client import OAuth2Client, PrivateKeyJwt\n\n        # load your private key from wherever it is stored:\n        with open(\"my_private_key.pem\") as f:\n            my_private_key = Jwk.from_pem(f.read(), password=\"my_private_key_password\")\n\n        auth = PrivateKeyJwt(\"my_client_id\", my_private_key, alg=\"RS256\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    private_jwk: Jwk = field(converter=to_jwk)\n    alg: str | None\n\n    def __init__(\n        self,\n        client_id: str,\n        private_jwk: Jwk | dict[str, Any] | Any,\n        *,\n        alg: str | None = None,\n        lifetime: int = 60,\n        jti_gen: Callable[[], str] = lambda: str(uuid4()),\n        aud: str | None = None,\n    ) -&gt; None:\n        self.__attrs_init__(\n            client_id=client_id,\n            private_jwk=private_jwk,\n            alg=alg,\n            lifetime=lifetime,\n            jti_gen=jti_gen,\n            aud=aud,\n        )\n\n        alg = self.private_jwk.alg or alg\n        if not alg:\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n        if alg not in self.private_jwk.supported_signing_algorithms():\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n        if not self.private_jwk.is_private or self.private_jwk.is_symmetric:\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n        kid = self.private_jwk.get(\"kid\")\n        if not kid:\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a Client Assertion, asymmetrically signed with `private_jwk` as key.\n\n        Args:\n            audience: the audience to use for the generated Client Assertion.\n\n        Returns:\n            a Client Assertion.\n\n        \"\"\"\n        iat = int(datetime.now(tz=timezone.utc).timestamp())\n        exp = iat + self.lifetime\n        jti = str(self.jti_gen())\n\n        jwt = Jwt.sign(\n            claims={\n                \"iss\": self.client_id,\n                \"sub\": self.client_id,\n                \"aud\": audience,\n                \"iat\": iat,\n                \"exp\": exp,\n                \"jti\": jti,\n            },\n            key=self.private_jwk,\n            alg=self.alg,\n        )\n        return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.PrivateKeyJwt.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a Client Assertion, asymmetrically signed with <code>private_jwk</code> as key.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a Client Assertion, asymmetrically signed with `private_jwk` as key.\n\n    Args:\n        audience: the audience to use for the generated Client Assertion.\n\n    Returns:\n        a Client Assertion.\n\n    \"\"\"\n    iat = int(datetime.now(tz=timezone.utc).timestamp())\n    exp = iat + self.lifetime\n    jti = str(self.jti_gen())\n\n    jwt = Jwt.sign(\n        claims={\n            \"iss\": self.client_id,\n            \"sub\": self.client_id,\n            \"aud\": audience,\n            \"iat\": iat,\n            \"exp\": exp,\n            \"jti\": jti,\n        },\n        key=self.private_jwk,\n        alg=self.alg,\n    )\n    return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.PublicApp","title":"<code>PublicApp</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement the <code>none</code> authentication method for public apps.</p> <p>This scheme is used for Public Clients, which do not have any secret credentials. Those only send their client_id to the Authorization Server.</p> Example <pre><code>from requests_oauth2client import OAuth2Client, PublicApp\n\nauth = PublicApp(\"my_client_id\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen\nclass PublicApp(BaseClientAuthenticationMethod):\n    \"\"\"Implement the `none` authentication method for public apps.\n\n    This scheme is used for Public Clients, which do not have any secret credentials. Those only\n    send their client_id to the Authorization Server.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, PublicApp\n\n        auth = PublicApp(\"my_client_id\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the `client_id` field in the request body.\n\n        Args:\n            request: a request.\n\n        Returns:\n            the request with the added `client_id` form field.\n\n        \"\"\"\n        request = super().__call__(request)\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if request.body\n            else {}\n        )\n        params[b\"client_id\"] = [self.client_id.encode()]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.UnsupportedClientCredentials","title":"<code>UnsupportedClientCredentials</code>","text":"<p>               Bases: <code>TypeError</code>, <code>ValueError</code></p> <p>Raised when unsupported client credentials are provided.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class UnsupportedClientCredentials(TypeError, ValueError):\n    \"\"\"Raised when unsupported client credentials are provided.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.DeviceAuthorizationPoolingJob","title":"<code>DeviceAuthorizationPoolingJob</code>","text":"<p>               Bases: <code>BaseTokenEndpointPoolingJob</code></p> <p>A Token Endpoint pooling job for the Device Authorization Flow.</p> <p>This periodically checks if the user has finished with his authorization in a Device Authorization flow.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client that will be used to pool the token endpoint.</p> required <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a <code>device_code</code> as <code>str</code> or a <code>DeviceAuthorizationResponse</code>.</p> required <code>interval</code> <code>int | None</code> <p>The pooling interval to use. This overrides the one in <code>auth_req_id</code> if it is a <code>BackChannelAuthenticationResponse</code>.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>Number of seconds to add to the pooling interval when the AS returns a slow-down request.</p> <code>5</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the underlying calls to requests.request.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token request.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import DeviceAuthorizationPoolingJob, OAuth2Client\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\npooler = DeviceAuthorizationPoolingJob(client=client, device_code=\"my_device_code\")\n\ntoken = None\nwhile token is None:\n    token = pooler()\n</code></pre> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>@define(init=False)\nclass DeviceAuthorizationPoolingJob(BaseTokenEndpointPoolingJob):\n    \"\"\"A Token Endpoint pooling job for the Device Authorization Flow.\n\n    This periodically checks if the user has finished with his authorization in a Device\n    Authorization flow.\n\n    Args:\n        client: an OAuth2Client that will be used to pool the token endpoint.\n        device_code: a `device_code` as `str` or a `DeviceAuthorizationResponse`.\n        interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is\n            a `BackChannelAuthenticationResponse`.\n        slow_down_interval: Number of seconds to add to the pooling interval when the AS returns\n            a slow-down request.\n        requests_kwargs: Additional parameters for the underlying calls to [requests.request][].\n        **token_kwargs: Additional parameters for the token request.\n\n    Example:\n        ```python\n        from requests_oauth2client import DeviceAuthorizationPoolingJob, OAuth2Client\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        pooler = DeviceAuthorizationPoolingJob(client=client, device_code=\"my_device_code\")\n\n        token = None\n        while token is None:\n            token = pooler()\n        ```\n\n    \"\"\"\n\n    device_code: str\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        device_code: str | DeviceAuthorizationResponse,\n        interval: int | None = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(device_code, DeviceAuthorizationResponse):\n            interval = interval or device_code.interval\n            device_code = device_code.device_code\n\n        self.__attrs_init__(\n            client=client,\n            device_code=device_code,\n            interval=interval or 5,\n            slow_down_interval=slow_down_interval,\n            requests_kwargs=requests_kwargs or {},\n            token_kwargs=token_kwargs,\n        )\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Implement the Device Code token request.\n\n        This actually calls [OAuth2Client.device_code(device_code)][requests_oauth2client.OAuth2Client.device_code]\n        on `self.client`.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        return self.client.device_code(self.device_code, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.DeviceAuthorizationPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Implement the Device Code token request.</p> <p>This actually calls OAuth2Client.device_code(device_code) on <code>self.client</code>.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Implement the Device Code token request.\n\n    This actually calls [OAuth2Client.device_code(device_code)][requests_oauth2client.OAuth2Client.device_code]\n    on `self.client`.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    return self.client.device_code(self.device_code, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.DeviceAuthorizationResponse","title":"<code>DeviceAuthorizationResponse</code>","text":"<p>Represent a response returned by the device Authorization Endpoint.</p> <p>All parameters are those returned by the AS as response to a Device Authorization Request.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>user_code</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>verification_uri</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>verification_uri_complete</code> <code>str | None</code> <p>the <code>device_code</code> as returned by the AS.</p> <code>None</code> <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for the device_code. Also accepts an <code>expires_in</code> parameter, as a number of seconds in the future.</p> <code>None</code> <code>interval</code> <code>int | None</code> <p>the pooling <code>interval</code> as returned by the AS.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>class DeviceAuthorizationResponse:\n    \"\"\"Represent a response returned by the device Authorization Endpoint.\n\n    All parameters are those returned by the AS as response to a Device Authorization Request.\n\n    Args:\n        device_code: the `device_code` as returned by the AS.\n        user_code: the `device_code` as returned by the AS.\n        verification_uri: the `device_code` as returned by the AS.\n        verification_uri_complete: the `device_code` as returned by the AS.\n        expires_at: the expiration date for the device_code.\n            Also accepts an `expires_in` parameter, as a number of seconds in the future.\n        interval: the pooling `interval` as returned by the AS.\n        **kwargs: additional parameters as returned by the AS.\n\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        device_code: str,\n        user_code: str,\n        verification_uri: str,\n        verification_uri_complete: str | None = None,\n        expires_at: datetime | None = None,\n        interval: int | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        self.device_code = device_code\n        self.user_code = user_code\n        self.verification_uri = verification_uri\n        self.verification_uri_complete = verification_uri_complete\n        self.expires_at = expires_at\n        self.interval = interval\n        self.other = kwargs\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Check if the `device_code` within this response is expired.\n\n        Returns:\n            `True` if the device_code is expired, `False` if it is still valid, `None` if there is\n            no `expires_in` hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n</code></pre>"},{"location":"api/#requests_oauth2client.DeviceAuthorizationResponse.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Check if the <code>device_code</code> within this response is expired.</p> <p>Returns:</p> Type Description <code>bool | None</code> <p><code>True</code> if the device_code is expired, <code>False</code> if it is still valid, <code>None</code> if there is</p> <code>bool | None</code> <p>no <code>expires_in</code> hint.</p> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Check if the `device_code` within this response is expired.\n\n    Returns:\n        `True` if the device_code is expired, `False` if it is still valid, `None` if there is\n        no `expires_in` hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.AccessDenied","title":"<code>AccessDenied</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when the Authorization Server returns <code>error = access_denied</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AccessDenied(EndpointError):\n    \"\"\"Raised when the Authorization Server returns `error = access_denied`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.AccountSelectionRequired","title":"<code>AccountSelectionRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = account_selection_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AccountSelectionRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = account_selection_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationPending","title":"<code>AuthorizationPending</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = authorization_pending</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AuthorizationPending(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = authorization_pending`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationResponseError","title":"<code>AuthorizationResponseError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for error responses returned by the Authorization endpoint.</p> <p>An <code>AuthorizationResponseError</code> contains the error message, description and uri that are returned by the AS.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>str</code> <p>the <code>error</code> identifier as returned by the AS</p> required <code>description</code> <code>str | None</code> <p>the <code>error_description</code> as returned by the AS</p> <code>None</code> <code>uri</code> <code>str | None</code> <p>the <code>error_uri</code> as returned by the AS</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AuthorizationResponseError(Exception):\n    \"\"\"Base class for error responses returned by the Authorization endpoint.\n\n    An `AuthorizationResponseError` contains the error message, description and uri that are\n    returned by the AS.\n\n    Args:\n        error: the `error` identifier as returned by the AS\n        description: the `error_description` as returned by the AS\n        uri: the `error_uri` as returned by the AS\n\n    \"\"\"\n\n    def __init__(\n        self,\n        request: AuthorizationRequest,\n        response: str,\n        error: str,\n        description: str | None = None,\n        uri: str | None = None,\n    ) -&gt; None:\n        self.error = error\n        self.description = description\n        self.uri = uri\n        self.request = request\n        self.response = response\n</code></pre>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationError","title":"<code>BackChannelAuthenticationError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for errors returned by the BackChannel Authentication endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class BackChannelAuthenticationError(EndpointError):\n    \"\"\"Base class for errors returned by the BackChannel Authentication endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.ConsentRequired","title":"<code>ConsentRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = consent_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ConsentRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = consent_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.DeviceAuthorizationError","title":"<code>DeviceAuthorizationError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for Device Authorization Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class DeviceAuthorizationError(EndpointError):\n    \"\"\"Base class for Device Authorization Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.EndpointError","title":"<code>EndpointError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Base class for exceptions raised from backend endpoint errors.</p> <p>This contains the error message, description and uri that are returned by the AS in the OAuth 2.0 standardised way.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the raw response containing the error.</p> required <code>error</code> <code>str</code> <p>the <code>error</code> identifier as returned by the AS.</p> required <code>description</code> <code>str | None</code> <p>the <code>error_description</code> as returned by the AS.</p> <code>None</code> <code>uri</code> <code>str | None</code> <p>the <code>error_uri</code> as returned by the AS.</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class EndpointError(OAuth2Error):\n    \"\"\"Base class for exceptions raised from backend endpoint errors.\n\n    This contains the error message, description and uri that are returned\n    by the AS in the OAuth 2.0 standardised way.\n\n    Args:\n        response: the raw response containing the error.\n        error: the `error` identifier as returned by the AS.\n        description: the `error_description` as returned by the AS.\n        uri: the `error_uri` as returned by the AS.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        response: requests.Response,\n        client: OAuth2Client,\n        error: str,\n        description: str | None = None,\n        uri: str | None = None,\n    ) -&gt; None:\n        super().__init__(response=response, client=client)\n        self.error = error\n        self.description = description\n        self.uri = uri\n</code></pre>"},{"location":"api/#requests_oauth2client.ExpiredToken","title":"<code>ExpiredToken</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = expired_token</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ExpiredToken(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = expired_token`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InteractionRequired","title":"<code>InteractionRequired</code>","text":"<p>               Bases: <code>AuthorizationResponseError</code></p> <p>Raised when the Authorization Endpoint returns <code>error = interaction_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InteractionRequired(AuthorizationResponseError):\n    \"\"\"Raised when the Authorization Endpoint returns `error = interaction_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.IntrospectionError","title":"<code>IntrospectionError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for Introspection Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class IntrospectionError(EndpointError):\n    \"\"\"Base class for Introspection Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidAuthResponse","title":"<code>InvalidAuthResponse</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when the Authorization Endpoint returns an invalid response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidAuthResponse(ValueError):\n    \"\"\"Raised when the Authorization Endpoint returns an invalid response.\"\"\"\n\n    def __init__(self, message: str, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(f\"The Authorization Response is invalid: {message}\")\n        self.request = request\n        self.response = response\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidBackChannelAuthenticationResponse","title":"<code>InvalidBackChannelAuthenticationResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the BackChannel Authentication endpoint returns a non-standard response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidBackChannelAuthenticationResponse(OAuth2Error):\n    \"\"\"Raised when the BackChannel Authentication endpoint returns a non-standard response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidClient","title":"<code>InvalidClient</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_client</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidClient(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_client`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidDeviceAuthorizationResponse","title":"<code>InvalidDeviceAuthorizationResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Device Authorization Endpoint returns a non-standard error response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidDeviceAuthorizationResponse(OAuth2Error):\n    \"\"\"Raised when the Device Authorization Endpoint returns a non-standard error response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidGrant","title":"<code>InvalidGrant</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_grant</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidGrant(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_grant`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidPushedAuthorizationResponse","title":"<code>InvalidPushedAuthorizationResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Pushed Authorization Endpoint returns an error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidPushedAuthorizationResponse(OAuth2Error):\n    \"\"\"Raised when the Pushed Authorization Endpoint returns an error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidRequest","title":"<code>InvalidRequest</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_request</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidRequest(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_request`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidScope","title":"<code>InvalidScope</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_scope</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidScope(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_scope`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidTarget","title":"<code>InvalidTarget</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_target</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidTarget(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_target`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidTokenResponse","title":"<code>InvalidTokenResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Token Endpoint returns a non-standard response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidTokenResponse(OAuth2Error):\n    \"\"\"Raised when the Token Endpoint returns a non-standard response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.LoginRequired","title":"<code>LoginRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = login_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class LoginRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = login_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIssuer","title":"<code>MismatchingIssuer</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised on mismatching <code>iss</code> value.</p> <p>This happens when the Authorization Endpoints returns an 'iss' that doesn't match the expected value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingIssuer(InvalidAuthResponse):\n    \"\"\"Raised on mismatching `iss` value.\n\n    This happens when the Authorization Endpoints returns an 'iss' that doesn't match the expected\n    value.\n\n    \"\"\"\n\n    def __init__(self, received: str, expected: str, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(f\"mismatching `iss` (received '{received}', expected '{expected}')\", request, response)\n        self.received = received\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingState","title":"<code>MismatchingState</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised on mismatching <code>state</code> value.</p> <p>This happens when the Authorization Endpoints returns a 'state' parameter that doesn't match the value passed in the Authorization Request.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingState(InvalidAuthResponse):\n    \"\"\"Raised on mismatching `state` value.\n\n    This happens when the Authorization Endpoints returns a 'state' parameter that doesn't match the\n    value passed in the Authorization Request.\n\n    \"\"\"\n\n    def __init__(self, received: str, expected: str, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(f\"mismatching `state` (received '{received}', expected '{expected}')\", request, response)\n        self.received = received\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingAuthCode","title":"<code>MissingAuthCode</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return the mandatory <code>code</code>.</p> <p>This happens when the Authorization Endpoint does not return an error, but does not return an authorization <code>code</code> either.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingAuthCode(InvalidAuthResponse):\n    \"\"\"Raised when the Authorization Endpoint does not return the mandatory `code`.\n\n    This happens when the Authorization Endpoint does not return an error, but does not return an\n    authorization `code` either.\n\n    \"\"\"\n\n    def __init__(self, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(\"missing `code` query parameter in response\", request, response)\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingIssuer","title":"<code>MissingIssuer</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return an <code>iss</code> parameter as expected.</p> <p>The Authorization Server advertises its support with a flag <code>authorization_response_iss_parameter_supported</code> in its discovery document. If it is set to <code>true</code>, it must include an <code>iss</code> parameter in its authorization responses, containing its issuer identifier.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingIssuer(InvalidAuthResponse):\n    \"\"\"Raised when the Authorization Endpoint does not return an `iss` parameter as expected.\n\n    The Authorization Server advertises its support with a flag\n    `authorization_response_iss_parameter_supported` in its discovery document. If it is set to\n    `true`, it must include an `iss` parameter in its authorization responses, containing its issuer\n    identifier.\n\n    \"\"\"\n\n    def __init__(self, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(\"missing `iss` query parameter in response\", request, response)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Error","title":"<code>OAuth2Error</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for Exceptions raised when a backend endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the HTTP response containing the error</p> required <code>client</code> <p>the OAuth2Client used to send the request</p> required Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class OAuth2Error(Exception):\n    \"\"\"Base class for Exceptions raised when a backend endpoint returns an error.\n\n    Args:\n        response: the HTTP response containing the error\n        client : the OAuth2Client used to send the request\n\n    \"\"\"\n\n    def __init__(self, response: requests.Response, client: OAuth2Client) -&gt; None:\n        super().__init__(\"The remote endpoint returned an error\")\n        self.response = response\n        self.client = client\n\n    @property\n    def request(self) -&gt; requests.PreparedRequest:\n        \"\"\"The request leading to the error.\"\"\"\n        return self.response.request\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Error.request","title":"<code>request: requests.PreparedRequest</code>  <code>property</code>","text":"<p>The request leading to the error.</p>"},{"location":"api/#requests_oauth2client.RevocationError","title":"<code>RevocationError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for Revocation Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class RevocationError(EndpointError):\n    \"\"\"Base class for Revocation Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.ServerError","title":"<code>ServerError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when the token endpoint returns <code>error = server_error</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ServerError(EndpointError):\n    \"\"\"Raised when the token endpoint returns `error = server_error`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.SessionSelectionRequired","title":"<code>SessionSelectionRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = session_selection_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class SessionSelectionRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = session_selection_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.SlowDown","title":"<code>SlowDown</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = slow_down</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class SlowDown(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = slow_down`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.TokenEndpointError","title":"<code>TokenEndpointError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for errors that are specific to the token endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class TokenEndpointError(EndpointError):\n    \"\"\"Base class for errors that are specific to the token endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnauthorizedClient","title":"<code>UnauthorizedClient</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when the Authorization Server returns <code>error = unauthorized_client</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnauthorizedClient(EndpointError):\n    \"\"\"Raised when the Authorization Server returns `error = unauthorized_client`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnknownIntrospectionError","title":"<code>UnknownIntrospectionError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Introspection Endpoint returns a non-standard error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnknownIntrospectionError(OAuth2Error):\n    \"\"\"Raised when the Introspection Endpoint returns a non-standard error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnknownTokenEndpointError","title":"<code>UnknownTokenEndpointError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when an otherwise unknown error is returned by the token endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnknownTokenEndpointError(EndpointError):\n    \"\"\"Raised when an otherwise unknown error is returned by the token endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnsupportedTokenType","title":"<code>UnsupportedTokenType</code>","text":"<p>               Bases: <code>RevocationError</code></p> <p>Raised when the Revocation endpoint returns <code>error = unsupported_token_type</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnsupportedTokenType(RevocationError):\n    \"\"\"Raised when the Revocation endpoint returns `error = unsupported_token_type`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseTokenEndpointPoolingJob","title":"<code>BaseTokenEndpointPoolingJob</code>","text":"<p>Base class for Token Endpoint pooling jobs.</p> <p>This is used for decoupled flows like CIBA or Device Authorization.</p> <p>This class must be subclassed to implement actual BackChannel flows. This needs an OAuth2Client that will be used to pool the token endpoint. The initial pooling <code>interval</code> is configurable.</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>@define\nclass BaseTokenEndpointPoolingJob:\n    \"\"\"Base class for Token Endpoint pooling jobs.\n\n    This is used for decoupled flows like CIBA or Device Authorization.\n\n    This class must be subclassed to implement actual BackChannel flows. This needs an\n    [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token\n    endpoint. The initial pooling `interval` is configurable.\n\n    \"\"\"\n\n    client: OAuth2Client\n    requests_kwargs: dict[str, Any]\n    token_kwargs: dict[str, Any]\n    interval: int\n    slow_down_interval: int\n\n    def __call__(self) -&gt; BearerToken | None:\n        \"\"\"Wrap the actual Token Endpoint call with a pooling interval.\n\n        Everytime this method is called, it will wait for the entire duration of the pooling\n        interval before calling\n        [token_request()][requests_oauth2client.pooling.TokenEndpointPoolingJob.token_request]. So\n        you can call it immediately after initiating the BackChannel flow, and it will wait before\n        initiating the first call.\n\n        This implements the logic to handle\n        [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] or\n        [SlowDown][requests_oauth2client.exceptions.SlowDown] requests by the AS.\n\n        Returns:\n            a `BearerToken` if the AS returns one, or `None` if the Authorization is still pending.\n\n        \"\"\"\n        self.sleep()\n        try:\n            return self.token_request()\n        except SlowDown:\n            self.slow_down()\n        except AuthorizationPending:\n            self.authorization_pending()\n        return None\n\n    def sleep(self) -&gt; None:\n        \"\"\"Implement the wait between two requests of the token endpoint.\n\n        By default, relies on time.sleep().\n\n        \"\"\"\n        time.sleep(self.interval)\n\n    def slow_down(self) -&gt; None:\n        \"\"\"Implement the behavior when receiving a 'slow_down' response from the AS.\n\n        By default, it increases the pooling interval by the slow down interval.\n\n        \"\"\"\n        self.interval += self.slow_down_interval\n\n    def authorization_pending(self) -&gt; None:\n        \"\"\"Implement the behavior when receiving an 'authorization_pending' response from the AS.\n\n        By default, it does nothing.\n\n        \"\"\"\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Abstract method for the token endpoint call.\n\n        Subclasses must implement this. This method must raise\n        [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after\n        the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase\n        the pooling interval by `slow_down_interval` seconds.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseTokenEndpointPoolingJob.sleep","title":"<code>sleep()</code>","text":"<p>Implement the wait between two requests of the token endpoint.</p> <p>By default, relies on time.sleep().</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def sleep(self) -&gt; None:\n    \"\"\"Implement the wait between two requests of the token endpoint.\n\n    By default, relies on time.sleep().\n\n    \"\"\"\n    time.sleep(self.interval)\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseTokenEndpointPoolingJob.slow_down","title":"<code>slow_down()</code>","text":"<p>Implement the behavior when receiving a 'slow_down' response from the AS.</p> <p>By default, it increases the pooling interval by the slow down interval.</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def slow_down(self) -&gt; None:\n    \"\"\"Implement the behavior when receiving a 'slow_down' response from the AS.\n\n    By default, it increases the pooling interval by the slow down interval.\n\n    \"\"\"\n    self.interval += self.slow_down_interval\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseTokenEndpointPoolingJob.authorization_pending","title":"<code>authorization_pending()</code>","text":"<p>Implement the behavior when receiving an 'authorization_pending' response from the AS.</p> <p>By default, it does nothing.</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def authorization_pending(self) -&gt; None:\n    \"\"\"Implement the behavior when receiving an 'authorization_pending' response from the AS.\n\n    By default, it does nothing.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseTokenEndpointPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Abstract method for the token endpoint call.</p> <p>Subclasses must implement this. This method must raise AuthorizationPending to retry after the pooling interval, or SlowDown to increase the pooling interval by <code>slow_down_interval</code> seconds.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Abstract method for the token endpoint call.\n\n    Subclasses must implement this. This method must raise\n    [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after\n    the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase\n    the pooling interval by `slow_down_interval` seconds.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerToken","title":"<code>BearerToken</code>","text":"<p>               Bases: <code>TokenResponse</code>, <code>AuthBase</code></p> <p>Represents a Bearer Token as returned by a Token Endpoint.</p> <p>This is a wrapper around a Bearer Token and associated parameters, such as expiration date and refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint.</p> <p>All parameters are as returned by a Token Endpoint. The token expiration date can be passed as datetime in the <code>expires_at</code> parameter, or an <code>expires_in</code> parameter, as number of seconds in the future, can be passed instead.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>str</code> <p>an <code>access_token</code>, as returned by the AS.</p> required <code>expires_at</code> <code>datetime | None</code> <p>an expiration date. This method also accepts an <code>expires_in</code> hint as returned by the AS, if any.</p> <code>None</code> <code>scope</code> <code>str | None</code> <p>a <code>scope</code>, as returned by the AS, if any.</p> <code>None</code> <code>refresh_token</code> <code>str | None</code> <p>a <code>refresh_token</code>, as returned by the AS, if any.</p> <code>None</code> <code>token_type</code> <code>str</code> <p>a <code>token_type</code>, as returned by the AS.</p> <code>TOKEN_TYPE</code> <code>id_token</code> <code>str | bytes | IdToken | JweCompact | None</code> <p>an <code>id_token</code>, as returned by the AS, if any.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters as returned by the AS, if any.</p> <code>{}</code> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@frozen(init=False)\nclass BearerToken(TokenResponse, requests.auth.AuthBase):\n    \"\"\"Represents a Bearer Token as returned by a Token Endpoint.\n\n    This is a wrapper around a Bearer Token and associated parameters, such as expiration date and\n    refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint.\n\n    All parameters are as returned by a Token Endpoint. The token expiration date can be passed as\n    datetime in the `expires_at` parameter, or an `expires_in` parameter, as number of seconds in\n    the future, can be passed instead.\n\n    Args:\n        access_token: an `access_token`, as returned by the AS.\n        expires_at: an expiration date. This method also accepts an `expires_in` hint as\n            returned by the AS, if any.\n        scope: a `scope`, as returned by the AS, if any.\n        refresh_token: a `refresh_token`, as returned by the AS, if any.\n        token_type: a `token_type`, as returned by the AS.\n        id_token: an `id_token`, as returned by the AS, if any.\n        **kwargs: additional parameters as returned by the AS, if any.\n\n    \"\"\"\n\n    TOKEN_TYPE: ClassVar[str] = AccessTokenType.BEARER.value\n    AUTHORIZATION_HEADER: ClassVar[str] = \"Authorization\"\n\n    access_token: str\n    expires_at: datetime | None = None\n    scope: str | None = None\n    refresh_token: str | None = None\n    token_type: str = TOKEN_TYPE\n    id_token: IdToken | jwskate.JweCompact | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        access_token: str,\n        *,\n        expires_at: datetime | None = None,\n        scope: str | None = None,\n        refresh_token: str | None = None,\n        token_type: str = TOKEN_TYPE,\n        id_token: str | bytes | IdToken | jwskate.JweCompact | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        if token_type.title() != self.TOKEN_TYPE.title():\n            raise UnsupportedTokenType(token_type)\n        id_token_jwt: IdToken | jwskate.JweCompact | None\n        if isinstance(id_token, (str, bytes)):\n            try:\n                id_token_jwt = IdToken(id_token)\n            except jwskate.InvalidJwt:\n                try:\n                    id_token_jwt = jwskate.JweCompact(id_token)\n                except jwskate.InvalidJwe:\n                    msg = \"token is neither a JWT or a JWE.\"\n                    raise InvalidIdToken(msg, self) from None\n        else:\n            id_token_jwt = id_token\n        self.__attrs_init__(\n            access_token=access_token,\n            expires_at=expires_at,\n            scope=scope,\n            refresh_token=refresh_token,\n            token_type=token_type,\n            id_token=id_token_jwt,\n            kwargs=kwargs,\n        )\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Check if the access token is expired.\n\n        Args:\n            leeway: If the token expires in the next given number of seconds,\n                then consider it expired already.\n\n        Returns:\n            One of:\n\n            - `True` if the access token is expired\n            - `False` if it is still valid\n            - `None` if there is no expires_in hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) + timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n\n    def authorization_header(self) -&gt; str:\n        \"\"\"Return the appropriate Authorization Header value for this token.\n\n        The value is formatted correctly according to RFC6750.\n\n        Returns:\n            the value to use in an HTTP Authorization Header\n\n        \"\"\"\n        return f\"Bearer {self.access_token}\"\n\n    def validate_id_token(  # noqa: PLR0915, C901\n        self, client: OAuth2Client, azr: AuthorizationResponse, exp_leeway: int = 0, auth_time_leeway: int = 10\n    ) -&gt; Self:\n        \"\"\"Validate the ID Token, and return a new instance with the decrypted ID Token.\n\n        If the ID Token was not encrypted, the returned instance will contain the same ID Token.\n\n        This will validate the id_token as described in [OIDC 1.0\n        $3.1.3.7](https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation).\n\n        Args:\n            client: the `OAuth2Client` that was used to obtain this token\n            azr: the `AuthorizationResponse`, as obtained by a call to `AuthorizationRequest.validate()`\n            exp_leeway: a leeway, in seconds, applied to the ID Token expiration date\n            auth_time_leeway: a leeway, in seconds, applied to the `auth_time` validation\n\n        Raises:\n            MissingIdToken: if the ID Token is missing\n            InvalidIdToken: this is a base exception class, which is raised:\n\n                - if the ID Token is not a JWT\n                - or is encrypted while a clear-text token is expected\n                - or is clear-text while an encrypted token is expected\n                - if token is encrypted but client does not have a decryption key\n                - if the token does not contain an `alg` header\n            MismatchingIdTokenAlg: if the `alg` header from the ID Token does not match\n                the expected `client.id_token_signed_response_alg`.\n            MismatchingIdTokenIssuer: if the `iss` claim from the ID Token does not match\n                the expected `azr.issuer`.\n            MismatchingIdTokenAcr: if the `acr` claim from the ID Token does not match\n                on of the expected `azr.acr_values`.\n            MismatchingIdTokenAudience: if the `aud` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenAzp: if the `azp` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenNonce: if the `nonce` claim from the ID Token does not match\n                the expected `azr.nonce`.\n            ExpiredIdToken: if the ID Token is expired at the time of the check.\n            UnsupportedIdTokenAlg: if the signature alg for the ID Token is not supported.\n\n        \"\"\"\n        if not self.id_token:\n            raise MissingIdToken(self)\n\n        raw_id_token = self.id_token\n\n        if isinstance(raw_id_token, jwskate.JweCompact) and client.id_token_encrypted_response_alg is None:\n            msg = \"token is encrypted while it should be clear-text\"\n            raise InvalidIdToken(msg, self)\n        if isinstance(raw_id_token, IdToken) and client.id_token_encrypted_response_alg is not None:\n            msg = \"token is clear-text while it should be encrypted\"\n            raise InvalidIdToken(msg, self)\n\n        if isinstance(raw_id_token, jwskate.JweCompact):\n            enc_jwk = client.id_token_decryption_key\n            if enc_jwk is None:\n                msg = \"token is encrypted but client does not have a decryption key\"\n                raise InvalidIdToken(msg, self)\n            nested_id_token = raw_id_token.decrypt(enc_jwk)\n            id_token = IdToken(nested_id_token)\n        else:\n            id_token = raw_id_token\n\n        id_token_alg = id_token.get_header(\"alg\")\n        if id_token_alg is None:\n            id_token_alg = client.id_token_signed_response_alg\n        if id_token_alg is None:\n            msg = \"\"\"\ntoken does not contain an `alg` parameter to specify the signature algorithm,\nand no algorithm has been configured for the client (using param `id_token_signed_response_alg`).\n\"\"\"\n            raise InvalidIdToken(msg, self, id_token)\n        if client.id_token_signed_response_alg is not None and id_token_alg != client.id_token_signed_response_alg:\n            raise MismatchingIdTokenAlg(id_token.alg, client.id_token_signed_response_alg, self, id_token)\n\n        verification_jwk: jwskate.Jwk\n\n        if id_token_alg in jwskate.SignatureAlgs.ALL_SYMMETRIC:\n            if not client.client_secret:\n                msg = \"token is symmetrically signed but this client does not have a Client Secret.\"\n                raise InvalidIdToken(msg, self, id_token)\n            verification_jwk = jwskate.SymmetricJwk.from_bytes(client.client_secret, alg=id_token_alg)\n            id_token.verify_signature(verification_jwk, alg=id_token_alg)\n        elif id_token_alg in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n            if not client.authorization_server_jwks:\n                msg = \"token is asymmetrically signed but the Authorization Server JWKS is not available.\"\n                raise InvalidIdToken(msg, self, id_token)\n\n            if id_token.get_header(\"kid\") is None:\n                msg = \"\"\"\ntoken does not contain a Key ID (kid) to specify the asymmetric key\nto use for signature verification.\"\"\"\n                raise InvalidIdToken(msg, self, id_token)\n            try:\n                verification_jwk = client.authorization_server_jwks.get_jwk_by_kid(id_token.kid)\n            except KeyError:\n                msg = f\"\"\"\\\ntoken is asymmetrically signed but there is no key\nwith kid='{id_token.kid}' in the Authorization Server JWKS.\"\"\"\n                raise InvalidIdToken(msg, self, id_token) from None\n\n            if id_token_alg not in verification_jwk.supported_signing_algorithms():\n                msg = \"token is asymmetrically signed but its algorithm is not supported by the verification key.\"\n                raise InvalidIdToken(msg, self, id_token)\n        else:\n            raise UnsupportedIdTokenAlg(self, id_token, id_token_alg)\n\n        id_token.verify(verification_jwk, alg=id_token_alg)\n\n        if azr.issuer and id_token.issuer != azr.issuer:\n            raise MismatchingIdTokenIssuer(id_token.issuer, azr.issuer, self, id_token)\n\n        if id_token.audiences and client.client_id not in id_token.audiences:\n            raise MismatchingIdTokenAudience(id_token.audiences, client.client_id, self, id_token)\n\n        if id_token.authorized_party is not None and id_token.authorized_party != client.client_id:\n            raise MismatchingIdTokenAzp(id_token.azp, client.client_id, self, id_token)\n\n        if id_token.is_expired(leeway=exp_leeway):\n            raise ExpiredIdToken(self, id_token)\n\n        if azr.nonce and id_token.nonce != azr.nonce:\n            raise MismatchingIdTokenNonce(id_token.nonce, azr.nonce, self, id_token)\n\n        if azr.acr_values and id_token.acr not in azr.acr_values:\n            raise MismatchingIdTokenAcr(id_token.acr, azr.acr_values, self, id_token)\n\n        hash_function = IdToken.hash_method(verification_jwk, id_token_alg)\n\n        at_hash = id_token.get_claim(\"at_hash\")\n        if at_hash is not None:\n            expected_at_hash = hash_function(self.access_token)\n            if expected_at_hash != at_hash:\n                msg = f\"mismatching 'at_hash' value (expected '{expected_at_hash}', got '{at_hash}')\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        c_hash = id_token.get_claim(\"c_hash\")\n        if c_hash is not None:\n            expected_c_hash = hash_function(azr.code)\n            if expected_c_hash != c_hash:\n                msg = f\"mismatching 'c_hash' value (expected '{expected_c_hash}', got '{c_hash}')\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        s_hash = id_token.get_claim(\"s_hash\")\n        if s_hash is not None:\n            if azr.state is None:\n                msg = \"token has a 's_hash' claim but no state was included in the request.\"\n                raise InvalidIdToken(msg, self, id_token)\n            expected_s_hash = hash_function(azr.state)\n            if expected_s_hash != s_hash:\n                msg = f\"mismatching 's_hash' value (expected '{expected_s_hash}', got '{s_hash}')\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        if azr.max_age is not None:\n            auth_time = id_token.auth_datetime\n            if auth_time is None:\n                msg = \"\"\"\na `max_age` parameter was included in the authorization request,\nbut the ID Token does not contain an `auth_time` claim.\n\"\"\"\n                raise InvalidIdToken(msg, self, id_token) from None\n            auth_age = datetime.now(tz=timezone.utc) - auth_time\n            if auth_age.total_seconds() &gt; azr.max_age + auth_time_leeway:\n                msg = f\"\"\"\nuser authentication happened too far in the past.\nThe `auth_time` parameter from the ID Token indicate that\nthe last Authentication Time was at {auth_time} ({auth_age.total_seconds()} sec ago),\nbut the authorization request `max_age` parameter specified that it must\nbe a maximum of {azr.max_age} sec ago.\n\"\"\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        return self.__class__(\n            access_token=self.access_token,\n            expires_at=self.expires_at,\n            scope=self.scope,\n            refresh_token=self.refresh_token,\n            token_type=self.token_type,\n            id_token=id_token,\n            **self.kwargs,\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the access token value, as a string.\n\n        Returns:\n            the access token string\n\n        \"\"\"\n        return self.access_token\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dict of parameters.\n\n        That is suitable for serialization or to init another BearerToken.\n\n        \"\"\"\n        d = asdict(self)\n        d.pop(\"expires_at\")\n        d[\"expires_in\"] = self.expires_in\n        d.update(**d.pop(\"kwargs\", {}))\n        return {key: val for key, val in d.items() if val is not None}\n\n    @property\n    def expires_in(self) -&gt; int | None:\n        \"\"\"Number of seconds until expiration.\"\"\"\n        if self.expires_at:\n            return ceil((self.expires_at - datetime.now(tz=timezone.utc)).total_seconds())\n        return None\n\n    def __getattr__(self, key: str) -&gt; Any:\n        \"\"\"Return custom attributes from this BearerToken.\n\n        Args:\n            key: a key\n\n        Returns:\n            the associated value in this token response\n\n        Raises:\n            AttributeError: if the attribute is not found in this response.\n\n        \"\"\"\n        return self.kwargs.get(key) or super().__getattribute__(key)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the usage of Bearer Tokens in requests.\n\n        This will add a properly formatted `Authorization: Bearer &lt;token&gt;` header in the request.\n\n        If the configured token is an instance of BearerToken with an expires_at attribute, raises\n        [ExpiredAccessToken][requests_oauth2client.exceptions.ExpiredAccessToken] once the access\n        token is expired.\n\n        Args:\n            request: the request\n\n        Returns:\n            the same request with an Access Token added in `Authorization` Header\n\n        Raises:\n            ExpiredAccessToken: if the token is expired\n\n        \"\"\"\n        if self.access_token is None:\n            return request  # pragma: no cover\n        if self.is_expired():\n            raise ExpiredAccessToken(self)\n        request.headers[self.AUTHORIZATION_HEADER] = self.authorization_header()\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerToken.expires_in","title":"<code>expires_in: int | None</code>  <code>property</code>","text":"<p>Number of seconds until expiration.</p>"},{"location":"api/#requests_oauth2client.BearerToken.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Check if the access token is expired.</p> <p>Parameters:</p> Name Type Description Default <code>leeway</code> <code>int</code> <p>If the token expires in the next given number of seconds, then consider it expired already.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>One of:</p> <code>bool | None</code> <ul> <li><code>True</code> if the access token is expired</li> </ul> <code>bool | None</code> <ul> <li><code>False</code> if it is still valid</li> </ul> <code>bool | None</code> <ul> <li><code>None</code> if there is no expires_in hint.</li> </ul> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Check if the access token is expired.\n\n    Args:\n        leeway: If the token expires in the next given number of seconds,\n            then consider it expired already.\n\n    Returns:\n        One of:\n\n        - `True` if the access token is expired\n        - `False` if it is still valid\n        - `None` if there is no expires_in hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) + timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerToken.authorization_header","title":"<code>authorization_header()</code>","text":"<p>Return the appropriate Authorization Header value for this token.</p> <p>The value is formatted correctly according to RFC6750.</p> <p>Returns:</p> Type Description <code>str</code> <p>the value to use in an HTTP Authorization Header</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def authorization_header(self) -&gt; str:\n    \"\"\"Return the appropriate Authorization Header value for this token.\n\n    The value is formatted correctly according to RFC6750.\n\n    Returns:\n        the value to use in an HTTP Authorization Header\n\n    \"\"\"\n    return f\"Bearer {self.access_token}\"\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerToken.validate_id_token","title":"<code>validate_id_token(client, azr, exp_leeway=0, auth_time_leeway=10)</code>","text":"<p>Validate the ID Token, and return a new instance with the decrypted ID Token.</p> <p>If the ID Token was not encrypted, the returned instance will contain the same ID Token.</p> <p>This will validate the id_token as described in OIDC 1.0 $3.1.3.7.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the <code>OAuth2Client</code> that was used to obtain this token</p> required <code>azr</code> <code>AuthorizationResponse</code> <p>the <code>AuthorizationResponse</code>, as obtained by a call to <code>AuthorizationRequest.validate()</code></p> required <code>exp_leeway</code> <code>int</code> <p>a leeway, in seconds, applied to the ID Token expiration date</p> <code>0</code> <code>auth_time_leeway</code> <code>int</code> <p>a leeway, in seconds, applied to the <code>auth_time</code> validation</p> <code>10</code> <p>Raises:</p> Type Description <code>MissingIdToken</code> <p>if the ID Token is missing</p> <code>InvalidIdToken</code> <p>this is a base exception class, which is raised:</p> <ul> <li>if the ID Token is not a JWT</li> <li>or is encrypted while a clear-text token is expected</li> <li>or is clear-text while an encrypted token is expected</li> <li>if token is encrypted but client does not have a decryption key</li> <li>if the token does not contain an <code>alg</code> header</li> </ul> <code>MismatchingIdTokenAlg</code> <p>if the <code>alg</code> header from the ID Token does not match the expected <code>client.id_token_signed_response_alg</code>.</p> <code>MismatchingIdTokenIssuer</code> <p>if the <code>iss</code> claim from the ID Token does not match the expected <code>azr.issuer</code>.</p> <code>MismatchingIdTokenAcr</code> <p>if the <code>acr</code> claim from the ID Token does not match on of the expected <code>azr.acr_values</code>.</p> <code>MismatchingIdTokenAudience</code> <p>if the <code>aud</code> claim from the ID Token does not match the expected <code>client.client_id</code>.</p> <code>MismatchingIdTokenAzp</code> <p>if the <code>azp</code> claim from the ID Token does not match the expected <code>client.client_id</code>.</p> <code>MismatchingIdTokenNonce</code> <p>if the <code>nonce</code> claim from the ID Token does not match the expected <code>azr.nonce</code>.</p> <code>ExpiredIdToken</code> <p>if the ID Token is expired at the time of the check.</p> <code>UnsupportedIdTokenAlg</code> <p>if the signature alg for the ID Token is not supported.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>    def validate_id_token(  # noqa: PLR0915, C901\n        self, client: OAuth2Client, azr: AuthorizationResponse, exp_leeway: int = 0, auth_time_leeway: int = 10\n    ) -&gt; Self:\n        \"\"\"Validate the ID Token, and return a new instance with the decrypted ID Token.\n\n        If the ID Token was not encrypted, the returned instance will contain the same ID Token.\n\n        This will validate the id_token as described in [OIDC 1.0\n        $3.1.3.7](https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation).\n\n        Args:\n            client: the `OAuth2Client` that was used to obtain this token\n            azr: the `AuthorizationResponse`, as obtained by a call to `AuthorizationRequest.validate()`\n            exp_leeway: a leeway, in seconds, applied to the ID Token expiration date\n            auth_time_leeway: a leeway, in seconds, applied to the `auth_time` validation\n\n        Raises:\n            MissingIdToken: if the ID Token is missing\n            InvalidIdToken: this is a base exception class, which is raised:\n\n                - if the ID Token is not a JWT\n                - or is encrypted while a clear-text token is expected\n                - or is clear-text while an encrypted token is expected\n                - if token is encrypted but client does not have a decryption key\n                - if the token does not contain an `alg` header\n            MismatchingIdTokenAlg: if the `alg` header from the ID Token does not match\n                the expected `client.id_token_signed_response_alg`.\n            MismatchingIdTokenIssuer: if the `iss` claim from the ID Token does not match\n                the expected `azr.issuer`.\n            MismatchingIdTokenAcr: if the `acr` claim from the ID Token does not match\n                on of the expected `azr.acr_values`.\n            MismatchingIdTokenAudience: if the `aud` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenAzp: if the `azp` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenNonce: if the `nonce` claim from the ID Token does not match\n                the expected `azr.nonce`.\n            ExpiredIdToken: if the ID Token is expired at the time of the check.\n            UnsupportedIdTokenAlg: if the signature alg for the ID Token is not supported.\n\n        \"\"\"\n        if not self.id_token:\n            raise MissingIdToken(self)\n\n        raw_id_token = self.id_token\n\n        if isinstance(raw_id_token, jwskate.JweCompact) and client.id_token_encrypted_response_alg is None:\n            msg = \"token is encrypted while it should be clear-text\"\n            raise InvalidIdToken(msg, self)\n        if isinstance(raw_id_token, IdToken) and client.id_token_encrypted_response_alg is not None:\n            msg = \"token is clear-text while it should be encrypted\"\n            raise InvalidIdToken(msg, self)\n\n        if isinstance(raw_id_token, jwskate.JweCompact):\n            enc_jwk = client.id_token_decryption_key\n            if enc_jwk is None:\n                msg = \"token is encrypted but client does not have a decryption key\"\n                raise InvalidIdToken(msg, self)\n            nested_id_token = raw_id_token.decrypt(enc_jwk)\n            id_token = IdToken(nested_id_token)\n        else:\n            id_token = raw_id_token\n\n        id_token_alg = id_token.get_header(\"alg\")\n        if id_token_alg is None:\n            id_token_alg = client.id_token_signed_response_alg\n        if id_token_alg is None:\n            msg = \"\"\"\ntoken does not contain an `alg` parameter to specify the signature algorithm,\nand no algorithm has been configured for the client (using param `id_token_signed_response_alg`).\n\"\"\"\n            raise InvalidIdToken(msg, self, id_token)\n        if client.id_token_signed_response_alg is not None and id_token_alg != client.id_token_signed_response_alg:\n            raise MismatchingIdTokenAlg(id_token.alg, client.id_token_signed_response_alg, self, id_token)\n\n        verification_jwk: jwskate.Jwk\n\n        if id_token_alg in jwskate.SignatureAlgs.ALL_SYMMETRIC:\n            if not client.client_secret:\n                msg = \"token is symmetrically signed but this client does not have a Client Secret.\"\n                raise InvalidIdToken(msg, self, id_token)\n            verification_jwk = jwskate.SymmetricJwk.from_bytes(client.client_secret, alg=id_token_alg)\n            id_token.verify_signature(verification_jwk, alg=id_token_alg)\n        elif id_token_alg in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n            if not client.authorization_server_jwks:\n                msg = \"token is asymmetrically signed but the Authorization Server JWKS is not available.\"\n                raise InvalidIdToken(msg, self, id_token)\n\n            if id_token.get_header(\"kid\") is None:\n                msg = \"\"\"\ntoken does not contain a Key ID (kid) to specify the asymmetric key\nto use for signature verification.\"\"\"\n                raise InvalidIdToken(msg, self, id_token)\n            try:\n                verification_jwk = client.authorization_server_jwks.get_jwk_by_kid(id_token.kid)\n            except KeyError:\n                msg = f\"\"\"\\\ntoken is asymmetrically signed but there is no key\nwith kid='{id_token.kid}' in the Authorization Server JWKS.\"\"\"\n                raise InvalidIdToken(msg, self, id_token) from None\n\n            if id_token_alg not in verification_jwk.supported_signing_algorithms():\n                msg = \"token is asymmetrically signed but its algorithm is not supported by the verification key.\"\n                raise InvalidIdToken(msg, self, id_token)\n        else:\n            raise UnsupportedIdTokenAlg(self, id_token, id_token_alg)\n\n        id_token.verify(verification_jwk, alg=id_token_alg)\n\n        if azr.issuer and id_token.issuer != azr.issuer:\n            raise MismatchingIdTokenIssuer(id_token.issuer, azr.issuer, self, id_token)\n\n        if id_token.audiences and client.client_id not in id_token.audiences:\n            raise MismatchingIdTokenAudience(id_token.audiences, client.client_id, self, id_token)\n\n        if id_token.authorized_party is not None and id_token.authorized_party != client.client_id:\n            raise MismatchingIdTokenAzp(id_token.azp, client.client_id, self, id_token)\n\n        if id_token.is_expired(leeway=exp_leeway):\n            raise ExpiredIdToken(self, id_token)\n\n        if azr.nonce and id_token.nonce != azr.nonce:\n            raise MismatchingIdTokenNonce(id_token.nonce, azr.nonce, self, id_token)\n\n        if azr.acr_values and id_token.acr not in azr.acr_values:\n            raise MismatchingIdTokenAcr(id_token.acr, azr.acr_values, self, id_token)\n\n        hash_function = IdToken.hash_method(verification_jwk, id_token_alg)\n\n        at_hash = id_token.get_claim(\"at_hash\")\n        if at_hash is not None:\n            expected_at_hash = hash_function(self.access_token)\n            if expected_at_hash != at_hash:\n                msg = f\"mismatching 'at_hash' value (expected '{expected_at_hash}', got '{at_hash}')\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        c_hash = id_token.get_claim(\"c_hash\")\n        if c_hash is not None:\n            expected_c_hash = hash_function(azr.code)\n            if expected_c_hash != c_hash:\n                msg = f\"mismatching 'c_hash' value (expected '{expected_c_hash}', got '{c_hash}')\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        s_hash = id_token.get_claim(\"s_hash\")\n        if s_hash is not None:\n            if azr.state is None:\n                msg = \"token has a 's_hash' claim but no state was included in the request.\"\n                raise InvalidIdToken(msg, self, id_token)\n            expected_s_hash = hash_function(azr.state)\n            if expected_s_hash != s_hash:\n                msg = f\"mismatching 's_hash' value (expected '{expected_s_hash}', got '{s_hash}')\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        if azr.max_age is not None:\n            auth_time = id_token.auth_datetime\n            if auth_time is None:\n                msg = \"\"\"\na `max_age` parameter was included in the authorization request,\nbut the ID Token does not contain an `auth_time` claim.\n\"\"\"\n                raise InvalidIdToken(msg, self, id_token) from None\n            auth_age = datetime.now(tz=timezone.utc) - auth_time\n            if auth_age.total_seconds() &gt; azr.max_age + auth_time_leeway:\n                msg = f\"\"\"\nuser authentication happened too far in the past.\nThe `auth_time` parameter from the ID Token indicate that\nthe last Authentication Time was at {auth_time} ({auth_age.total_seconds()} sec ago),\nbut the authorization request `max_age` parameter specified that it must\nbe a maximum of {azr.max_age} sec ago.\n\"\"\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        return self.__class__(\n            access_token=self.access_token,\n            expires_at=self.expires_at,\n            scope=self.scope,\n            refresh_token=self.refresh_token,\n            token_type=self.token_type,\n            id_token=id_token,\n            **self.kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerToken.as_dict","title":"<code>as_dict()</code>","text":"<p>Return a dict of parameters.</p> <p>That is suitable for serialization or to init another BearerToken.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return a dict of parameters.\n\n    That is suitable for serialization or to init another BearerToken.\n\n    \"\"\"\n    d = asdict(self)\n    d.pop(\"expires_at\")\n    d[\"expires_in\"] = self.expires_in\n    d.update(**d.pop(\"kwargs\", {}))\n    return {key: val for key, val in d.items() if val is not None}\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerTokenSerializer","title":"<code>BearerTokenSerializer</code>","text":"<p>A helper class to serialize Token Response returned by an AS.</p> <p>This may be used to store BearerTokens in session or cookies.</p> <p>It needs a <code>dumper</code> and a <code>loader</code> functions that will respectively serialize and deserialize BearerTokens. Default implementations are provided with use gzip and base64url on the serialized JSON representation.</p> <p>Parameters:</p> Name Type Description Default <code>dumper</code> <code>Callable[[BearerToken], str] | None</code> <p>a function to serialize a token into a <code>str</code>.</p> <code>None</code> <code>loader</code> <code>Callable[[str], BearerToken] | None</code> <p>a function to deserialize a serialized token representation.</p> <code>None</code> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class BearerTokenSerializer:\n    \"\"\"A helper class to serialize Token Response returned by an AS.\n\n    This may be used to store BearerTokens in session or cookies.\n\n    It needs a `dumper` and a `loader` functions that will respectively serialize and deserialize\n    BearerTokens. Default implementations are provided with use gzip and base64url on the serialized\n    JSON representation.\n\n    Args:\n        dumper: a function to serialize a token into a `str`.\n        loader: a function to deserialize a serialized token representation.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        dumper: Callable[[BearerToken], str] | None = None,\n        loader: Callable[[str], BearerToken] | None = None,\n    ) -&gt; None:\n        self.dumper = dumper or self.default_dumper\n        self.loader = loader or self.default_loader\n\n    @staticmethod\n    def default_dumper(token: BearerToken) -&gt; str:\n        \"\"\"Serialize a token as JSON, then compress with deflate, then encodes as base64url.\n\n        Args:\n            token: the `BearerToken` to serialize\n\n        Returns:\n            the serialized value\n\n        \"\"\"\n        d = asdict(token)\n        d.update(**d.pop(\"kwargs\", {}))\n        return (\n            BinaPy.serialize_to(\"json\", {k: w for k, w in d.items() if w is not None}).to(\"deflate\").to(\"b64u\").ascii()\n        )\n\n    def default_loader(self, serialized: str, token_class: type[BearerToken] = BearerToken) -&gt; BearerToken:\n        \"\"\"Deserialize a BearerToken.\n\n        This does the opposite operations than `default_dumper`.\n\n        Args:\n            serialized: the serialized token\n            token_class: class to use to deserialize the Token\n\n        Returns:\n            a BearerToken\n\n        \"\"\"\n        attrs = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n        expires_at = attrs.get(\"expires_at\")\n        if expires_at:\n            attrs[\"expires_at\"] = datetime.fromtimestamp(expires_at, tz=timezone.utc)\n        return token_class(**attrs)\n\n    def dumps(self, token: BearerToken) -&gt; str:\n        \"\"\"Serialize and compress a given token for easier storage.\n\n        Args:\n            token: a BearerToken to serialize\n\n        Returns:\n            the serialized token, as a str\n\n        \"\"\"\n        return self.dumper(token)\n\n    def loads(self, serialized: str) -&gt; BearerToken:\n        \"\"\"Deserialize a serialized token.\n\n        Args:\n            serialized: the serialized token\n\n        Returns:\n            the deserialized token\n\n        \"\"\"\n        return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerTokenSerializer.default_dumper","title":"<code>default_dumper(token)</code>  <code>staticmethod</code>","text":"<p>Serialize a token as JSON, then compress with deflate, then encodes as base64url.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BearerToken</code> <p>the <code>BearerToken</code> to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized value</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@staticmethod\ndef default_dumper(token: BearerToken) -&gt; str:\n    \"\"\"Serialize a token as JSON, then compress with deflate, then encodes as base64url.\n\n    Args:\n        token: the `BearerToken` to serialize\n\n    Returns:\n        the serialized value\n\n    \"\"\"\n    d = asdict(token)\n    d.update(**d.pop(\"kwargs\", {}))\n    return (\n        BinaPy.serialize_to(\"json\", {k: w for k, w in d.items() if w is not None}).to(\"deflate\").to(\"b64u\").ascii()\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerTokenSerializer.default_loader","title":"<code>default_loader(serialized, token_class=BearerToken)</code>","text":"<p>Deserialize a BearerToken.</p> <p>This does the opposite operations than <code>default_dumper</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized token</p> required <code>token_class</code> <code>type[BearerToken]</code> <p>class to use to deserialize the Token</p> <code>BearerToken</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def default_loader(self, serialized: str, token_class: type[BearerToken] = BearerToken) -&gt; BearerToken:\n    \"\"\"Deserialize a BearerToken.\n\n    This does the opposite operations than `default_dumper`.\n\n    Args:\n        serialized: the serialized token\n        token_class: class to use to deserialize the Token\n\n    Returns:\n        a BearerToken\n\n    \"\"\"\n    attrs = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n    expires_at = attrs.get(\"expires_at\")\n    if expires_at:\n        attrs[\"expires_at\"] = datetime.fromtimestamp(expires_at, tz=timezone.utc)\n    return token_class(**attrs)\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerTokenSerializer.dumps","title":"<code>dumps(token)</code>","text":"<p>Serialize and compress a given token for easier storage.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BearerToken</code> <p>a BearerToken to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized token, as a str</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def dumps(self, token: BearerToken) -&gt; str:\n    \"\"\"Serialize and compress a given token for easier storage.\n\n    Args:\n        token: a BearerToken to serialize\n\n    Returns:\n        the serialized token, as a str\n\n    \"\"\"\n    return self.dumper(token)\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerTokenSerializer.loads","title":"<code>loads(serialized)</code>","text":"<p>Deserialize a serialized token.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized token</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>the deserialized token</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def loads(self, serialized: str) -&gt; BearerToken:\n    \"\"\"Deserialize a serialized token.\n\n    Args:\n        serialized: the serialized token\n\n    Returns:\n        the deserialized token\n\n    \"\"\"\n    return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.ExpiredAccessToken","title":"<code>ExpiredAccessToken</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Raised when an expired access token is used.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class ExpiredAccessToken(RuntimeError):\n    \"\"\"Raised when an expired access token is used.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.ExpiredIdToken","title":"<code>ExpiredIdToken</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token is expired.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class ExpiredIdToken(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token is expired.\"\"\"\n\n    def __init__(self, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(\"token is expired\", token, id_token)\n        self.received = id_token.expires_at\n        self.expected = datetime.now(tz=timezone.utc)\n</code></pre>"},{"location":"api/#requests_oauth2client.IdToken","title":"<code>IdToken</code>","text":"<p>               Bases: <code>SignedJwt</code></p> <p>Represent an ID Token.</p> <p>An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be decoded beforehand.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class IdToken(jwskate.SignedJwt):\n    \"\"\"Represent an ID Token.\n\n    An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be decoded\n    beforehand.\n\n    \"\"\"\n\n    @property\n    def authorized_party(self) -&gt; str | None:\n        \"\"\"The Authorized Party (azp).\"\"\"\n        azp = self.claims.get(\"azp\")\n        if azp is None or isinstance(azp, str):\n            return azp\n        msg = \"`azp` attribute must be a string.\"\n        raise AttributeError(msg)\n\n    @property\n    def auth_datetime(self) -&gt; datetime | None:\n        \"\"\"The last user authentication time (auth_time).\"\"\"\n        auth_time = self.claims.get(\"auth_time\")\n        if auth_time is None:\n            return None\n        if isinstance(auth_time, int) and auth_time &gt; 0:\n            return self.timestamp_to_datetime(auth_time)\n        msg = \"`auth_time` must be a positive integer\"\n        raise AttributeError(msg)\n\n    @classmethod\n    def hash_method(cls, key: jwskate.Jwk, alg: str | None = None) -&gt; Callable[[str], str]:\n        \"\"\"Returns a callable that generates valid OIDC hashes, such as `at_hash`, `c_hash`, etc.\n\n        Args:\n            key: the ID token signature verification public key\n            alg: the ID token signature algorithm\n\n        Returns:\n            a callable that takes a string as input and produces a valid hash as a str output\n\n        \"\"\"\n        alg_class = jwskate.select_alg_class(key.SIGNATURE_ALGORITHMS, jwk_alg=key.alg, alg=alg)\n        if alg_class == jwskate.EdDsa:\n            if key.crv == \"Ed25519\":\n\n                def hash_method(token: str) -&gt; str:\n                    return BinaPy(token).to(\"sha512\")[:32].to(\"b64u\").decode()\n\n            elif key.crv == \"Ed448\":\n\n                def hash_method(token: str) -&gt; str:\n                    return BinaPy(token).to(\"shake256\", 456).to(\"b64u\").decode()\n\n        else:\n            hash_alg = alg_class.hashing_alg.name\n            hash_size = alg_class.hashing_alg.digest_size\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(hash_alg)[: hash_size // 2].to(\"b64u\").decode()\n\n        return hash_method\n</code></pre>"},{"location":"api/#requests_oauth2client.IdToken.authorized_party","title":"<code>authorized_party: str | None</code>  <code>property</code>","text":"<p>The Authorized Party (azp).</p>"},{"location":"api/#requests_oauth2client.IdToken.auth_datetime","title":"<code>auth_datetime: datetime | None</code>  <code>property</code>","text":"<p>The last user authentication time (auth_time).</p>"},{"location":"api/#requests_oauth2client.IdToken.hash_method","title":"<code>hash_method(key, alg=None)</code>  <code>classmethod</code>","text":"<p>Returns a callable that generates valid OIDC hashes, such as <code>at_hash</code>, <code>c_hash</code>, etc.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Jwk</code> <p>the ID token signature verification public key</p> required <code>alg</code> <code>str | None</code> <p>the ID token signature algorithm</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[str], str]</code> <p>a callable that takes a string as input and produces a valid hash as a str output</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@classmethod\ndef hash_method(cls, key: jwskate.Jwk, alg: str | None = None) -&gt; Callable[[str], str]:\n    \"\"\"Returns a callable that generates valid OIDC hashes, such as `at_hash`, `c_hash`, etc.\n\n    Args:\n        key: the ID token signature verification public key\n        alg: the ID token signature algorithm\n\n    Returns:\n        a callable that takes a string as input and produces a valid hash as a str output\n\n    \"\"\"\n    alg_class = jwskate.select_alg_class(key.SIGNATURE_ALGORITHMS, jwk_alg=key.alg, alg=alg)\n    if alg_class == jwskate.EdDsa:\n        if key.crv == \"Ed25519\":\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(\"sha512\")[:32].to(\"b64u\").decode()\n\n        elif key.crv == \"Ed448\":\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(\"shake256\", 456).to(\"b64u\").decode()\n\n    else:\n        hash_alg = alg_class.hashing_alg.name\n        hash_size = alg_class.hashing_alg.digest_size\n\n        def hash_method(token: str) -&gt; str:\n            return BinaPy(token).to(hash_alg)[: hash_size // 2].to(\"b64u\").decode()\n\n    return hash_method\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidIdToken","title":"<code>InvalidIdToken</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when trying to validate an invalid ID Token value.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class InvalidIdToken(ValueError):\n    \"\"\"Raised when trying to validate an invalid ID Token value.\"\"\"\n\n    def __init__(self, message: str, token: TokenResponse, id_token: IdToken | None = None) -&gt; None:\n        super().__init__(f\"Invalid ID Token: {message}\")\n        self.token = token\n        self.id_token = id_token\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIdTokenAcr","title":"<code>MismatchingIdTokenAcr</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token doesn't contain one of the requested ACR Values.</p> <p>This happens when the authorization request includes an <code>acr_values</code> parameter but the returned ID Token includes a different value.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAcr(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token doesn't contain one of the requested ACR Values.\n\n    This happens when the authorization request includes an `acr_values` parameter but the returned\n    ID Token includes a different value.\n\n    \"\"\"\n\n    def __init__(self, acr: str, expected: Sequence[str], token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"token contains acr '{acr}' while client expects one of '{expected}'\", token, id_token)\n        self.received = acr\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIdTokenAlg","title":"<code>MismatchingIdTokenAlg</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token is signed with an unexpected alg.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAlg(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token is signed with an unexpected alg.\"\"\"\n\n    def __init__(self, token_alg: str, client_alg: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"token is signed with alg {token_alg}, client expects {client_alg}\", token, id_token)\n        self.received = token_alg\n        self.expected = client_alg\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIdTokenAudience","title":"<code>MismatchingIdTokenAudience</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the ID Token audience does not include the requesting Client ID.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAudience(InvalidIdToken):\n    \"\"\"Raised when the ID Token audience does not include the requesting Client ID.\"\"\"\n\n    def __init__(self, audiences: Sequence[str], client_id: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(\n            f\"token audience (`aud`) '{audiences}' does not match client_id '{client_id}'\", token, id_token\n        )\n        self.received = audiences\n        self.expected = client_id\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIdTokenAzp","title":"<code>MismatchingIdTokenAzp</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the ID Token Authorized Presenter (azp) claim is not the Client ID.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAzp(InvalidIdToken):\n    \"\"\"Raised when the ID Token Authorized Presenter (azp) claim is not the Client ID.\"\"\"\n\n    def __init__(self, azp: str, client_id: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(\n            f\"token Authorized Presenter (`azp`) claim '{azp}' does not match client_id '{client_id}'\", token, id_token\n        )\n        self.received = azp\n        self.expected = client_id\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIdTokenIssuer","title":"<code>MismatchingIdTokenIssuer</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised on mismatching <code>iss</code> value in an ID Token.</p> <p>This happens when the expected <code>issuer</code> value is different from the <code>iss</code> value in an obtained ID Token.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenIssuer(InvalidIdToken):\n    \"\"\"Raised on mismatching `iss` value in an ID Token.\n\n    This happens when the expected `issuer` value is different from the `iss` value in an obtained ID Token.\n\n    \"\"\"\n\n    def __init__(self, iss: str | None, expected: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"`iss` from token '{iss}' does not match expected value '{expected}'\", token, id_token)\n        self.received = iss\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIdTokenNonce","title":"<code>MismatchingIdTokenNonce</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised on mismatching <code>nonce</code> value in an ID Token.</p> <p>This happens when the authorization request includes a <code>nonce</code> but the returned ID Token include a different value.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenNonce(InvalidIdToken):\n    \"\"\"Raised on mismatching `nonce` value in an ID Token.\n\n    This happens when the authorization request includes a `nonce` but the returned ID Token include\n    a different value.\n\n    \"\"\"\n\n    def __init__(self, nonce: str, expected: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"nonce from token '{nonce}' does not match expected value '{expected}'\", token, id_token)\n        self.received = nonce\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingIdToken","title":"<code>MissingIdToken</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the Authorization Endpoint does not return a mandatory ID Token.</p> <p>This happens when the Authorization Endpoint does not return an error, but does not return an ID Token either.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MissingIdToken(InvalidIdToken):\n    \"\"\"Raised when the Authorization Endpoint does not return a mandatory ID Token.\n\n    This happens when the Authorization Endpoint does not return an error, but does not return an ID\n    Token either.\n\n    \"\"\"\n\n    def __init__(self, token: TokenResponse) -&gt; None:\n        super().__init__(\"An expected `id_token` is missing in the response.\", token, None)\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidUri","title":"<code>InvalidUri</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a URI does not pass validation by <code>validate_endpoint_uri()</code>.</p> Source code in <code>requests_oauth2client/utils.py</code> <pre><code>class InvalidUri(ValueError):\n    \"\"\"Raised when a URI does not pass validation by `validate_endpoint_uri()`.\"\"\"\n\n    def __init__(\n        self, url: str, *, https: bool, no_credentials: bool, no_port: bool, no_fragment: bool, path: bool\n    ) -&gt; None:\n        super().__init__(\"Invalid endpoint uri.\")\n        self.url = url\n        self.https = https\n        self.no_credentials = no_credentials\n        self.no_port = no_port\n        self.no_fragment = no_fragment\n        self.path = path\n\n    def errors(self) -&gt; Iterator[str]:\n        \"\"\"Iterate over all error descriptions, as str.\"\"\"\n        if self.https:\n            yield \"must use https\"\n        if self.no_credentials:\n            yield \"must not contain basic credentials\"\n        if self.no_port:\n            yield \"no custom port number allowed\"\n        if self.no_fragment:\n            yield \"must not contain a uri fragment\"\n        if self.path:\n            yield \"must include a path other than /\"\n\n    def __str__(self) -&gt; str:\n        all_errors = \", \".join(self.errors())\n        return f\"Invalid URI: {all_errors}\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidUri.errors","title":"<code>errors()</code>","text":"<p>Iterate over all error descriptions, as str.</p> Source code in <code>requests_oauth2client/utils.py</code> <pre><code>def errors(self) -&gt; Iterator[str]:\n    \"\"\"Iterate over all error descriptions, as str.\"\"\"\n    if self.https:\n        yield \"must use https\"\n    if self.no_credentials:\n        yield \"must not contain basic credentials\"\n    if self.no_port:\n        yield \"no custom port number allowed\"\n    if self.no_fragment:\n        yield \"must not contain a uri fragment\"\n    if self.path:\n        yield \"must include a path other than /\"\n</code></pre>"},{"location":"api/#requests_oauth2client.oauth2_discovery_document_url","title":"<code>oauth2_discovery_document_url(issuer)</code>","text":"<p>Construct the standardised OAuth 2.0 discovery document url for a given <code>issuer</code>.</p> <p>Based an <code>issuer</code> identifier, returns the standardised URL where the OAuth20 server metadata can be retrieved.</p> <p>The returned URL is built as specified in RFC8414.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>an OAuth20 Authentication Server <code>issuer</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>the standardised discovery document URL. Note that no attempt to fetch this document is</p> <code>str</code> <p>made.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def oauth2_discovery_document_url(issuer: str) -&gt; str:\n    \"\"\"Construct the standardised OAuth 2.0 discovery document url for a given `issuer`.\n\n    Based an `issuer` identifier, returns the standardised URL where the OAuth20 server metadata can\n    be retrieved.\n\n    The returned URL is built as specified in\n    [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414).\n\n    Args:\n        issuer: an OAuth20 Authentication Server `issuer`\n\n    Returns:\n        the standardised discovery document URL. Note that no attempt to fetch this document is\n        made.\n\n    \"\"\"\n    return well_known_uri(issuer, \"oauth-authorization-server\", at_root=True)\n</code></pre>"},{"location":"api/#requests_oauth2client.oidc_discovery_document_url","title":"<code>oidc_discovery_document_url(issuer)</code>","text":"<p>Construct the OIDC discovery document url for a given <code>issuer</code>.</p> <p>Given an <code>issuer</code> identifier, return the standardised URL where the OIDC discovery document can be retrieved.</p> <p>The returned URL is biuilt as specified in OpenID Connect Discovery 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>an OIDC Authentication Server <code>issuer</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>the standardised discovery document URL. Note that no attempt to fetch this document is</p> <code>str</code> <p>made.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def oidc_discovery_document_url(issuer: str) -&gt; str:\n    \"\"\"Construct the OIDC discovery document url for a given `issuer`.\n\n    Given an `issuer` identifier, return the standardised URL where the OIDC discovery document can\n    be retrieved.\n\n    The returned URL is biuilt as specified in [OpenID Connect Discovery\n    1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Args:\n        issuer: an OIDC Authentication Server `issuer`\n\n    Returns:\n        the standardised discovery document URL. Note that no attempt to fetch this document is\n        made.\n\n    \"\"\"\n    return well_known_uri(issuer, \"openid-configuration\", at_root=False)\n</code></pre>"},{"location":"api/#requests_oauth2client.well_known_uri","title":"<code>well_known_uri(origin, name, *, at_root=True)</code>","text":"<p>Return the location of a well-known document on an origin url.</p> <p>See RFC8615 and OIDC Discovery.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>str</code> <p>origin to use to build the well-known uri.</p> required <code>name</code> <code>str</code> <p>document name to use to build the well-known uri.</p> required <code>at_root</code> <code>bool</code> <p>if <code>True</code>, assume the well-known document is at root level (as defined in RFC8615). If <code>False</code>, assume the well-known location is per-directory, as defined in OpenID Connect Discovery 1.0.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>the well-know uri, relative to origin, where the well-known document named <code>name</code> should be</p> <code>str</code> <p>found.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def well_known_uri(origin: str, name: str, *, at_root: bool = True) -&gt; str:\n    \"\"\"Return the location of a well-known document on an origin url.\n\n    See [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615) and [OIDC\n    Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Args:\n        origin: origin to use to build the well-known uri.\n        name: document name to use to build the well-known uri.\n        at_root: if `True`, assume the well-known document is at root level (as defined in [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615)).\n            If `False`, assume the well-known location is per-directory, as defined in [OpenID\n            Connect Discovery\n            1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Returns:\n        the well-know uri, relative to origin, where the well-known document named `name` should be\n        found.\n\n    \"\"\"\n    url = furl(origin)\n    if at_root:\n        url.path = Path(\".well-known\") / url.path / name\n    else:\n        url.path.add(Path(\".well-known\") / name)\n    return str(url)\n</code></pre>"},{"location":"api/#requests_oauth2client.validate_endpoint_uri","title":"<code>validate_endpoint_uri(uri, *, https=True, no_credentials=True, no_port=True, no_fragment=True, path=True)</code>","text":"<p>Validate that a URI is suitable as an endpoint URI.</p> <p>It checks:</p> <ul> <li>that the scheme is <code>https</code></li> <li>that no custom port number is being used</li> <li>that no username or password are included</li> <li>that no fragment is included</li> <li>that a path is present</li> </ul> <p>Those checks can be individually disabled by using the parameters.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>the uri</p> required <code>https</code> <code>bool</code> <p>if <code>True</code>, check that the uri is https</p> <code>True</code> <code>no_port</code> <code>bool</code> <p>if <code>True</code>, check that no custom port number is included</p> <code>True</code> <code>no_credentials</code> <code>bool</code> <p>if <code>True</code>, check that no username/password are included</p> <code>True</code> <code>no_fragment</code> <code>bool</code> <p>if <code>True</code>, check that the uri contains no fragment</p> <code>True</code> <code>path</code> <code>bool</code> <p>if <code>True</code>, check that the uri contains a path component</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the supplied url is not suitable</p> <p>Returns:</p> Type Description <code>str</code> <p>the endpoint URI, if all checks passed</p> Source code in <code>requests_oauth2client/utils.py</code> <pre><code>def validate_endpoint_uri(\n    uri: str,\n    *,\n    https: bool = True,\n    no_credentials: bool = True,\n    no_port: bool = True,\n    no_fragment: bool = True,\n    path: bool = True,\n) -&gt; str:\n    \"\"\"Validate that a URI is suitable as an endpoint URI.\n\n    It checks:\n\n    - that the scheme is `https`\n    - that no custom port number is being used\n    - that no username or password are included\n    - that no fragment is included\n    - that a path is present\n\n    Those checks can be individually disabled by using the parameters.\n\n    Args:\n        uri: the uri\n        https: if `True`, check that the uri is https\n        no_port: if `True`, check that no custom port number is included\n        no_credentials: if ` True`, check that no username/password are included\n        no_fragment: if `True`, check that the uri contains no fragment\n        path: if `True`, check that the uri contains a path component\n\n    Raises:\n        ValueError: if the supplied url is not suitable\n\n    Returns:\n        the endpoint URI, if all checks passed\n\n    \"\"\"\n    url = furl(uri)\n    if https and url.scheme == \"https\":\n        https = False\n    if no_port and url.port == 443:  # noqa: PLR2004\n        no_port = False\n    if no_credentials and not url.username and not url.password:\n        no_credentials = False\n    if no_fragment and not url.fragment:\n        no_fragment = False\n    if path and url.path and url.path != \"/\":\n        path = False\n\n    if https or no_port or no_credentials or no_fragment or path:\n        raise InvalidUri(\n            uri, https=https, no_port=no_port, no_credentials=no_credentials, no_fragment=no_fragment, path=path\n        )\n\n    return uri\n</code></pre>"},{"location":"api/#requests_oauth2client.validate_issuer_uri","title":"<code>validate_issuer_uri(uri)</code>","text":"<p>Validate that an Issuer Identifier URI is valid.</p> <p>This is almost the same as a valid endpoint URI, but a path is not mandatory.</p> Source code in <code>requests_oauth2client/utils.py</code> <pre><code>def validate_issuer_uri(uri: str) -&gt; str:\n    \"\"\"Validate that an Issuer Identifier URI is valid.\n\n    This is almost the same as a valid endpoint URI, but a path is not mandatory.\n\n    \"\"\"\n    return validate_endpoint_uri(uri, path=False)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client","title":"<code>api_client</code>","text":"<p><code>ApiClient</code> main module.</p>"},{"location":"api/#requests_oauth2client.api_client.InvalidBoolFieldsParam","title":"<code>InvalidBoolFieldsParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an invalid value is passed as 'bool_fields' parameter.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>class InvalidBoolFieldsParam(ValueError):\n    \"\"\"Raised when an invalid value is passed as 'bool_fields' parameter.\"\"\"\n\n    def __init__(self, bool_fields: object) -&gt; None:\n        super().__init__(\"\"\"\\\nInvalid value for 'bool_fields' parameter. It must be an iterable of 2 str values:\n- first one for the True value\n- second one for the False value\nboolean fields in `data` or `params` with a boolean value (`True` or `False`)\nwill be serialized to the corresponding value.\nDefault is `('true', 'false')`\nUse this parameter when the target API expects some other values, e.g.:\n- ('on', 'off')\n- ('1', '0')\n- ('yes', 'no')\n\"\"\")\n        self.value = bool_fields\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.InvalidPathParam","title":"<code>InvalidPathParam</code>","text":"<p>               Bases: <code>TypeError</code>, <code>ValueError</code></p> <p>Raised when an unexpected path is passed as 'url' parameter.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>class InvalidPathParam(TypeError, ValueError):\n    \"\"\"Raised when an unexpected path is passed as 'url' parameter.\"\"\"\n\n    def __init__(self, path: None | str | bytes | Iterable[str | bytes | int]) -&gt; None:\n        super().__init__(\"\"\"\\\nUnexpected path. Please provide a path that is relative to the configured `base_url`:\n- `None` (default) to call the base_url\n- a `str` or `bytes`, that will be joined to the base_url (with a / separator, if required)\n- or an iterable of string-able objects, which will be joined to the base_url with / separators\n\"\"\")\n        self.url = path\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient","title":"<code>ApiClient</code>","text":"<p>A Wrapper around requests.Session with extra features for REST API calls.</p> <p>Additional features compared to using a requests.Session directly:</p> <ul> <li>You must set a root url at creation time, which then allows passing relative urls at request time.</li> <li>It may also raise exceptions instead of returning error responses.</li> <li>You can also pass additional kwargs at init time, which will be used to configure the Session, instead of setting them later.</li> <li>for parameters passed as <code>json</code>, <code>params</code> or <code>data</code>, values that are <code>None</code> can be automatically discarded from the request</li> <li>boolean values in <code>data</code> or <code>params</code> fields can be serialized to values that are suitable for the target API, like <code>\"true\"</code>  or <code>\"false\"</code>, or <code>\"1\"</code> / <code>\"0\"</code>, instead of the default values <code>\"True\"</code> or <code>\"False\"</code>.</li> </ul> <p><code>base_url</code> will serve as root for relative urls passed to ApiClient.request(), ApiClient.get(), etc.</p> <p>A requests.HTTPError will be raised everytime an API call returns an error code (&gt;= 400), unless you set <code>raise_for_status</code> to <code>False</code>. Additional parameters passed at init time, including <code>auth</code> will be used to configure the Session.</p> Example <pre><code>from requests_oauth2client import ApiClient\n\napi = ApiClient(\"https://myapi.local/resource\", timeout=10)\nresp = api.get(\"/myid\")  # this will send a GET request\n# to https://myapi.local/resource/myid\n\n# you can pass an underlying requests.Session at init time\nsession = requests.Session()\nsession.proxies = {\"https\": \"https://localhost:3128\"}\napi = ApiClient(\"https://myapi.local/resource\", session=session)\n\n# or you can let ApiClient init its own session and provide additional configuration\n# parameters:\napi = ApiClient(\n    \"https://myapi.local/resource\",\n    proxies={\"https\": \"https://localhost:3128\"},\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>the base api url, that is the root for all the target API endpoints.</p> required <code>auth</code> <code>AuthBase | None</code> <p>the requests.auth.AuthBase to use as authentication handler.</p> <code>None</code> <code>timeout</code> <code>int | None</code> <p>the default timeout, in seconds, to use for each request from this <code>ApiClient</code>. Can be set to <code>None</code> to disable timeout.</p> <code>60</code> <code>raise_for_status</code> <code>bool</code> <p>if <code>True</code>, exceptions will be raised everytime a request returns an error code (&gt;= 400).</p> <code>True</code> <code>none_fields</code> <code>Literal['include', 'exclude', 'empty']</code> <p>defines what to do with parameters with value <code>None</code> in <code>data</code> or <code>json</code> fields.</p> <ul> <li>if <code>\"exclude\"</code> (default), fields whose values are <code>None</code> are not included in the request.</li> <li>if <code>\"include\"</code>, they are included with string value <code>None</code>. This is the default behavior of <code>requests</code>. Note that they will be serialized to <code>null</code> in JSON.</li> <li>if <code>\"empty\"</code>, they are included with an empty value (as an empty string).</li> </ul> <code>'exclude'</code> <code>bool_fields</code> <code>tuple[Any, Any] | None</code> <p>a tuple of <code>(true_value, false_value)</code>. Fields from <code>data</code> or <code>params</code> with a boolean value (<code>True</code> or <code>False</code>) will be serialized to the corresponding value. This can be useful since some APIs expect a <code>'true'</code> or <code>'false'</code> value as boolean, and <code>requests</code> serializes <code>True</code> to <code>'True'</code> and <code>False</code> to <code>'False'</code>. Set it to <code>None</code> to restore default requests behaviour.</p> <code>('true', 'false')</code> <code>session</code> <code>Session | None</code> <p>a preconfigured <code>requests.Session</code> to use with this <code>ApiClient</code>.</p> <code>None</code> <code>**session_kwargs</code> <code>Any</code> <p>additional kwargs to configure the underlying <code>requests.Session</code>.</p> <code>{}</code> <p>Raises:</p> Type Description <code>InvalidBoolFieldsParam</code> <p>if the provided <code>bool_fields</code> parameter is invalid.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>@frozen(init=False)\nclass ApiClient:\n    \"\"\"A Wrapper around [requests.Session][] with extra features for REST API calls.\n\n    Additional features compared to using a [requests.Session][] directly:\n\n    - You must set a root url at creation time, which then allows passing relative urls at request time.\n    - It may also raise exceptions instead of returning error responses.\n    - You can also pass additional kwargs at init time, which will be used to configure the\n    [Session][requests.Session], instead of setting them later.\n    - for parameters passed as `json`, `params` or `data`, values that are `None` can be\n    automatically discarded from the request\n    - boolean values in `data` or `params` fields can be serialized to values that are suitable\n    for the target API, like `\"true\"`  or `\"false\"`, or `\"1\"` / `\"0\"`, instead of the default\n    values `\"True\"` or `\"False\"`.\n\n    `base_url` will serve as root for relative urls passed to\n    [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request],\n    [ApiClient.get()][requests_oauth2client.api_client.ApiClient.get], etc.\n\n    A [requests.HTTPError][] will be raised everytime an API call returns an error code (&gt;= 400), unless\n    you set `raise_for_status` to `False`. Additional parameters passed at init time, including\n    `auth` will be used to configure the [Session][requests.Session].\n\n    Example:\n        ```python\n        from requests_oauth2client import ApiClient\n\n        api = ApiClient(\"https://myapi.local/resource\", timeout=10)\n        resp = api.get(\"/myid\")  # this will send a GET request\n        # to https://myapi.local/resource/myid\n\n        # you can pass an underlying requests.Session at init time\n        session = requests.Session()\n        session.proxies = {\"https\": \"https://localhost:3128\"}\n        api = ApiClient(\"https://myapi.local/resource\", session=session)\n\n        # or you can let ApiClient init its own session and provide additional configuration\n        # parameters:\n        api = ApiClient(\n            \"https://myapi.local/resource\",\n            proxies={\"https\": \"https://localhost:3128\"},\n        )\n        ```\n\n    Args:\n        base_url: the base api url, that is the root for all the target API endpoints.\n        auth: the [requests.auth.AuthBase][] to use as authentication handler.\n        timeout: the default timeout, in seconds, to use for each request from this `ApiClient`.\n            Can be set to `None` to disable timeout.\n        raise_for_status: if `True`, exceptions will be raised everytime a request returns an\n            error code (&gt;= 400).\n        none_fields: defines what to do with parameters with value `None` in `data` or `json` fields.\n\n            - if `\"exclude\"` (default), fields whose values are `None` are not included in the request.\n            - if `\"include\"`, they are included with string value `None`. This is\n            the default behavior of `requests`. Note that they will be serialized to `null` in JSON.\n            - if `\"empty\"`, they are included with an empty value (as an empty string).\n        bool_fields: a tuple of `(true_value, false_value)`. Fields from `data` or `params` with\n            a boolean value (`True` or `False`) will be serialized to the corresponding value.\n            This can be useful since some APIs expect a `'true'` or `'false'` value as boolean,\n            and `requests` serializes `True` to `'True'` and `False` to `'False'`.\n            Set it to `None` to restore default requests behaviour.\n        session: a preconfigured `requests.Session` to use with this `ApiClient`.\n        **session_kwargs: additional kwargs to configure the underlying `requests.Session`.\n\n    Raises:\n        InvalidBoolFieldsParam: if the provided `bool_fields` parameter is invalid.\n\n    \"\"\"\n\n    base_url: str\n    auth: requests.auth.AuthBase | None = None\n    timeout: int | None = 60\n    raise_for_status: bool = True\n    none_fields: Literal[\"include\", \"exclude\", \"empty\"] = \"exclude\"\n    bool_fields: tuple[Any, Any] | None = \"true\", \"false\"\n    session: requests.Session = field(factory=requests.Session)\n\n    def __init__(\n        self,\n        base_url: str,\n        *,\n        auth: requests.auth.AuthBase | None = None,\n        timeout: int | None = 60,\n        raise_for_status: bool = True,\n        none_fields: Literal[\"include\", \"exclude\", \"empty\"] = \"exclude\",\n        bool_fields: tuple[Any, Any] | None = (\"true\", \"false\"),\n        session: requests.Session | None = None,\n        **session_kwargs: Any,\n    ) -&gt; None:\n        session = session or requests.Session()\n        for key, val in session_kwargs.items():\n            setattr(session, key, val)\n\n        if bool_fields is None:\n            bool_fields = (\"True\", \"False\")\n        else:\n            validate_bool_fields(bool_fields)\n\n        self.__attrs_init__(\n            base_url=base_url,\n            auth=auth,\n            raise_for_status=raise_for_status,\n            none_fields=none_fields,\n            bool_fields=bool_fields,\n            timeout=timeout,\n            session=session,\n        )\n\n    def request(  # noqa: C901, PLR0913, D417\n        self,\n        method: str,\n        path: None | str | bytes | Iterable[str | bytes | int] = None,\n        *,\n        params: None | bytes | MutableMapping[str, str] = None,\n        data: (\n            Iterable[bytes]\n            | str\n            | bytes\n            | list[tuple[Any, Any]]\n            | tuple[tuple[Any, Any], ...]\n            | Mapping[Any, Any]\n            | None\n        ) = None,\n        headers: MutableMapping[str, str] | None = None,\n        cookies: None | RequestsCookieJar | MutableMapping[str, str] = None,\n        files: MutableMapping[str, IO[Any]] | None = None,\n        auth: (\n            None\n            | tuple[str, str]\n            | requests.auth.AuthBase\n            | Callable[[requests.PreparedRequest], requests.PreparedRequest]\n        ) = None,\n        timeout: None | float | tuple[float, float] | tuple[float, None] = None,\n        allow_redirects: bool = False,\n        proxies: MutableMapping[str, str] | None = None,\n        hooks: None\n        | (\n            MutableMapping[\n                str,\n                (Iterable[Callable[[requests.Response], Any]] | Callable[[requests.Response], Any]),\n            ]\n        ) = None,\n        stream: bool | None = None,\n        verify: str | bool | None = None,\n        cert: str | tuple[str, str] | None = None,\n        json: Mapping[str, Any] | None = None,\n        raise_for_status: bool | None = None,\n        none_fields: Literal[\"include\", \"exclude\", \"empty\"] | None = None,\n        bool_fields: tuple[Any, Any] | None = None,\n    ) -&gt; requests.Response:\n        \"\"\"A wrapper around [requests.Session.request][] method with extra features.\n\n        Additional features are described in\n        [ApiClient][requests_oauth2client.api_client.ApiClient] documentation.\n\n        All parameters will be passed as-is to [requests.Session.request][], expected those\n        described below which have a special behavior.\n\n        Args:\n          path: the url where the request will be sent to. Can be:\n\n            - a path, as `str`: that path will be joined to the configured API url,\n            - an iterable of path segments: that will be joined to the root url.\n          raise_for_status: like the parameter of the same name from\n            [ApiClient][requests_oauth2client.api_client.ApiClient],\n            but this will be applied for this request only.\n          none_fields: like the parameter of the same name from\n            [ApiClient][requests_oauth2client.api_client.ApiClient],\n            but this will be applied for this request only.\n          bool_fields: like the parameter of the same name from\n            [ApiClient][requests_oauth2client.api_client.ApiClient],\n            but this will be applied for this request only.\n\n        Returns:\n          a Response as returned by requests\n\n        Raises:\n            InvalidBoolFieldsParam: if the provided `bool_fields` parameter is invalid.\n\n        \"\"\"\n        path = self.to_absolute_url(path)\n\n        if none_fields is None:\n            none_fields = self.none_fields\n\n        if none_fields == \"exclude\":\n            if isinstance(data, Mapping):\n                data = {key: val for key, val in data.items() if val is not None}\n            if isinstance(json, Mapping):\n                json = {key: val for key, val in json.items() if val is not None}\n        elif none_fields == \"empty\":\n            if isinstance(data, Mapping):\n                data = {key: val if val is not None else \"\" for key, val in data.items()}\n            if isinstance(json, Mapping):\n                json = {key: val if val is not None else \"\" for key, val in json.items()}\n\n        if bool_fields is None:\n            bool_fields = self.bool_fields\n\n        if bool_fields:\n            true_value, false_value = validate_bool_fields(bool_fields)\n            if isinstance(data, MutableMapping):\n                for key, val in data.items():\n                    if val is True:\n                        data[key] = true_value\n                    elif val is False:\n                        data[key] = false_value\n            if isinstance(params, MutableMapping):\n                for key, val in params.items():\n                    if val is True:\n                        params[key] = true_value\n                    elif val is False:\n                        params[key] = false_value\n\n        timeout = timeout or self.timeout\n\n        response = self.session.request(\n            method,\n            path,\n            params=params,\n            data=data,\n            headers=headers,\n            cookies=cookies,\n            files=files,\n            auth=auth or self.auth,\n            timeout=timeout,\n            allow_redirects=allow_redirects,\n            proxies=proxies,\n            hooks=hooks,\n            stream=stream,\n            verify=verify,\n            cert=cert,\n            json=json,\n        )\n\n        if raise_for_status is None:\n            raise_for_status = self.raise_for_status\n        if raise_for_status:\n            response.raise_for_status()\n        return response\n\n    def to_absolute_url(self, path: None | str | bytes | Iterable[str | bytes | int] = None) -&gt; str:\n        \"\"\"Convert a relative url to an absolute url.\n\n        Given a `path`, return the matching absolute url, based on the `base_url` that is\n        configured for this API.\n\n        The result of this method is different from a standard `urljoin()`, because a relative_url\n        that starts with a \"/\" will not override the path from the base url. You can also pass an\n        iterable of path parts as relative url, which will be properly joined with \"/\". Those parts\n        may be `str` (which will be urlencoded) or `bytes` (which will be decoded as UTF-8 first) or\n        any other type (which will be converted to `str` first, using the `str() function`). See the\n        table below for example results which would exhibit most cases:\n\n        | base_url | relative_url | result_url |\n        |---------------------------|-----------------------------|-------------------------------------------|\n        | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `b\"/path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `\"path\"` | `\"https://myhost.com/root/path\"` |\n        | `\"https://myhost.com/root\"` | `None` | `\"https://myhost.com/root\"` |\n        | `\"https://myhost.com/root\"` |  `(\"user\", 1, \"resource\")` | `\"https://myhost.com/root/user/1/resource\"` |\n        | `\"https://myhost.com/root\"` | `\"https://otherhost.org/foo\"` | `ValueError` |\n\n        Args:\n          path: a relative url\n\n        Returns:\n          the resulting absolute url\n\n        Raises:\n            InvalidPathParam: if the provided path does not allow constructing a valid url\n\n        \"\"\"\n        url = path\n\n        if url is None:\n            url = self.base_url\n        else:\n            if not isinstance(url, (str, bytes)):\n                try:\n                    url = \"/\".join(\n                        [urlencode(part.decode() if isinstance(part, bytes) else str(part)) for part in url if part],\n                    )\n                except Exception as exc:\n                    raise InvalidPathParam(url) from exc\n\n            if isinstance(url, bytes):\n                url = url.decode()\n\n            if \"://\" in url:\n                raise InvalidPathParam(url)\n\n            url = urljoin(self.base_url + \"/\", url.lstrip(\"/\"))\n\n        if url is None or not isinstance(url, str):\n            raise InvalidPathParam(url)  # pragma: no cover\n\n        return url\n\n    def get(\n        self,\n        path: None | str | bytes | Iterable[str | bytes | int] = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a GET request and return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n            path: the path where the request will be sent.\n            raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n            **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n            a response object.\n\n        Raises:\n            requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"GET\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def post(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a POST request and return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n          a response object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"POST\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def patch(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a PATCH request. Return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"PATCH\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def put(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a PUT request. Return a [Response][requests.Response] object.\n\n        The passed `url` is relative to the `base_url` passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"PUT\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def delete(\n        self,\n        path: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a DELETE request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time. It takes the same\n        parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          path: the path where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`.\n\n        Returns:\n          a response object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"DELETE\", path, raise_for_status=raise_for_status, **kwargs)\n\n    def __getattr__(self, item: str) -&gt; ApiClient:\n        \"\"\"Allow access sub resources with an attribute-based syntax.\n\n        Args:\n            item: a subpath\n\n        Returns:\n            a new `ApiClient` initialized on the new base url\n\n        Example:\n            ```python\n            from requests_oauth2client import ApiClient\n\n            api = ApiClient(\"https://myapi.local\")\n            resource1 = api.resource1.get()  # GET https://myapi.local/resource1\n            resource2 = api.resource2.get()  # GET https://myapi.local/resource2\n            ```\n\n        \"\"\"\n        return self[item]\n\n    def __getitem__(self, item: str) -&gt; ApiClient:\n        \"\"\"Allow access to sub resources with a subscription-based syntax.\n\n        Args:\n            item: a subpath\n\n        Returns:\n            a new `ApiClient` initialized on the new base url\n\n        Example:\n            ```python\n            from requests_oauth2client import ApiClient\n\n            api = ApiClient(\"https://myapi.local\")\n            resource1 = api[\"resource1\"].get()  # GET https://myapi.local/resource1\n            resource2 = api[\"resource2\"].get()  # GET https://myapi.local/resource2\n            ```\n\n        \"\"\"\n        new_base_uri = self.to_absolute_url(item)\n        return ApiClient(\n            new_base_uri,\n            session=self.session,\n            none_fields=self.none_fields,\n            bool_fields=self.bool_fields,\n            timeout=self.timeout,\n            raise_for_status=self.raise_for_status,\n        )\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Allow `ApiClient` to act as a context manager.\n\n        You can then use an `ApiClient` instance in a `with` clause, the same way as\n        `requests.Session`. The underlying request.Session will be closed on exit.\n\n        Example:\n            ```python\n            with ApiClient(\"https://myapi.com/path\") as client:\n                resp = client.get(\"resource\")\n            ```\n\n        \"\"\"\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Close the underlying requests.Session on exit.\"\"\"\n        self.session.close()\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.request","title":"<code>request(method, path=None, *, params=None, data=None, headers=None, cookies=None, files=None, auth=None, timeout=None, allow_redirects=False, proxies=None, hooks=None, stream=None, verify=None, cert=None, json=None, raise_for_status=None, none_fields=None, bool_fields=None)</code>","text":"<p>A wrapper around requests.Session.request method with extra features.</p> <p>Additional features are described in ApiClient documentation.</p> <p>All parameters will be passed as-is to requests.Session.request, expected those described below which have a special behavior.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>the url where the request will be sent to. Can be:</p> <ul> <li>a path, as <code>str</code>: that path will be joined to the configured API url,</li> <li>an iterable of path segments: that will be joined to the root url.</li> </ul> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>like the parameter of the same name from ApiClient, but this will be applied for this request only.</p> <code>None</code> <code>none_fields</code> <code>Literal['include', 'exclude', 'empty'] | None</code> <p>like the parameter of the same name from ApiClient, but this will be applied for this request only.</p> <code>None</code> <code>bool_fields</code> <code>tuple[Any, Any] | None</code> <p>like the parameter of the same name from ApiClient, but this will be applied for this request only.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response as returned by requests</p> <p>Raises:</p> Type Description <code>InvalidBoolFieldsParam</code> <p>if the provided <code>bool_fields</code> parameter is invalid.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def request(  # noqa: C901, PLR0913, D417\n    self,\n    method: str,\n    path: None | str | bytes | Iterable[str | bytes | int] = None,\n    *,\n    params: None | bytes | MutableMapping[str, str] = None,\n    data: (\n        Iterable[bytes]\n        | str\n        | bytes\n        | list[tuple[Any, Any]]\n        | tuple[tuple[Any, Any], ...]\n        | Mapping[Any, Any]\n        | None\n    ) = None,\n    headers: MutableMapping[str, str] | None = None,\n    cookies: None | RequestsCookieJar | MutableMapping[str, str] = None,\n    files: MutableMapping[str, IO[Any]] | None = None,\n    auth: (\n        None\n        | tuple[str, str]\n        | requests.auth.AuthBase\n        | Callable[[requests.PreparedRequest], requests.PreparedRequest]\n    ) = None,\n    timeout: None | float | tuple[float, float] | tuple[float, None] = None,\n    allow_redirects: bool = False,\n    proxies: MutableMapping[str, str] | None = None,\n    hooks: None\n    | (\n        MutableMapping[\n            str,\n            (Iterable[Callable[[requests.Response], Any]] | Callable[[requests.Response], Any]),\n        ]\n    ) = None,\n    stream: bool | None = None,\n    verify: str | bool | None = None,\n    cert: str | tuple[str, str] | None = None,\n    json: Mapping[str, Any] | None = None,\n    raise_for_status: bool | None = None,\n    none_fields: Literal[\"include\", \"exclude\", \"empty\"] | None = None,\n    bool_fields: tuple[Any, Any] | None = None,\n) -&gt; requests.Response:\n    \"\"\"A wrapper around [requests.Session.request][] method with extra features.\n\n    Additional features are described in\n    [ApiClient][requests_oauth2client.api_client.ApiClient] documentation.\n\n    All parameters will be passed as-is to [requests.Session.request][], expected those\n    described below which have a special behavior.\n\n    Args:\n      path: the url where the request will be sent to. Can be:\n\n        - a path, as `str`: that path will be joined to the configured API url,\n        - an iterable of path segments: that will be joined to the root url.\n      raise_for_status: like the parameter of the same name from\n        [ApiClient][requests_oauth2client.api_client.ApiClient],\n        but this will be applied for this request only.\n      none_fields: like the parameter of the same name from\n        [ApiClient][requests_oauth2client.api_client.ApiClient],\n        but this will be applied for this request only.\n      bool_fields: like the parameter of the same name from\n        [ApiClient][requests_oauth2client.api_client.ApiClient],\n        but this will be applied for this request only.\n\n    Returns:\n      a Response as returned by requests\n\n    Raises:\n        InvalidBoolFieldsParam: if the provided `bool_fields` parameter is invalid.\n\n    \"\"\"\n    path = self.to_absolute_url(path)\n\n    if none_fields is None:\n        none_fields = self.none_fields\n\n    if none_fields == \"exclude\":\n        if isinstance(data, Mapping):\n            data = {key: val for key, val in data.items() if val is not None}\n        if isinstance(json, Mapping):\n            json = {key: val for key, val in json.items() if val is not None}\n    elif none_fields == \"empty\":\n        if isinstance(data, Mapping):\n            data = {key: val if val is not None else \"\" for key, val in data.items()}\n        if isinstance(json, Mapping):\n            json = {key: val if val is not None else \"\" for key, val in json.items()}\n\n    if bool_fields is None:\n        bool_fields = self.bool_fields\n\n    if bool_fields:\n        true_value, false_value = validate_bool_fields(bool_fields)\n        if isinstance(data, MutableMapping):\n            for key, val in data.items():\n                if val is True:\n                    data[key] = true_value\n                elif val is False:\n                    data[key] = false_value\n        if isinstance(params, MutableMapping):\n            for key, val in params.items():\n                if val is True:\n                    params[key] = true_value\n                elif val is False:\n                    params[key] = false_value\n\n    timeout = timeout or self.timeout\n\n    response = self.session.request(\n        method,\n        path,\n        params=params,\n        data=data,\n        headers=headers,\n        cookies=cookies,\n        files=files,\n        auth=auth or self.auth,\n        timeout=timeout,\n        allow_redirects=allow_redirects,\n        proxies=proxies,\n        hooks=hooks,\n        stream=stream,\n        verify=verify,\n        cert=cert,\n        json=json,\n    )\n\n    if raise_for_status is None:\n        raise_for_status = self.raise_for_status\n    if raise_for_status:\n        response.raise_for_status()\n    return response\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.to_absolute_url","title":"<code>to_absolute_url(path=None)</code>","text":"<p>Convert a relative url to an absolute url.</p> <p>Given a <code>path</code>, return the matching absolute url, based on the <code>base_url</code> that is configured for this API.</p> <p>The result of this method is different from a standard <code>urljoin()</code>, because a relative_url that starts with a \"/\" will not override the path from the base url. You can also pass an iterable of path parts as relative url, which will be properly joined with \"/\". Those parts may be <code>str</code> (which will be urlencoded) or <code>bytes</code> (which will be decoded as UTF-8 first) or any other type (which will be converted to <code>str</code> first, using the <code>str() function</code>). See the table below for example results which would exhibit most cases:</p> base_url relative_url result_url <code>\"https://myhost.com/root\"</code> <code>\"/path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>\"/path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>b\"/path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>\"path\"</code> <code>\"https://myhost.com/root/path\"</code> <code>\"https://myhost.com/root\"</code> <code>None</code> <code>\"https://myhost.com/root\"</code> <code>\"https://myhost.com/root\"</code> <code>(\"user\", 1, \"resource\")</code> <code>\"https://myhost.com/root/user/1/resource\"</code> <code>\"https://myhost.com/root\"</code> <code>\"https://otherhost.org/foo\"</code> <code>ValueError</code> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>a relative url</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the resulting absolute url</p> <p>Raises:</p> Type Description <code>InvalidPathParam</code> <p>if the provided path does not allow constructing a valid url</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def to_absolute_url(self, path: None | str | bytes | Iterable[str | bytes | int] = None) -&gt; str:\n    \"\"\"Convert a relative url to an absolute url.\n\n    Given a `path`, return the matching absolute url, based on the `base_url` that is\n    configured for this API.\n\n    The result of this method is different from a standard `urljoin()`, because a relative_url\n    that starts with a \"/\" will not override the path from the base url. You can also pass an\n    iterable of path parts as relative url, which will be properly joined with \"/\". Those parts\n    may be `str` (which will be urlencoded) or `bytes` (which will be decoded as UTF-8 first) or\n    any other type (which will be converted to `str` first, using the `str() function`). See the\n    table below for example results which would exhibit most cases:\n\n    | base_url | relative_url | result_url |\n    |---------------------------|-----------------------------|-------------------------------------------|\n    | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `\"/path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `b\"/path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `\"path\"` | `\"https://myhost.com/root/path\"` |\n    | `\"https://myhost.com/root\"` | `None` | `\"https://myhost.com/root\"` |\n    | `\"https://myhost.com/root\"` |  `(\"user\", 1, \"resource\")` | `\"https://myhost.com/root/user/1/resource\"` |\n    | `\"https://myhost.com/root\"` | `\"https://otherhost.org/foo\"` | `ValueError` |\n\n    Args:\n      path: a relative url\n\n    Returns:\n      the resulting absolute url\n\n    Raises:\n        InvalidPathParam: if the provided path does not allow constructing a valid url\n\n    \"\"\"\n    url = path\n\n    if url is None:\n        url = self.base_url\n    else:\n        if not isinstance(url, (str, bytes)):\n            try:\n                url = \"/\".join(\n                    [urlencode(part.decode() if isinstance(part, bytes) else str(part)) for part in url if part],\n                )\n            except Exception as exc:\n                raise InvalidPathParam(url) from exc\n\n        if isinstance(url, bytes):\n            url = url.decode()\n\n        if \"://\" in url:\n            raise InvalidPathParam(url)\n\n        url = urljoin(self.base_url + \"/\", url.lstrip(\"/\"))\n\n    if url is None or not isinstance(url, str):\n        raise InvalidPathParam(url)  # pragma: no cover\n\n    return url\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.get","title":"<code>get(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a GET request and return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def get(\n    self,\n    path: None | str | bytes | Iterable[str | bytes | int] = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a GET request and return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n        path: the path where the request will be sent.\n        raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n        **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n        a response object.\n\n    Raises:\n        requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"GET\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.post","title":"<code>post(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a POST request and return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def post(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a POST request and return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n      a response object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"POST\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.patch","title":"<code>patch(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a PATCH request. Return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def patch(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a PATCH request. Return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"PATCH\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.put","title":"<code>put(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a PUT request. Return a Response object.</p> <p>The passed <code>url</code> is relative to the <code>base_url</code> passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def put(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a PUT request. Return a [Response][requests.Response] object.\n\n    The passed `url` is relative to the `base_url` passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"PUT\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.delete","title":"<code>delete(path=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a DELETE request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>the path where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def delete(\n    self,\n    path: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a DELETE request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time. It takes the same\n    parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      path: the path where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`.\n\n    Returns:\n      a response object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"DELETE\", path, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.validate_bool_fields","title":"<code>validate_bool_fields(bool_fields)</code>","text":"<p>Validate the <code>bool_fields</code> paremeter.</p> <p>It must be a sequence of 2 values. First one is the <code>True</code> value, second one is the <code>False</code> value. Both must be <code>str</code> or string-able values.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def validate_bool_fields(bool_fields: tuple[str, str]) -&gt; tuple[str, str]:\n    \"\"\"Validate the `bool_fields` paremeter.\n\n    It must be a sequence of 2 values. First one is the `True` value, second one is the `False` value.\n    Both must be `str` or string-able values.\n\n    \"\"\"\n    try:\n        true_value, false_value = bool_fields\n    except ValueError:\n        raise InvalidBoolFieldsParam(bool_fields) from None\n    else:\n        return str(true_value), str(false_value)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth","title":"<code>auth</code>","text":"<p>This module contains <code>requests</code>-compatible Auth Handlers that implement OAuth 2.0.</p>"},{"location":"api/#requests_oauth2client.auth.NonRenewableTokenError","title":"<code>NonRenewableTokenError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when attempting to renew a token non-interactively when missing renewing material.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class NonRenewableTokenError(Exception):\n    \"\"\"Raised when attempting to renew a token non-interactively when missing renewing material.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.BaseOAuth2RenewableTokenAuth","title":"<code>BaseOAuth2RenewableTokenAuth</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Base class for BearerToken-based Auth Handlers, with an obtainable or renewable token.</p> <p>In addition to adding a properly formatted <code>Authorization</code> header, this will obtain a new token once the current token is expired. Expiration is detected based on the <code>expires_in</code> hint returned by the AS. A configurable <code>leeway</code>, in number of seconds, will make sure that a new token is obtained some seconds before the actual expiration is reached. This may help in situations where the client, AS and RS have slightly offset clocks.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass BaseOAuth2RenewableTokenAuth(requests.auth.AuthBase):\n    \"\"\"Base class for BearerToken-based Auth Handlers, with an obtainable or renewable token.\n\n    In addition to adding a properly formatted `Authorization` header, this will obtain a new token\n    once the current token is expired. Expiration is detected based on the `expires_in` hint\n    returned by the AS. A configurable `leeway`, in number of seconds, will make sure that a new\n    token is obtained some seconds before the actual expiration is reached. This may help in\n    situations where the client, AS and RS have slightly offset clocks.\n\n    \"\"\"\n\n    client: OAuth2Client = field(on_setattr=setters.frozen)\n    token: BearerToken | None\n    leeway: int = field(on_setattr=setters.frozen)\n    token_kwargs: dict[str, Any] = field(on_setattr=setters.frozen)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the Access Token to the request.\n\n        If Access Token is not specified or expired, obtain a new one first.\n\n        Raises:\n            NonRenewableTokenError: if the token is not renewable\n\n        \"\"\"\n        if self.token is None or self.token.is_expired(self.leeway):\n            self.renew_token()\n        if self.token is None:\n            raise NonRenewableTokenError  # pragma: no cover\n        return self.token(request)\n\n    def renew_token(self) -&gt; None:\n        \"\"\"Obtain a new Bearer Token.\n\n        Subclasses should implement this.\n\n        \"\"\"\n        raise NotImplementedError\n\n    def forget_token(self) -&gt; None:\n        \"\"\"Forget the current token, forcing a renewal on the next HTTP request.\"\"\"\n        self.token = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.BaseOAuth2RenewableTokenAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new Bearer Token.</p> <p>Subclasses should implement this.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def renew_token(self) -&gt; None:\n    \"\"\"Obtain a new Bearer Token.\n\n    Subclasses should implement this.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.BaseOAuth2RenewableTokenAuth.forget_token","title":"<code>forget_token()</code>","text":"<p>Forget the current token, forcing a renewal on the next HTTP request.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def forget_token(self) -&gt; None:\n    \"\"\"Forget the current token, forcing a renewal on the next HTTP request.\"\"\"\n    self.token = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.BaseOAuth2RefreshTokenAuth","title":"<code>BaseOAuth2RefreshTokenAuth</code>","text":"<p>               Bases: <code>BaseOAuth2RenewableTokenAuth</code></p> <p>Base class for flows which can have a refresh-token.</p> <p>This implements a <code>renew_token()</code> method which uses the refresh token to obtain new tokens.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass BaseOAuth2RefreshTokenAuth(BaseOAuth2RenewableTokenAuth):\n    \"\"\"Base class for flows which can have a refresh-token.\n\n    This implements a `renew_token()` method which uses the refresh token to obtain new tokens.\n\n    \"\"\"\n\n    @override\n    def renew_token(self) -&gt; None:\n        \"\"\"Obtain a new token, using the Refresh Token, if available.\n\n        Raises:\n            NonRenewableTokenError: if the token is not renewable.\n\n        \"\"\"\n        if self.token is None or self.token.refresh_token is None:\n            raise NonRenewableTokenError\n\n        self.token = self.client.refresh_token(refresh_token=self.token, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.BaseOAuth2RefreshTokenAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new token, using the Refresh Token, if available.</p> <p>Raises:</p> Type Description <code>NonRenewableTokenError</code> <p>if the token is not renewable.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@override\ndef renew_token(self) -&gt; None:\n    \"\"\"Obtain a new token, using the Refresh Token, if available.\n\n    Raises:\n        NonRenewableTokenError: if the token is not renewable.\n\n    \"\"\"\n    if self.token is None or self.token.refresh_token is None:\n        raise NonRenewableTokenError\n\n    self.token = self.client.refresh_token(refresh_token=self.token, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2ClientCredentialsAuth","title":"<code>OAuth2ClientCredentialsAuth</code>","text":"<p>               Bases: <code>BaseOAuth2RenewableTokenAuth</code></p> <p>An Auth Handler for the Client Credentials grant.</p> <p>This requests AuthBase automatically gets Access Tokens from an OAuth 2.0 Token Endpoint with the Client Credentials grant, and will get a new one once the current one is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>extra kw parameters to pass to the Token Endpoint. May include <code>scope</code>, <code>resource</code>, etc.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import OAuth2Client, OAuth2ClientCredentialsAuth, requests\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\noauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\")\nresp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2ClientCredentialsAuth(BaseOAuth2RenewableTokenAuth):\n    \"\"\"An Auth Handler for the [Client Credentials grant](https://www.rfc-editor.org/rfc/rfc6749#section-4.4).\n\n    This [requests AuthBase][requests.auth.AuthBase] automatically gets Access Tokens from an OAuth\n    2.0 Token Endpoint with the Client Credentials grant, and will get a new one once the current\n    one is expired.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds\n        **token_kwargs: extra kw parameters to pass to the Token Endpoint. May include `scope`, `resource`, etc.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, OAuth2ClientCredentialsAuth, requests\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        oauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\")\n        resp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc)\n        ```\n\n    \"\"\"\n\n    def __init__(\n        self, client: OAuth2Client, *, leeway: int = 20, token: str | BearerToken | None = None, **token_kwargs: Any\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(client=client, token=token, leeway=leeway, token_kwargs=token_kwargs)\n\n    @override\n    def renew_token(self) -&gt; None:\n        \"\"\"Obtain a new token for use within this Auth Handler.\"\"\"\n        self.token = self.client.client_credentials(**self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2ClientCredentialsAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new token for use within this Auth Handler.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@override\ndef renew_token(self) -&gt; None:\n    \"\"\"Obtain a new token for use within this Auth Handler.\"\"\"\n    self.token = self.client.client_credentials(**self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AccessTokenAuth","title":"<code>OAuth2AccessTokenAuth</code>","text":"<p>               Bases: <code>BaseOAuth2RefreshTokenAuth</code></p> <p>Authentication Handler for OAuth 2.0 Access Tokens and (optional) Refresh Tokens.</p> <p>This Requests Auth handler implementation uses an access token as Bearer token, and can automatically refresh it when expired, if a refresh token is available.</p> <p>Token can be a simple <code>str</code> containing a raw access token value, or a BearerToken that can contain a <code>refresh_token</code>. If a <code>refresh_token</code> and an expiration date are available (based on <code>expires_in</code> hint), this Auth Handler will automatically refresh the access token once it is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the client to use to refresh tokens.</p> required <code>token</code> <code>str | BearerToken</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> required <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds.</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import BearerToken, OAuth2Client, OAuth2AccessTokenAuth, requests\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n# obtain a BearerToken any way you see fit, optionally including a refresh token\n# for this example, the token value is hardcoded\ntoken = BearerToken(access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\")\nauth = OAuth2AccessTokenAuth(client, token, scope=\"my_scope\")\nresp = requests.post(\"https://my.api.local/resource\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2AccessTokenAuth(BaseOAuth2RefreshTokenAuth):\n    \"\"\"Authentication Handler for OAuth 2.0 Access Tokens and (optional) Refresh Tokens.\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation uses an access token as\n    Bearer token, and can automatically refresh it when expired, if a refresh token is available.\n\n    Token can be a simple `str` containing a raw access token value, or a\n    [BearerToken][requests_oauth2client.tokens.BearerToken] that can contain a `refresh_token`.\n    If a `refresh_token` and an expiration date are available (based on `expires_in` hint),\n    this Auth Handler will automatically refresh the access token once it is expired.\n\n    Args:\n        client: the client to use to refresh tokens.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds.\n        **token_kwargs: additional kwargs to pass to the token endpoint.\n\n    Example:\n        ```python\n        from requests_oauth2client import BearerToken, OAuth2Client, OAuth2AccessTokenAuth, requests\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        # obtain a BearerToken any way you see fit, optionally including a refresh token\n        # for this example, the token value is hardcoded\n        token = BearerToken(access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\")\n        auth = OAuth2AccessTokenAuth(client, token, scope=\"my_scope\")\n        resp = requests.post(\"https://my.api.local/resource\", auth=auth)\n        ```\n\n    \"\"\"\n\n    def __init__(\n        self, client: OAuth2Client, token: str | BearerToken, *, leeway: int = 20, **token_kwargs: Any\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(client=client, token=token, leeway=leeway, token_kwargs=token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AuthorizationCodeAuth","title":"<code>OAuth2AuthorizationCodeAuth</code>","text":"<p>               Bases: <code>BaseOAuth2RefreshTokenAuth</code></p> <p>Authentication handler for the Authorization Code grant.</p> <p>This Requests Auth handler implementation exchanges an Authorization Code for an access token, then automatically refreshes it once it is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the client to use to obtain Access Tokens.</p> required <code>code</code> <code>str | AuthorizationResponse | None</code> <p>an Authorization Code that has been obtained from the AS.</p> required <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds.</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import ApiClient, OAuth2Client, OAuth2AuthorizationCodeAuth\n\nclient = OAuth2Client(token_endpoint=\"https://myas.local/token\", auth=(\"client_id\", \"client_secret\"))\ncode = \"my_code\"  # you must obtain this code yourself\napi = ApiClient(\"https://my.api.local/resource\", auth=OAuth2AuthorizationCodeAuth(client, code))\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2AuthorizationCodeAuth(BaseOAuth2RefreshTokenAuth):  # type: ignore[override]\n    \"\"\"Authentication handler for the [Authorization Code grant](https://www.rfc-editor.org/rfc/rfc6749#section-4.1).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges an Authorization\n    Code for an access token, then automatically refreshes it once it is expired.\n\n    Args:\n        client: the client to use to obtain Access Tokens.\n        code: an Authorization Code that has been obtained from the AS.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds.\n        **token_kwargs: additional kwargs to pass to the token endpoint.\n\n    Example:\n        ```python\n        from requests_oauth2client import ApiClient, OAuth2Client, OAuth2AuthorizationCodeAuth\n\n        client = OAuth2Client(token_endpoint=\"https://myas.local/token\", auth=(\"client_id\", \"client_secret\"))\n        code = \"my_code\"  # you must obtain this code yourself\n        api = ApiClient(\"https://my.api.local/resource\", auth=OAuth2AuthorizationCodeAuth(client, code))\n        ```\n\n    \"\"\"\n\n    code: str | AuthorizationResponse | None\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        code: str | AuthorizationResponse | None,\n        *,\n        leeway: int = 20,\n        token: str | BearerToken | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(\n            client=client,\n            token=token,\n            code=code,\n            leeway=leeway,\n            token_kwargs=token_kwargs,\n        )\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the Authorization Code grant as an Authentication Handler.\n\n        This exchanges an Authorization Code for an access token and adds it in the request.\n\n        Args:\n            request: the request\n\n        Returns:\n            the request, with an Access Token added in Authorization Header\n\n        \"\"\"\n        if self.token is None or self.token.is_expired():\n            self.exchange_code_for_token()\n        return super().__call__(request)\n\n    def exchange_code_for_token(self) -&gt; None:\n        \"\"\"Exchange the authorization code for an access token.\"\"\"\n        if self.code:  # pragma: no branch\n            self.token = self.client.authorization_code(code=self.code, **self.token_kwargs)\n            self.code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AuthorizationCodeAuth.exchange_code_for_token","title":"<code>exchange_code_for_token()</code>","text":"<p>Exchange the authorization code for an access token.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def exchange_code_for_token(self) -&gt; None:\n    \"\"\"Exchange the authorization code for an access token.\"\"\"\n    if self.code:  # pragma: no branch\n        self.token = self.client.authorization_code(code=self.code, **self.token_kwargs)\n        self.code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2ResourceOwnerPasswordAuth","title":"<code>OAuth2ResourceOwnerPasswordAuth</code>","text":"<p>               Bases: <code>BaseOAuth2RenewableTokenAuth</code></p> <p>Authentication Handler for the Resource Owner Password Credentials Flow.</p> <p>This Requests Auth handler implementation exchanges the user credentials for an Access Token, then automatically repeats the process to get a new one once the current one is expired.</p> <p>Note that this flow is considered deprecated, and the Authorization Code flow should be used whenever possible. Among other bad things, ROPC:</p> <ul> <li>does not support SSO between multiple apps,</li> <li>does not support MFA or risk-based adaptative authentication,</li> <li>depends on the user typing its credentials directly inside the application, instead of on a dedicated, centralized login page managed by the AS, which makes it totally insecure for 3rd party apps.</li> </ul> <p>It needs the username and password and an OAuth2Client to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the client to use to obtain Access Tokens</p> required <code>username</code> <code>str</code> <p>the username</p> required <code>password</code> <code>str</code> <p>the user password</p> required <code>leeway</code> <code>int</code> <p>an amount of time, in seconds</p> <code>20</code> <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint</p> <code>{}</code> Example <pre><code>from requests_oauth2client import ApiClient, OAuth2Client, OAuth2ResourceOwnerPasswordAuth\n\nclient = OAuth2Client(\n    token_endpoint=\"https://myas.local/token\",\n    auth=(\"client_id\", \"client_secret\"),\n)\nusername = \"my_username\"\npassword = \"my_password\"  # you must obtain those credentials from the user\nauth = OAuth2ResourceOwnerPasswordAuth(client, username=username, password=password)\napi = ApiClient(\"https://myapi.local\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2ResourceOwnerPasswordAuth(BaseOAuth2RenewableTokenAuth):  # type: ignore[override]\n    \"\"\"Authentication Handler for the [Resource Owner Password Credentials Flow](https://www.rfc-editor.org/rfc/rfc6749#section-4.3).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges the user\n    credentials for an Access Token, then automatically repeats the process to get a new one\n    once the current one is expired.\n\n    Note that this flow is considered *deprecated*, and the Authorization Code flow should be\n    used whenever possible.\n    Among other bad things, ROPC:\n\n    - does not support SSO between multiple apps,\n    - does not support MFA or risk-based adaptative authentication,\n    - depends on the user typing its credentials directly inside the application, instead of on a\n    dedicated, centralized login page managed by the AS, which makes it totally insecure for 3rd party apps.\n\n    It needs the username and password and an\n    [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be able to get a token from\n    the AS Token Endpoint just before the first request using this Auth Handler is being sent.\n\n    Args:\n        client: the client to use to obtain Access Tokens\n        username: the username\n        password: the user password\n        leeway: an amount of time, in seconds\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        **token_kwargs: additional kwargs to pass to the token endpoint\n\n    Example:\n        ```python\n        from requests_oauth2client import ApiClient, OAuth2Client, OAuth2ResourceOwnerPasswordAuth\n\n        client = OAuth2Client(\n            token_endpoint=\"https://myas.local/token\",\n            auth=(\"client_id\", \"client_secret\"),\n        )\n        username = \"my_username\"\n        password = \"my_password\"  # you must obtain those credentials from the user\n        auth = OAuth2ResourceOwnerPasswordAuth(client, username=username, password=password)\n        api = ApiClient(\"https://myapi.local\", auth=auth)\n        ```\n    \"\"\"\n\n    username: str\n    password: str\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        *,\n        username: str,\n        password: str,\n        leeway: int = 20,\n        token: str | BearerToken | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(\n            client=client,\n            token=token,\n            leeway=leeway,\n            token_kwargs=token_kwargs,\n            username=username,\n            password=password,\n        )\n\n    @override\n    def renew_token(self) -&gt; None:\n        \"\"\"Exchange the user credentials for an Access Token.\"\"\"\n        self.token = self.client.resource_owner_password(\n            username=self.username,\n            password=self.password,\n            **self.token_kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2ResourceOwnerPasswordAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Exchange the user credentials for an Access Token.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@override\ndef renew_token(self) -&gt; None:\n    \"\"\"Exchange the user credentials for an Access Token.\"\"\"\n    self.token = self.client.resource_owner_password(\n        username=self.username,\n        password=self.password,\n        **self.token_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2DeviceCodeAuth","title":"<code>OAuth2DeviceCodeAuth</code>","text":"<p>               Bases: <code>BaseOAuth2RefreshTokenAuth</code></p> <p>Authentication Handler for the Device Code Flow.</p> <p>This Requests Auth handler implementation exchanges a Device Code for an Access Token, then automatically refreshes it once it is expired.</p> <p>It needs a Device Code and an OAuth2Client to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a Device Code obtained from the AS.</p> required <code>interval</code> <code>int</code> <p>the interval to use to pool the Token Endpoint, in seconds.</p> <code>5</code> <code>expires_in</code> <code>int</code> <p>the lifetime of the token, in seconds.</p> <code>360</code> <code>token</code> <code>str | BearerToken | None</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds.</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import OAuth2Client, OAuth2DeviceCodeAuth, requests\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\ndevice_code = client.device_authorization()\nauth = OAuth2DeviceCodeAuth(client, device_code)\nresp = requests.post(\"https://my.api.local/resource\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@define(init=False)\nclass OAuth2DeviceCodeAuth(BaseOAuth2RefreshTokenAuth):  # type: ignore[override]\n    \"\"\"Authentication Handler for the [Device Code Flow](https://www.rfc-editor.org/rfc/rfc8628).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges a Device Code for\n    an Access Token, then automatically refreshes it once it is expired.\n\n    It needs a Device Code and an [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be\n    able to get a token from the AS Token Endpoint just before the first request using this Auth\n    Handler is being sent.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        device_code: a Device Code obtained from the AS.\n        interval: the interval to use to pool the Token Endpoint, in seconds.\n        expires_in: the lifetime of the token, in seconds.\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds.\n        **token_kwargs: additional kwargs to pass to the token endpoint.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, OAuth2DeviceCodeAuth, requests\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        device_code = client.device_authorization()\n        auth = OAuth2DeviceCodeAuth(client, device_code)\n        resp = requests.post(\"https://my.api.local/resource\", auth=auth)\n        ```\n\n    \"\"\"\n\n    device_code: str | DeviceAuthorizationResponse\n    interval: int\n    expires_in: int\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        *,\n        device_code: str | DeviceAuthorizationResponse,\n        leeway: int = 20,\n        interval: int = 5,\n        expires_in: int = 360,\n        token: str | BearerToken | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(token, str):\n            token = BearerToken(token)\n        self.__attrs_init__(\n            client=client,\n            token=token,\n            leeway=leeway,\n            token_kwargs=token_kwargs,\n            device_code=device_code,\n            interval=interval,\n            expires_in=expires_in,\n        )\n\n    @override\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the Device Code grant as a request Authentication Handler.\n\n        This exchanges a Device Code for an access token and adds it in HTTP requests.\n\n        Args:\n            request: a [requests.PreparedRequest][]\n\n        Returns:\n            a [requests.PreparedRequest][] with an Access Token added in Authorization Header\n\n        \"\"\"\n        if self.token is None:\n            self.exchange_device_code_for_token()\n        return super().__call__(request)\n\n    def exchange_device_code_for_token(self) -&gt; None:\n        \"\"\"Exchange the Device Code for an access token.\n\n        This will poll the Token Endpoint until the user finishes the authorization process.\n\n        \"\"\"\n        from .device_authorization import DeviceAuthorizationPoolingJob\n\n        if self.device_code:  # pragma: no branch\n            pooling_job = DeviceAuthorizationPoolingJob(\n                client=self.client,\n                device_code=self.device_code,\n                interval=self.interval,\n            )\n            token = None\n            while token is None:\n                token = pooling_job()\n            self.token = token\n            self.device_code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2DeviceCodeAuth.exchange_device_code_for_token","title":"<code>exchange_device_code_for_token()</code>","text":"<p>Exchange the Device Code for an access token.</p> <p>This will poll the Token Endpoint until the user finishes the authorization process.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def exchange_device_code_for_token(self) -&gt; None:\n    \"\"\"Exchange the Device Code for an access token.\n\n    This will poll the Token Endpoint until the user finishes the authorization process.\n\n    \"\"\"\n    from .device_authorization import DeviceAuthorizationPoolingJob\n\n    if self.device_code:  # pragma: no branch\n        pooling_job = DeviceAuthorizationPoolingJob(\n            client=self.client,\n            device_code=self.device_code,\n            interval=self.interval,\n        )\n        token = None\n        while token is None:\n            token = pooling_job()\n        self.token = token\n        self.device_code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request","title":"<code>authorization_request</code>","text":"<p>Classes and utilities related to Authorization Requests and Responses.</p>"},{"location":"api/#requests_oauth2client.authorization_request.ResponseTypes","title":"<code>ResponseTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>All standardised <code>response_type</code> values.</p> <p>Note that you should always use <code>code</code>. All other values are deprecated.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class ResponseTypes(str, Enum):\n    \"\"\"All standardised `response_type` values.\n\n    Note that you should always use `code`. All other values are deprecated.\n\n    \"\"\"\n\n    CODE = \"code\"\n    NONE = \"none\"\n    TOKEN = \"token\"\n    IDTOKEN = \"id_token\"\n    CODE_IDTOKEN = \"code id_token\"\n    CODE_TOKEN = \"code token\"\n    CODE_IDTOKEN_TOKEN = \"code id_token token\"\n    IDTOKEN_TOKEN = \"id_token token\"\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.CodeChallengeMethods","title":"<code>CodeChallengeMethods</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>All standardised <code>code_challenge</code> values.</p> <p>You should always use <code>S256</code>.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class CodeChallengeMethods(str, Enum):\n    \"\"\"All standardised `code_challenge` values.\n\n    You should always use `S256`.\n\n    \"\"\"\n\n    S256 = \"S256\"\n    plain = \"plain\"\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.UnsupportedCodeChallengeMethod","title":"<code>UnsupportedCodeChallengeMethod</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an unsupported code_challenge_method is provided.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class UnsupportedCodeChallengeMethod(ValueError):\n    \"\"\"Raised when an unsupported code_challenge_method is provided.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.InvalidCodeVerifierParam","title":"<code>InvalidCodeVerifierParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an invalid code_verifier is supplied.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class InvalidCodeVerifierParam(ValueError):\n    \"\"\"Raised when an invalid code_verifier is supplied.\"\"\"\n\n    def __init__(self, code_verifier: str) -&gt; None:\n        super().__init__(\"\"\"\\\nInvalid 'code_verifier'. It must be a 43 to 128 characters long string, with:\n- lowercase letters\n- uppercase letters\n- digits\n- underscore, dash, tilde, or dot (_-~.)\n\"\"\")\n        self.code_verifier = code_verifier\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils","title":"<code>PkceUtils</code>","text":"<p>Contains helper methods for PKCE, as described in RFC7636.</p> <p>See RFC7636.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class PkceUtils:\n    \"\"\"Contains helper methods for PKCE, as described in RFC7636.\n\n    See [RFC7636](https://tools.ietf.org/html/rfc7636).\n\n    \"\"\"\n\n    code_verifier_pattern = re.compile(r\"^[a-zA-Z0-9_\\-~.]{43,128}$\")\n    \"\"\"A regex that matches valid code verifiers.\"\"\"\n\n    @classmethod\n    def generate_code_verifier(cls) -&gt; str:\n        \"\"\"Generate a valid `code_verifier`.\n\n        Returns:\n            a `code_verifier` ready to use for PKCE\n\n        \"\"\"\n        return secrets.token_urlsafe(96)\n\n    @classmethod\n    def derive_challenge(cls, verifier: str | bytes, method: str = CodeChallengeMethods.S256) -&gt; str:\n        \"\"\"Derive the `code_challenge` from a given `code_verifier`.\n\n        Args:\n            verifier: a code verifier\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            a `code_challenge` derived from the given verifier\n\n        Raises:\n            InvalidCodeVerifierParam: if the `verifier` does not match `code_verifier_pattern`\n            UnsupportedCodeChallengeMethod: if the method is not supported\n\n        \"\"\"\n        if isinstance(verifier, bytes):\n            verifier = verifier.decode()\n\n        if not cls.code_verifier_pattern.match(verifier):\n            raise InvalidCodeVerifierParam(verifier)\n\n        if method == CodeChallengeMethods.S256:\n            return BinaPy(verifier).to(\"sha256\").to(\"b64u\").ascii()\n        if method == CodeChallengeMethods.plain:\n            return verifier\n\n        raise UnsupportedCodeChallengeMethod(method)\n\n    @classmethod\n    def generate_code_verifier_and_challenge(cls, method: str = CodeChallengeMethods.S256) -&gt; tuple[str, str]:\n        \"\"\"Generate a valid `code_verifier` and derive its `code_challenge`.\n\n        Args:\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            a `(code_verifier, code_challenge)` tuple.\n\n        \"\"\"\n        verifier = cls.generate_code_verifier()\n        challenge = cls.derive_challenge(verifier, method)\n        return verifier, challenge\n\n    @classmethod\n    def validate_code_verifier(cls, verifier: str, challenge: str, method: str = CodeChallengeMethods.S256) -&gt; bool:\n        \"\"\"Validate a `code_verifier` against a `code_challenge`.\n\n        Args:\n            verifier: the `code_verifier`, exactly as submitted by the client on token request.\n            challenge: the `code_challenge`, exactly as submitted by the client on authorization request.\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            `True` if verifier is valid, or `False` otherwise\n\n        \"\"\"\n        return (\n            cls.code_verifier_pattern.match(verifier) is not None\n            and cls.derive_challenge(verifier, method) == challenge\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.code_verifier_pattern","title":"<code>code_verifier_pattern = re.compile('^[a-zA-Z0-9_\\\\-~.]{43,128}$')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A regex that matches valid code verifiers.</p>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.generate_code_verifier","title":"<code>generate_code_verifier()</code>  <code>classmethod</code>","text":"<p>Generate a valid <code>code_verifier</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>a <code>code_verifier</code> ready to use for PKCE</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_code_verifier(cls) -&gt; str:\n    \"\"\"Generate a valid `code_verifier`.\n\n    Returns:\n        a `code_verifier` ready to use for PKCE\n\n    \"\"\"\n    return secrets.token_urlsafe(96)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.derive_challenge","title":"<code>derive_challenge(verifier, method=CodeChallengeMethods.S256)</code>  <code>classmethod</code>","text":"<p>Derive the <code>code_challenge</code> from a given <code>code_verifier</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>str | bytes</code> <p>a code verifier</p> required <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>S256</code> <p>Returns:</p> Type Description <code>str</code> <p>a <code>code_challenge</code> derived from the given verifier</p> <p>Raises:</p> Type Description <code>InvalidCodeVerifierParam</code> <p>if the <code>verifier</code> does not match <code>code_verifier_pattern</code></p> <code>UnsupportedCodeChallengeMethod</code> <p>if the method is not supported</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef derive_challenge(cls, verifier: str | bytes, method: str = CodeChallengeMethods.S256) -&gt; str:\n    \"\"\"Derive the `code_challenge` from a given `code_verifier`.\n\n    Args:\n        verifier: a code verifier\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        a `code_challenge` derived from the given verifier\n\n    Raises:\n        InvalidCodeVerifierParam: if the `verifier` does not match `code_verifier_pattern`\n        UnsupportedCodeChallengeMethod: if the method is not supported\n\n    \"\"\"\n    if isinstance(verifier, bytes):\n        verifier = verifier.decode()\n\n    if not cls.code_verifier_pattern.match(verifier):\n        raise InvalidCodeVerifierParam(verifier)\n\n    if method == CodeChallengeMethods.S256:\n        return BinaPy(verifier).to(\"sha256\").to(\"b64u\").ascii()\n    if method == CodeChallengeMethods.plain:\n        return verifier\n\n    raise UnsupportedCodeChallengeMethod(method)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.generate_code_verifier_and_challenge","title":"<code>generate_code_verifier_and_challenge(method=CodeChallengeMethods.S256)</code>  <code>classmethod</code>","text":"<p>Generate a valid <code>code_verifier</code> and derive its <code>code_challenge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>S256</code> <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>a <code>(code_verifier, code_challenge)</code> tuple.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_code_verifier_and_challenge(cls, method: str = CodeChallengeMethods.S256) -&gt; tuple[str, str]:\n    \"\"\"Generate a valid `code_verifier` and derive its `code_challenge`.\n\n    Args:\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        a `(code_verifier, code_challenge)` tuple.\n\n    \"\"\"\n    verifier = cls.generate_code_verifier()\n    challenge = cls.derive_challenge(verifier, method)\n    return verifier, challenge\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.validate_code_verifier","title":"<code>validate_code_verifier(verifier, challenge, method=CodeChallengeMethods.S256)</code>  <code>classmethod</code>","text":"<p>Validate a <code>code_verifier</code> against a <code>code_challenge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>str</code> <p>the <code>code_verifier</code>, exactly as submitted by the client on token request.</p> required <code>challenge</code> <code>str</code> <p>the <code>code_challenge</code>, exactly as submitted by the client on authorization request.</p> required <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>S256</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if verifier is valid, or <code>False</code> otherwise</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef validate_code_verifier(cls, verifier: str, challenge: str, method: str = CodeChallengeMethods.S256) -&gt; bool:\n    \"\"\"Validate a `code_verifier` against a `code_challenge`.\n\n    Args:\n        verifier: the `code_verifier`, exactly as submitted by the client on token request.\n        challenge: the `code_challenge`, exactly as submitted by the client on authorization request.\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        `True` if verifier is valid, or `False` otherwise\n\n    \"\"\"\n    return (\n        cls.code_verifier_pattern.match(verifier) is not None\n        and cls.derive_challenge(verifier, method) == challenge\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.UnsupportedResponseTypeParam","title":"<code>UnsupportedResponseTypeParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an unsupported response_type is passed as parameter.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class UnsupportedResponseTypeParam(ValueError):\n    \"\"\"Raised when an unsupported response_type is passed as parameter.\"\"\"\n\n    def __init__(self, response_type: str) -&gt; None:\n        super().__init__(\"\"\"The only supported response type is 'code'.\"\"\", response_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.MissingIssuerParam","title":"<code>MissingIssuerParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when the 'issuer' parameter is required but not provided.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class MissingIssuerParam(ValueError):\n    \"\"\"Raised when the 'issuer' parameter is required but not provided.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"\"\"\\\nWhen 'authorization_response_iss_parameter_supported' is `True`, you must\nprovide the expected `issuer` as parameter.\n\"\"\")\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.InvalidMaxAgeParam","title":"<code>InvalidMaxAgeParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an invalid 'max_age' parameter is provided.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class InvalidMaxAgeParam(ValueError):\n    \"\"\"Raised when an invalid 'max_age' parameter is provided.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"\"\"\\\nInvalid 'max_age' parameter. It must be a positive number of seconds.\nThis specifies the allowable elapsed time in seconds since the last time\nthe End-User was actively authenticated by the OP.\n\"\"\")\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationResponse","title":"<code>AuthorizationResponse</code>","text":"<p>Represent a successful Authorization Response.</p> <p>An Authorization Response is the redirection initiated by the AS to the client's redirection endpoint (redirect_uri) after an Authorization Request. This Response is typically created with a call to <code>AuthorizationRequest.validate_callback()</code> once the call to the client Redirection Endpoint is made. AuthorizationResponse contains the following, all accessible as attributes:</p> <ul> <li>all the parameters that have been returned by the AS, most notably the <code>code</code>, and optional    parameters such as <code>state</code>.</li> <li>the redirect_uri that was used for the Authorization Request</li> <li>the code_verifier matching the code_challenge that was used for the Authorization Request</li> </ul> <p>Parameters <code>redirect_uri</code> and <code>code_verifier</code> must be those from the matching <code>AuthorizationRequest</code>. All other parameters including <code>code</code> and <code>state</code> must be those extracted from the Authorization Response parameters.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>the authorization code returned by the AS</p> required <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri that was passed as parameter in the AuthorizationRequest</p> <code>None</code> <code>code_verifier</code> <code>str | None</code> <p>the code_verifier matching the code_challenge that was passed as parameter in the AuthorizationRequest</p> <code>None</code> <code>state</code> <code>str | None</code> <p>the state returned by the AS</p> <code>None</code> <code>**kwargs</code> <code>str</code> <p>other parameters as returned by the AS</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass AuthorizationResponse:\n    \"\"\"Represent a successful Authorization Response.\n\n    An Authorization Response is the redirection initiated by the AS to the client's redirection\n    endpoint (redirect_uri) after an Authorization Request. This Response is typically created with\n    a call to `AuthorizationRequest.validate_callback()` once the call to the client Redirection\n    Endpoint is made. AuthorizationResponse contains the following, all accessible as attributes:\n\n     - all the parameters that have been returned by the AS, most notably the `code`, and optional\n       parameters such as `state`.\n     - the redirect_uri that was used for the Authorization Request\n     - the code_verifier matching the code_challenge that was used for the Authorization Request\n\n    Parameters `redirect_uri` and `code_verifier` must be those from the matching\n    `AuthorizationRequest`. All other parameters including `code` and `state` must be those\n    extracted from the Authorization Response parameters.\n\n    Args:\n        code: the authorization code returned by the AS\n        redirect_uri: the redirect_uri that was passed as parameter in the AuthorizationRequest\n        code_verifier: the code_verifier matching the code_challenge that was passed as\n            parameter in the AuthorizationRequest\n        state: the state returned by the AS\n        **kwargs: other parameters as returned by the AS\n\n    \"\"\"\n\n    code: str\n    redirect_uri: str | None = None\n    code_verifier: str | None = None\n    state: str | None = None\n    nonce: str | None = None\n    acr_values: tuple[str, ...] | None = None\n    max_age: int | None = None\n    issuer: str | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    def __init__(\n        self,\n        *,\n        code: str,\n        redirect_uri: str | None = None,\n        code_verifier: str | None = None,\n        state: str | None = None,\n        nonce: str | None = None,\n        acr_values: str | Sequence[str] | None = None,\n        max_age: int | None = None,\n        issuer: str | None = None,\n        **kwargs: str,\n    ) -&gt; None:\n        if not acr_values:\n            acr_values = None\n        elif isinstance(acr_values, str):\n            acr_values = tuple(acr_values.split(\" \"))\n        else:\n            acr_values = tuple(acr_values)\n\n        self.__attrs_init__(\n            code=code,\n            redirect_uri=redirect_uri,\n            code_verifier=code_verifier,\n            state=state,\n            nonce=nonce,\n            acr_values=acr_values,\n            max_age=max_age,\n            issuer=issuer,\n            kwargs=kwargs,\n        )\n\n    def __getattr__(self, item: str) -&gt; str | None:\n        \"\"\"Make additional parameters available as attributes.\n\n        Args:\n            item: the attribute name\n\n        Returns:\n            the attribute value, or None if it isn't part of the returned attributes\n\n        \"\"\"\n        return self.kwargs.get(item)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest","title":"<code>AuthorizationRequest</code>","text":"<p>Represent an Authorization Request.</p> <p>This class makes it easy to generate valid Authorization Request URI (possibly including a state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization Response.</p> <p>All parameters passed at init time will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour:</p> <ul> <li><code>state</code>: if <code>...</code> (default), a random <code>state</code> parameter will be generated for you.   You may pass your own <code>state</code> as <code>str</code>, or set it to <code>None</code> so that the <code>state</code> parameter   will not be included in the request. You may access that state in the <code>state</code> attribute   from this request.</li> <li><code>nonce</code>: if <code>...</code> (default) and <code>scope</code> includes 'openid', a random <code>nonce</code> will be   generated and included in the request. You may access that <code>nonce</code> in the <code>nonce</code> attribute   from this request.</li> <li><code>code_verifier</code>: if <code>None</code>, and <code>code_challenge_method</code> is <code>'S256'</code> or <code>'plain'</code>,   a valid <code>code_challenge</code> and <code>code_verifier</code> for PKCE will be automatically generated,   and the <code>code_challenge</code> will be included in the request.   You may pass your own <code>code_verifier</code> as a <code>str</code> parameter, in which case the   appropriate <code>code_challenge</code> will be included in the request, according to the   <code>code_challenge_method</code>.</li> <li> <p><code>authorization_response_iss_parameter_supported</code> and <code>issuer</code>:    those are used for Server Issuer Identification. By default:</p> <ul> <li>If <code>\u00ecssuer</code> is set and an issuer is included in the Authorization Response, then the consistency between those 2 values will be checked when using <code>validate_callback()</code>.</li> <li>If issuer is not included in the response, then no issuer check is performed.</li> </ul> <p>Set <code>authorization_response_iss_parameter_supported</code> to <code>True</code> to enforce server identification:</p> <ul> <li>an <code>issuer</code> must also be provided as parameter, and the AS must return that same value for the response to be considered valid by <code>validate_callback()</code>.</li> <li>if no issuer is included in the Authorization Response, then an error will be raised.</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the uri for the authorization endpoint.</p> required <code>client_id</code> <code>str</code> <p>the client_id to include in the request.</p> required <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri to include in the request. This is required in OAuth 2.0 and optional in OAuth 2.1. Pass <code>None</code> if you don't need any redirect_uri in the Authorization Request.</p> <code>None</code> <code>scope</code> <code>None | str | Iterable[str]</code> <p>the scope to include in the request, as an iterable of <code>str</code>, or a single space-separated <code>str</code>.</p> <code>'openid'</code> <code>response_type</code> <code>str</code> <p>the response type to include in the request.</p> <code>CODE</code> <code>state</code> <code>str | ellipsis | None</code> <p>the state to include in the request, or <code>...</code> to autogenerate one (default).</p> <code>...</code> <code>nonce</code> <code>str | ellipsis | None</code> <p>the nonce to include in the request, or <code>...</code> to autogenerate one (default).</p> <code>...</code> <code>code_verifier</code> <code>str | None</code> <p>the code verifier to include in the request. If left as <code>None</code> and <code>code_challenge_method</code> is set, a valid code_verifier will be generated.</p> <code>None</code> <code>code_challenge_method</code> <code>str | None</code> <p>the method to use to derive the <code>code_challenge</code> from the <code>code_verifier</code>.</p> <code>S256</code> <code>acr_values</code> <code>str | Iterable[str] | None</code> <p>requested Authentication Context Class Reference values.</p> <code>None</code> <code>issuer</code> <code>str | None</code> <p>Issuer Identifier value from the OAuth/OIDC Server, if using Server Issuer Identification.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>extra parameters to include in the request, as-is.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import AuthorizationRequest\n\nazr = AuthorizationRequest(\n    authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n    client_id=\"my_client_id\",\n    redirect_uri=\"http://localhost/callback\",\n    scope=\"openid email profile\",\n)\nprint(azr)\n</code></pre> <p>Raises:</p> Type Description <code>InvalidMaxAgeParam</code> <p>if the <code>max_age</code> parameter is invalid.</p> <code>MissingIssuerParam</code> <p>if <code>authorization_response_iss_parameter_supported</code> is set to <code>True</code> but the <code>issuer</code> parameter is not provided.</p> <code>UnsupportedResponseTypeParam</code> <p>if <code>response_type</code> is not supported.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False, repr=False)\nclass AuthorizationRequest:\n    \"\"\"Represent an Authorization Request.\n\n    This class makes it easy to generate valid Authorization Request URI (possibly including a\n    state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization\n    Response.\n\n    All parameters passed at init time will be included in the request query parameters as-is,\n    excepted for a few parameters which have a special behaviour:\n\n    - `state`: if `...` (default), a random `state` parameter will be generated for you.\n      You may pass your own `state` as `str`, or set it to `None` so that the `state` parameter\n      will not be included in the request. You may access that state in the `state` attribute\n      from this request.\n    - `nonce`: if `...` (default) and `scope` includes 'openid', a random `nonce` will be\n      generated and included in the request. You may access that `nonce` in the `nonce` attribute\n      from this request.\n    - `code_verifier`: if `None`, and `code_challenge_method` is `'S256'` or `'plain'`,\n      a valid `code_challenge` and `code_verifier` for PKCE will be automatically generated,\n      and the `code_challenge` will be included in the request.\n      You may pass your own `code_verifier` as a `str` parameter, in which case the\n      appropriate `code_challenge` will be included in the request, according to the\n      `code_challenge_method`.\n    - `authorization_response_iss_parameter_supported` and `issuer`:\n       those are used for Server Issuer Identification. By default:\n\n        - If `\u00ecssuer` is set and an issuer is included in the Authorization Response,\n        then the consistency between those 2 values will be checked when using `validate_callback()`.\n        - If issuer is not included in the response, then no issuer check is performed.\n\n        Set `authorization_response_iss_parameter_supported` to `True` to enforce server identification:\n\n        - an `issuer` must also be provided as parameter, and the AS must return that same value\n        for the response to be considered valid by `validate_callback()`.\n        - if no issuer is included in the Authorization Response, then an error will be raised.\n\n    Args:\n        authorization_endpoint: the uri for the authorization endpoint.\n        client_id: the client_id to include in the request.\n        redirect_uri: the redirect_uri to include in the request. This is required in OAuth 2.0 and optional\n            in OAuth 2.1. Pass `None` if you don't need any redirect_uri in the Authorization\n            Request.\n        scope: the scope to include in the request, as an iterable of `str`, or a single space-separated `str`.\n        response_type: the response type to include in the request.\n        state: the state to include in the request, or `...` to autogenerate one (default).\n        nonce: the nonce to include in the request, or `...` to autogenerate one (default).\n        code_verifier: the code verifier to include in the request.\n            If left as `None` and `code_challenge_method` is set, a valid code_verifier\n            will be generated.\n        code_challenge_method: the method to use to derive the `code_challenge` from the `code_verifier`.\n        acr_values: requested Authentication Context Class Reference values.\n        issuer: Issuer Identifier value from the OAuth/OIDC Server, if using Server Issuer Identification.\n        **kwargs: extra parameters to include in the request, as-is.\n\n    Example:\n        ```python\n        from requests_oauth2client import AuthorizationRequest\n\n        azr = AuthorizationRequest(\n            authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n            client_id=\"my_client_id\",\n            redirect_uri=\"http://localhost/callback\",\n            scope=\"openid email profile\",\n        )\n        print(azr)\n        ```\n\n    Raises:\n        InvalidMaxAgeParam: if the `max_age` parameter is invalid.\n        MissingIssuerParam: if `authorization_response_iss_parameter_supported` is set to `True`\n            but the `issuer` parameter is not provided.\n        UnsupportedResponseTypeParam: if `response_type` is not supported.\n\n    \"\"\"\n\n    authorization_endpoint: str\n\n    client_id: str = field(metadata={\"query\": True})\n    redirect_uri: str | None = field(metadata={\"query\": True}, default=None)\n    scope: tuple[str, ...] | None = field(metadata={\"query\": True}, default=(\"openid\",))\n    response_type: str = field(metadata={\"query\": True}, default=ResponseTypes.CODE)\n    state: str | None = field(metadata={\"query\": True}, default=None)\n    nonce: str | None = field(metadata={\"query\": True}, default=None)\n    code_challenge_method: str | None = field(metadata={\"query\": True}, default=CodeChallengeMethods.S256)\n    acr_values: tuple[str, ...] | None = field(metadata={\"query\": True}, default=None)\n    max_age: int | None = field(metadata={\"query\": True}, default=None)\n    kwargs: dict[str, Any] = Factory(dict)\n\n    code_verifier: str | None = None\n    code_challenge: str | None = field(init=False, metadata={\"query\": True})\n    authorization_response_iss_parameter_supported: bool = False\n    issuer: str | None = None\n\n    exception_classes: ClassVar[dict[str, type[AuthorizationResponseError]]] = {\n        \"interaction_required\": InteractionRequired,\n        \"login_required\": LoginRequired,\n        \"session_selection_required\": SessionSelectionRequired,\n        \"consent_required\": ConsentRequired,\n    }\n\n    @classmethod\n    def generate_state(cls) -&gt; str:\n        \"\"\"Generate a random `state` parameter.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    @classmethod\n    def generate_nonce(cls) -&gt; str:\n        \"\"\"Generate a random `nonce`.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    def __init__(  # noqa: PLR0913, C901\n        self,\n        authorization_endpoint: str,\n        *,\n        client_id: str,\n        redirect_uri: str | None = None,\n        scope: None | str | Iterable[str] = \"openid\",\n        response_type: str = ResponseTypes.CODE,\n        state: str | ellipsis | None = ...,  # noqa: F821\n        nonce: str | ellipsis | None = ...,  # noqa: F821\n        code_verifier: str | None = None,\n        code_challenge_method: str | None = CodeChallengeMethods.S256,\n        acr_values: str | Iterable[str] | None = None,\n        max_age: int | None = None,\n        issuer: str | None = None,\n        authorization_response_iss_parameter_supported: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        if response_type != ResponseTypes.CODE:\n            raise UnsupportedResponseTypeParam(response_type)\n\n        if authorization_response_iss_parameter_supported and not issuer:\n            raise MissingIssuerParam\n\n        if state is ...:\n            state = self.generate_state()\n        if state is not None and not isinstance(state, str):\n            state = str(state)  # pragma: no cover\n\n        if nonce is ...:\n            nonce = self.generate_nonce() if scope is not None and \"openid\" in scope else None\n        if nonce is not None and not isinstance(nonce, str):\n            nonce = str(nonce)  # pragma: no cover\n\n        if not scope:\n            scope = None\n\n        if scope is not None:\n            scope = tuple(scope.split(\" \")) if isinstance(scope, str) else tuple(scope)\n\n        if acr_values is not None:\n            acr_values = tuple(acr_values.split()) if isinstance(acr_values, str) else tuple(acr_values)\n\n        if max_age is not None and max_age &lt; 0:\n            raise InvalidMaxAgeParam\n\n        if \"code_challenge\" in kwargs:\n            msg = (\n                \"A `code_challenge` must not be passed as parameter. Pass the `code_verifier`\"\n                \" instead, and the appropriate `code_challenge` will automatically be derived\"\n                \" from it and included in the request, based on `code_challenge_method`.\"\n            )\n            raise ValueError(msg)\n\n        code_challenge: str | None = None\n        if code_challenge_method:\n            if not code_verifier:\n                code_verifier = PkceUtils.generate_code_verifier()\n            code_challenge = PkceUtils.derive_challenge(code_verifier, code_challenge_method)\n        else:\n            code_verifier = None\n\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            redirect_uri=redirect_uri,\n            issuer=issuer,\n            response_type=response_type,\n            scope=scope,\n            state=state,\n            nonce=nonce,\n            code_verifier=code_verifier,\n            code_challenge_method=code_challenge_method,\n            acr_values=acr_values,\n            max_age=max_age,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            kwargs=kwargs,\n        )\n        object.__setattr__(self, \"code_challenge\", code_challenge)\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the full argument dict.\n\n        This can be used to serialize this request and/or to initialize a similar request.\n\n        \"\"\"\n        d = asdict(self)\n        d.update(**d.pop(\"kwargs\", {}))\n        d.pop(\"code_challenge\")\n        return d\n\n    @property\n    def args(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dict with all the query parameters from this AuthorizationRequest.\n\n        Returns:\n            a dict of parameters\n\n        \"\"\"\n        d = {field.name: getattr(self, field.name) for field in fields(type(self)) if field.metadata.get(\"query\")}\n        if d[\"scope\"]:\n            d[\"scope\"] = \" \".join(d[\"scope\"])\n        d.update(self.kwargs)\n\n        return {key: val for key, val in d.items() if val is not None}\n\n    def validate_callback(self, response: str) -&gt; AuthorizationResponse:\n        \"\"\"Validate an Authorization Response against this Request.\n\n        Validate a given Authorization Response URI against this Authorization Request, and return\n        an\n        [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse].\n\n        This includes matching the `state` parameter, checking for returned errors, and extracting\n        the returned `code` and other parameters.\n\n        Args:\n            response: the Authorization Response URI. This can be the full URL, or just the\n                query parameters (still encoded as x-www-form-urlencoded).\n\n        Returns:\n            the extracted code, if all checks are successful\n\n        Raises:\n            MissingAuthCode: if the `code` is missing in the response\n            MissingIssuer: if Server Issuer verification is active and the response does\n                not contain an `iss`.\n            MismatchingIssuer: if the 'iss' received from the response does not match the\n                expected value.\n            MismatchingState: if the response `state` does not match the expected value.\n            OAuth2Error: if the response includes an error.\n            MissingAuthCode: if the response does not contain a `code`.\n            UnsupportedResponseTypeParam: if response_type anything else than 'code'.\n\n        \"\"\"\n        try:\n            response_url = furl(response)\n        except ValueError:\n            return self.on_response_error(response)\n\n        # validate 'iss' according to RFC9207\n        received_issuer = response_url.args.get(\"iss\")\n        if self.authorization_response_iss_parameter_supported or received_issuer:\n            if received_issuer is None:\n                raise MissingIssuer(self, response)\n            if self.issuer and received_issuer != self.issuer:\n                raise MismatchingIssuer(self.issuer, received_issuer, self, response)\n\n        # validate state\n        requested_state = self.state\n        if requested_state:\n            received_state = response_url.args.get(\"state\")\n            if requested_state != received_state:\n                raise MismatchingState(requested_state, received_state, self, response)\n\n        error = response_url.args.get(\"error\")\n        if error:\n            return self.on_response_error(response)\n\n        if self.response_type == ResponseTypes.CODE:\n            code: str = response_url.args.get(\"code\")\n            if code is None:\n                raise MissingAuthCode(self, response)\n        else:\n            raise UnsupportedResponseTypeParam(self.response_type)  # pragma: no cover\n\n        return AuthorizationResponse(\n            code_verifier=self.code_verifier,\n            redirect_uri=self.redirect_uri,\n            nonce=self.nonce,\n            acr_values=self.acr_values,\n            max_age=self.max_age,\n            **response_url.args,\n        )\n\n    def sign_request_jwt(\n        self,\n        jwk: Jwk | dict[str, Any],\n        alg: str | None = None,\n        lifetime: int | None = None,\n    ) -&gt; SignedJwt:\n        \"\"\"Sign the `request` object that matches this Authorization Request parameters.\n\n        Args:\n            jwk: the JWK to use to sign the request\n            alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n            lifetime: an optional number of seconds of validity for the signed request.\n                If present, `iat` an `exp` claims will be included in the signed JWT.\n\n        Returns:\n            a `Jwt` that contains the signed request object.\n\n        \"\"\"\n        claims = self.args\n        if lifetime:\n            claims[\"iat\"] = Jwt.timestamp()\n            claims[\"exp\"] = Jwt.timestamp(lifetime)\n        return Jwt.sign(\n            claims,\n            key=jwk,\n            alg=alg,\n        )\n\n    def sign(\n        self,\n        jwk: Jwk | dict[str, Any],\n        alg: str | None = None,\n        lifetime: int | None = None,\n        **kwargs: Any,\n    ) -&gt; RequestParameterAuthorizationRequest:\n        \"\"\"Sign this Authorization Request and return a new one.\n\n        This replaces all parameters with a signed `request` JWT.\n\n        Args:\n            jwk: the JWK to use to sign the request\n            alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, don't use an 'exp' claim.\n            kwargs: additional query parameters to include in the signed authorization request\n\n        Returns:\n            the signed Authorization Request\n\n        \"\"\"\n        request_jwt = self.sign_request_jwt(jwk, alg, lifetime)\n        return RequestParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request=str(request_jwt),\n            expires_at=request_jwt.expires_at,\n            **kwargs,\n        )\n\n    def sign_and_encrypt_request_jwt(\n        self,\n        sign_jwk: Jwk | dict[str, Any],\n        enc_jwk: Jwk | dict[str, Any],\n        sign_alg: str | None = None,\n        enc_alg: str | None = None,\n        enc: str = \"A128CBC-HS256\",\n        lifetime: int | None = None,\n    ) -&gt; JweCompact:\n        \"\"\"Sign and encrypt a `request` object for this Authorization Request.\n\n        The signed `request` will contain the same parameters as this AuthorizationRequest.\n\n        Args:\n            sign_jwk: the JWK to use to sign the request\n            enc_jwk: the JWK to use to encrypt the request\n            sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n            enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n            enc: the encoding to use to encrypt the request.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, do not include an 'exp' claim.\n\n        Returns:\n            the signed and encrypted request object, as a `jwskate.Jwt`\n\n        \"\"\"\n        claims = self.args\n        if lifetime:\n            claims[\"iat\"] = Jwt.timestamp()\n            claims[\"exp\"] = Jwt.timestamp(lifetime)\n        return Jwt.sign_and_encrypt(\n            claims=claims,\n            sign_key=sign_jwk,\n            sign_alg=sign_alg,\n            enc_key=enc_jwk,\n            enc_alg=enc_alg,\n            enc=enc,\n        )\n\n    def sign_and_encrypt(\n        self,\n        sign_jwk: Jwk | dict[str, Any],\n        enc_jwk: Jwk | dict[str, Any],\n        sign_alg: str | None = None,\n        enc_alg: str | None = None,\n        enc: str = \"A128CBC-HS256\",\n        lifetime: int | None = None,\n    ) -&gt; RequestParameterAuthorizationRequest:\n        \"\"\"Sign and encrypt the current Authorization Request.\n\n        This replaces all parameters with a matching `request` object.\n\n        Args:\n            sign_jwk: the JWK to use to sign the request\n            enc_jwk: the JWK to use to encrypt the request\n            sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n            enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n            enc: the encoding to use to encrypt the request.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, do not include an 'exp' claim.\n\n        Returns:\n            a `RequestParameterAuthorizationRequest`, with a request object as parameter\n\n        \"\"\"\n        request_jwt = self.sign_and_encrypt_request_jwt(\n            sign_jwk=sign_jwk,\n            enc_jwk=enc_jwk,\n            sign_alg=sign_alg,\n            enc_alg=enc_alg,\n            enc=enc,\n            lifetime=lifetime,\n        )\n        return RequestParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request=str(request_jwt),\n        )\n\n    def on_response_error(self, response: str) -&gt; AuthorizationResponse:\n        \"\"\"Error handler for Authorization Response errors.\n\n        Triggered by\n        [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback]\n        if the response uri contains an error.\n\n        Args:\n            response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n        Returns:\n            may return a default code that will be returned by `validate_callback`. But this method\n            will most likely raise exceptions instead.\n\n        Raises:\n            AuthorizationResponseError: if the response contains an `error`. The raised exception may be a subclass\n\n        \"\"\"\n        response_url = furl(response)\n        error = response_url.args.get(\"error\")\n        error_description = response_url.args.get(\"error_description\")\n        error_uri = response_url.args.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, AuthorizationResponseError)\n        raise exception_class(\n            request=self, response=response, error=error, description=error_description, uri=error_uri\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl`.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args=self.args,\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.args","title":"<code>args: dict[str, Any]</code>  <code>property</code>","text":"<p>Return a dict with all the query parameters from this AuthorizationRequest.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>a dict of parameters</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.furl","title":"<code>furl: furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.uri","title":"<code>uri: str</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.generate_state","title":"<code>generate_state()</code>  <code>classmethod</code>","text":"<p>Generate a random <code>state</code> parameter.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_state(cls) -&gt; str:\n    \"\"\"Generate a random `state` parameter.\"\"\"\n    return secrets.token_urlsafe(32)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.generate_nonce","title":"<code>generate_nonce()</code>  <code>classmethod</code>","text":"<p>Generate a random <code>nonce</code>.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_nonce(cls) -&gt; str:\n    \"\"\"Generate a random `nonce`.\"\"\"\n    return secrets.token_urlsafe(32)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the full argument dict.</p> <p>This can be used to serialize this request and/or to initialize a similar request.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the full argument dict.\n\n    This can be used to serialize this request and/or to initialize a similar request.\n\n    \"\"\"\n    d = asdict(self)\n    d.update(**d.pop(\"kwargs\", {}))\n    d.pop(\"code_challenge\")\n    return d\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback","title":"<code>validate_callback(response)</code>","text":"<p>Validate an Authorization Response against this Request.</p> <p>Validate a given Authorization Response URI against this Authorization Request, and return an AuthorizationResponse.</p> <p>This includes matching the <code>state</code> parameter, checking for returned errors, and extracting the returned <code>code</code> and other parameters.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>the Authorization Response URI. This can be the full URL, or just the query parameters (still encoded as x-www-form-urlencoded).</p> required <p>Returns:</p> Type Description <code>AuthorizationResponse</code> <p>the extracted code, if all checks are successful</p> <p>Raises:</p> Type Description <code>MissingAuthCode</code> <p>if the <code>code</code> is missing in the response</p> <code>MissingIssuer</code> <p>if Server Issuer verification is active and the response does not contain an <code>iss</code>.</p> <code>MismatchingIssuer</code> <p>if the 'iss' received from the response does not match the expected value.</p> <code>MismatchingState</code> <p>if the response <code>state</code> does not match the expected value.</p> <code>OAuth2Error</code> <p>if the response includes an error.</p> <code>MissingAuthCode</code> <p>if the response does not contain a <code>code</code>.</p> <code>UnsupportedResponseTypeParam</code> <p>if response_type anything else than 'code'.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def validate_callback(self, response: str) -&gt; AuthorizationResponse:\n    \"\"\"Validate an Authorization Response against this Request.\n\n    Validate a given Authorization Response URI against this Authorization Request, and return\n    an\n    [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse].\n\n    This includes matching the `state` parameter, checking for returned errors, and extracting\n    the returned `code` and other parameters.\n\n    Args:\n        response: the Authorization Response URI. This can be the full URL, or just the\n            query parameters (still encoded as x-www-form-urlencoded).\n\n    Returns:\n        the extracted code, if all checks are successful\n\n    Raises:\n        MissingAuthCode: if the `code` is missing in the response\n        MissingIssuer: if Server Issuer verification is active and the response does\n            not contain an `iss`.\n        MismatchingIssuer: if the 'iss' received from the response does not match the\n            expected value.\n        MismatchingState: if the response `state` does not match the expected value.\n        OAuth2Error: if the response includes an error.\n        MissingAuthCode: if the response does not contain a `code`.\n        UnsupportedResponseTypeParam: if response_type anything else than 'code'.\n\n    \"\"\"\n    try:\n        response_url = furl(response)\n    except ValueError:\n        return self.on_response_error(response)\n\n    # validate 'iss' according to RFC9207\n    received_issuer = response_url.args.get(\"iss\")\n    if self.authorization_response_iss_parameter_supported or received_issuer:\n        if received_issuer is None:\n            raise MissingIssuer(self, response)\n        if self.issuer and received_issuer != self.issuer:\n            raise MismatchingIssuer(self.issuer, received_issuer, self, response)\n\n    # validate state\n    requested_state = self.state\n    if requested_state:\n        received_state = response_url.args.get(\"state\")\n        if requested_state != received_state:\n            raise MismatchingState(requested_state, received_state, self, response)\n\n    error = response_url.args.get(\"error\")\n    if error:\n        return self.on_response_error(response)\n\n    if self.response_type == ResponseTypes.CODE:\n        code: str = response_url.args.get(\"code\")\n        if code is None:\n            raise MissingAuthCode(self, response)\n    else:\n        raise UnsupportedResponseTypeParam(self.response_type)  # pragma: no cover\n\n    return AuthorizationResponse(\n        code_verifier=self.code_verifier,\n        redirect_uri=self.redirect_uri,\n        nonce=self.nonce,\n        acr_values=self.acr_values,\n        max_age=self.max_age,\n        **response_url.args,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign_request_jwt","title":"<code>sign_request_jwt(jwk, alg=None, lifetime=None)</code>","text":"<p>Sign the <code>request</code> object that matches this Authorization Request parameters.</p> <p>Parameters:</p> Name Type Description Default <code>jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>lifetime</code> <code>int | None</code> <p>an optional number of seconds of validity for the signed request. If present, <code>iat</code> an <code>exp</code> claims will be included in the signed JWT.</p> <code>None</code> <p>Returns:</p> Type Description <code>SignedJwt</code> <p>a <code>Jwt</code> that contains the signed request object.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_request_jwt(\n    self,\n    jwk: Jwk | dict[str, Any],\n    alg: str | None = None,\n    lifetime: int | None = None,\n) -&gt; SignedJwt:\n    \"\"\"Sign the `request` object that matches this Authorization Request parameters.\n\n    Args:\n        jwk: the JWK to use to sign the request\n        alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n        lifetime: an optional number of seconds of validity for the signed request.\n            If present, `iat` an `exp` claims will be included in the signed JWT.\n\n    Returns:\n        a `Jwt` that contains the signed request object.\n\n    \"\"\"\n    claims = self.args\n    if lifetime:\n        claims[\"iat\"] = Jwt.timestamp()\n        claims[\"exp\"] = Jwt.timestamp(lifetime)\n    return Jwt.sign(\n        claims,\n        key=jwk,\n        alg=alg,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign","title":"<code>sign(jwk, alg=None, lifetime=None, **kwargs)</code>","text":"<p>Sign this Authorization Request and return a new one.</p> <p>This replaces all parameters with a signed <code>request</code> JWT.</p> <p>Parameters:</p> Name Type Description Default <code>jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, don't use an 'exp' claim.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>additional query parameters to include in the signed authorization request</p> <code>{}</code> <p>Returns:</p> Type Description <code>RequestParameterAuthorizationRequest</code> <p>the signed Authorization Request</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign(\n    self,\n    jwk: Jwk | dict[str, Any],\n    alg: str | None = None,\n    lifetime: int | None = None,\n    **kwargs: Any,\n) -&gt; RequestParameterAuthorizationRequest:\n    \"\"\"Sign this Authorization Request and return a new one.\n\n    This replaces all parameters with a signed `request` JWT.\n\n    Args:\n        jwk: the JWK to use to sign the request\n        alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, don't use an 'exp' claim.\n        kwargs: additional query parameters to include in the signed authorization request\n\n    Returns:\n        the signed Authorization Request\n\n    \"\"\"\n    request_jwt = self.sign_request_jwt(jwk, alg, lifetime)\n    return RequestParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request=str(request_jwt),\n        expires_at=request_jwt.expires_at,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign_and_encrypt_request_jwt","title":"<code>sign_and_encrypt_request_jwt(sign_jwk, enc_jwk, sign_alg=None, enc_alg=None, enc='A128CBC-HS256', lifetime=None)</code>","text":"<p>Sign and encrypt a <code>request</code> object for this Authorization Request.</p> <p>The signed <code>request</code> will contain the same parameters as this AuthorizationRequest.</p> <p>Parameters:</p> Name Type Description Default <code>sign_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>enc_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to encrypt the request</p> required <code>sign_alg</code> <code>str | None</code> <p>the alg to use to sign the request, if <code>sign_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc_alg</code> <code>str | None</code> <p>the alg to use to encrypt the request, if <code>enc_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc</code> <code>str</code> <p>the encoding to use to encrypt the request.</p> <code>'A128CBC-HS256'</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.</p> <code>None</code> <p>Returns:</p> Type Description <code>JweCompact</code> <p>the signed and encrypted request object, as a <code>jwskate.Jwt</code></p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_and_encrypt_request_jwt(\n    self,\n    sign_jwk: Jwk | dict[str, Any],\n    enc_jwk: Jwk | dict[str, Any],\n    sign_alg: str | None = None,\n    enc_alg: str | None = None,\n    enc: str = \"A128CBC-HS256\",\n    lifetime: int | None = None,\n) -&gt; JweCompact:\n    \"\"\"Sign and encrypt a `request` object for this Authorization Request.\n\n    The signed `request` will contain the same parameters as this AuthorizationRequest.\n\n    Args:\n        sign_jwk: the JWK to use to sign the request\n        enc_jwk: the JWK to use to encrypt the request\n        sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n        enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n        enc: the encoding to use to encrypt the request.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, do not include an 'exp' claim.\n\n    Returns:\n        the signed and encrypted request object, as a `jwskate.Jwt`\n\n    \"\"\"\n    claims = self.args\n    if lifetime:\n        claims[\"iat\"] = Jwt.timestamp()\n        claims[\"exp\"] = Jwt.timestamp(lifetime)\n    return Jwt.sign_and_encrypt(\n        claims=claims,\n        sign_key=sign_jwk,\n        sign_alg=sign_alg,\n        enc_key=enc_jwk,\n        enc_alg=enc_alg,\n        enc=enc,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign_and_encrypt","title":"<code>sign_and_encrypt(sign_jwk, enc_jwk, sign_alg=None, enc_alg=None, enc='A128CBC-HS256', lifetime=None)</code>","text":"<p>Sign and encrypt the current Authorization Request.</p> <p>This replaces all parameters with a matching <code>request</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>sign_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>enc_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to encrypt the request</p> required <code>sign_alg</code> <code>str | None</code> <p>the alg to use to sign the request, if <code>sign_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc_alg</code> <code>str | None</code> <p>the alg to use to encrypt the request, if <code>enc_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc</code> <code>str</code> <p>the encoding to use to encrypt the request.</p> <code>'A128CBC-HS256'</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.</p> <code>None</code> <p>Returns:</p> Type Description <code>RequestParameterAuthorizationRequest</code> <p>a <code>RequestParameterAuthorizationRequest</code>, with a request object as parameter</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_and_encrypt(\n    self,\n    sign_jwk: Jwk | dict[str, Any],\n    enc_jwk: Jwk | dict[str, Any],\n    sign_alg: str | None = None,\n    enc_alg: str | None = None,\n    enc: str = \"A128CBC-HS256\",\n    lifetime: int | None = None,\n) -&gt; RequestParameterAuthorizationRequest:\n    \"\"\"Sign and encrypt the current Authorization Request.\n\n    This replaces all parameters with a matching `request` object.\n\n    Args:\n        sign_jwk: the JWK to use to sign the request\n        enc_jwk: the JWK to use to encrypt the request\n        sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n        enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n        enc: the encoding to use to encrypt the request.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, do not include an 'exp' claim.\n\n    Returns:\n        a `RequestParameterAuthorizationRequest`, with a request object as parameter\n\n    \"\"\"\n    request_jwt = self.sign_and_encrypt_request_jwt(\n        sign_jwk=sign_jwk,\n        enc_jwk=enc_jwk,\n        sign_alg=sign_alg,\n        enc_alg=enc_alg,\n        enc=enc,\n        lifetime=lifetime,\n    )\n    return RequestParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request=str(request_jwt),\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.on_response_error","title":"<code>on_response_error(response)</code>","text":"<p>Error handler for Authorization Response errors.</p> <p>Triggered by validate_callback() if the response uri contains an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>the Authorization Response URI. This can be the full URL, or just the query parameters.</p> required <p>Returns:</p> Type Description <code>AuthorizationResponse</code> <p>may return a default code that will be returned by <code>validate_callback</code>. But this method</p> <code>AuthorizationResponse</code> <p>will most likely raise exceptions instead.</p> <p>Raises:</p> Type Description <code>AuthorizationResponseError</code> <p>if the response contains an <code>error</code>. The raised exception may be a subclass</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def on_response_error(self, response: str) -&gt; AuthorizationResponse:\n    \"\"\"Error handler for Authorization Response errors.\n\n    Triggered by\n    [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback]\n    if the response uri contains an error.\n\n    Args:\n        response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n    Returns:\n        may return a default code that will be returned by `validate_callback`. But this method\n        will most likely raise exceptions instead.\n\n    Raises:\n        AuthorizationResponseError: if the response contains an `error`. The raised exception may be a subclass\n\n    \"\"\"\n    response_url = furl(response)\n    error = response_url.args.get(\"error\")\n    error_description = response_url.args.get(\"error_description\")\n    error_uri = response_url.args.get(\"error_uri\")\n    exception_class = self.exception_classes.get(error, AuthorizationResponseError)\n    raise exception_class(\n        request=self, response=response, error=error, description=error_description, uri=error_uri\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.RequestParameterAuthorizationRequest","title":"<code>RequestParameterAuthorizationRequest</code>","text":"<p>Represent an Authorization Request that includes a <code>request</code> JWT.</p> <p>To construct such a request yourself, the easiest way is to initialize an <code>AuthorizationRequest</code> then sign it with <code>AuthorizationRequest.sign()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the Authorization Endpoint uri</p> required <code>client_id</code> <code>str</code> <p>the client_id</p> required <code>request</code> <code>Jwt | str</code> <p>the request JWT</p> required <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for this request</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>extra parameters to include in the request</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False, repr=False)\nclass RequestParameterAuthorizationRequest:\n    \"\"\"Represent an Authorization Request that includes a `request` JWT.\n\n    To construct such a request yourself, the easiest way is to initialize\n    an [`AuthorizationRequest`][requests_oauth2client.authorization_request.AuthorizationRequest]\n    then sign it with\n    [`AuthorizationRequest.sign()`][requests_oauth2client.authorization_request.AuthorizationRequest.sign].\n\n    Args:\n        authorization_endpoint: the Authorization Endpoint uri\n        client_id: the client_id\n        request: the request JWT\n        expires_at: the expiration date for this request\n        kwargs: extra parameters to include in the request\n\n    \"\"\"\n\n    authorization_endpoint: str\n    client_id: str\n    request: Jwt\n    expires_at: datetime | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        authorization_endpoint: str,\n        client_id: str,\n        request: Jwt | str,\n        expires_at: datetime | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        if isinstance(request, str):\n            request = Jwt(request)\n\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            request=request,\n            expires_at=expires_at,\n            kwargs=kwargs,\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl` instance.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args={\"client_id\": self.client_id, \"request\": str(self.request), **self.kwargs},\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\n\n        Returns:\n             the Authorization Request URI\n\n        \"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.RequestParameterAuthorizationRequest.furl","title":"<code>furl: furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code> instance.</p>"},{"location":"api/#requests_oauth2client.authorization_request.RequestParameterAuthorizationRequest.uri","title":"<code>uri: str</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest","title":"<code>RequestUriParameterAuthorizationRequest</code>","text":"<p>Represent an Authorization Request that includes a <code>request_uri</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the Authorization Endpoint uri</p> required <code>client_id</code> <code>str</code> <p>the client_id</p> required <code>request_uri</code> <code>str</code> <p>the request_uri</p> required <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for this request</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>extra parameters to include in the request</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass RequestUriParameterAuthorizationRequest:\n    \"\"\"Represent an Authorization Request that includes a `request_uri` parameter.\n\n    Args:\n        authorization_endpoint: the Authorization Endpoint uri\n        client_id: the client_id\n        request_uri: the request_uri\n        expires_at: the expiration date for this request\n        kwargs: extra parameters to include in the request\n\n    \"\"\"\n\n    authorization_endpoint: str\n    client_id: str\n    request_uri: str\n    expires_at: datetime | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        authorization_endpoint: str,\n        client_id: str,\n        request_uri: str,\n        expires_at: datetime | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            request_uri=request_uri,\n            expires_at=expires_at,\n            kwargs=kwargs,\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl` instance.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args={\"client_id\": self.client_id, \"request_uri\": self.request_uri, **self.kwargs},\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest.furl","title":"<code>furl: furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code> instance.</p>"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest.uri","title":"<code>uri: str</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer","title":"<code>AuthorizationRequestSerializer</code>","text":"<p>(De)Serializer for <code>AuthorizationRequest</code> instances.</p> <p>You might need to store pending authorization requests in session, either server-side or client- side. This class is here to help you do that.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class AuthorizationRequestSerializer:\n    \"\"\"(De)Serializer for `AuthorizationRequest` instances.\n\n    You might need to store pending authorization requests in session, either server-side or client-\n    side. This class is here to help you do that.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        dumper: Callable[[AuthorizationRequest], str] | None = None,\n        loader: Callable[[str], AuthorizationRequest] | None = None,\n    ) -&gt; None:\n        self.dumper = dumper or self.default_dumper\n        self.loader = loader or self.default_loader\n\n    @staticmethod\n    def default_dumper(azr: AuthorizationRequest) -&gt; str:\n        \"\"\"Provide a default dumper implementation.\n\n        Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as\n        base64url.\n\n        Args:\n            azr: the `AuthorizationRequest` to serialize\n\n        Returns:\n            the serialized value\n\n        \"\"\"\n        d = asdict(azr)\n        d.update(**d.pop(\"kwargs\", {}))\n        d.pop(\"code_challenge\")\n        return BinaPy.serialize_to(\"json\", d).to(\"deflate\").to(\"b64u\").ascii()\n\n    @staticmethod\n    def default_loader(\n        serialized: str,\n        azr_class: type[AuthorizationRequest] = AuthorizationRequest,\n    ) -&gt; AuthorizationRequest:\n        \"\"\"Provide a default deserializer implementation.\n\n        This does the opposite operations than `default_dumper`.\n\n        Args:\n            serialized: the serialized AuthorizationRequest\n            azr_class: the class to deserialize the Authorization Request to\n\n        Returns:\n            an AuthorizationRequest\n\n        \"\"\"\n        args = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n        return azr_class(**args)\n\n    def dumps(self, azr: AuthorizationRequest) -&gt; str:\n        \"\"\"Serialize and compress a given AuthorizationRequest for easier storage.\n\n        Args:\n            azr: an AuthorizationRequest to serialize\n\n        Returns:\n            the serialized AuthorizationRequest, as a str\n\n        \"\"\"\n        return self.dumper(azr)\n\n    def loads(self, serialized: str) -&gt; AuthorizationRequest:\n        \"\"\"Deserialize a serialized AuthorizationRequest.\n\n        Args:\n            serialized: the serialized AuthorizationRequest\n\n        Returns:\n            the deserialized AuthorizationRequest\n\n        \"\"\"\n        return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.default_dumper","title":"<code>default_dumper(azr)</code>  <code>staticmethod</code>","text":"<p>Provide a default dumper implementation.</p> <p>Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as base64url.</p> <p>Parameters:</p> Name Type Description Default <code>azr</code> <code>AuthorizationRequest</code> <p>the <code>AuthorizationRequest</code> to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized value</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@staticmethod\ndef default_dumper(azr: AuthorizationRequest) -&gt; str:\n    \"\"\"Provide a default dumper implementation.\n\n    Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as\n    base64url.\n\n    Args:\n        azr: the `AuthorizationRequest` to serialize\n\n    Returns:\n        the serialized value\n\n    \"\"\"\n    d = asdict(azr)\n    d.update(**d.pop(\"kwargs\", {}))\n    d.pop(\"code_challenge\")\n    return BinaPy.serialize_to(\"json\", d).to(\"deflate\").to(\"b64u\").ascii()\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.default_loader","title":"<code>default_loader(serialized, azr_class=AuthorizationRequest)</code>  <code>staticmethod</code>","text":"<p>Provide a default deserializer implementation.</p> <p>This does the opposite operations than <code>default_dumper</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized AuthorizationRequest</p> required <code>azr_class</code> <code>type[AuthorizationRequest]</code> <p>the class to deserialize the Authorization Request to</p> <code>AuthorizationRequest</code> <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>an AuthorizationRequest</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@staticmethod\ndef default_loader(\n    serialized: str,\n    azr_class: type[AuthorizationRequest] = AuthorizationRequest,\n) -&gt; AuthorizationRequest:\n    \"\"\"Provide a default deserializer implementation.\n\n    This does the opposite operations than `default_dumper`.\n\n    Args:\n        serialized: the serialized AuthorizationRequest\n        azr_class: the class to deserialize the Authorization Request to\n\n    Returns:\n        an AuthorizationRequest\n\n    \"\"\"\n    args = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n    return azr_class(**args)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.dumps","title":"<code>dumps(azr)</code>","text":"<p>Serialize and compress a given AuthorizationRequest for easier storage.</p> <p>Parameters:</p> Name Type Description Default <code>azr</code> <code>AuthorizationRequest</code> <p>an AuthorizationRequest to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized AuthorizationRequest, as a str</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def dumps(self, azr: AuthorizationRequest) -&gt; str:\n    \"\"\"Serialize and compress a given AuthorizationRequest for easier storage.\n\n    Args:\n        azr: an AuthorizationRequest to serialize\n\n    Returns:\n        the serialized AuthorizationRequest, as a str\n\n    \"\"\"\n    return self.dumper(azr)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.loads","title":"<code>loads(serialized)</code>","text":"<p>Deserialize a serialized AuthorizationRequest.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized AuthorizationRequest</p> required <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>the deserialized AuthorizationRequest</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def loads(self, serialized: str) -&gt; AuthorizationRequest:\n    \"\"\"Deserialize a serialized AuthorizationRequest.\n\n    Args:\n        serialized: the serialized AuthorizationRequest\n\n    Returns:\n        the deserialized AuthorizationRequest\n\n    \"\"\"\n    return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication","title":"<code>backchannel_authentication</code>","text":"<p>Implementation of CIBA.</p> <p>CIBA stands for Client Initiated BackChannel Authentication and is standardised by the OpenID Fundation. https://openid.net/specs/openid-client-initiated-backchannel- authentication-core-1_0.html.</p>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse","title":"<code>BackChannelAuthenticationResponse</code>","text":"<p>Represent a BackChannel Authentication Response.</p> <p>This contains all the parameters that are returned by the AS as a result of a BackChannel Authentication Request, such as <code>auth_req_id</code> (required), and the optional <code>expires_at</code>, <code>interval</code>, and/or any custom parameters.</p> <p>Parameters:</p> Name Type Description Default <code>auth_req_id</code> <code>str</code> <p>the <code>auth_req_id</code> as returned by the AS.</p> required <code>expires_at</code> <code>datetime | None</code> <p>the date when the <code>auth_req_id</code> expires. Note that this request also accepts an <code>expires_in</code> parameter, in seconds.</p> <code>None</code> <code>interval</code> <code>int | None</code> <p>the Token Endpoint pooling interval, in seconds, as returned by the AS.</p> <code>20</code> <code>**kwargs</code> <code>Any</code> <p>any additional custom parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>class BackChannelAuthenticationResponse:\n    \"\"\"Represent a BackChannel Authentication Response.\n\n    This contains all the parameters that are returned by the AS as a result of a BackChannel\n    Authentication Request, such as `auth_req_id` (required), and the optional `expires_at`,\n    `interval`, and/or any custom parameters.\n\n    Args:\n        auth_req_id: the `auth_req_id` as returned by the AS.\n        expires_at: the date when the `auth_req_id` expires.\n            Note that this request also accepts an `expires_in` parameter, in seconds.\n        interval: the Token Endpoint pooling interval, in seconds, as returned by the AS.\n        **kwargs: any additional custom parameters as returned by the AS.\n\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        auth_req_id: str,\n        expires_at: datetime | None = None,\n        interval: int | None = 20,\n        **kwargs: Any,\n    ) -&gt; None:\n        self.auth_req_id = auth_req_id\n        self.expires_at = expires_at\n        self.interval = interval\n        self.other = kwargs\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Return `True` if the `auth_req_id` within this response is expired.\n\n        Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is\n        derived from the `expires_in` hint returned by the AS BackChannel Authentication endpoint),\n        this will return `None`.\n\n        Returns:\n            `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is\n            no `expires_in` hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n\n    @property\n    def expires_in(self) -&gt; int | None:\n        \"\"\"Number of seconds until expiration.\"\"\"\n        if self.expires_at:\n            return ceil((self.expires_at - datetime.now(tz=timezone.utc)).total_seconds())\n        return None\n\n    def __getattr__(self, key: str) -&gt; Any:\n        \"\"\"Return attributes from this `BackChannelAuthenticationResponse`.\n\n        Allows accessing response parameters with `token_response.expires_in` or\n        `token_response.any_custom_attribute`.\n\n        Args:\n            key: a key\n\n        Returns:\n            the associated value in this token response\n\n        Raises:\n            AttributeError: if the attribute is not present in the response\n\n        \"\"\"\n        return self.other.get(key) or super().__getattribute__(key)\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse.expires_in","title":"<code>expires_in: int | None</code>  <code>property</code>","text":"<p>Number of seconds until expiration.</p>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Return <code>True</code> if the <code>auth_req_id</code> within this response is expired.</p> <p>Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is derived from the <code>expires_in</code> hint returned by the AS BackChannel Authentication endpoint), this will return <code>None</code>.</p> <p>Returns:</p> Type Description <code>bool | None</code> <p><code>True</code> if the auth_req_id is expired, <code>False</code> if it is still valid, <code>None</code> if there is</p> <code>bool | None</code> <p>no <code>expires_in</code> hint.</p> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Return `True` if the `auth_req_id` within this response is expired.\n\n    Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is\n    derived from the `expires_in` hint returned by the AS BackChannel Authentication endpoint),\n    this will return `None`.\n\n    Returns:\n        `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is\n        no `expires_in` hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationPoolingJob","title":"<code>BackChannelAuthenticationPoolingJob</code>","text":"<p>               Bases: <code>BaseTokenEndpointPoolingJob</code></p> <p>A pooling job for the BackChannel Authentication flow.</p> <p>This will poll the Token Endpoint until the user finishes with its authentication.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client that will be used to pool the token endpoint.</p> required <code>auth_req_id</code> <code>str | BackChannelAuthenticationResponse</code> <p>an <code>auth_req_id</code> as <code>str</code> or a <code>BackChannelAuthenticationResponse</code>.</p> required <code>interval</code> <code>int | None</code> <p>The pooling interval, in seconds, to use. This overrides the one in <code>auth_req_id</code> if it is a <code>BackChannelAuthenticationResponse</code>. Defaults to 5 seconds.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>Number of seconds to add to the pooling interval when the AS returns a slow down request.</p> <code>5</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the underlying calls to requests.request.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token request.</p> <code>{}</code> Example <pre><code>client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\npool_job = BackChannelAuthenticationPoolingJob(\n    client=client,\n    auth_req_id=\"my_auth_req_id\",\n)\n\ntoken = None\nwhile token is None:\n    token = pool_job()\n</code></pre> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>@define(init=False)\nclass BackChannelAuthenticationPoolingJob(BaseTokenEndpointPoolingJob):\n    \"\"\"A pooling job for the BackChannel Authentication flow.\n\n    This will poll the Token Endpoint until the user finishes with its authentication.\n\n    Args:\n        client: an OAuth2Client that will be used to pool the token endpoint.\n        auth_req_id: an `auth_req_id` as `str` or a `BackChannelAuthenticationResponse`.\n        interval: The pooling interval, in seconds, to use. This overrides\n            the one in `auth_req_id` if it is a `BackChannelAuthenticationResponse`.\n            Defaults to 5 seconds.\n        slow_down_interval: Number of seconds to add to the pooling interval when the AS returns\n            a slow down request.\n        requests_kwargs: Additional parameters for the underlying calls to [requests.request][].\n        **token_kwargs: Additional parameters for the token request.\n\n    Example:\n        ```python\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        pool_job = BackChannelAuthenticationPoolingJob(\n            client=client,\n            auth_req_id=\"my_auth_req_id\",\n        )\n\n        token = None\n        while token is None:\n            token = pool_job()\n        ```\n\n    \"\"\"\n\n    auth_req_id: str\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        auth_req_id: str | BackChannelAuthenticationResponse,\n        *,\n        interval: int | None = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n            interval = interval or auth_req_id.interval\n            auth_req_id = auth_req_id.auth_req_id\n\n        self.__attrs_init__(\n            client=client,\n            auth_req_id=auth_req_id,\n            interval=interval or 5,\n            slow_down_interval=slow_down_interval,\n            requests_kwargs=requests_kwargs or {},\n            token_kwargs=token_kwargs,\n        )\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Implement the CIBA token request.\n\n        This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        return self.client.ciba(self.auth_req_id, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Implement the CIBA token request.</p> <p>This actually calls [OAuth2Client.ciba(auth_req_id)] on <code>client</code>.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Implement the CIBA token request.\n\n    This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    return self.client.ciba(self.auth_req_id, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client","title":"<code>client</code>","text":"<p>This module contains the <code>OAuth2Client</code> class.</p>"},{"location":"api/#requests_oauth2client.client.InvalidParam","title":"<code>InvalidParam</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Base class for invalid parameters errors.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidParam(ValueError):\n    \"\"\"Base class for invalid parameters errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.client.MissingIdTokenEncryptedResponseAlgParam","title":"<code>MissingIdTokenEncryptedResponseAlgParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an ID Token encryption is required but not provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingIdTokenEncryptedResponseAlgParam(InvalidParam):\n    \"\"\"Raised when an ID Token encryption is required but not provided.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"\"\"\\\nAn ID Token decryption key has been provided but no decryption algorithm is defined.\nYou can either pass an `id_token_encrypted_response_alg` parameter with the alg identifier,\nor include an `alg` attribute in the decryption key, if it is in Jwk format.\n\"\"\")\n</code></pre>"},{"location":"api/#requests_oauth2client.client.InvalidEndpointUri","title":"<code>InvalidEndpointUri</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid endpoint uri is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidEndpointUri(InvalidParam):\n    \"\"\"Raised when an invalid endpoint uri is provided.\"\"\"\n\n    def __init__(self, endpoint: str, uri: str, exc: InvalidUri) -&gt; None:\n        super().__init__(f\"Invalid endpoint uri '{uri}' for '{endpoint}': {exc}\")\n        self.endpoint = endpoint\n        self.uri = uri\n</code></pre>"},{"location":"api/#requests_oauth2client.client.InvalidIssuer","title":"<code>InvalidIssuer</code>","text":"<p>               Bases: <code>InvalidEndpointUri</code></p> <p>Raised when an invalid issuer parameter is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidIssuer(InvalidEndpointUri):\n    \"\"\"Raised when an invalid issuer parameter is provided.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.client.InvalidScopeParam","title":"<code>InvalidScopeParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid scope parameter is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidScopeParam(InvalidParam):\n    \"\"\"Raised when an invalid scope parameter is provided.\"\"\"\n\n    def __init__(self, scope: object) -&gt; None:\n        super().__init__(\"\"\"\\\nUnsupported scope value. It must be one of:\n- a space separated `str` of scopes names\n- an iterable of scope names as `str`\n\"\"\")\n        self.scope = scope\n</code></pre>"},{"location":"api/#requests_oauth2client.client.MissingRefreshToken","title":"<code>MissingRefreshToken</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a refresh token is required but not present.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingRefreshToken(ValueError):\n    \"\"\"Raised when a refresh token is required but not present.\"\"\"\n\n    def __init__(self, token: TokenResponse) -&gt; None:\n        super().__init__(\"A refresh_token is required but is not present in this Access Token.\")\n        self.token = token\n</code></pre>"},{"location":"api/#requests_oauth2client.client.MissingDeviceCode","title":"<code>MissingDeviceCode</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a device_code is required but not provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingDeviceCode(ValueError):\n    \"\"\"Raised when a device_code is required but not provided.\"\"\"\n\n    def __init__(self, dar: DeviceAuthorizationResponse) -&gt; None:\n        super().__init__(\"A device_code is missing in this DeviceAuthorizationResponse\")\n        self.device_authorization_response = dar\n</code></pre>"},{"location":"api/#requests_oauth2client.client.MissingAuthRequestId","title":"<code>MissingAuthRequestId</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an 'auth_req_id' is missing in a BackChannelAuthenticationResponse.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingAuthRequestId(ValueError):\n    \"\"\"Raised when an 'auth_req_id' is missing in a BackChannelAuthenticationResponse.\"\"\"\n\n    def __init__(self, bcar: BackChannelAuthenticationResponse) -&gt; None:\n        super().__init__(\"An 'auth_req_id' is required but is missing from this BackChannelAuthenticationResponse.\")\n        self.backchannel_authentication_response = bcar\n</code></pre>"},{"location":"api/#requests_oauth2client.client.UnknownTokenType","title":"<code>UnknownTokenType</code>","text":"<p>               Bases: <code>InvalidParam</code>, <code>TypeError</code></p> <p>Raised when the type of a token cannot be determined automatically.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class UnknownTokenType(InvalidParam, TypeError):\n    \"\"\"Raised when the type of a token cannot be determined automatically.\"\"\"\n\n    def __init__(self, message: str, token: object, token_type: str | None) -&gt; None:\n        super().__init__(f\"Unable to determine the type of token provided: {message}\")\n        self.token = token\n        self.token_type = token_type\n</code></pre>"},{"location":"api/#requests_oauth2client.client.UnknownSubjectTokenType","title":"<code>UnknownSubjectTokenType</code>","text":"<p>               Bases: <code>UnknownTokenType</code></p> <p>Raised when the type of subject_token cannot be determined automatically.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class UnknownSubjectTokenType(UnknownTokenType):\n    \"\"\"Raised when the type of subject_token cannot be determined automatically.\"\"\"\n\n    def __init__(self, subject_token: object, subject_token_type: str | None) -&gt; None:\n        super().__init__(\"subject_token\", subject_token, subject_token_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.UnknownActorTokenType","title":"<code>UnknownActorTokenType</code>","text":"<p>               Bases: <code>UnknownTokenType</code></p> <p>Raised when the type of actor_token cannot be determined automatically.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class UnknownActorTokenType(UnknownTokenType):\n    \"\"\"Raised when the type of actor_token cannot be determined automatically.\"\"\"\n\n    def __init__(self, actor_token: object, actor_token_type: str | None) -&gt; None:\n        super().__init__(\"actor_token\", token=actor_token, token_type=actor_token_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.InvalidBackchannelAuthenticationRequestHintParam","title":"<code>InvalidBackchannelAuthenticationRequestHintParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid hint is provided in a backchannel authentication request.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidBackchannelAuthenticationRequestHintParam(InvalidParam):\n    \"\"\"Raised when an invalid hint is provided in a backchannel authentication request.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.client.InvalidAcrValuesParam","title":"<code>InvalidAcrValuesParam</code>","text":"<p>               Bases: <code>InvalidParam</code></p> <p>Raised when an invalid 'acr_values' parameter is provided.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidAcrValuesParam(InvalidParam):\n    \"\"\"Raised when an invalid 'acr_values' parameter is provided.\"\"\"\n\n    def __init__(self, acr_values: object) -&gt; None:\n        super().__init__(f\"Invalid 'acr_values' parameter: {acr_values}\")\n        self.acr_values = acr_values\n</code></pre>"},{"location":"api/#requests_oauth2client.client.InvalidDiscoveryDocument","title":"<code>InvalidDiscoveryDocument</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when handling an invalid Discovery Document.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class InvalidDiscoveryDocument(ValueError):\n    \"\"\"Raised when handling an invalid Discovery Document.\"\"\"\n\n    def __init__(self, message: str, discovery_document: dict[str, Any]) -&gt; None:\n        super().__init__(f\"Invalid discovery document: {message}\")\n        self.discovery_document = discovery_document\n</code></pre>"},{"location":"api/#requests_oauth2client.client.Endpoints","title":"<code>Endpoints</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>All standardised OAuth 2.0 and extensions endpoints.</p> <p>If an endpoint is not mentioned here, then its usage is not supported by OAuth2Client.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class Endpoints(str, Enum):\n    \"\"\"All standardised OAuth 2.0 and extensions endpoints.\n\n    If an endpoint is not mentioned here, then its usage is not supported by OAuth2Client.\n\n    \"\"\"\n\n    TOKEN = \"token_endpoint\"\n    AUTHORIZATION = \"authorization_endpoint\"\n    BACKCHANNEL_AUTHENTICATION = \"backchannel_authentication_endpoint\"\n    DEVICE_AUTHORIZATION = \"device_authorization_endpoint\"\n    INSTROSPECTION = \"introspection_endpoint\"\n    REVOCATION = \"revocation_endpoint\"\n    PUSHED_AUTHORIZATION_REQUEST = \"pushed_authorization_request_endpoint\"\n    JWKS = \"jwks_uri\"\n    USER_INFO = \"userinfo_endpoint\"\n</code></pre>"},{"location":"api/#requests_oauth2client.client.MissingEndpointUri","title":"<code>MissingEndpointUri</code>","text":"<p>               Bases: <code>AttributeError</code></p> <p>Raised when a required endpoint uri is not known.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class MissingEndpointUri(AttributeError):\n    \"\"\"Raised when a required endpoint uri is not known.\"\"\"\n\n    def __init__(self, endpoint: str) -&gt; None:\n        super().__init__(f\"No '{endpoint}' defined for this client.\")\n</code></pre>"},{"location":"api/#requests_oauth2client.client.GrantTypes","title":"<code>GrantTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum of standardized <code>grant_type</code> values.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class GrantTypes(str, Enum):\n    \"\"\"An enum of standardized `grant_type` values.\"\"\"\n\n    CLIENT_CREDENTIALS = \"client_credentials\"\n    AUTHORIZATION_CODE = \"authorization_code\"\n    REFRESH_TOKEN = \"refresh_token\"\n    RESOURCE_OWNER_PASSWORD = \"password\"\n    TOKEN_EXCHANGE = \"urn:ietf:params:oauth:grant-type:token-exchange\"\n    JWT_BEARER = \"urn:ietf:params:oauth:grant-type:jwt-bearer\"\n    CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION = \"urn:openid:params:grant-type:ciba\"\n    DEVICE_CODE = \"urn:ietf:params:oauth:grant-type:device_code\"\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client","title":"<code>OAuth2Client</code>","text":"<p>An OAuth 2.x Client, that can send requests to an OAuth 2.x Authorization Server.</p> <p><code>OAuth2Client</code> is able to obtain tokens from the Token Endpoint using any of the standardised Grant Types, and to communicate with the various backend endpoints like the Revocation, Introspection, and UserInfo Endpoint.</p> <p>To init an OAuth2Client, you only need the url to the Token Endpoint and the Credentials (a client_id and one of a secret or private_key) that will be used to authenticate to that endpoint. Other endpoint urls, such as the Authorization Endpoint, Revocation Endpoint, etc. can be passed as parameter as well if you intend to use them.</p> <p>This class is not intended to help with the end-user authentication or any request that goes in a browser. For authentication requests, see AuthorizationRequest. You may use the method <code>authorization_request()</code> to generate <code>AuthorizationRequest</code>s with the preconfigured <code>authorization_endpoint</code>, <code>client_id</code> and `redirect_uri' from this client.</p> <p>Parameters:</p> Name Type Description Default <code>token_endpoint</code> <code>str</code> <p>the Token Endpoint URI where this client will get access tokens</p> required <code>auth</code> <code>AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None</code> <p>the authentication handler to use for client authentication on the token endpoint. Can be:</p> <ul> <li>a requests.auth.AuthBase instance (which will be used as-is)</li> <li>a tuple of <code>(client_id, client_secret)</code> which will initialize an instance of ClientSecretPost</li> <li>a <code>(client_id, jwk)</code> to initialize a PrivateKeyJwt,</li> <li>or a <code>client_id</code> which will use PublicApp authentication.</li> </ul> <code>None</code> <code>client_id</code> <code>str | None</code> <p>client ID (use either this or <code>auth</code>)</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>client secret (use either this or <code>auth</code>)</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>private_key to use for client authentication (use either this or <code>auth</code>)</p> <code>None</code> <code>revocation_endpoint</code> <code>str | None</code> <p>the Revocation Endpoint URI to use for revoking tokens</p> <code>None</code> <code>introspection_endpoint</code> <code>str | None</code> <p>the Introspection Endpoint URI to use to get info about tokens</p> <code>None</code> <code>userinfo_endpoint</code> <code>str | None</code> <p>the Userinfo Endpoint URI to use to get information about the user</p> <code>None</code> <code>authorization_endpoint</code> <code>str | None</code> <p>the Authorization Endpoint URI, used for initializing Authorization Requests</p> <code>None</code> <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri for this client</p> <code>None</code> <code>backchannel_authentication_endpoint</code> <code>str | None</code> <p>the BackChannel Authentication URI</p> <code>None</code> <code>device_authorization_endpoint</code> <code>str | None</code> <p>the Device Authorization Endpoint URI to use to authorize devices</p> <code>None</code> <code>jwks_uri</code> <code>str | None</code> <p>the JWKS URI to use to obtain the AS public keys</p> <code>None</code> <code>code_challenge_method</code> <code>str</code> <p>challenge method to use for PKCE (should always be 'S256')</p> <code>S256</code> <code>session</code> <code>Session | None</code> <p>a requests Session to use when sending HTTP requests. Useful if some extra parameters such as proxy or client certificate must be used to connect to the AS.</p> <code>None</code> <code>testing</code> <code>bool</code> <p>if <code>True</code>, don't verify the validity of the endpoint urls that are passed as parameter.</p> <code>False</code> <code>**extra_metadata</code> <code>Any</code> <p>additional metadata for this client, unused by this class, but may be used by subclasses. Those will be accessible with the <code>extra_metadata</code> attribute.</p> <code>{}</code> Example <pre><code>client = OAuth2Client(\n    token_endpoint=\"https://my.as.local/token\",\n    revocation_endpoint=\"https://my.as.local/revoke\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\n# once initialized, a client can send requests to its configured endpoints\ncc_token = client.client_credentials(scope=\"my_scope\")\nac_token = client.authorization_code(code=\"my_code\")\nclient.revoke_access_token(cc_token)\n</code></pre> <p>Raises:</p> Type Description <code>MissingIDTokenEncryptedResponseAlgParam</code> <p>if an <code>id_token_decryption_key</code> is provided but no decryption alg is provided, either:</p> <ul> <li>using <code>id_token_encrypted_response_alg</code>,</li> <li>or in the <code>alg</code> parameter of the <code>Jwk</code> key</li> </ul> <code>MissingIssuerParam</code> <p>if <code>authorization_response_iss_parameter_supported</code> is set to <code>True</code> but the <code>issuer</code> is not provided.</p> <code>InvalidEndpointUri</code> <p>if a provided endpoint uri is not considered valid. For the rare cases where those checks must be disabled, you can use <code>testing=True</code>.</p> <code>InvalidIssuer</code> <p>if the <code>issuer</code> value is not considered valid.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@frozen(init=False)\nclass OAuth2Client:\n    \"\"\"An OAuth 2.x Client, that can send requests to an OAuth 2.x Authorization Server.\n\n    `OAuth2Client` is able to obtain tokens from the Token Endpoint using any of the standardised\n    Grant Types, and to communicate with the various backend endpoints like the Revocation,\n    Introspection, and UserInfo Endpoint.\n\n    To init an OAuth2Client, you only need the url to the Token Endpoint and the Credentials\n    (a client_id and one of a secret or private_key) that will be used to authenticate to that endpoint.\n    Other endpoint urls, such as the Authorization Endpoint, Revocation Endpoint, etc. can be passed as\n    parameter as well if you intend to use them.\n\n\n    This class is not intended to help with the end-user authentication or any request that goes in\n    a browser. For authentication requests, see\n    [AuthorizationRequest][requests_oauth2client.authorization_request.AuthorizationRequest]. You\n    may use the method `authorization_request()` to generate `AuthorizationRequest`s with the\n    preconfigured `authorization_endpoint`, `client_id` and `redirect_uri' from this client.\n\n    Args:\n        token_endpoint: the Token Endpoint URI where this client will get access tokens\n        auth: the authentication handler to use for client authentication on the token endpoint.\n            Can be:\n\n            - a [requests.auth.AuthBase][] instance (which will be used as-is)\n            - a tuple of `(client_id, client_secret)` which will initialize an instance\n            of [ClientSecretPost][requests_oauth2client.client_authentication.ClientSecretPost]\n            - a `(client_id, jwk)` to initialize\n            a [PrivateKeyJwt][requests_oauth2client.client_authentication.PrivateKeyJwt],\n            - or a `client_id` which will\n            use [PublicApp][requests_oauth2client.client_authentication.PublicApp] authentication.\n\n        client_id: client ID (use either this or `auth`)\n        client_secret: client secret (use either this or `auth`)\n        private_key: private_key to use for client authentication (use either this or `auth`)\n        revocation_endpoint: the Revocation Endpoint URI to use for revoking tokens\n        introspection_endpoint: the Introspection Endpoint URI to use to get info about tokens\n        userinfo_endpoint: the Userinfo Endpoint URI to use to get information about the user\n        authorization_endpoint: the Authorization Endpoint URI, used for initializing Authorization Requests\n        redirect_uri: the redirect_uri for this client\n        backchannel_authentication_endpoint: the BackChannel Authentication URI\n        device_authorization_endpoint: the Device Authorization Endpoint URI to use to authorize devices\n        jwks_uri: the JWKS URI to use to obtain the AS public keys\n        code_challenge_method: challenge method to use for PKCE (should always be 'S256')\n        session: a requests Session to use when sending HTTP requests.\n            Useful if some extra parameters such as proxy or client certificate must be used\n            to connect to the AS.\n        testing: if `True`, don't verify the validity of the endpoint urls that are passed as parameter.\n        **extra_metadata: additional metadata for this client, unused by this class, but may be\n            used by subclasses. Those will be accessible with the `extra_metadata` attribute.\n\n    Example:\n        ```python\n        client = OAuth2Client(\n            token_endpoint=\"https://my.as.local/token\",\n            revocation_endpoint=\"https://my.as.local/revoke\",\n            client_id=\"client_id\",\n            client_secret=\"client_secret\",\n        )\n\n        # once initialized, a client can send requests to its configured endpoints\n        cc_token = client.client_credentials(scope=\"my_scope\")\n        ac_token = client.authorization_code(code=\"my_code\")\n        client.revoke_access_token(cc_token)\n        ```\n\n    Raises:\n        MissingIDTokenEncryptedResponseAlgParam: if an `id_token_decryption_key` is provided\n            but no decryption alg is provided, either:\n\n            - using `id_token_encrypted_response_alg`,\n            - or in the `alg` parameter of the `Jwk` key\n        MissingIssuerParam: if `authorization_response_iss_parameter_supported` is set to `True`\n            but the `issuer` is not provided.\n        InvalidEndpointUri: if a provided endpoint uri is not considered valid. For the rare cases\n            where those checks must be disabled, you can use `testing=True`.\n        InvalidIssuer: if the `issuer` value is not considered valid.\n\n    \"\"\"\n\n    auth: requests.auth.AuthBase = field(converter=client_auth_factory)\n    token_endpoint: str = field()\n    revocation_endpoint: str | None = field()\n    introspection_endpoint: str | None = field()\n    userinfo_endpoint: str | None = field()\n    authorization_endpoint: str | None = field()\n    redirect_uri: str | None = field()\n    backchannel_authentication_endpoint: str | None = field()\n    device_authorization_endpoint: str | None = field()\n    pushed_authorization_request_endpoint: str | None = field()\n    jwks_uri: str | None = field()\n    authorization_server_jwks: JwkSet\n    issuer: str | None = field()\n    id_token_signed_response_alg: str | None = SignatureAlgs.RS256\n    id_token_encrypted_response_alg: str | None = None\n    id_token_decryption_key: Jwk | None = None\n    code_challenge_method: str | None = CodeChallengeMethods.S256\n    authorization_response_iss_parameter_supported: bool = False\n    session: requests.Session = field(factory=requests.Session)\n    extra_metadata: dict[str, Any] = field(factory=dict)\n    testing: bool = False\n\n    token_class: type[BearerToken] = BearerToken\n\n    exception_classes: ClassVar[dict[str, type[EndpointError]]] = {\n        \"server_error\": ServerError,\n        \"invalid_request\": InvalidRequest,\n        \"invalid_client\": InvalidClient,\n        \"invalid_scope\": InvalidScope,\n        \"invalid_target\": InvalidTarget,\n        \"invalid_grant\": InvalidGrant,\n        \"access_denied\": AccessDenied,\n        \"unauthorized_client\": UnauthorizedClient,\n        \"authorization_pending\": AuthorizationPending,\n        \"slow_down\": SlowDown,\n        \"expired_token\": ExpiredToken,\n        \"unsupported_token_type\": UnsupportedTokenType,\n    }\n\n    def __init__(  # noqa: PLR0913\n        self,\n        token_endpoint: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        revocation_endpoint: str | None = None,\n        introspection_endpoint: str | None = None,\n        userinfo_endpoint: str | None = None,\n        authorization_endpoint: str | None = None,\n        redirect_uri: str | None = None,\n        backchannel_authentication_endpoint: str | None = None,\n        device_authorization_endpoint: str | None = None,\n        pushed_authorization_request_endpoint: str | None = None,\n        jwks_uri: str | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        issuer: str | None = None,\n        id_token_signed_response_alg: str | None = SignatureAlgs.RS256,\n        id_token_encrypted_response_alg: str | None = None,\n        id_token_decryption_key: Jwk | dict[str, Any] | None = None,\n        code_challenge_method: str = CodeChallengeMethods.S256,\n        authorization_response_iss_parameter_supported: bool = False,\n        token_class: type[BearerToken] = BearerToken,\n        session: requests.Session | None = None,\n        testing: bool = False,\n        **extra_metadata: Any,\n    ) -&gt; None:\n        if authorization_response_iss_parameter_supported and not issuer:\n            raise MissingIssuerParam\n\n        auth = client_auth_factory(\n            auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            default_auth_handler=ClientSecretPost,\n        )\n\n        if authorization_server_jwks is None:\n            authorization_server_jwks = JwkSet()\n        elif not isinstance(authorization_server_jwks, JwkSet):\n            authorization_server_jwks = JwkSet(authorization_server_jwks)\n\n        if id_token_decryption_key is not None and not isinstance(id_token_decryption_key, Jwk):\n            id_token_decryption_key = Jwk(id_token_decryption_key)\n\n        if id_token_decryption_key is not None and id_token_encrypted_response_alg is None:\n            if id_token_decryption_key.alg:\n                id_token_encrypted_response_alg = id_token_decryption_key.alg\n            else:\n                raise MissingIdTokenEncryptedResponseAlgParam\n\n        if session is None:\n            session = requests.Session()\n\n        self.__attrs_init__(\n            testing=testing,\n            token_endpoint=token_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            redirect_uri=redirect_uri,\n            backchannel_authentication_endpoint=backchannel_authentication_endpoint,\n            device_authorization_endpoint=device_authorization_endpoint,\n            pushed_authorization_request_endpoint=pushed_authorization_request_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            issuer=issuer,\n            session=session,\n            auth=auth,\n            id_token_signed_response_alg=id_token_signed_response_alg,\n            id_token_encrypted_response_alg=id_token_encrypted_response_alg,\n            id_token_decryption_key=id_token_decryption_key,\n            code_challenge_method=code_challenge_method,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            extra_metadata=extra_metadata,\n            token_class=token_class,\n        )\n\n    @token_endpoint.validator\n    @revocation_endpoint.validator\n    @introspection_endpoint.validator\n    @userinfo_endpoint.validator\n    @authorization_endpoint.validator\n    @backchannel_authentication_endpoint.validator\n    @device_authorization_endpoint.validator\n    @pushed_authorization_request_endpoint.validator\n    @jwks_uri.validator\n    def validate_endpoint_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n        \"\"\"Validate that an endpoint URI is suitable for use.\n\n        If you need to disable some checks (for AS testing purposes only!), provide a different\n        method here.\n\n        \"\"\"\n        if self.testing or uri is None:\n            return uri\n        try:\n            return validate_endpoint_uri(uri)\n        except InvalidUri as exc:\n            raise InvalidEndpointUri(endpoint=attribute.name, uri=uri, exc=exc) from exc\n\n    @issuer.validator\n    def validate_issuer_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n        \"\"\"Validate that an Issuer identifier is suitable for use.\n\n        This is the same check as an endpoint URI, but the path may be (and usually is) empty.\n\n        \"\"\"\n        if self.testing or uri is None:\n            return uri\n        try:\n            return validate_issuer_uri(uri)\n        except InvalidUri as exc:\n            raise InvalidIssuer(attribute.name, uri, exc) from exc\n\n    @property\n    def client_id(self) -&gt; str:\n        \"\"\"Client ID.\"\"\"\n        if hasattr(self.auth, \"client_id\"):\n            return self.auth.client_id  # type: ignore[no-any-return]\n        msg = \"This client uses a custom authentication method without client_id.\"\n        raise AttributeError(msg)  # pragma: no cover\n\n    @property\n    def client_secret(self) -&gt; str | None:\n        \"\"\"Client Secret.\"\"\"\n        if hasattr(self.auth, \"client_secret\"):\n            return self.auth.client_secret  # type: ignore[no-any-return]\n        return None\n\n    @property\n    def client_jwks(self) -&gt; JwkSet:\n        \"\"\"A `JwkSet` containing the public keys for this client.\n\n        Keys are:\n\n        - the public key for client assertion signature verification (if using private_key_jwt)\n        - the ID Token encryption key\n\n        \"\"\"\n        jwks = JwkSet()\n        if isinstance(self.auth, PrivateKeyJwt):\n            jwks.add_jwk(self.auth.private_jwk.public_jwk().with_usage_parameters())\n        if self.id_token_decryption_key:\n            jwks.add_jwk(self.id_token_decryption_key.public_jwk().with_usage_parameters())\n        return jwks\n\n    def _request(\n        self,\n        endpoint: str,\n        on_success: Callable[[requests.Response], T],\n        on_failure: Callable[[requests.Response], T],\n        accept: str = \"application/json\",\n        method: str = \"POST\",\n        **requests_kwargs: Any,\n    ) -&gt; T:\n        \"\"\"Send a request to one of the endpoints.\n\n        This is a helper method that takes care of the following tasks:\n\n        - make sure the endpoint as been configured\n        - set `Accept: application/json` header\n        - send the HTTP POST request, then\n            - apply `on_success` to a successful response\n            - or apply `on_failure` otherwise\n        - return the result\n\n        Args:\n            endpoint: name of the endpoint to use\n            on_success: a callable to apply to successful responses\n            on_failure: a callable to apply to error responses\n            accept: the Accept header to include in the request\n            method: the HTTP method to use\n            **requests_kwargs: keyword arguments for the request\n\n        \"\"\"\n        endpoint_uri = self._require_endpoint(endpoint)\n        requests_kwargs.setdefault(\"headers\", {})\n        requests_kwargs[\"headers\"][\"Accept\"] = accept\n\n        response = self.session.request(\n            method,\n            endpoint_uri,\n            **requests_kwargs,\n        )\n        if response.ok:\n            return on_success(response)\n\n        return on_failure(response)\n\n    def token_request(\n        self,\n        data: dict[str, Any],\n        timeout: int = 10,\n        **requests_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint.\n\n        Authentication will be added automatically based on the defined `auth` for this client.\n\n        Args:\n          data: parameters to send to the token endpoint. Items with a `None`\n               or empty value will not be sent in the request.\n          timeout: a timeout value for the call\n          **requests_kwargs: additional parameters for requests.post()\n\n        Returns:\n            the token endpoint response, as\n            [`BearerToken`][requests_oauth2client.tokens.BearerToken] instance.\n\n        \"\"\"\n        return self._request(\n            Endpoints.TOKEN,\n            auth=self.auth,\n            data=data,\n            timeout=timeout,\n            on_success=self.parse_token_response,\n            on_failure=self.on_token_error,\n            **requests_kwargs,\n        )\n\n    def parse_token_response(self, response: requests.Response) -&gt; BearerToken:\n        \"\"\"Parse a Response returned by the Token Endpoint.\n\n        Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse\n        responses returned by the Token Endpoint. Those responses contain an `access_token` and\n        additional attributes.\n\n        Args:\n            response: the [Response][requests.Response] returned by the Token Endpoint.\n\n        Returns:\n            a [`BearerToken`][requests_oauth2client.tokens.BearerToken] based on the response\n            contents.\n\n        \"\"\"\n        try:\n            token_response = self.token_class(**response.json())\n        except Exception:  # noqa: BLE001\n            return self.on_token_error(response)\n        else:\n            return token_response\n\n    def on_token_error(self, response: requests.Response) -&gt; BearerToken:\n        \"\"\"Error handler for `token_request()`.\n\n        Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the\n        Token Endpoint returns an error.\n\n        Args:\n            response: the [Response][requests.Response] returned by the Token Endpoint.\n\n        Returns:\n            nothing, and raises an exception instead. But a subclass may return a\n            [`BearerToken`][requests_oauth2client.tokens.BearerToken] to implement a default\n            behaviour if needed.\n\n        Raises:\n            InvalidTokenResponse: if the error response does not contain an OAuth 2.0 standard\n                error response.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidTokenResponse(response=response, client=self) from exc\n        raise exception\n\n    def client_credentials(\n        self,\n        scope: str | Iterable[str] | None = None,\n        *,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint using the `client_credentials` grant.\n\n        Args:\n            scope: the scope to send with the request. Can be a str, or an iterable of str.\n                to pass that way include `scope`, `audience`, `resource`, etc.\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`. Common parameters\n\n        Returns:\n            a BearerToken\n\n        Raises:\n            InvalidScopeParam: if the `scope` parameter is not suitable\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if scope and not isinstance(scope, str):\n            try:\n                scope = \" \".join(scope)\n            except Exception as exc:\n                raise InvalidScopeParam(scope) from exc\n\n        data = dict(grant_type=GrantTypes.CLIENT_CREDENTIALS, scope=scope, **token_kwargs)\n        return self.token_request(data, **requests_kwargs)\n\n    def authorization_code(\n        self,\n        code: str | AuthorizationResponse,\n        *,\n        validate: bool = True,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint with the `authorization_code` grant.\n\n        Args:\n             code: an authorization code or an `AuthorizationResponse` to exchange for tokens\n             validate: if `True`, validate the received ID Token (this works only if `code` is an AuthorizationResponse)\n             requests_kwargs: additional parameters for the call to requests\n             **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `code`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        \"\"\"\n        azr: AuthorizationResponse | None = None\n        if isinstance(code, AuthorizationResponse):\n            token_kwargs.setdefault(\"code_verifier\", code.code_verifier)\n            token_kwargs.setdefault(\"redirect_uri\", code.redirect_uri)\n            azr = code\n            code = code.code\n\n        requests_kwargs = requests_kwargs or {}\n\n        data = dict(grant_type=GrantTypes.AUTHORIZATION_CODE, code=code, **token_kwargs)\n        token = self.token_request(data, **requests_kwargs)\n        if validate and token.id_token and isinstance(azr, AuthorizationResponse):\n            return token.validate_id_token(self, azr)\n        return token\n\n    def refresh_token(\n        self,\n        refresh_token: str | BearerToken,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint with the `refresh_token` grant.\n\n        Args:\n            refresh_token: a refresh_token, as a string, or as a `BearerToken`.\n                That `BearerToken` must have a `refresh_token`.\n            requests_kwargs: additional parameters for the call to `requests`\n            **token_kwargs: additional parameters for the token endpoint,\n                alongside `grant_type`, `refresh_token`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        Raises:\n            MissingRefreshToken: if `refresh_token` is a BearerToken instance but does not\n                contain a `refresh_token`\n\n        \"\"\"\n        if isinstance(refresh_token, BearerToken):\n            if refresh_token.refresh_token is None or not isinstance(refresh_token.refresh_token, str):\n                raise MissingRefreshToken(refresh_token)\n            refresh_token = refresh_token.refresh_token\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(grant_type=GrantTypes.REFRESH_TOKEN, refresh_token=refresh_token, **token_kwargs)\n        return self.token_request(data, **requests_kwargs)\n\n    def device_code(\n        self,\n        device_code: str | DeviceAuthorizationResponse,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint using the Device Code grant.\n\n        The grant_type is `urn:ietf:params:oauth:grant-type:device_code`. This needs a Device Code,\n        or a `DeviceAuthorizationResponse` as parameter.\n\n        Args:\n            device_code: a device code, or a `DeviceAuthorizationResponse`\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        Raises:\n            MissingDeviceCode: if `device_code` is a DeviceAuthorizationResponse but does not\n                contain a `device_code`.\n\n        \"\"\"\n        if isinstance(device_code, DeviceAuthorizationResponse):\n            if device_code.device_code is None or not isinstance(device_code.device_code, str):\n                raise MissingDeviceCode(device_code)\n            device_code = device_code.device_code\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantTypes.DEVICE_CODE,\n            device_code=device_code,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def ciba(\n        self,\n        auth_req_id: str | BackChannelAuthenticationResponse,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a CIBA request to the Token Endpoint.\n\n        A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant.\n\n        Args:\n            auth_req_id: an authentication request ID, as returned by the AS\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        Raises:\n            MissingAuthRequestId: if `auth_req_id` is a BackChannelAuthenticationResponse but does not contain\n                an `auth_req_id`.\n\n        \"\"\"\n        if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n            if auth_req_id.auth_req_id is None or not isinstance(auth_req_id.auth_req_id, str):\n                raise MissingAuthRequestId(auth_req_id)\n            auth_req_id = auth_req_id.auth_req_id\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantTypes.CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION,\n            auth_req_id=auth_req_id,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def token_exchange(\n        self,\n        subject_token: str | BearerToken | IdToken,\n        subject_token_type: str | None = None,\n        actor_token: None | str | BearerToken | IdToken = None,\n        actor_token_type: str | None = None,\n        requested_token_type: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a Token Exchange request.\n\n        A Token Exchange request is actually a request to the Token Endpoint with a grant_type\n        `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n        Args:\n            subject_token: the subject token to exchange for a new token.\n            subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based\n                on `type(subject_token)`.\n            actor_token: the actor token to include in the request, if any.\n            actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based\n                on `type(actor_token)`.\n            requested_token_type: a token type identifier for the requested token.\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            a `BearerToken` as returned by the Authorization Server.\n\n        Raises:\n            UnknownSubjectTokenType: if the type of `subject_token` cannot be determined automatically.\n            UnknownActorTokenType: if the type of `actor_token` cannot be determined automaticatlly.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        try:\n            subject_token_type = self.get_token_type(subject_token_type, subject_token)\n        except ValueError as exc:\n            raise UnknownSubjectTokenType(subject_token, subject_token_type) from exc\n        if actor_token:  # pragma: no branch\n            try:\n                actor_token_type = self.get_token_type(actor_token_type, actor_token)\n            except ValueError as exc:\n                raise UnknownActorTokenType(actor_token, actor_token_type) from exc\n\n        data = dict(\n            grant_type=GrantTypes.TOKEN_EXCHANGE,\n            subject_token=subject_token,\n            subject_token_type=subject_token_type,\n            actor_token=actor_token,\n            actor_token_type=actor_token_type,\n            requested_token_type=requested_token_type,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def jwt_bearer(\n        self,\n        assertion: Jwt | str,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request using a JWT as authorization grant.\n\n        This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).\n\n        Args:\n            assertion: a JWT (as an instance of `jwskate.Jwt` or as a `str`) to use as authorization grant.\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            a `BearerToken` as returned by the Authorization Server.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if not isinstance(assertion, Jwt):\n            assertion = Jwt(assertion)\n\n        data = dict(\n            grant_type=GrantTypes.JWT_BEARER,\n            assertion=assertion,\n            **token_kwargs,\n        )\n\n        return self.token_request(data, **requests_kwargs)\n\n    def resource_owner_password(\n        self,\n        username: str,\n        password: str,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request using the Resource Owner Password Grant.\n\n        This Grant Type is deprecated and should only be used when there is no other choice.\n\n        Args:\n            username: the resource owner user name\n            password: the resource owner password\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            a `BearerToken` as returned by the Authorization Server\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantTypes.RESOURCE_OWNER_PASSWORD,\n            username=username,\n            password=password,\n            **token_kwargs,\n        )\n\n        return self.token_request(data, **requests_kwargs)\n\n    def authorization_request(\n        self,\n        *,\n        scope: None | str | Iterable[str] = \"openid\",\n        response_type: str = ResponseTypes.CODE,\n        redirect_uri: str | None = None,\n        state: str | ellipsis | None = ...,  # noqa: F821\n        nonce: str | ellipsis | None = ...,  # noqa: F821\n        code_verifier: str | None = None,\n        **kwargs: Any,\n    ) -&gt; AuthorizationRequest:\n        \"\"\"Generate an Authorization Request for this client.\n\n        Args:\n            scope: the `scope` to use\n            response_type: the `response_type` to use\n            redirect_uri: the `redirect_uri` to include in the request. By default,\n                the `redirect_uri` defined at init time is used.\n            state: the `state` parameter to use. Leave default to generate a random value.\n            nonce: a `nonce`. Leave default to generate a random value.\n            code_verifier: the PKCE `code_verifier` to use. Leave default to generate a random value.\n            **kwargs: additional parameters to include in the auth request\n\n        Returns:\n            an AuthorizationRequest with the supplied parameters\n\n        \"\"\"\n        authorization_endpoint = self._require_endpoint(\"authorization_endpoint\")\n\n        redirect_uri = redirect_uri or self.redirect_uri\n\n        return AuthorizationRequest(\n            authorization_endpoint=authorization_endpoint,\n            client_id=self.client_id,\n            redirect_uri=redirect_uri,\n            issuer=self.issuer,\n            response_type=response_type,\n            scope=scope,\n            state=state,\n            nonce=nonce,\n            code_verifier=code_verifier,\n            code_challenge_method=self.code_challenge_method,\n            **kwargs,\n        )\n\n    def pushed_authorization_request(\n        self,\n        authorization_request: AuthorizationRequest,\n        requests_kwargs: dict[str, Any] | None = None,\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Send a Pushed Authorization Request.\n\n        This sends a request to the Pushed Authorization Request Endpoint, and returns a\n        `RequestUriParameterAuthorizationRequest` initialized with the AS response.\n\n        Args:\n            authorization_request: the authorization request to send\n            requests_kwargs: additional parameters for `requests.request()`\n\n        Returns:\n            the `RequestUriParameterAuthorizationRequest` initialized based on the AS response\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n        return self._request(\n            Endpoints.PUSHED_AUTHORIZATION_REQUEST,\n            data=authorization_request.args,\n            auth=self.auth,\n            on_success=self.parse_pushed_authorization_response,\n            on_failure=self.on_pushed_authorization_request_error,\n            **requests_kwargs,\n        )\n\n    def parse_pushed_authorization_response(\n        self,\n        response: requests.Response,\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Parse the response obtained by `pushed_authorization_request()`.\n\n        Args:\n            response: the `requests.Response` returned by the PAR endpoint\n\n        Returns:\n            a RequestUriParameterAuthorizationRequest instance\n\n        \"\"\"\n        response_json = response.json()\n        request_uri = response_json.get(\"request_uri\")\n        expires_in = response_json.get(\"expires_in\")\n\n        return RequestUriParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request_uri=request_uri,\n            expires_in=expires_in,\n        )\n\n    def on_pushed_authorization_request_error(\n        self,\n        response: requests.Response,\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Error Handler for Pushed Authorization Endpoint errors.\n\n        Args:\n            response: the HTTP response as returned by the AS PAR endpoint.\n\n        Returns:\n            a RequestUriParameterAuthorizationRequest, if the error is recoverable\n\n        Raises:\n            EndpointError: a subclass of this error depending on the error returned by the AS\n            InvalidPushedAuthorizationResponse: if the returned response is not following the\n                specifications\n            UnknownTokenEndpointError: for unknown/unhandled errors\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidPushedAuthorizationResponse(response=response, client=self) from exc\n        raise exception\n\n    def userinfo(self, access_token: BearerToken | str) -&gt; Any:\n        \"\"\"Call the UserInfo endpoint.\n\n        This sends a request to the UserInfo endpoint, with the specified access_token, and returns\n        the parsed result.\n\n        Args:\n            access_token: the access token to use\n\n        Returns:\n            the [Response][requests.Response] returned by the userinfo endpoint.\n\n        \"\"\"\n        if isinstance(access_token, str):\n            access_token = BearerToken(access_token)\n        return self._request(\n            Endpoints.USER_INFO,\n            auth=access_token,\n            on_success=self.parse_userinfo_response,\n            on_failure=self.on_userinfo_error,\n        )\n\n    def parse_userinfo_response(self, resp: requests.Response) -&gt; Any:\n        \"\"\"Parse the response obtained by `userinfo()`.\n\n        Invoked by [userinfo()][requests_oauth2client.client.OAuth2Client.userinfo] to parse the\n        response from the UserInfo endpoint, this will extract and return its JSON content.\n\n        Args:\n            resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n        Returns:\n            the parsed JSON content from this response.\n\n        \"\"\"\n        return resp.json()\n\n    def on_userinfo_error(self, resp: requests.Response) -&gt; Any:\n        \"\"\"Parse UserInfo error response.\n\n        Args:\n            resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n        Returns:\n            nothing, raises exception instead.\n\n        \"\"\"\n        resp.raise_for_status()\n\n    @classmethod\n    def get_token_type(  # noqa: C901\n        cls,\n        token_type: str | None = None,\n        token: None | str | BearerToken | IdToken = None,\n    ) -&gt; str:\n        \"\"\"Get standardized token type identifiers.\n\n        Return a standardized token type identifier, based on a short `token_type` hint and/or a\n        token value.\n\n        Args:\n            token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\"\n                or \"id_token\"\n            token: a token value, as an instance of `BearerToken` or IdToken, or as a `str`.\n\n        Returns:\n            the token_type as defined in the Token Exchange RFC8693.\n\n        Raises:\n            UnknownTokenType: if the type of token cannot be determined\n\n        \"\"\"\n        if not (token_type or token):\n            msg = \"Cannot determine type of an empty token without a token_type hint\"\n            raise UnknownTokenType(msg, token, token_type)\n\n        if token_type is None:\n            if isinstance(token, str):\n                msg = \"\"\"\\\nCannot determine the type of provided token when it is a bare `str`. Please specify a 'token_type'.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            if isinstance(token, BearerToken):\n                return \"urn:ietf:params:oauth:token-type:access_token\"\n            if isinstance(token, IdToken):\n                return \"urn:ietf:params:oauth:token-type:id_token\"\n            msg = f\"Unknown token type {type(token)}\"\n            raise UnknownTokenType(msg, token, token_type)\n        if token_type == TokenType.ACCESS_TOKEN:\n            if token is not None and not isinstance(token, (str, BearerToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nA BearerToken or an access_token as a `str` is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:access_token\"\n        if token_type == TokenType.REFRESH_TOKEN:\n            if token is not None and isinstance(token, BearerToken) and not token.refresh_token:\n                msg = f\"\"\"\\\nThe supplied BearerToken does not contain a refresh_token, which is inconsistent with token_type '{token_type}'.\nA BearerToken containing a refresh_token is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:refresh_token\"\n        if token_type == TokenType.ID_TOKEN:\n            if token is not None and not isinstance(token, (str, IdToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nAn IdToken or a string representation of it is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:id_token\"\n\n        return {\n            \"saml1\": \"urn:ietf:params:oauth:token-type:saml1\",\n            \"saml2\": \"urn:ietf:params:oauth:token-type:saml2\",\n            \"jwt\": \"urn:ietf:params:oauth:token-type:jwt\",\n        }.get(token_type, token_type)\n\n    def revoke_access_token(\n        self,\n        access_token: BearerToken | str,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a request to the Revocation Endpoint to revoke an access token.\n\n        Args:\n            access_token: the access token to revoke\n            requests_kwargs: additional parameters for the underlying requests.post() call\n            **revoke_kwargs: additional parameters to pass to the revocation endpoint\n\n        \"\"\"\n        return self.revoke_token(\n            access_token,\n            token_type_hint=TokenType.ACCESS_TOKEN,\n            requests_kwargs=requests_kwargs,\n            **revoke_kwargs,\n        )\n\n    def revoke_refresh_token(\n        self,\n        refresh_token: str | BearerToken,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a request to the Revocation Endpoint to revoke a refresh token.\n\n        Args:\n            refresh_token: the refresh token to revoke.\n            requests_kwargs: additional parameters to pass to the revocation endpoint.\n            **revoke_kwargs: additional parameters to pass to the revocation endpoint.\n\n        Returns:\n            `True` if the revocation request is successful, `False` if this client has no configured\n            revocation endpoint.\n\n        Raises:\n            MissingRefreshToken: when `refresh_token` is a [BearerToken][requests_oauth2client.tokens.BearerToken]\n                but does not contain a `refresh_token`.\n\n        \"\"\"\n        if isinstance(refresh_token, BearerToken):\n            if refresh_token.refresh_token is None:\n                raise MissingRefreshToken(refresh_token)\n            refresh_token = refresh_token.refresh_token\n\n        return self.revoke_token(\n            refresh_token,\n            token_type_hint=TokenType.REFRESH_TOKEN,\n            requests_kwargs=requests_kwargs,\n            **revoke_kwargs,\n        )\n\n    def revoke_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a Token Revocation request.\n\n        By default, authentication will be the same than the one used for the Token Endpoint.\n\n        Args:\n            token: the token to revoke.\n            token_type_hint: a token_type_hint to send to the revocation endpoint.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **revoke_kwargs: additional parameters to send to the revocation endpoint.\n\n        Returns:\n            `True` if the revocation succeeds, `False` if no revocation endpoint is present or a\n            non-standardised error is returned.\n\n        Raises:\n            MissingEndpointUri: if the Revocation Endpoint URI is not configured.\n            MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n                but does not contain a `refresh_token`.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if token_type_hint == TokenType.REFRESH_TOKEN and isinstance(token, BearerToken):\n            if token.refresh_token is None:\n                raise MissingRefreshToken(token)\n            token = token.refresh_token\n\n        data = dict(revoke_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            Endpoints.REVOCATION,\n            data=data,\n            auth=self.auth,\n            on_success=lambda _: True,\n            on_failure=self.on_revocation_error,\n            **requests_kwargs,\n        )\n\n    def on_revocation_error(self, response: requests.Response) -&gt; bool:\n        \"\"\"Error handler for `revoke_token()`.\n\n        Invoked by [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token] when the\n        revocation endpoint returns an error.\n\n        Args:\n            response: the [Response][requests.Response] as returned by the Revocation Endpoint\n\n        Returns:\n            `False` to signal that an error occurred. May raise exceptions instead depending on the\n            revocation response.\n\n        Raises:\n            EndpointError: if the response contains a standardised OAuth 2.0 error.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, RevocationError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception:  # noqa: BLE001\n            return False\n        raise exception\n\n    def introspect_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **introspect_kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"Send a request to the Introspection Endpoint.\n\n        Parameter `token` can be:\n\n        - a `str`\n        - a `BearerToken` instance\n\n        You may pass any arbitrary `token` and `token_type_hint` values as `str`. Those will\n        be included in the request, as-is.\n        If `token` is a `BearerToken`, then `token_type_hint` must be either:\n\n        - `None`: the access_token will be instrospected and no token_type_hint will be included\n        in the request\n        - `access_token`: same as `None`, but the token_type_hint will be included\n        - or `refresh_token`: only available if a Refresh Token is present in the BearerToken.\n\n        Args:\n            token: the token to instrospect\n            token_type_hint: the `token_type_hint` to include in the request.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **introspect_kwargs: additional parameters to send to the introspection endpoint.\n\n        Returns:\n            the response as returned by the Introspection Endpoint.\n\n        Raises:\n            MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n                but does not contain a `refresh_token`.\n            UnknownTokenType: if `token_type_hint` is neither `None`, `\"access_token\"` or `\"refresh_token\"`.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if isinstance(token, BearerToken):\n            if token_type_hint is None or token_type_hint == TokenType.ACCESS_TOKEN:\n                token = token.access_token\n            elif token_type_hint == TokenType.REFRESH_TOKEN:\n                if token.refresh_token is None:\n                    raise MissingRefreshToken(token)\n\n                token = token.refresh_token\n            else:\n                msg = \"\"\"\\\nInvalid `token_type_hint`. To test arbitrary `token_type_hint` values, you must provide `token` as a `str`.\"\"\"\n                raise UnknownTokenType(msg, token, token_type_hint)\n\n        data = dict(introspect_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            Endpoints.INSTROSPECTION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_introspection_response,\n            on_failure=self.on_introspection_error,\n            **requests_kwargs,\n        )\n\n    def parse_introspection_response(self, response: requests.Response) -&gt; Any:\n        \"\"\"Parse Token Introspection Responses received by `introspect_token()`.\n\n        Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n        to parse the returned response. This decodes the JSON content if possible, otherwise it\n        returns the response as a string.\n\n        Args:\n            response: the [Response][requests.Response] as returned by the Introspection Endpoint.\n\n        Returns:\n            the decoded JSON content, or a `str` with the content.\n\n        \"\"\"\n        try:\n            return response.json()\n        except ValueError:\n            return response.text\n\n    def on_introspection_error(self, response: requests.Response) -&gt; Any:\n        \"\"\"Error handler for `introspect_token()`.\n\n        Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n        to parse the returned response in the case an error is returned.\n\n        Args:\n            response: the response as returned by the Introspection Endpoint.\n\n        Returns:\n            usually raises exceptions. A subclass can return a default response instead.\n\n        Raises:\n            EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n            UnknownIntrospectionError: if the response is not a standard error response.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, IntrospectionError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise UnknownIntrospectionError(response=response, client=self) from exc\n        raise exception\n\n    def backchannel_authentication_request(  # noqa: PLR0913\n        self,\n        scope: None | str | Iterable[str] = \"openid\",\n        *,\n        client_notification_token: str | None = None,\n        acr_values: None | str | Iterable[str] = None,\n        login_hint_token: str | None = None,\n        id_token_hint: str | None = None,\n        login_hint: str | None = None,\n        binding_message: str | None = None,\n        user_code: str | None = None,\n        requested_expiry: int | None = None,\n        private_jwk: Jwk | dict[str, Any] | None = None,\n        alg: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **ciba_kwargs: Any,\n    ) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Send a CIBA Authentication Request.\n\n        Args:\n             scope: the scope to include in the request.\n             client_notification_token: the Client Notification Token to include in the request.\n             acr_values: the acr values to include in the request.\n             login_hint_token: the Login Hint Token to include in the request.\n             id_token_hint: the ID Token Hint to include in the request.\n             login_hint: the Login Hint to include in the request.\n             binding_message: the Binding Message to include in the request.\n             user_code: the User Code to include in the request\n             requested_expiry: the Requested Expiry, in seconds, to include in the request.\n             private_jwk: the JWK to use to sign the request (optional)\n             alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.\n             requests_kwargs: additional parameters for\n             **ciba_kwargs: additional parameters to include in the request.\n\n        Returns:\n            a BackChannelAuthenticationResponse as returned by AS\n\n        Raises:\n            InvalidBackchannelAuthenticationRequestHintParam: if none of `login_hint`, `login_hint_token`\n                or `id_token_hint` is provided, or more than one of them is provided.\n            InvalidScopeParam: if the `scope` parameter is invalid.\n            InvalidAcrValuesParam: if the `acr_values` parameter is invalid.\n\n        \"\"\"\n        if not (login_hint or login_hint_token or id_token_hint):\n            msg = \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n            raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n        if (login_hint_token and id_token_hint) or (login_hint and id_token_hint) or (login_hint_token and login_hint):\n            msg = \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n            raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n        requests_kwargs = requests_kwargs or {}\n\n        if scope is not None and not isinstance(scope, str):\n            try:\n                scope = \" \".join(scope)\n            except Exception as exc:\n                raise InvalidScopeParam(scope) from exc\n\n        if acr_values is not None and not isinstance(acr_values, str):\n            try:\n                acr_values = \" \".join(acr_values)\n            except Exception as exc:\n                raise InvalidAcrValuesParam(acr_values) from exc\n\n        data = dict(\n            ciba_kwargs,\n            scope=scope,\n            client_notification_token=client_notification_token,\n            acr_values=acr_values,\n            login_hint_token=login_hint_token,\n            id_token_hint=id_token_hint,\n            login_hint=login_hint,\n            binding_message=binding_message,\n            user_code=user_code,\n            requested_expiry=requested_expiry,\n        )\n\n        if private_jwk is not None:\n            data = {\"request\": str(Jwt.sign(data, key=private_jwk, alg=alg))}\n\n        return self._request(\n            Endpoints.BACKCHANNEL_AUTHENTICATION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_backchannel_authentication_response,\n            on_failure=self.on_backchannel_authentication_error,\n            **requests_kwargs,\n        )\n\n    def parse_backchannel_authentication_response(\n        self,\n        response: requests.Response,\n    ) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Parse a response received by `backchannel_authentication_request()`.\n\n        Invoked by\n        [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n        to parse the response returned by the BackChannel Authentication Endpoint.\n\n        Args:\n            response: the response returned by the BackChannel Authentication Endpoint.\n\n        Returns:\n            a `BackChannelAuthenticationResponse`\n\n        Raises:\n            InvalidBackChannelAuthenticationResponse: if the response does not contain a standard\n                BackChannel Authentication response.\n\n        \"\"\"\n        try:\n            return BackChannelAuthenticationResponse(**response.json())\n        except TypeError as exc:\n            raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n\n    def on_backchannel_authentication_error(self, response: requests.Response) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Error handler for `backchannel_authentication_request()`.\n\n        Invoked by\n        [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n        to parse the response returned by the BackChannel Authentication Endpoint, when it is an\n        error.\n\n        Args:\n            response: the response returned by the BackChannel Authentication Endpoint.\n\n        Returns:\n            usually raises an exception. But a subclass can return a default response instead.\n\n        Raises:\n            EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n            InvalidBackChannelAuthenticationResponse: for non-standard error responses.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, BackChannelAuthenticationError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n        raise exception\n\n    def authorize_device(\n        self,\n        requests_kwargs: dict[str, Any] | None = None,\n        **data: Any,\n    ) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Send a Device Authorization Request.\n\n        Args:\n            **data: additional data to send to the Device Authorization Endpoint\n            requests_kwargs: additional parameters for `requests.request()`\n\n        Returns:\n            a Device Authorization Response\n\n        Raises:\n            MissingEndpointUri: if the Device Authorization URI is not configured\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        return self._request(\n            Endpoints.DEVICE_AUTHORIZATION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_device_authorization_response,\n            on_failure=self.on_device_authorization_error,\n            **requests_kwargs,\n        )\n\n    def parse_device_authorization_response(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Parse a Device Authorization Response received by `authorize_device()`.\n\n        Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n        to parse the response returned by the Device Authorization Endpoint.\n\n        Args:\n            response: the response returned by the Device Authorization Endpoint.\n\n        Returns:\n            a `DeviceAuthorizationResponse` as returned by AS\n\n        \"\"\"\n        return DeviceAuthorizationResponse(**response.json())\n\n    def on_device_authorization_error(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Error handler for `authorize_device()`.\n\n        Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n        to parse the response returned by the Device Authorization Endpoint, when that response is\n        an error.\n\n        Args:\n            response: the response returned by the Device Authorization Endpoint.\n\n        Returns:\n            usually raises an Exception. But a subclass may return a default response instead.\n\n        Raises:\n            EndpointError: for standard OAuth 2.0 errors\n            InvalidDeviceAuthorizationResponse: for non-standard error responses.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, DeviceAuthorizationError)\n            exception = exception_class(\n                response=response,\n                client=self,\n                error=error,\n                description=error_description,\n                uri=error_uri,\n            )\n        except Exception as exc:\n            raise InvalidDeviceAuthorizationResponse(response=response, client=self) from exc\n        raise exception\n\n    def update_authorization_server_public_keys(self, requests_kwargs: dict[str, Any] | None = None) -&gt; JwkSet:\n        \"\"\"Update the cached AS public keys by retrieving them from its `jwks_uri`.\n\n        Public keys are returned by this method, as a `jwskate.JwkSet`. They are also\n        available in attribute `authorization_server_jwks`.\n\n        Returns:\n            the retrieved public keys\n\n        Raises:\n            ValueError: if no `jwks_uri` is configured\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        jwks = self._request(\n            Endpoints.JWKS,\n            auth=None,\n            method=\"GET\",\n            on_success=lambda resp: resp.json(),\n            on_failure=lambda resp: resp.raise_for_status(),\n            **requests_kwargs,\n        )\n        self.authorization_server_jwks.update(jwks)\n        return self.authorization_server_jwks\n\n    @classmethod\n    def from_discovery_endpoint(\n        cls,\n        url: str | None = None,\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        session: requests.Session | None = None,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialise an OAuth2Client based on Authorization Server Metadata.\n\n        This will retrieve the standardised metadata document available at `url`, and will extract\n        all Endpoint Uris from that document, will fetch the current public keys from its\n        `jwks_uri`, then will initialise an OAuth2Client based on those endpoints.\n\n        Args:\n             url: the url where the server metadata will be retrieved\n             auth: the authentication handler to use for client authentication\n             client_id: client ID\n             client_secret: client secret to use to authenticate the client\n             private_key: private key to sign client assertions\n             session: a `requests.Session` to use to retrieve the document and initialise the client with\n             issuer: if an issuer is given, check that it matches the one from the retrieved document\n             testing: if True, don't try to validate the endpoint urls that are part of the document\n             **kwargs: additional keyword parameters to pass to OAuth2Client\n\n        Returns:\n            an OAuth2Client with endpoint initialised based on the obtained metadata\n\n        Raises:\n            InvalidParam: if neither `url` nor `issuer` are suitable urls\n            requests.HTTPError: if an error happens while fetching the documents\n\n        Example:\n            ```python\n            from requests_oauth2client import OAuth2Client\n\n            client = OAuth2Client.from_discovery_endpoint(\n                issuer=\"https://myserver.net\",\n                client_id=\"my_client_id,\n                client_secret=\"my_client_secret\"\n            )\n            ```\n\n        \"\"\"\n        if url is None and issuer is not None:\n            url = oidc_discovery_document_url(issuer)\n        if url is None:\n            msg = \"Please specify at least one of `issuer` or `url`\"\n            raise InvalidParam(msg)\n\n        validate_endpoint_uri(url, path=False)\n\n        session = session or requests.Session()\n        discovery = session.get(url).json()\n\n        jwks_uri = discovery.get(\"jwks_uri\")\n        if jwks_uri:\n            jwks = JwkSet(session.get(jwks_uri).json())\n\n        return cls.from_discovery_document(\n            discovery,\n            issuer=issuer,\n            auth=auth,\n            session=session,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            authorization_server_jwks=jwks,\n            testing=testing,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_discovery_document(\n        cls,\n        discovery: dict[str, Any],\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        session: requests.Session | None = None,\n        https: bool = True,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an OAuth2Client, based on the server metadata from `discovery`.\n\n        Args:\n             discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint.\n             issuer: if an issuer is given, check that it matches the one mentioned in the document\n             auth: the authentication handler to use for client authentication\n             client_id: client ID\n             client_secret: client secret to use to authenticate the client\n             private_key: private key to sign client assertions\n             authorization_server_jwks: the current authorization server JWKS keys\n             session: a requests Session to use to retrieve the document and initialise the client with\n             https: (deprecated) if `True`, validates that urls in the discovery document use the https scheme\n             testing: if True, don't try to validate the endpoint urls that are part of the document\n             **kwargs: additional args that will be passed to OAuth2Client\n\n        Returns:\n            an `OAuth2Client` initialized with the endpoints from the discovery document\n\n        Raises:\n            InvalidDiscoveryDocument: if the document does not contain at least a `\"token_endpoint\"`.\n\n        \"\"\"\n        if not https:\n            warnings.warn(\n                \"\"\"\\\nThe https parameter is deprecated.\nTo disable endpoint uri validation, set `testing=True` when initializing your `OAuth2Client`.\"\"\",\n                stacklevel=1,\n            )\n            testing = True\n        if issuer and discovery.get(\"issuer\") != issuer:\n            msg = (\n                f\"Mismatching `issuer` value in discovery document\"\n                f\" (received '{discovery.get('issuer')}', expected '{issuer}')\"\n            )\n            raise InvalidParam(\n                msg,\n                issuer,\n                discovery.get(\"issuer\"),\n            )\n        if issuer is None:\n            issuer = discovery.get(\"issuer\")\n\n        token_endpoint = discovery.get(Endpoints.TOKEN)\n        if token_endpoint is None:\n            msg = \"token_endpoint not found in that discovery document\"\n            raise InvalidDiscoveryDocument(msg, discovery)\n        authorization_endpoint = discovery.get(Endpoints.AUTHORIZATION)\n        revocation_endpoint = discovery.get(Endpoints.REVOCATION)\n        introspection_endpoint = discovery.get(Endpoints.INSTROSPECTION)\n        userinfo_endpoint = discovery.get(Endpoints.USER_INFO)\n        jwks_uri = discovery.get(Endpoints.JWKS)\n        if jwks_uri is not None:\n            validate_endpoint_uri(jwks_uri, https=https)\n        authorization_response_iss_parameter_supported = discovery.get(\n            \"authorization_response_iss_parameter_supported\",\n            False,\n        )\n\n        return cls(\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            session=session,\n            issuer=issuer,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            testing=testing,\n            **kwargs,\n        )\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Allow using `OAuth2Client` as a context-manager.\n\n        The Authorization Server public keys are retrieved on `__enter__`.\n\n        \"\"\"\n        self.update_authorization_server_public_keys()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; bool:\n        return True\n\n    def _require_endpoint(self, endpoint: str) -&gt; str:\n        \"\"\"Check that a required endpoint url is set.\"\"\"\n        url = getattr(self, endpoint, None)\n        if not url:\n            raise MissingEndpointUri(endpoint)\n\n        return str(url)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_id","title":"<code>client_id: str</code>  <code>property</code>","text":"<p>Client ID.</p>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_secret","title":"<code>client_secret: str | None</code>  <code>property</code>","text":"<p>Client Secret.</p>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_jwks","title":"<code>client_jwks: JwkSet</code>  <code>property</code>","text":"<p>A <code>JwkSet</code> containing the public keys for this client.</p> <p>Keys are:</p> <ul> <li>the public key for client assertion signature verification (if using private_key_jwt)</li> <li>the ID Token encryption key</li> </ul>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.validate_endpoint_uri","title":"<code>validate_endpoint_uri(attribute, uri)</code>","text":"<p>Validate that an endpoint URI is suitable for use.</p> <p>If you need to disable some checks (for AS testing purposes only!), provide a different method here.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@token_endpoint.validator\n@revocation_endpoint.validator\n@introspection_endpoint.validator\n@userinfo_endpoint.validator\n@authorization_endpoint.validator\n@backchannel_authentication_endpoint.validator\n@device_authorization_endpoint.validator\n@pushed_authorization_request_endpoint.validator\n@jwks_uri.validator\ndef validate_endpoint_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n    \"\"\"Validate that an endpoint URI is suitable for use.\n\n    If you need to disable some checks (for AS testing purposes only!), provide a different\n    method here.\n\n    \"\"\"\n    if self.testing or uri is None:\n        return uri\n    try:\n        return validate_endpoint_uri(uri)\n    except InvalidUri as exc:\n        raise InvalidEndpointUri(endpoint=attribute.name, uri=uri, exc=exc) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.validate_issuer_uri","title":"<code>validate_issuer_uri(attribute, uri)</code>","text":"<p>Validate that an Issuer identifier is suitable for use.</p> <p>This is the same check as an endpoint URI, but the path may be (and usually is) empty.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@issuer.validator\ndef validate_issuer_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n    \"\"\"Validate that an Issuer identifier is suitable for use.\n\n    This is the same check as an endpoint URI, but the path may be (and usually is) empty.\n\n    \"\"\"\n    if self.testing or uri is None:\n        return uri\n    try:\n        return validate_issuer_uri(uri)\n    except InvalidUri as exc:\n        raise InvalidIssuer(attribute.name, uri, exc) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.token_request","title":"<code>token_request(data, timeout=10, **requests_kwargs)</code>","text":"<p>Send a request to the token endpoint.</p> <p>Authentication will be added automatically based on the defined <code>auth</code> for this client.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>parameters to send to the token endpoint. Items with a <code>None</code>    or empty value will not be sent in the request.</p> required <code>timeout</code> <code>int</code> <p>a timeout value for the call</p> <code>10</code> <code>**requests_kwargs</code> <code>Any</code> <p>additional parameters for requests.post()</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>the token endpoint response, as</p> <code>BearerToken</code> <p><code>BearerToken</code> instance.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def token_request(\n    self,\n    data: dict[str, Any],\n    timeout: int = 10,\n    **requests_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint.\n\n    Authentication will be added automatically based on the defined `auth` for this client.\n\n    Args:\n      data: parameters to send to the token endpoint. Items with a `None`\n           or empty value will not be sent in the request.\n      timeout: a timeout value for the call\n      **requests_kwargs: additional parameters for requests.post()\n\n    Returns:\n        the token endpoint response, as\n        [`BearerToken`][requests_oauth2client.tokens.BearerToken] instance.\n\n    \"\"\"\n    return self._request(\n        Endpoints.TOKEN,\n        auth=self.auth,\n        data=data,\n        timeout=timeout,\n        on_success=self.parse_token_response,\n        on_failure=self.on_token_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_token_response","title":"<code>parse_token_response(response)</code>","text":"<p>Parse a Response returned by the Token Endpoint.</p> <p>Invoked by token_request to parse responses returned by the Token Endpoint. Those responses contain an <code>access_token</code> and additional attributes.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response returned by the Token Endpoint.</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> based on the response</p> <code>BearerToken</code> <p>contents.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_token_response(self, response: requests.Response) -&gt; BearerToken:\n    \"\"\"Parse a Response returned by the Token Endpoint.\n\n    Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse\n    responses returned by the Token Endpoint. Those responses contain an `access_token` and\n    additional attributes.\n\n    Args:\n        response: the [Response][requests.Response] returned by the Token Endpoint.\n\n    Returns:\n        a [`BearerToken`][requests_oauth2client.tokens.BearerToken] based on the response\n        contents.\n\n    \"\"\"\n    try:\n        token_response = self.token_class(**response.json())\n    except Exception:  # noqa: BLE001\n        return self.on_token_error(response)\n    else:\n        return token_response\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_token_error","title":"<code>on_token_error(response)</code>","text":"<p>Error handler for <code>token_request()</code>.</p> <p>Invoked by token_request when the Token Endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response returned by the Token Endpoint.</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>nothing, and raises an exception instead. But a subclass may return a</p> <code>BearerToken</code> <p><code>BearerToken</code> to implement a default</p> <code>BearerToken</code> <p>behaviour if needed.</p> <p>Raises:</p> Type Description <code>InvalidTokenResponse</code> <p>if the error response does not contain an OAuth 2.0 standard error response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_token_error(self, response: requests.Response) -&gt; BearerToken:\n    \"\"\"Error handler for `token_request()`.\n\n    Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the\n    Token Endpoint returns an error.\n\n    Args:\n        response: the [Response][requests.Response] returned by the Token Endpoint.\n\n    Returns:\n        nothing, and raises an exception instead. But a subclass may return a\n        [`BearerToken`][requests_oauth2client.tokens.BearerToken] to implement a default\n        behaviour if needed.\n\n    Raises:\n        InvalidTokenResponse: if the error response does not contain an OAuth 2.0 standard\n            error response.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidTokenResponse(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_credentials","title":"<code>client_credentials(scope=None, *, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint using the <code>client_credentials</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>str | Iterable[str] | None</code> <p>the scope to send with the request. Can be a str, or an iterable of str. to pass that way include <code>scope</code>, <code>audience</code>, <code>resource</code>, etc.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>. Common parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> <p>Raises:</p> Type Description <code>InvalidScopeParam</code> <p>if the <code>scope</code> parameter is not suitable</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def client_credentials(\n    self,\n    scope: str | Iterable[str] | None = None,\n    *,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint using the `client_credentials` grant.\n\n    Args:\n        scope: the scope to send with the request. Can be a str, or an iterable of str.\n            to pass that way include `scope`, `audience`, `resource`, etc.\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`. Common parameters\n\n    Returns:\n        a BearerToken\n\n    Raises:\n        InvalidScopeParam: if the `scope` parameter is not suitable\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if scope and not isinstance(scope, str):\n        try:\n            scope = \" \".join(scope)\n        except Exception as exc:\n            raise InvalidScopeParam(scope) from exc\n\n    data = dict(grant_type=GrantTypes.CLIENT_CREDENTIALS, scope=scope, **token_kwargs)\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorization_code","title":"<code>authorization_code(code, *, validate=True, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint with the <code>authorization_code</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str | AuthorizationResponse</code> <p>an authorization code or an <code>AuthorizationResponse</code> to exchange for tokens</p> required <code>validate</code> <code>bool</code> <p>if <code>True</code>, validate the received ID Token (this works only if <code>code</code> is an AuthorizationResponse)</p> <code>True</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>code</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorization_code(\n    self,\n    code: str | AuthorizationResponse,\n    *,\n    validate: bool = True,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint with the `authorization_code` grant.\n\n    Args:\n         code: an authorization code or an `AuthorizationResponse` to exchange for tokens\n         validate: if `True`, validate the received ID Token (this works only if `code` is an AuthorizationResponse)\n         requests_kwargs: additional parameters for the call to requests\n         **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `code`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    \"\"\"\n    azr: AuthorizationResponse | None = None\n    if isinstance(code, AuthorizationResponse):\n        token_kwargs.setdefault(\"code_verifier\", code.code_verifier)\n        token_kwargs.setdefault(\"redirect_uri\", code.redirect_uri)\n        azr = code\n        code = code.code\n\n    requests_kwargs = requests_kwargs or {}\n\n    data = dict(grant_type=GrantTypes.AUTHORIZATION_CODE, code=code, **token_kwargs)\n    token = self.token_request(data, **requests_kwargs)\n    if validate and token.id_token and isinstance(azr, AuthorizationResponse):\n        return token.validate_id_token(self, azr)\n    return token\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.refresh_token","title":"<code>refresh_token(refresh_token, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint with the <code>refresh_token</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str | BearerToken</code> <p>a refresh_token, as a string, or as a <code>BearerToken</code>. That <code>BearerToken</code> must have a <code>refresh_token</code>.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to <code>requests</code></p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>refresh_token</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> <p>Raises:</p> Type Description <code>MissingRefreshToken</code> <p>if <code>refresh_token</code> is a BearerToken instance but does not contain a <code>refresh_token</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def refresh_token(\n    self,\n    refresh_token: str | BearerToken,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint with the `refresh_token` grant.\n\n    Args:\n        refresh_token: a refresh_token, as a string, or as a `BearerToken`.\n            That `BearerToken` must have a `refresh_token`.\n        requests_kwargs: additional parameters for the call to `requests`\n        **token_kwargs: additional parameters for the token endpoint,\n            alongside `grant_type`, `refresh_token`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    Raises:\n        MissingRefreshToken: if `refresh_token` is a BearerToken instance but does not\n            contain a `refresh_token`\n\n    \"\"\"\n    if isinstance(refresh_token, BearerToken):\n        if refresh_token.refresh_token is None or not isinstance(refresh_token.refresh_token, str):\n            raise MissingRefreshToken(refresh_token)\n        refresh_token = refresh_token.refresh_token\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(grant_type=GrantTypes.REFRESH_TOKEN, refresh_token=refresh_token, **token_kwargs)\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.device_code","title":"<code>device_code(device_code, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint using the Device Code grant.</p> <p>The grant_type is <code>urn:ietf:params:oauth:grant-type:device_code</code>. This needs a Device Code, or a <code>DeviceAuthorizationResponse</code> as parameter.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a device code, or a <code>DeviceAuthorizationResponse</code></p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>device_code</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> <p>Raises:</p> Type Description <code>MissingDeviceCode</code> <p>if <code>device_code</code> is a DeviceAuthorizationResponse but does not contain a <code>device_code</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def device_code(\n    self,\n    device_code: str | DeviceAuthorizationResponse,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint using the Device Code grant.\n\n    The grant_type is `urn:ietf:params:oauth:grant-type:device_code`. This needs a Device Code,\n    or a `DeviceAuthorizationResponse` as parameter.\n\n    Args:\n        device_code: a device code, or a `DeviceAuthorizationResponse`\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    Raises:\n        MissingDeviceCode: if `device_code` is a DeviceAuthorizationResponse but does not\n            contain a `device_code`.\n\n    \"\"\"\n    if isinstance(device_code, DeviceAuthorizationResponse):\n        if device_code.device_code is None or not isinstance(device_code.device_code, str):\n            raise MissingDeviceCode(device_code)\n        device_code = device_code.device_code\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantTypes.DEVICE_CODE,\n        device_code=device_code,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.ciba","title":"<code>ciba(auth_req_id, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a CIBA request to the Token Endpoint.</p> <p>A CIBA request is a Token Request using the <code>urn:openid:params:grant-type:ciba</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>auth_req_id</code> <code>str | BackChannelAuthenticationResponse</code> <p>an authentication request ID, as returned by the AS</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>auth_req_id</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> <p>Raises:</p> Type Description <code>MissingAuthRequestId</code> <p>if <code>auth_req_id</code> is a BackChannelAuthenticationResponse but does not contain an <code>auth_req_id</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def ciba(\n    self,\n    auth_req_id: str | BackChannelAuthenticationResponse,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a CIBA request to the Token Endpoint.\n\n    A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant.\n\n    Args:\n        auth_req_id: an authentication request ID, as returned by the AS\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    Raises:\n        MissingAuthRequestId: if `auth_req_id` is a BackChannelAuthenticationResponse but does not contain\n            an `auth_req_id`.\n\n    \"\"\"\n    if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n        if auth_req_id.auth_req_id is None or not isinstance(auth_req_id.auth_req_id, str):\n            raise MissingAuthRequestId(auth_req_id)\n        auth_req_id = auth_req_id.auth_req_id\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantTypes.CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION,\n        auth_req_id=auth_req_id,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.token_exchange","title":"<code>token_exchange(subject_token, subject_token_type=None, actor_token=None, actor_token_type=None, requested_token_type=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a Token Exchange request.</p> <p>A Token Exchange request is actually a request to the Token Endpoint with a grant_type <code>urn:ietf:params:oauth:grant-type:token-exchange</code>.</p> <p>Parameters:</p> Name Type Description Default <code>subject_token</code> <code>str | BearerToken | IdToken</code> <p>the subject token to exchange for a new token.</p> required <code>subject_token_type</code> <code>str | None</code> <p>a token type identifier for the subject_token, mandatory if it cannot be guessed based on <code>type(subject_token)</code>.</p> <code>None</code> <code>actor_token</code> <code>None | str | BearerToken | IdToken</code> <p>the actor token to include in the request, if any.</p> <code>None</code> <code>actor_token_type</code> <code>str | None</code> <p>a token type identifier for the actor_token, mandatory if it cannot be guessed based on <code>type(actor_token)</code>.</p> <code>None</code> <code>requested_token_type</code> <code>str | None</code> <p>a token type identifier for the requested token.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> as returned by the Authorization Server.</p> <p>Raises:</p> Type Description <code>UnknownSubjectTokenType</code> <p>if the type of <code>subject_token</code> cannot be determined automatically.</p> <code>UnknownActorTokenType</code> <p>if the type of <code>actor_token</code> cannot be determined automaticatlly.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def token_exchange(\n    self,\n    subject_token: str | BearerToken | IdToken,\n    subject_token_type: str | None = None,\n    actor_token: None | str | BearerToken | IdToken = None,\n    actor_token_type: str | None = None,\n    requested_token_type: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a Token Exchange request.\n\n    A Token Exchange request is actually a request to the Token Endpoint with a grant_type\n    `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n    Args:\n        subject_token: the subject token to exchange for a new token.\n        subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based\n            on `type(subject_token)`.\n        actor_token: the actor token to include in the request, if any.\n        actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based\n            on `type(actor_token)`.\n        requested_token_type: a token type identifier for the requested token.\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        a `BearerToken` as returned by the Authorization Server.\n\n    Raises:\n        UnknownSubjectTokenType: if the type of `subject_token` cannot be determined automatically.\n        UnknownActorTokenType: if the type of `actor_token` cannot be determined automaticatlly.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    try:\n        subject_token_type = self.get_token_type(subject_token_type, subject_token)\n    except ValueError as exc:\n        raise UnknownSubjectTokenType(subject_token, subject_token_type) from exc\n    if actor_token:  # pragma: no branch\n        try:\n            actor_token_type = self.get_token_type(actor_token_type, actor_token)\n        except ValueError as exc:\n            raise UnknownActorTokenType(actor_token, actor_token_type) from exc\n\n    data = dict(\n        grant_type=GrantTypes.TOKEN_EXCHANGE,\n        subject_token=subject_token,\n        subject_token_type=subject_token_type,\n        actor_token=actor_token,\n        actor_token_type=actor_token_type,\n        requested_token_type=requested_token_type,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.jwt_bearer","title":"<code>jwt_bearer(assertion, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request using a JWT as authorization grant.</p> <p>This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).</p> <p>Parameters:</p> Name Type Description Default <code>assertion</code> <code>Jwt | str</code> <p>a JWT (as an instance of <code>jwskate.Jwt</code> or as a <code>str</code>) to use as authorization grant.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> as returned by the Authorization Server.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def jwt_bearer(\n    self,\n    assertion: Jwt | str,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request using a JWT as authorization grant.\n\n    This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).\n\n    Args:\n        assertion: a JWT (as an instance of `jwskate.Jwt` or as a `str`) to use as authorization grant.\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        a `BearerToken` as returned by the Authorization Server.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if not isinstance(assertion, Jwt):\n        assertion = Jwt(assertion)\n\n    data = dict(\n        grant_type=GrantTypes.JWT_BEARER,\n        assertion=assertion,\n        **token_kwargs,\n    )\n\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.resource_owner_password","title":"<code>resource_owner_password(username, password, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request using the Resource Owner Password Grant.</p> <p>This Grant Type is deprecated and should only be used when there is no other choice.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>the resource owner user name</p> required <code>password</code> <code>str</code> <p>the resource owner password</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> as returned by the Authorization Server</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def resource_owner_password(\n    self,\n    username: str,\n    password: str,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request using the Resource Owner Password Grant.\n\n    This Grant Type is deprecated and should only be used when there is no other choice.\n\n    Args:\n        username: the resource owner user name\n        password: the resource owner password\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        a `BearerToken` as returned by the Authorization Server\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantTypes.RESOURCE_OWNER_PASSWORD,\n        username=username,\n        password=password,\n        **token_kwargs,\n    )\n\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorization_request","title":"<code>authorization_request(*, scope='openid', response_type=ResponseTypes.CODE, redirect_uri=None, state=..., nonce=..., code_verifier=None, **kwargs)</code>","text":"<p>Generate an Authorization Request for this client.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>None | str | Iterable[str]</code> <p>the <code>scope</code> to use</p> <code>'openid'</code> <code>response_type</code> <code>str</code> <p>the <code>response_type</code> to use</p> <code>CODE</code> <code>redirect_uri</code> <code>str | None</code> <p>the <code>redirect_uri</code> to include in the request. By default, the <code>redirect_uri</code> defined at init time is used.</p> <code>None</code> <code>state</code> <code>str | ellipsis | None</code> <p>the <code>state</code> parameter to use. Leave default to generate a random value.</p> <code>...</code> <code>nonce</code> <code>str | ellipsis | None</code> <p>a <code>nonce</code>. Leave default to generate a random value.</p> <code>...</code> <code>code_verifier</code> <code>str | None</code> <p>the PKCE <code>code_verifier</code> to use. Leave default to generate a random value.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters to include in the auth request</p> <code>{}</code> <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>an AuthorizationRequest with the supplied parameters</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorization_request(\n    self,\n    *,\n    scope: None | str | Iterable[str] = \"openid\",\n    response_type: str = ResponseTypes.CODE,\n    redirect_uri: str | None = None,\n    state: str | ellipsis | None = ...,  # noqa: F821\n    nonce: str | ellipsis | None = ...,  # noqa: F821\n    code_verifier: str | None = None,\n    **kwargs: Any,\n) -&gt; AuthorizationRequest:\n    \"\"\"Generate an Authorization Request for this client.\n\n    Args:\n        scope: the `scope` to use\n        response_type: the `response_type` to use\n        redirect_uri: the `redirect_uri` to include in the request. By default,\n            the `redirect_uri` defined at init time is used.\n        state: the `state` parameter to use. Leave default to generate a random value.\n        nonce: a `nonce`. Leave default to generate a random value.\n        code_verifier: the PKCE `code_verifier` to use. Leave default to generate a random value.\n        **kwargs: additional parameters to include in the auth request\n\n    Returns:\n        an AuthorizationRequest with the supplied parameters\n\n    \"\"\"\n    authorization_endpoint = self._require_endpoint(\"authorization_endpoint\")\n\n    redirect_uri = redirect_uri or self.redirect_uri\n\n    return AuthorizationRequest(\n        authorization_endpoint=authorization_endpoint,\n        client_id=self.client_id,\n        redirect_uri=redirect_uri,\n        issuer=self.issuer,\n        response_type=response_type,\n        scope=scope,\n        state=state,\n        nonce=nonce,\n        code_verifier=code_verifier,\n        code_challenge_method=self.code_challenge_method,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.pushed_authorization_request","title":"<code>pushed_authorization_request(authorization_request, requests_kwargs=None)</code>","text":"<p>Send a Pushed Authorization Request.</p> <p>This sends a request to the Pushed Authorization Request Endpoint, and returns a <code>RequestUriParameterAuthorizationRequest</code> initialized with the AS response.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_request</code> <code>AuthorizationRequest</code> <p>the authorization request to send</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for <code>requests.request()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>the <code>RequestUriParameterAuthorizationRequest</code> initialized based on the AS response</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def pushed_authorization_request(\n    self,\n    authorization_request: AuthorizationRequest,\n    requests_kwargs: dict[str, Any] | None = None,\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Send a Pushed Authorization Request.\n\n    This sends a request to the Pushed Authorization Request Endpoint, and returns a\n    `RequestUriParameterAuthorizationRequest` initialized with the AS response.\n\n    Args:\n        authorization_request: the authorization request to send\n        requests_kwargs: additional parameters for `requests.request()`\n\n    Returns:\n        the `RequestUriParameterAuthorizationRequest` initialized based on the AS response\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n    return self._request(\n        Endpoints.PUSHED_AUTHORIZATION_REQUEST,\n        data=authorization_request.args,\n        auth=self.auth,\n        on_success=self.parse_pushed_authorization_response,\n        on_failure=self.on_pushed_authorization_request_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_pushed_authorization_response","title":"<code>parse_pushed_authorization_response(response)</code>","text":"<p>Parse the response obtained by <code>pushed_authorization_request()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the <code>requests.Response</code> returned by the PAR endpoint</p> required <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>a RequestUriParameterAuthorizationRequest instance</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_pushed_authorization_response(\n    self,\n    response: requests.Response,\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Parse the response obtained by `pushed_authorization_request()`.\n\n    Args:\n        response: the `requests.Response` returned by the PAR endpoint\n\n    Returns:\n        a RequestUriParameterAuthorizationRequest instance\n\n    \"\"\"\n    response_json = response.json()\n    request_uri = response_json.get(\"request_uri\")\n    expires_in = response_json.get(\"expires_in\")\n\n    return RequestUriParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request_uri=request_uri,\n        expires_in=expires_in,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_pushed_authorization_request_error","title":"<code>on_pushed_authorization_request_error(response)</code>","text":"<p>Error Handler for Pushed Authorization Endpoint errors.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the HTTP response as returned by the AS PAR endpoint.</p> required <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>a RequestUriParameterAuthorizationRequest, if the error is recoverable</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>a subclass of this error depending on the error returned by the AS</p> <code>InvalidPushedAuthorizationResponse</code> <p>if the returned response is not following the specifications</p> <code>UnknownTokenEndpointError</code> <p>for unknown/unhandled errors</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_pushed_authorization_request_error(\n    self,\n    response: requests.Response,\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Error Handler for Pushed Authorization Endpoint errors.\n\n    Args:\n        response: the HTTP response as returned by the AS PAR endpoint.\n\n    Returns:\n        a RequestUriParameterAuthorizationRequest, if the error is recoverable\n\n    Raises:\n        EndpointError: a subclass of this error depending on the error returned by the AS\n        InvalidPushedAuthorizationResponse: if the returned response is not following the\n            specifications\n        UnknownTokenEndpointError: for unknown/unhandled errors\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidPushedAuthorizationResponse(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.userinfo","title":"<code>userinfo(access_token)</code>","text":"<p>Call the UserInfo endpoint.</p> <p>This sends a request to the UserInfo endpoint, with the specified access_token, and returns the parsed result.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>BearerToken | str</code> <p>the access token to use</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the Response returned by the userinfo endpoint.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def userinfo(self, access_token: BearerToken | str) -&gt; Any:\n    \"\"\"Call the UserInfo endpoint.\n\n    This sends a request to the UserInfo endpoint, with the specified access_token, and returns\n    the parsed result.\n\n    Args:\n        access_token: the access token to use\n\n    Returns:\n        the [Response][requests.Response] returned by the userinfo endpoint.\n\n    \"\"\"\n    if isinstance(access_token, str):\n        access_token = BearerToken(access_token)\n    return self._request(\n        Endpoints.USER_INFO,\n        auth=access_token,\n        on_success=self.parse_userinfo_response,\n        on_failure=self.on_userinfo_error,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_userinfo_response","title":"<code>parse_userinfo_response(resp)</code>","text":"<p>Parse the response obtained by <code>userinfo()</code>.</p> <p>Invoked by userinfo() to parse the response from the UserInfo endpoint, this will extract and return its JSON content.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>a Response returned from the UserInfo endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the parsed JSON content from this response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_userinfo_response(self, resp: requests.Response) -&gt; Any:\n    \"\"\"Parse the response obtained by `userinfo()`.\n\n    Invoked by [userinfo()][requests_oauth2client.client.OAuth2Client.userinfo] to parse the\n    response from the UserInfo endpoint, this will extract and return its JSON content.\n\n    Args:\n        resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n    Returns:\n        the parsed JSON content from this response.\n\n    \"\"\"\n    return resp.json()\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_userinfo_error","title":"<code>on_userinfo_error(resp)</code>","text":"<p>Parse UserInfo error response.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>a Response returned from the UserInfo endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>nothing, raises exception instead.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_userinfo_error(self, resp: requests.Response) -&gt; Any:\n    \"\"\"Parse UserInfo error response.\n\n    Args:\n        resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n    Returns:\n        nothing, raises exception instead.\n\n    \"\"\"\n    resp.raise_for_status()\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.get_token_type","title":"<code>get_token_type(token_type=None, token=None)</code>  <code>classmethod</code>","text":"<p>Get standardized token type identifiers.</p> <p>Return a standardized token type identifier, based on a short <code>token_type</code> hint and/or a token value.</p> <p>Parameters:</p> Name Type Description Default <code>token_type</code> <code>str | None</code> <p>a token_type hint, as <code>str</code>. May be \"access_token\", \"refresh_token\" or \"id_token\"</p> <code>None</code> <code>token</code> <code>None | str | BearerToken | IdToken</code> <p>a token value, as an instance of <code>BearerToken</code> or IdToken, or as a <code>str</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the token_type as defined in the Token Exchange RFC8693.</p> <p>Raises:</p> Type Description <code>UnknownTokenType</code> <p>if the type of token cannot be determined</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>    @classmethod\n    def get_token_type(  # noqa: C901\n        cls,\n        token_type: str | None = None,\n        token: None | str | BearerToken | IdToken = None,\n    ) -&gt; str:\n        \"\"\"Get standardized token type identifiers.\n\n        Return a standardized token type identifier, based on a short `token_type` hint and/or a\n        token value.\n\n        Args:\n            token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\"\n                or \"id_token\"\n            token: a token value, as an instance of `BearerToken` or IdToken, or as a `str`.\n\n        Returns:\n            the token_type as defined in the Token Exchange RFC8693.\n\n        Raises:\n            UnknownTokenType: if the type of token cannot be determined\n\n        \"\"\"\n        if not (token_type or token):\n            msg = \"Cannot determine type of an empty token without a token_type hint\"\n            raise UnknownTokenType(msg, token, token_type)\n\n        if token_type is None:\n            if isinstance(token, str):\n                msg = \"\"\"\\\nCannot determine the type of provided token when it is a bare `str`. Please specify a 'token_type'.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            if isinstance(token, BearerToken):\n                return \"urn:ietf:params:oauth:token-type:access_token\"\n            if isinstance(token, IdToken):\n                return \"urn:ietf:params:oauth:token-type:id_token\"\n            msg = f\"Unknown token type {type(token)}\"\n            raise UnknownTokenType(msg, token, token_type)\n        if token_type == TokenType.ACCESS_TOKEN:\n            if token is not None and not isinstance(token, (str, BearerToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nA BearerToken or an access_token as a `str` is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:access_token\"\n        if token_type == TokenType.REFRESH_TOKEN:\n            if token is not None and isinstance(token, BearerToken) and not token.refresh_token:\n                msg = f\"\"\"\\\nThe supplied BearerToken does not contain a refresh_token, which is inconsistent with token_type '{token_type}'.\nA BearerToken containing a refresh_token is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:refresh_token\"\n        if token_type == TokenType.ID_TOKEN:\n            if token is not None and not isinstance(token, (str, IdToken)):\n                msg = f\"\"\"\\\nThe supplied token is of type '{type(token)}' which is inconsistent with token_type '{token_type}'.\nAn IdToken or a string representation of it is expected.\n\"\"\"\n                raise UnknownTokenType(msg, token, token_type)\n            return \"urn:ietf:params:oauth:token-type:id_token\"\n\n        return {\n            \"saml1\": \"urn:ietf:params:oauth:token-type:saml1\",\n            \"saml2\": \"urn:ietf:params:oauth:token-type:saml2\",\n            \"jwt\": \"urn:ietf:params:oauth:token-type:jwt\",\n        }.get(token_type, token_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_access_token","title":"<code>revoke_access_token(access_token, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a request to the Revocation Endpoint to revoke an access token.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>BearerToken | str</code> <p>the access token to revoke</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the underlying requests.post() call</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to pass to the revocation endpoint</p> <code>{}</code> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_access_token(\n    self,\n    access_token: BearerToken | str,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a request to the Revocation Endpoint to revoke an access token.\n\n    Args:\n        access_token: the access token to revoke\n        requests_kwargs: additional parameters for the underlying requests.post() call\n        **revoke_kwargs: additional parameters to pass to the revocation endpoint\n\n    \"\"\"\n    return self.revoke_token(\n        access_token,\n        token_type_hint=TokenType.ACCESS_TOKEN,\n        requests_kwargs=requests_kwargs,\n        **revoke_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_refresh_token","title":"<code>revoke_refresh_token(refresh_token, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a request to the Revocation Endpoint to revoke a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str | BearerToken</code> <p>the refresh token to revoke.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the revocation endpoint.</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to pass to the revocation endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the revocation request is successful, <code>False</code> if this client has no configured</p> <code>bool</code> <p>revocation endpoint.</p> <p>Raises:</p> Type Description <code>MissingRefreshToken</code> <p>when <code>refresh_token</code> is a BearerToken but does not contain a <code>refresh_token</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_refresh_token(\n    self,\n    refresh_token: str | BearerToken,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a request to the Revocation Endpoint to revoke a refresh token.\n\n    Args:\n        refresh_token: the refresh token to revoke.\n        requests_kwargs: additional parameters to pass to the revocation endpoint.\n        **revoke_kwargs: additional parameters to pass to the revocation endpoint.\n\n    Returns:\n        `True` if the revocation request is successful, `False` if this client has no configured\n        revocation endpoint.\n\n    Raises:\n        MissingRefreshToken: when `refresh_token` is a [BearerToken][requests_oauth2client.tokens.BearerToken]\n            but does not contain a `refresh_token`.\n\n    \"\"\"\n    if isinstance(refresh_token, BearerToken):\n        if refresh_token.refresh_token is None:\n            raise MissingRefreshToken(refresh_token)\n        refresh_token = refresh_token.refresh_token\n\n    return self.revoke_token(\n        refresh_token,\n        token_type_hint=TokenType.REFRESH_TOKEN,\n        requests_kwargs=requests_kwargs,\n        **revoke_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_token","title":"<code>revoke_token(token, token_type_hint=None, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a Token Revocation request.</p> <p>By default, authentication will be the same than the one used for the Token Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str | BearerToken</code> <p>the token to revoke.</p> required <code>token_type_hint</code> <code>str | None</code> <p>a token_type_hint to send to the revocation endpoint.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to the underling call to requests.post()</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to send to the revocation endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the revocation succeeds, <code>False</code> if no revocation endpoint is present or a</p> <code>bool</code> <p>non-standardised error is returned.</p> <p>Raises:</p> Type Description <code>MissingEndpointUri</code> <p>if the Revocation Endpoint URI is not configured.</p> <code>MissingRefreshToken</code> <p>if <code>token_type_hint</code> is <code>\"refresh_token\"</code> and <code>token</code> is a BearerToken but does not contain a <code>refresh_token</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_token(\n    self,\n    token: str | BearerToken,\n    token_type_hint: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a Token Revocation request.\n\n    By default, authentication will be the same than the one used for the Token Endpoint.\n\n    Args:\n        token: the token to revoke.\n        token_type_hint: a token_type_hint to send to the revocation endpoint.\n        requests_kwargs: additional parameters to the underling call to requests.post()\n        **revoke_kwargs: additional parameters to send to the revocation endpoint.\n\n    Returns:\n        `True` if the revocation succeeds, `False` if no revocation endpoint is present or a\n        non-standardised error is returned.\n\n    Raises:\n        MissingEndpointUri: if the Revocation Endpoint URI is not configured.\n        MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n            but does not contain a `refresh_token`.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if token_type_hint == TokenType.REFRESH_TOKEN and isinstance(token, BearerToken):\n        if token.refresh_token is None:\n            raise MissingRefreshToken(token)\n        token = token.refresh_token\n\n    data = dict(revoke_kwargs, token=str(token))\n    if token_type_hint:\n        data[\"token_type_hint\"] = token_type_hint\n\n    return self._request(\n        Endpoints.REVOCATION,\n        data=data,\n        auth=self.auth,\n        on_success=lambda _: True,\n        on_failure=self.on_revocation_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_revocation_error","title":"<code>on_revocation_error(response)</code>","text":"<p>Error handler for <code>revoke_token()</code>.</p> <p>Invoked by revoke_token() when the revocation endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response as returned by the Revocation Endpoint</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>False</code> to signal that an error occurred. May raise exceptions instead depending on the</p> <code>bool</code> <p>revocation response.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>if the response contains a standardised OAuth 2.0 error.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_revocation_error(self, response: requests.Response) -&gt; bool:\n    \"\"\"Error handler for `revoke_token()`.\n\n    Invoked by [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token] when the\n    revocation endpoint returns an error.\n\n    Args:\n        response: the [Response][requests.Response] as returned by the Revocation Endpoint\n\n    Returns:\n        `False` to signal that an error occurred. May raise exceptions instead depending on the\n        revocation response.\n\n    Raises:\n        EndpointError: if the response contains a standardised OAuth 2.0 error.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, RevocationError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception:  # noqa: BLE001\n        return False\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.introspect_token","title":"<code>introspect_token(token, token_type_hint=None, requests_kwargs=None, **introspect_kwargs)</code>","text":"<p>Send a request to the Introspection Endpoint.</p> <p>Parameter <code>token</code> can be:</p> <ul> <li>a <code>str</code></li> <li>a <code>BearerToken</code> instance</li> </ul> <p>You may pass any arbitrary <code>token</code> and <code>token_type_hint</code> values as <code>str</code>. Those will be included in the request, as-is. If <code>token</code> is a <code>BearerToken</code>, then <code>token_type_hint</code> must be either:</p> <ul> <li><code>None</code>: the access_token will be instrospected and no token_type_hint will be included in the request</li> <li><code>access_token</code>: same as <code>None</code>, but the token_type_hint will be included</li> <li>or <code>refresh_token</code>: only available if a Refresh Token is present in the BearerToken.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str | BearerToken</code> <p>the token to instrospect</p> required <code>token_type_hint</code> <code>str | None</code> <p>the <code>token_type_hint</code> to include in the request.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to the underling call to requests.post()</p> <code>None</code> <code>**introspect_kwargs</code> <code>Any</code> <p>additional parameters to send to the introspection endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>the response as returned by the Introspection Endpoint.</p> <p>Raises:</p> Type Description <code>MissingRefreshToken</code> <p>if <code>token_type_hint</code> is <code>\"refresh_token\"</code> and <code>token</code> is a BearerToken but does not contain a <code>refresh_token</code>.</p> <code>UnknownTokenType</code> <p>if <code>token_type_hint</code> is neither <code>None</code>, <code>\"access_token\"</code> or <code>\"refresh_token\"</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>    def introspect_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **introspect_kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"Send a request to the Introspection Endpoint.\n\n        Parameter `token` can be:\n\n        - a `str`\n        - a `BearerToken` instance\n\n        You may pass any arbitrary `token` and `token_type_hint` values as `str`. Those will\n        be included in the request, as-is.\n        If `token` is a `BearerToken`, then `token_type_hint` must be either:\n\n        - `None`: the access_token will be instrospected and no token_type_hint will be included\n        in the request\n        - `access_token`: same as `None`, but the token_type_hint will be included\n        - or `refresh_token`: only available if a Refresh Token is present in the BearerToken.\n\n        Args:\n            token: the token to instrospect\n            token_type_hint: the `token_type_hint` to include in the request.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **introspect_kwargs: additional parameters to send to the introspection endpoint.\n\n        Returns:\n            the response as returned by the Introspection Endpoint.\n\n        Raises:\n            MissingRefreshToken: if `token_type_hint` is `\"refresh_token\"` and `token` is a BearerToken\n                but does not contain a `refresh_token`.\n            UnknownTokenType: if `token_type_hint` is neither `None`, `\"access_token\"` or `\"refresh_token\"`.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if isinstance(token, BearerToken):\n            if token_type_hint is None or token_type_hint == TokenType.ACCESS_TOKEN:\n                token = token.access_token\n            elif token_type_hint == TokenType.REFRESH_TOKEN:\n                if token.refresh_token is None:\n                    raise MissingRefreshToken(token)\n\n                token = token.refresh_token\n            else:\n                msg = \"\"\"\\\nInvalid `token_type_hint`. To test arbitrary `token_type_hint` values, you must provide `token` as a `str`.\"\"\"\n                raise UnknownTokenType(msg, token, token_type_hint)\n\n        data = dict(introspect_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            Endpoints.INSTROSPECTION,\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_introspection_response,\n            on_failure=self.on_introspection_error,\n            **requests_kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_introspection_response","title":"<code>parse_introspection_response(response)</code>","text":"<p>Parse Token Introspection Responses received by <code>introspect_token()</code>.</p> <p>Invoked by introspect_token() to parse the returned response. This decodes the JSON content if possible, otherwise it returns the response as a string.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response as returned by the Introspection Endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the decoded JSON content, or a <code>str</code> with the content.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_introspection_response(self, response: requests.Response) -&gt; Any:\n    \"\"\"Parse Token Introspection Responses received by `introspect_token()`.\n\n    Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n    to parse the returned response. This decodes the JSON content if possible, otherwise it\n    returns the response as a string.\n\n    Args:\n        response: the [Response][requests.Response] as returned by the Introspection Endpoint.\n\n    Returns:\n        the decoded JSON content, or a `str` with the content.\n\n    \"\"\"\n    try:\n        return response.json()\n    except ValueError:\n        return response.text\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_introspection_error","title":"<code>on_introspection_error(response)</code>","text":"<p>Error handler for <code>introspect_token()</code>.</p> <p>Invoked by introspect_token() to parse the returned response in the case an error is returned.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response as returned by the Introspection Endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>usually raises exceptions. A subclass can return a default response instead.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>(or one of its subclasses) if the response contains a standard OAuth 2.0 error.</p> <code>UnknownIntrospectionError</code> <p>if the response is not a standard error response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_introspection_error(self, response: requests.Response) -&gt; Any:\n    \"\"\"Error handler for `introspect_token()`.\n\n    Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n    to parse the returned response in the case an error is returned.\n\n    Args:\n        response: the response as returned by the Introspection Endpoint.\n\n    Returns:\n        usually raises exceptions. A subclass can return a default response instead.\n\n    Raises:\n        EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n        UnknownIntrospectionError: if the response is not a standard error response.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, IntrospectionError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise UnknownIntrospectionError(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.backchannel_authentication_request","title":"<code>backchannel_authentication_request(scope='openid', *, client_notification_token=None, acr_values=None, login_hint_token=None, id_token_hint=None, login_hint=None, binding_message=None, user_code=None, requested_expiry=None, private_jwk=None, alg=None, requests_kwargs=None, **ciba_kwargs)</code>","text":"<p>Send a CIBA Authentication Request.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>None | str | Iterable[str]</code> <p>the scope to include in the request.</p> <code>'openid'</code> <code>client_notification_token</code> <code>str | None</code> <p>the Client Notification Token to include in the request.</p> <code>None</code> <code>acr_values</code> <code>None | str | Iterable[str]</code> <p>the acr values to include in the request.</p> <code>None</code> <code>login_hint_token</code> <code>str | None</code> <p>the Login Hint Token to include in the request.</p> <code>None</code> <code>id_token_hint</code> <code>str | None</code> <p>the ID Token Hint to include in the request.</p> <code>None</code> <code>login_hint</code> <code>str | None</code> <p>the Login Hint to include in the request.</p> <code>None</code> <code>binding_message</code> <code>str | None</code> <p>the Binding Message to include in the request.</p> <code>None</code> <code>user_code</code> <code>str | None</code> <p>the User Code to include in the request</p> <code>None</code> <code>requested_expiry</code> <code>int | None</code> <p>the Requested Expiry, in seconds, to include in the request.</p> <code>None</code> <code>private_jwk</code> <code>Jwk | dict[str, Any] | None</code> <p>the JWK to use to sign the request (optional)</p> <code>None</code> <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for</p> <code>None</code> <code>**ciba_kwargs</code> <code>Any</code> <p>additional parameters to include in the request.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>a BackChannelAuthenticationResponse as returned by AS</p> <p>Raises:</p> Type Description <code>InvalidBackchannelAuthenticationRequestHintParam</code> <p>if none of <code>login_hint</code>, <code>login_hint_token</code> or <code>id_token_hint</code> is provided, or more than one of them is provided.</p> <code>InvalidScopeParam</code> <p>if the <code>scope</code> parameter is invalid.</p> <code>InvalidAcrValuesParam</code> <p>if the <code>acr_values</code> parameter is invalid.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def backchannel_authentication_request(  # noqa: PLR0913\n    self,\n    scope: None | str | Iterable[str] = \"openid\",\n    *,\n    client_notification_token: str | None = None,\n    acr_values: None | str | Iterable[str] = None,\n    login_hint_token: str | None = None,\n    id_token_hint: str | None = None,\n    login_hint: str | None = None,\n    binding_message: str | None = None,\n    user_code: str | None = None,\n    requested_expiry: int | None = None,\n    private_jwk: Jwk | dict[str, Any] | None = None,\n    alg: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **ciba_kwargs: Any,\n) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Send a CIBA Authentication Request.\n\n    Args:\n         scope: the scope to include in the request.\n         client_notification_token: the Client Notification Token to include in the request.\n         acr_values: the acr values to include in the request.\n         login_hint_token: the Login Hint Token to include in the request.\n         id_token_hint: the ID Token Hint to include in the request.\n         login_hint: the Login Hint to include in the request.\n         binding_message: the Binding Message to include in the request.\n         user_code: the User Code to include in the request\n         requested_expiry: the Requested Expiry, in seconds, to include in the request.\n         private_jwk: the JWK to use to sign the request (optional)\n         alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.\n         requests_kwargs: additional parameters for\n         **ciba_kwargs: additional parameters to include in the request.\n\n    Returns:\n        a BackChannelAuthenticationResponse as returned by AS\n\n    Raises:\n        InvalidBackchannelAuthenticationRequestHintParam: if none of `login_hint`, `login_hint_token`\n            or `id_token_hint` is provided, or more than one of them is provided.\n        InvalidScopeParam: if the `scope` parameter is invalid.\n        InvalidAcrValuesParam: if the `acr_values` parameter is invalid.\n\n    \"\"\"\n    if not (login_hint or login_hint_token or id_token_hint):\n        msg = \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n        raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n    if (login_hint_token and id_token_hint) or (login_hint and id_token_hint) or (login_hint_token and login_hint):\n        msg = \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n        raise InvalidBackchannelAuthenticationRequestHintParam(msg)\n\n    requests_kwargs = requests_kwargs or {}\n\n    if scope is not None and not isinstance(scope, str):\n        try:\n            scope = \" \".join(scope)\n        except Exception as exc:\n            raise InvalidScopeParam(scope) from exc\n\n    if acr_values is not None and not isinstance(acr_values, str):\n        try:\n            acr_values = \" \".join(acr_values)\n        except Exception as exc:\n            raise InvalidAcrValuesParam(acr_values) from exc\n\n    data = dict(\n        ciba_kwargs,\n        scope=scope,\n        client_notification_token=client_notification_token,\n        acr_values=acr_values,\n        login_hint_token=login_hint_token,\n        id_token_hint=id_token_hint,\n        login_hint=login_hint,\n        binding_message=binding_message,\n        user_code=user_code,\n        requested_expiry=requested_expiry,\n    )\n\n    if private_jwk is not None:\n        data = {\"request\": str(Jwt.sign(data, key=private_jwk, alg=alg))}\n\n    return self._request(\n        Endpoints.BACKCHANNEL_AUTHENTICATION,\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_backchannel_authentication_response,\n        on_failure=self.on_backchannel_authentication_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_backchannel_authentication_response","title":"<code>parse_backchannel_authentication_response(response)</code>","text":"<p>Parse a response received by <code>backchannel_authentication_request()</code>.</p> <p>Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the BackChannel Authentication Endpoint.</p> required <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>a <code>BackChannelAuthenticationResponse</code></p> <p>Raises:</p> Type Description <code>InvalidBackChannelAuthenticationResponse</code> <p>if the response does not contain a standard BackChannel Authentication response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_backchannel_authentication_response(\n    self,\n    response: requests.Response,\n) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Parse a response received by `backchannel_authentication_request()`.\n\n    Invoked by\n    [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n    to parse the response returned by the BackChannel Authentication Endpoint.\n\n    Args:\n        response: the response returned by the BackChannel Authentication Endpoint.\n\n    Returns:\n        a `BackChannelAuthenticationResponse`\n\n    Raises:\n        InvalidBackChannelAuthenticationResponse: if the response does not contain a standard\n            BackChannel Authentication response.\n\n    \"\"\"\n    try:\n        return BackChannelAuthenticationResponse(**response.json())\n    except TypeError as exc:\n        raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_backchannel_authentication_error","title":"<code>on_backchannel_authentication_error(response)</code>","text":"<p>Error handler for <code>backchannel_authentication_request()</code>.</p> <p>Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint, when it is an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the BackChannel Authentication Endpoint.</p> required <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>usually raises an exception. But a subclass can return a default response instead.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>(or one of its subclasses) if the response contains a standard OAuth 2.0 error.</p> <code>InvalidBackChannelAuthenticationResponse</code> <p>for non-standard error responses.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_backchannel_authentication_error(self, response: requests.Response) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Error handler for `backchannel_authentication_request()`.\n\n    Invoked by\n    [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n    to parse the response returned by the BackChannel Authentication Endpoint, when it is an\n    error.\n\n    Args:\n        response: the response returned by the BackChannel Authentication Endpoint.\n\n    Returns:\n        usually raises an exception. But a subclass can return a default response instead.\n\n    Raises:\n        EndpointError: (or one of its subclasses) if the response contains a standard OAuth 2.0 error.\n        InvalidBackChannelAuthenticationResponse: for non-standard error responses.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, BackChannelAuthenticationError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidBackChannelAuthenticationResponse(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorize_device","title":"<code>authorize_device(requests_kwargs=None, **data)</code>","text":"<p>Send a Device Authorization Request.</p> <p>Parameters:</p> Name Type Description Default <code>**data</code> <code>Any</code> <p>additional data to send to the Device Authorization Endpoint</p> <code>{}</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for <code>requests.request()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>a Device Authorization Response</p> <p>Raises:</p> Type Description <code>MissingEndpointUri</code> <p>if the Device Authorization URI is not configured</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorize_device(\n    self,\n    requests_kwargs: dict[str, Any] | None = None,\n    **data: Any,\n) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Send a Device Authorization Request.\n\n    Args:\n        **data: additional data to send to the Device Authorization Endpoint\n        requests_kwargs: additional parameters for `requests.request()`\n\n    Returns:\n        a Device Authorization Response\n\n    Raises:\n        MissingEndpointUri: if the Device Authorization URI is not configured\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    return self._request(\n        Endpoints.DEVICE_AUTHORIZATION,\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_device_authorization_response,\n        on_failure=self.on_device_authorization_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_device_authorization_response","title":"<code>parse_device_authorization_response(response)</code>","text":"<p>Parse a Device Authorization Response received by <code>authorize_device()</code>.</p> <p>Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the Device Authorization Endpoint.</p> required <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>a <code>DeviceAuthorizationResponse</code> as returned by AS</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_device_authorization_response(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Parse a Device Authorization Response received by `authorize_device()`.\n\n    Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n    to parse the response returned by the Device Authorization Endpoint.\n\n    Args:\n        response: the response returned by the Device Authorization Endpoint.\n\n    Returns:\n        a `DeviceAuthorizationResponse` as returned by AS\n\n    \"\"\"\n    return DeviceAuthorizationResponse(**response.json())\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_device_authorization_error","title":"<code>on_device_authorization_error(response)</code>","text":"<p>Error handler for <code>authorize_device()</code>.</p> <p>Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint, when that response is an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the Device Authorization Endpoint.</p> required <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>usually raises an Exception. But a subclass may return a default response instead.</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>for standard OAuth 2.0 errors</p> <code>InvalidDeviceAuthorizationResponse</code> <p>for non-standard error responses.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_device_authorization_error(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Error handler for `authorize_device()`.\n\n    Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n    to parse the response returned by the Device Authorization Endpoint, when that response is\n    an error.\n\n    Args:\n        response: the response returned by the Device Authorization Endpoint.\n\n    Returns:\n        usually raises an Exception. But a subclass may return a default response instead.\n\n    Raises:\n        EndpointError: for standard OAuth 2.0 errors\n        InvalidDeviceAuthorizationResponse: for non-standard error responses.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, DeviceAuthorizationError)\n        exception = exception_class(\n            response=response,\n            client=self,\n            error=error,\n            description=error_description,\n            uri=error_uri,\n        )\n    except Exception as exc:\n        raise InvalidDeviceAuthorizationResponse(response=response, client=self) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.update_authorization_server_public_keys","title":"<code>update_authorization_server_public_keys(requests_kwargs=None)</code>","text":"<p>Update the cached AS public keys by retrieving them from its <code>jwks_uri</code>.</p> <p>Public keys are returned by this method, as a <code>jwskate.JwkSet</code>. They are also available in attribute <code>authorization_server_jwks</code>.</p> <p>Returns:</p> Type Description <code>JwkSet</code> <p>the retrieved public keys</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if no <code>jwks_uri</code> is configured</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def update_authorization_server_public_keys(self, requests_kwargs: dict[str, Any] | None = None) -&gt; JwkSet:\n    \"\"\"Update the cached AS public keys by retrieving them from its `jwks_uri`.\n\n    Public keys are returned by this method, as a `jwskate.JwkSet`. They are also\n    available in attribute `authorization_server_jwks`.\n\n    Returns:\n        the retrieved public keys\n\n    Raises:\n        ValueError: if no `jwks_uri` is configured\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    jwks = self._request(\n        Endpoints.JWKS,\n        auth=None,\n        method=\"GET\",\n        on_success=lambda resp: resp.json(),\n        on_failure=lambda resp: resp.raise_for_status(),\n        **requests_kwargs,\n    )\n    self.authorization_server_jwks.update(jwks)\n    return self.authorization_server_jwks\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.from_discovery_endpoint","title":"<code>from_discovery_endpoint(url=None, issuer=None, *, auth=None, client_id=None, client_secret=None, private_key=None, session=None, testing=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialise an OAuth2Client based on Authorization Server Metadata.</p> <p>This will retrieve the standardised metadata document available at <code>url</code>, and will extract all Endpoint Uris from that document, will fetch the current public keys from its <code>jwks_uri</code>, then will initialise an OAuth2Client based on those endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | None</code> <p>the url where the server metadata will be retrieved</p> <code>None</code> <code>auth</code> <code>AuthBase | tuple[str, str] | str | None</code> <p>the authentication handler to use for client authentication</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>client ID</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>client secret to use to authenticate the client</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>private key to sign client assertions</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>a <code>requests.Session</code> to use to retrieve the document and initialise the client with</p> <code>None</code> <code>issuer</code> <code>str | None</code> <p>if an issuer is given, check that it matches the one from the retrieved document</p> <code>None</code> <code>testing</code> <code>bool</code> <p>if True, don't try to validate the endpoint urls that are part of the document</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>additional keyword parameters to pass to OAuth2Client</p> <code>{}</code> <p>Returns:</p> Type Description <code>OAuth2Client</code> <p>an OAuth2Client with endpoint initialised based on the obtained metadata</p> <p>Raises:</p> Type Description <code>InvalidParam</code> <p>if neither <code>url</code> nor <code>issuer</code> are suitable urls</p> <code>HTTPError</code> <p>if an error happens while fetching the documents</p> Example <pre><code>from requests_oauth2client import OAuth2Client\n\nclient = OAuth2Client.from_discovery_endpoint(\n    issuer=\"https://myserver.net\",\n    client_id=\"my_client_id,\n    client_secret=\"my_client_secret\"\n)\n</code></pre> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@classmethod\ndef from_discovery_endpoint(\n    cls,\n    url: str | None = None,\n    issuer: str | None = None,\n    *,\n    auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_key: Jwk | dict[str, Any] | None = None,\n    session: requests.Session | None = None,\n    testing: bool = False,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n    \"\"\"Initialise an OAuth2Client based on Authorization Server Metadata.\n\n    This will retrieve the standardised metadata document available at `url`, and will extract\n    all Endpoint Uris from that document, will fetch the current public keys from its\n    `jwks_uri`, then will initialise an OAuth2Client based on those endpoints.\n\n    Args:\n         url: the url where the server metadata will be retrieved\n         auth: the authentication handler to use for client authentication\n         client_id: client ID\n         client_secret: client secret to use to authenticate the client\n         private_key: private key to sign client assertions\n         session: a `requests.Session` to use to retrieve the document and initialise the client with\n         issuer: if an issuer is given, check that it matches the one from the retrieved document\n         testing: if True, don't try to validate the endpoint urls that are part of the document\n         **kwargs: additional keyword parameters to pass to OAuth2Client\n\n    Returns:\n        an OAuth2Client with endpoint initialised based on the obtained metadata\n\n    Raises:\n        InvalidParam: if neither `url` nor `issuer` are suitable urls\n        requests.HTTPError: if an error happens while fetching the documents\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client\n\n        client = OAuth2Client.from_discovery_endpoint(\n            issuer=\"https://myserver.net\",\n            client_id=\"my_client_id,\n            client_secret=\"my_client_secret\"\n        )\n        ```\n\n    \"\"\"\n    if url is None and issuer is not None:\n        url = oidc_discovery_document_url(issuer)\n    if url is None:\n        msg = \"Please specify at least one of `issuer` or `url`\"\n        raise InvalidParam(msg)\n\n    validate_endpoint_uri(url, path=False)\n\n    session = session or requests.Session()\n    discovery = session.get(url).json()\n\n    jwks_uri = discovery.get(\"jwks_uri\")\n    if jwks_uri:\n        jwks = JwkSet(session.get(jwks_uri).json())\n\n    return cls.from_discovery_document(\n        discovery,\n        issuer=issuer,\n        auth=auth,\n        session=session,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_key=private_key,\n        authorization_server_jwks=jwks,\n        testing=testing,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.from_discovery_document","title":"<code>from_discovery_document(discovery, issuer=None, *, auth=None, client_id=None, client_secret=None, private_key=None, authorization_server_jwks=None, session=None, https=True, testing=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize an OAuth2Client, based on the server metadata from <code>discovery</code>.</p> <p>Parameters:</p> Name Type Description Default <code>discovery</code> <code>dict[str, Any]</code> <p>a dict of server metadata, in the same format as retrieved from a discovery endpoint.</p> required <code>issuer</code> <code>str | None</code> <p>if an issuer is given, check that it matches the one mentioned in the document</p> <code>None</code> <code>auth</code> <code>AuthBase | tuple[str, str] | str | None</code> <p>the authentication handler to use for client authentication</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>client ID</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>client secret to use to authenticate the client</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>private key to sign client assertions</p> <code>None</code> <code>authorization_server_jwks</code> <code>JwkSet | dict[str, Any] | None</code> <p>the current authorization server JWKS keys</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>a requests Session to use to retrieve the document and initialise the client with</p> <code>None</code> <code>https</code> <code>bool</code> <p>(deprecated) if <code>True</code>, validates that urls in the discovery document use the https scheme</p> <code>True</code> <code>testing</code> <code>bool</code> <p>if True, don't try to validate the endpoint urls that are part of the document</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>additional args that will be passed to OAuth2Client</p> <code>{}</code> <p>Returns:</p> Type Description <code>OAuth2Client</code> <p>an <code>OAuth2Client</code> initialized with the endpoints from the discovery document</p> <p>Raises:</p> Type Description <code>InvalidDiscoveryDocument</code> <p>if the document does not contain at least a <code>\"token_endpoint\"</code>.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>    @classmethod\n    def from_discovery_document(\n        cls,\n        discovery: dict[str, Any],\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        session: requests.Session | None = None,\n        https: bool = True,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an OAuth2Client, based on the server metadata from `discovery`.\n\n        Args:\n             discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint.\n             issuer: if an issuer is given, check that it matches the one mentioned in the document\n             auth: the authentication handler to use for client authentication\n             client_id: client ID\n             client_secret: client secret to use to authenticate the client\n             private_key: private key to sign client assertions\n             authorization_server_jwks: the current authorization server JWKS keys\n             session: a requests Session to use to retrieve the document and initialise the client with\n             https: (deprecated) if `True`, validates that urls in the discovery document use the https scheme\n             testing: if True, don't try to validate the endpoint urls that are part of the document\n             **kwargs: additional args that will be passed to OAuth2Client\n\n        Returns:\n            an `OAuth2Client` initialized with the endpoints from the discovery document\n\n        Raises:\n            InvalidDiscoveryDocument: if the document does not contain at least a `\"token_endpoint\"`.\n\n        \"\"\"\n        if not https:\n            warnings.warn(\n                \"\"\"\\\nThe https parameter is deprecated.\nTo disable endpoint uri validation, set `testing=True` when initializing your `OAuth2Client`.\"\"\",\n                stacklevel=1,\n            )\n            testing = True\n        if issuer and discovery.get(\"issuer\") != issuer:\n            msg = (\n                f\"Mismatching `issuer` value in discovery document\"\n                f\" (received '{discovery.get('issuer')}', expected '{issuer}')\"\n            )\n            raise InvalidParam(\n                msg,\n                issuer,\n                discovery.get(\"issuer\"),\n            )\n        if issuer is None:\n            issuer = discovery.get(\"issuer\")\n\n        token_endpoint = discovery.get(Endpoints.TOKEN)\n        if token_endpoint is None:\n            msg = \"token_endpoint not found in that discovery document\"\n            raise InvalidDiscoveryDocument(msg, discovery)\n        authorization_endpoint = discovery.get(Endpoints.AUTHORIZATION)\n        revocation_endpoint = discovery.get(Endpoints.REVOCATION)\n        introspection_endpoint = discovery.get(Endpoints.INSTROSPECTION)\n        userinfo_endpoint = discovery.get(Endpoints.USER_INFO)\n        jwks_uri = discovery.get(Endpoints.JWKS)\n        if jwks_uri is not None:\n            validate_endpoint_uri(jwks_uri, https=https)\n        authorization_response_iss_parameter_supported = discovery.get(\n            \"authorization_response_iss_parameter_supported\",\n            False,\n        )\n\n        return cls(\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            session=session,\n            issuer=issuer,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            testing=testing,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication","title":"<code>client_authentication</code>","text":"<p>This module implements OAuth 2.0 Client Authentication Methods.</p> <p>An OAuth 2.0 Client must authenticate to the AS whenever it sends a request to the Token Endpoint, by including appropriate credentials. This module contains helper classes and methods that implement the standardized and commonly used Client Authentication Methods.</p>"},{"location":"api/#requests_oauth2client.client_authentication.InvalidRequestForClientAuthentication","title":"<code>InvalidRequestForClientAuthentication</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Raised when a request is not suitable for OAuth 2.0 client authentication.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class InvalidRequestForClientAuthentication(RuntimeError):\n    \"\"\"Raised when a request is not suitable for OAuth 2.0 client authentication.\"\"\"\n\n    def __init__(self, request: requests.PreparedRequest) -&gt; None:\n        super().__init__(\"This request is not suitabe for OAuth 2.0 client authentication.\")\n        self.request = request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.BaseClientAuthenticationMethod","title":"<code>BaseClientAuthenticationMethod</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Base class for all Client Authentication methods. This extends requests.auth.AuthBase.</p> <p>This base class checks that requests are suitable to add Client Authentication parameters to, and does not modify the request.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen\nclass BaseClientAuthenticationMethod(requests.auth.AuthBase):\n    \"\"\"Base class for all Client Authentication methods. This extends [requests.auth.AuthBase][].\n\n    This base class checks that requests are suitable to add Client Authentication parameters to,\n    and does not modify the request.\n\n    \"\"\"\n\n    client_id: str\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Check that the request is suitable for Client Authentication.\n\n        It checks:\n\n        * that the method is `POST`\n        * that the Content-Type is \"application/x-www-form-urlencoded\" or None\n\n        Args:\n            request: a [requests.PreparedRequest][]\n\n        Returns:\n            a [requests.PreparedRequest][], unmodified\n\n        Raises:\n            RuntimeError: if the request is not suitable for OAuth 2.0 Client Authentication\n\n        \"\"\"\n        if request.method != \"POST\" or request.headers.get(\"Content-Type\") not in (\n            \"application/x-www-form-urlencoded\",\n            None,\n        ):\n            raise InvalidRequestForClientAuthentication(request)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretBasic","title":"<code>ClientSecretBasic</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement <code>client_secret_basic</code> authentication.</p> <p>With this method, the client sends its Client ID and Secret, in the HTTP <code>Authorization</code> header, with the <code>Basic</code> scheme, in each authenticated request to the Authorization Server.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>client_secret</code> <code>str</code> <p>Client Secret</p> required Example <pre><code>from requests_oauth2client import ClientSecretBasic, OAuth2Client\n\nauth = ClientSecretBasic(\"my_client_id\", \"my_client_secret\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass ClientSecretBasic(BaseClientAuthenticationMethod):\n    \"\"\"Implement `client_secret_basic` authentication.\n\n    With this method, the client sends its Client ID and Secret, in the HTTP `Authorization` header, with\n    the `Basic` scheme, in each authenticated request to the Authorization Server.\n\n    Args:\n        client_id: Client ID\n        client_secret: Client Secret\n\n    Example:\n        ```python\n        from requests_oauth2client import ClientSecretBasic, OAuth2Client\n\n        auth = ClientSecretBasic(\"my_client_id\", \"my_client_secret\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    client_secret: str\n\n    def __init__(self, client_id: str, client_secret: str) -&gt; None:\n        self.__attrs_init__(\n            client_id=client_id,\n            client_secret=client_secret,\n        )\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the appropriate `Authorization` header in each request.\n\n        The Authorization header is formatted as such:\n        `Authorization: Basic BASE64('&lt;client_id:client_secret&gt;')`\n\n        Args:\n            request: the request\n\n        Returns:\n            a [requests.PreparedRequest][] with the added Authorization header.\n\n        \"\"\"\n        request = super().__call__(request)\n        b64encoded_credentials = BinaPy(f\"{self.client_id}:{self.client_secret}\").to(\"b64\").ascii()\n        request.headers[\"Authorization\"] = f\"Basic {b64encoded_credentials}\"\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretPost","title":"<code>ClientSecretPost</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement <code>client_secret_post</code> client authentication method.</p> <p>With this method, the client inserts its client_id and client_secret in each authenticated request to the AS.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>client_secret</code> <code>str</code> <p>Client Secret</p> required Example <pre><code>from requests_oauth2client import ClientSecretPost, OAuth2Client\n\nauth = ClientSecretPost(\"my_client_id\", \"my_client_secret\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass ClientSecretPost(BaseClientAuthenticationMethod):\n    \"\"\"Implement `client_secret_post` client authentication method.\n\n    With this method, the client inserts its client_id and client_secret in each authenticated\n    request to the AS.\n\n    Args:\n        client_id: Client ID\n        client_secret: Client Secret\n\n    Example:\n        ```python\n        from requests_oauth2client import ClientSecretPost, OAuth2Client\n\n        auth = ClientSecretPost(\"my_client_id\", \"my_client_secret\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    client_secret: str\n\n    def __init__(self, client_id: str, client_secret: str) -&gt; None:\n        self.__attrs_init__(\n            client_id=client_id,\n            client_secret=client_secret,\n        )\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the `client_id` and `client_secret` parameters in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added client credentials fields.\n\n        \"\"\"\n        request = super().__call__(request)\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if isinstance(request.body, (str, bytes))\n            else {}\n        )\n        params[b\"client_id\"] = [self.client_id.encode()]\n        params[b\"client_secret\"] = [self.client_secret.encode()]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.BaseClientAssertionAuthenticationMethod","title":"<code>BaseClientAssertionAuthenticationMethod</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Base class for assertion-based client authentication methods.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen\nclass BaseClientAssertionAuthenticationMethod(BaseClientAuthenticationMethod):\n    \"\"\"Base class for assertion-based client authentication methods.\"\"\"\n\n    lifetime: int\n    jti_gen: Callable[[], str]\n    aud: str | None\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a Client Assertion for a specific audience.\n\n        Args:\n            audience: the audience to use for the `aud` claim of the generated Client Assertion.\n\n        Returns:\n            a Client Assertion, as `str`.\n\n        \"\"\"\n        raise NotImplementedError\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add a `client_assertion` field in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added `client_assertion` field.\n\n        \"\"\"\n        request = super().__call__(request)\n        audience = self.aud or request.url\n        if audience is None:\n            raise InvalidRequestForClientAuthentication(request)  # pragma: no cover\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if request.body\n            else {}\n        )\n        client_assertion = self.client_assertion(audience)\n        params[b\"client_id\"] = [self.client_id.encode()]\n        params[b\"client_assertion\"] = [client_assertion.encode()]\n        params[b\"client_assertion_type\"] = [b\"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.BaseClientAssertionAuthenticationMethod.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a Client Assertion for a specific audience.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the <code>aud</code> claim of the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion, as <code>str</code>.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a Client Assertion for a specific audience.\n\n    Args:\n        audience: the audience to use for the `aud` claim of the generated Client Assertion.\n\n    Returns:\n        a Client Assertion, as `str`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretJwt","title":"<code>ClientSecretJwt</code>","text":"<p>               Bases: <code>BaseClientAssertionAuthenticationMethod</code></p> <p>Implement <code>client_secret_jwt</code> client authentication method.</p> <p>With this method, the client generates a client assertion, then symmetrically signs it with its Client Secret. The assertion is then sent to the AS in a <code>client_assertion</code> field with each authenticated request.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the <code>client_id</code> to use.</p> required <code>client_secret</code> <code>str</code> <p>the <code>client_secret</code> to use to sign generated Client Assertions.</p> required <code>alg</code> <code>str</code> <p>the alg to use to sign generated Client Assertions.</p> <code>HS256</code> <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> <code>60</code> <code>jti_gen</code> <code>Callable[[], str]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> <code>lambda: str(uuid4())</code> <code>aud</code> <code>str | None</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.</p> <code>None</code> Example <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\nauth = ClientSecretJwt(\"my_client_id\", \"my_client_secret\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass ClientSecretJwt(BaseClientAssertionAuthenticationMethod):\n    \"\"\"Implement `client_secret_jwt` client authentication method.\n\n    With this method, the client generates a client assertion, then symmetrically signs it with its Client Secret.\n    The assertion is then sent to the AS in a `client_assertion` field with each authenticated request.\n\n    Args:\n        client_id: the `client_id` to use.\n        client_secret: the `client_secret` to use to sign generated Client Assertions.\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\n        auth = ClientSecretJwt(\"my_client_id\", \"my_client_secret\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    client_secret: str\n    alg: str\n\n    def __init__(\n        self,\n        client_id: str,\n        client_secret: str,\n        lifetime: int = 60,\n        alg: str = SignatureAlgs.HS256,\n        jti_gen: Callable[[], str] = lambda: str(uuid4()),\n        aud: str | None = None,\n    ) -&gt; None:\n        self.__attrs_init__(\n            client_id=client_id,\n            client_secret=client_secret,\n            lifetime=lifetime,\n            alg=alg,\n            jti_gen=jti_gen,\n            aud=aud,\n        )\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a symmetrically signed Client Assertion.\n\n        Assertion is signed with the `client_secret` as key and the `alg` passed at init time.\n\n        Args:\n            audience: the audience to use for the generated Client Assertion.\n\n        Returns:\n            a Client Assertion, as `str`.\n\n        \"\"\"\n        iat = int(datetime.now(tz=timezone.utc).timestamp())\n        exp = iat + self.lifetime\n        jti = str(self.jti_gen())\n\n        jwk = SymmetricJwk.from_bytes(self.client_secret.encode())\n\n        jwt = Jwt.sign(\n            claims={\n                \"iss\": self.client_id,\n                \"sub\": self.client_id,\n                \"aud\": audience,\n                \"iat\": iat,\n                \"exp\": exp,\n                \"jti\": jti,\n            },\n            key=jwk,\n            alg=self.alg,\n        )\n        return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretJwt.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a symmetrically signed Client Assertion.</p> <p>Assertion is signed with the <code>client_secret</code> as key and the <code>alg</code> passed at init time.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion, as <code>str</code>.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a symmetrically signed Client Assertion.\n\n    Assertion is signed with the `client_secret` as key and the `alg` passed at init time.\n\n    Args:\n        audience: the audience to use for the generated Client Assertion.\n\n    Returns:\n        a Client Assertion, as `str`.\n\n    \"\"\"\n    iat = int(datetime.now(tz=timezone.utc).timestamp())\n    exp = iat + self.lifetime\n    jti = str(self.jti_gen())\n\n    jwk = SymmetricJwk.from_bytes(self.client_secret.encode())\n\n    jwt = Jwt.sign(\n        claims={\n            \"iss\": self.client_id,\n            \"sub\": self.client_id,\n            \"aud\": audience,\n            \"iat\": iat,\n            \"exp\": exp,\n            \"jti\": jti,\n        },\n        key=jwk,\n        alg=self.alg,\n    )\n    return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.InvalidClientAssertionSigningKeyOrAlg","title":"<code>InvalidClientAssertionSigningKeyOrAlg</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when the client assertion signing alg is not specified or invalid.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class InvalidClientAssertionSigningKeyOrAlg(ValueError):\n    \"\"\"Raised when the client assertion signing alg is not specified or invalid.\"\"\"\n\n    def __init__(self, alg: str | None) -&gt; None:\n        super().__init__(\"\"\"\\\nAn asymmetric private signing key, and an alg that is supported by the signing key is required.\nIt can be provided either:\n- as part of the private `Jwk`, in the parameter 'alg'\n- or passed as parameter `alg` when initializing a `PrivateKeyJwt`.\nExamples of valid `alg` values and matching key type:\n- 'RS256', 'RS512' (with a key of type RSA)\n- 'ES256', 'ES512' (with a key of type EC)\nThe private key must include a Key ID (in its 'kid' parameter).\n\"\"\")\n        self.alg = alg\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.PrivateKeyJwt","title":"<code>PrivateKeyJwt</code>","text":"<p>               Bases: <code>BaseClientAssertionAuthenticationMethod</code></p> <p>Implement <code>private_key_jwt</code> client authentication method.</p> <p>With this method, the client generates and sends a client_assertion, that is asymmetrically signed with a private key, on each direct request to the Authorization Server.</p> <p>The private key must be supplied as a <code>jwskate.Jwk</code> instance, or any key material that can be used to initialize one.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the <code>client_id</code> to use.</p> required <code>private_jwk</code> <code>Jwk | dict[str, Any] | Any</code> <p>the private key to use to sign generated Client Assertions.</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign generated Client Assertions.</p> <code>None</code> <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> <code>60</code> <code>jti_gen</code> <code>Callable[[], str]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> <code>lambda: str(uuid4())</code> <code>aud</code> <code>str | None</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.k</p> <code>None</code> Example <pre><code>from jwskate import Jwk\nfrom requests_oauth2client import OAuth2Client, PrivateKeyJwt\n\n# load your private key from wherever it is stored:\nwith open(\"my_private_key.pem\") as f:\n    my_private_key = Jwk.from_pem(f.read(), password=\"my_private_key_password\")\n\nauth = PrivateKeyJwt(\"my_client_id\", my_private_key, alg=\"RS256\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen(init=False)\nclass PrivateKeyJwt(BaseClientAssertionAuthenticationMethod):\n    \"\"\"Implement `private_key_jwt` client authentication method.\n\n    With this method, the client generates and sends a client_assertion, that is asymmetrically\n    signed with a private key, on each direct request to the Authorization Server.\n\n    The private key must be supplied as a [`jwskate.Jwk`][jwskate.jwk.Jwk] instance,\n    or any key material that can be used to initialize one.\n\n    Args:\n        client_id: the `client_id` to use.\n        private_jwk: the private key to use to sign generated Client Assertions.\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.k\n\n    Example:\n        ```python\n        from jwskate import Jwk\n        from requests_oauth2client import OAuth2Client, PrivateKeyJwt\n\n        # load your private key from wherever it is stored:\n        with open(\"my_private_key.pem\") as f:\n            my_private_key = Jwk.from_pem(f.read(), password=\"my_private_key_password\")\n\n        auth = PrivateKeyJwt(\"my_client_id\", my_private_key, alg=\"RS256\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    private_jwk: Jwk = field(converter=to_jwk)\n    alg: str | None\n\n    def __init__(\n        self,\n        client_id: str,\n        private_jwk: Jwk | dict[str, Any] | Any,\n        *,\n        alg: str | None = None,\n        lifetime: int = 60,\n        jti_gen: Callable[[], str] = lambda: str(uuid4()),\n        aud: str | None = None,\n    ) -&gt; None:\n        self.__attrs_init__(\n            client_id=client_id,\n            private_jwk=private_jwk,\n            alg=alg,\n            lifetime=lifetime,\n            jti_gen=jti_gen,\n            aud=aud,\n        )\n\n        alg = self.private_jwk.alg or alg\n        if not alg:\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n        if alg not in self.private_jwk.supported_signing_algorithms():\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n        if not self.private_jwk.is_private or self.private_jwk.is_symmetric:\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n        kid = self.private_jwk.get(\"kid\")\n        if not kid:\n            raise InvalidClientAssertionSigningKeyOrAlg(alg)\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a Client Assertion, asymmetrically signed with `private_jwk` as key.\n\n        Args:\n            audience: the audience to use for the generated Client Assertion.\n\n        Returns:\n            a Client Assertion.\n\n        \"\"\"\n        iat = int(datetime.now(tz=timezone.utc).timestamp())\n        exp = iat + self.lifetime\n        jti = str(self.jti_gen())\n\n        jwt = Jwt.sign(\n            claims={\n                \"iss\": self.client_id,\n                \"sub\": self.client_id,\n                \"aud\": audience,\n                \"iat\": iat,\n                \"exp\": exp,\n                \"jti\": jti,\n            },\n            key=self.private_jwk,\n            alg=self.alg,\n        )\n        return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.PrivateKeyJwt.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a Client Assertion, asymmetrically signed with <code>private_jwk</code> as key.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a Client Assertion, asymmetrically signed with `private_jwk` as key.\n\n    Args:\n        audience: the audience to use for the generated Client Assertion.\n\n    Returns:\n        a Client Assertion.\n\n    \"\"\"\n    iat = int(datetime.now(tz=timezone.utc).timestamp())\n    exp = iat + self.lifetime\n    jti = str(self.jti_gen())\n\n    jwt = Jwt.sign(\n        claims={\n            \"iss\": self.client_id,\n            \"sub\": self.client_id,\n            \"aud\": audience,\n            \"iat\": iat,\n            \"exp\": exp,\n            \"jti\": jti,\n        },\n        key=self.private_jwk,\n        alg=self.alg,\n    )\n    return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.PublicApp","title":"<code>PublicApp</code>","text":"<p>               Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement the <code>none</code> authentication method for public apps.</p> <p>This scheme is used for Public Clients, which do not have any secret credentials. Those only send their client_id to the Authorization Server.</p> Example <pre><code>from requests_oauth2client import OAuth2Client, PublicApp\n\nauth = PublicApp(\"my_client_id\")\nclient = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n</code></pre> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>@frozen\nclass PublicApp(BaseClientAuthenticationMethod):\n    \"\"\"Implement the `none` authentication method for public apps.\n\n    This scheme is used for Public Clients, which do not have any secret credentials. Those only\n    send their client_id to the Authorization Server.\n\n    Example:\n        ```python\n        from requests_oauth2client import OAuth2Client, PublicApp\n\n        auth = PublicApp(\"my_client_id\")\n        client = OAuth2Client(\"https://url.to.the/token_endpoint\", auth=auth)\n        ```\n\n    \"\"\"\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the `client_id` field in the request body.\n\n        Args:\n            request: a request.\n\n        Returns:\n            the request with the added `client_id` form field.\n\n        \"\"\"\n        request = super().__call__(request)\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if request.body\n            else {}\n        )\n        params[b\"client_id\"] = [self.client_id.encode()]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.UnsupportedClientCredentials","title":"<code>UnsupportedClientCredentials</code>","text":"<p>               Bases: <code>TypeError</code>, <code>ValueError</code></p> <p>Raised when unsupported client credentials are provided.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class UnsupportedClientCredentials(TypeError, ValueError):\n    \"\"\"Raised when unsupported client credentials are provided.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.client_auth_factory","title":"<code>client_auth_factory(auth, *, client_id=None, client_secret=None, private_key=None, default_auth_handler=ClientSecretPost)</code>","text":"<p>Initialize the appropriate Auth Handler based on the provided parameters.</p> <p>This initializes a <code>ClientAuthenticationMethod</code> subclass based on the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>auth</code> <code>AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None</code> <p>can be:</p> <ul> <li>a <code>requests.auth.AuthBase</code> instance (which will be used directly)</li> <li>a tuple of (client_id, client_secret) which will be used to initialize an instance of   <code>default_auth_handler</code>,</li> <li>a tuple of (client_id, jwk), used to initialize a <code>PrivateKeyJwk</code> (<code>jwk</code> being an   instance of <code>jwskate.Jwk</code> or a <code>dict</code>),</li> <li>a <code>client_id</code>, as <code>str</code>,</li> <li>or <code>None</code>, to pass <code>client_id</code> and other credentials as dedicated parameters, see   below.</li> </ul> required <code>client_id</code> <code>str | None</code> <p>the Client ID to use for this client</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>the Client Secret to use for this client, if any (for clients using an authentication method based on a secret)</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>the private key to use for private_key_jwt authentication method</p> <code>None</code> <code>default_auth_handler</code> <code>type[ClientSecretPost | ClientSecretBasic | ClientSecretJwt]</code> <p>if a client_id and client_secret are provided, initialize an instance of this class with those 2 parameters. You can choose between <code>ClientSecretBasic</code>, <code>ClientSecretPost</code>, or <code>ClientSecretJwt</code>.</p> <code>ClientSecretPost</code> <p>Returns:</p> Type Description <code>AuthBase</code> <p>an Auth Handler that will manage client authentication to the AS Token Endpoint or other</p> <code>AuthBase</code> <p>backend endpoints.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_auth_factory(\n    auth: requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None,\n    *,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_key: Jwk | dict[str, Any] | None = None,\n    default_auth_handler: type[ClientSecretPost | ClientSecretBasic | ClientSecretJwt] = ClientSecretPost,\n) -&gt; requests.auth.AuthBase:\n    \"\"\"Initialize the appropriate Auth Handler based on the provided parameters.\n\n    This initializes a `ClientAuthenticationMethod` subclass based on the provided parameters.\n\n    Args:\n        auth: can be:\n\n            - a `requests.auth.AuthBase` instance (which will be used directly)\n            - a tuple of (client_id, client_secret) which will be used to initialize an instance of\n              `default_auth_handler`,\n            - a tuple of (client_id, jwk), used to initialize a `PrivateKeyJwk` (`jwk` being an\n              instance of `jwskate.Jwk` or a `dict`),\n            - a `client_id`, as `str`,\n            - or `None`, to pass `client_id` and other credentials as dedicated parameters, see\n              below.\n        client_id: the Client ID to use for this client\n        client_secret: the Client Secret to use for this client, if any (for clients using\n            an authentication method based on a secret)\n        private_key: the private key to use for private_key_jwt authentication method\n        default_auth_handler: if a client_id and client_secret are provided, initialize an\n            instance of this class with those 2 parameters.\n            You can choose between `ClientSecretBasic`, `ClientSecretPost`, or `ClientSecretJwt`.\n\n    Returns:\n        an Auth Handler that will manage client authentication to the AS Token Endpoint or other\n        backend endpoints.\n\n    \"\"\"\n    if auth is not None and (client_id is not None or client_secret is not None or private_key is not None):\n        msg = \"\"\"\\\nPlease use either `auth` parameter to provide an authentication method,\nor use `client_id` and one of `client_secret` or `private_key`.\n\"\"\"\n        raise UnsupportedClientCredentials(msg)\n\n    if isinstance(auth, str):\n        client_id = auth\n    elif isinstance(auth, requests.auth.AuthBase):\n        return auth\n    elif isinstance(auth, tuple) and len(auth) == 2:  # noqa: PLR2004\n        client_id, credential = auth\n        if isinstance(credential, (Jwk, dict)):\n            private_key = credential\n        elif isinstance(credential, str):\n            client_secret = credential\n        else:\n            msg = \"This credential type is not supported:\"\n            raise UnsupportedClientCredentials(msg, type(credential), credential)\n\n    if client_id is None:\n        msg = \"A client_id must be provided.\"\n        raise UnsupportedClientCredentials(msg)\n\n    if private_key is not None:\n        return PrivateKeyJwt(client_id, private_jwk=private_key)\n    if client_secret is None:\n        return PublicApp(str(client_id))\n\n    return default_auth_handler(str(client_id), str(client_secret))\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization","title":"<code>device_authorization</code>","text":"<p>Implements the Device Authorization Flow as defined in RFC8628.</p> <p>See RFC8628.</p>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationResponse","title":"<code>DeviceAuthorizationResponse</code>","text":"<p>Represent a response returned by the device Authorization Endpoint.</p> <p>All parameters are those returned by the AS as response to a Device Authorization Request.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>user_code</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>verification_uri</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>verification_uri_complete</code> <code>str | None</code> <p>the <code>device_code</code> as returned by the AS.</p> <code>None</code> <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for the device_code. Also accepts an <code>expires_in</code> parameter, as a number of seconds in the future.</p> <code>None</code> <code>interval</code> <code>int | None</code> <p>the pooling <code>interval</code> as returned by the AS.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>class DeviceAuthorizationResponse:\n    \"\"\"Represent a response returned by the device Authorization Endpoint.\n\n    All parameters are those returned by the AS as response to a Device Authorization Request.\n\n    Args:\n        device_code: the `device_code` as returned by the AS.\n        user_code: the `device_code` as returned by the AS.\n        verification_uri: the `device_code` as returned by the AS.\n        verification_uri_complete: the `device_code` as returned by the AS.\n        expires_at: the expiration date for the device_code.\n            Also accepts an `expires_in` parameter, as a number of seconds in the future.\n        interval: the pooling `interval` as returned by the AS.\n        **kwargs: additional parameters as returned by the AS.\n\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        device_code: str,\n        user_code: str,\n        verification_uri: str,\n        verification_uri_complete: str | None = None,\n        expires_at: datetime | None = None,\n        interval: int | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        self.device_code = device_code\n        self.user_code = user_code\n        self.verification_uri = verification_uri\n        self.verification_uri_complete = verification_uri_complete\n        self.expires_at = expires_at\n        self.interval = interval\n        self.other = kwargs\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Check if the `device_code` within this response is expired.\n\n        Returns:\n            `True` if the device_code is expired, `False` if it is still valid, `None` if there is\n            no `expires_in` hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationResponse.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Check if the <code>device_code</code> within this response is expired.</p> <p>Returns:</p> Type Description <code>bool | None</code> <p><code>True</code> if the device_code is expired, <code>False</code> if it is still valid, <code>None</code> if there is</p> <code>bool | None</code> <p>no <code>expires_in</code> hint.</p> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Check if the `device_code` within this response is expired.\n\n    Returns:\n        `True` if the device_code is expired, `False` if it is still valid, `None` if there is\n        no `expires_in` hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationPoolingJob","title":"<code>DeviceAuthorizationPoolingJob</code>","text":"<p>               Bases: <code>BaseTokenEndpointPoolingJob</code></p> <p>A Token Endpoint pooling job for the Device Authorization Flow.</p> <p>This periodically checks if the user has finished with his authorization in a Device Authorization flow.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client that will be used to pool the token endpoint.</p> required <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a <code>device_code</code> as <code>str</code> or a <code>DeviceAuthorizationResponse</code>.</p> required <code>interval</code> <code>int | None</code> <p>The pooling interval to use. This overrides the one in <code>auth_req_id</code> if it is a <code>BackChannelAuthenticationResponse</code>.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>Number of seconds to add to the pooling interval when the AS returns a slow-down request.</p> <code>5</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the underlying calls to requests.request.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token request.</p> <code>{}</code> Example <pre><code>from requests_oauth2client import DeviceAuthorizationPoolingJob, OAuth2Client\n\nclient = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\npooler = DeviceAuthorizationPoolingJob(client=client, device_code=\"my_device_code\")\n\ntoken = None\nwhile token is None:\n    token = pooler()\n</code></pre> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>@define(init=False)\nclass DeviceAuthorizationPoolingJob(BaseTokenEndpointPoolingJob):\n    \"\"\"A Token Endpoint pooling job for the Device Authorization Flow.\n\n    This periodically checks if the user has finished with his authorization in a Device\n    Authorization flow.\n\n    Args:\n        client: an OAuth2Client that will be used to pool the token endpoint.\n        device_code: a `device_code` as `str` or a `DeviceAuthorizationResponse`.\n        interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is\n            a `BackChannelAuthenticationResponse`.\n        slow_down_interval: Number of seconds to add to the pooling interval when the AS returns\n            a slow-down request.\n        requests_kwargs: Additional parameters for the underlying calls to [requests.request][].\n        **token_kwargs: Additional parameters for the token request.\n\n    Example:\n        ```python\n        from requests_oauth2client import DeviceAuthorizationPoolingJob, OAuth2Client\n\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        pooler = DeviceAuthorizationPoolingJob(client=client, device_code=\"my_device_code\")\n\n        token = None\n        while token is None:\n            token = pooler()\n        ```\n\n    \"\"\"\n\n    device_code: str\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        device_code: str | DeviceAuthorizationResponse,\n        interval: int | None = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        if isinstance(device_code, DeviceAuthorizationResponse):\n            interval = interval or device_code.interval\n            device_code = device_code.device_code\n\n        self.__attrs_init__(\n            client=client,\n            device_code=device_code,\n            interval=interval or 5,\n            slow_down_interval=slow_down_interval,\n            requests_kwargs=requests_kwargs or {},\n            token_kwargs=token_kwargs,\n        )\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Implement the Device Code token request.\n\n        This actually calls [OAuth2Client.device_code(device_code)][requests_oauth2client.OAuth2Client.device_code]\n        on `self.client`.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        return self.client.device_code(self.device_code, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Implement the Device Code token request.</p> <p>This actually calls OAuth2Client.device_code(device_code) on <code>self.client</code>.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Implement the Device Code token request.\n\n    This actually calls [OAuth2Client.device_code(device_code)][requests_oauth2client.OAuth2Client.device_code]\n    on `self.client`.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    return self.client.device_code(self.device_code, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.discovery","title":"<code>discovery</code>","text":"<p>Implements Metadata discovery documents URLS.</p> <p>This is as defined in RFC8615 and OpenID Connect Discovery 1.0.</p>"},{"location":"api/#requests_oauth2client.discovery.well_known_uri","title":"<code>well_known_uri(origin, name, *, at_root=True)</code>","text":"<p>Return the location of a well-known document on an origin url.</p> <p>See RFC8615 and OIDC Discovery.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>str</code> <p>origin to use to build the well-known uri.</p> required <code>name</code> <code>str</code> <p>document name to use to build the well-known uri.</p> required <code>at_root</code> <code>bool</code> <p>if <code>True</code>, assume the well-known document is at root level (as defined in RFC8615). If <code>False</code>, assume the well-known location is per-directory, as defined in OpenID Connect Discovery 1.0.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>the well-know uri, relative to origin, where the well-known document named <code>name</code> should be</p> <code>str</code> <p>found.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def well_known_uri(origin: str, name: str, *, at_root: bool = True) -&gt; str:\n    \"\"\"Return the location of a well-known document on an origin url.\n\n    See [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615) and [OIDC\n    Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Args:\n        origin: origin to use to build the well-known uri.\n        name: document name to use to build the well-known uri.\n        at_root: if `True`, assume the well-known document is at root level (as defined in [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615)).\n            If `False`, assume the well-known location is per-directory, as defined in [OpenID\n            Connect Discovery\n            1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Returns:\n        the well-know uri, relative to origin, where the well-known document named `name` should be\n        found.\n\n    \"\"\"\n    url = furl(origin)\n    if at_root:\n        url.path = Path(\".well-known\") / url.path / name\n    else:\n        url.path.add(Path(\".well-known\") / name)\n    return str(url)\n</code></pre>"},{"location":"api/#requests_oauth2client.discovery.oidc_discovery_document_url","title":"<code>oidc_discovery_document_url(issuer)</code>","text":"<p>Construct the OIDC discovery document url for a given <code>issuer</code>.</p> <p>Given an <code>issuer</code> identifier, return the standardised URL where the OIDC discovery document can be retrieved.</p> <p>The returned URL is biuilt as specified in OpenID Connect Discovery 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>an OIDC Authentication Server <code>issuer</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>the standardised discovery document URL. Note that no attempt to fetch this document is</p> <code>str</code> <p>made.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def oidc_discovery_document_url(issuer: str) -&gt; str:\n    \"\"\"Construct the OIDC discovery document url for a given `issuer`.\n\n    Given an `issuer` identifier, return the standardised URL where the OIDC discovery document can\n    be retrieved.\n\n    The returned URL is biuilt as specified in [OpenID Connect Discovery\n    1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Args:\n        issuer: an OIDC Authentication Server `issuer`\n\n    Returns:\n        the standardised discovery document URL. Note that no attempt to fetch this document is\n        made.\n\n    \"\"\"\n    return well_known_uri(issuer, \"openid-configuration\", at_root=False)\n</code></pre>"},{"location":"api/#requests_oauth2client.discovery.oauth2_discovery_document_url","title":"<code>oauth2_discovery_document_url(issuer)</code>","text":"<p>Construct the standardised OAuth 2.0 discovery document url for a given <code>issuer</code>.</p> <p>Based an <code>issuer</code> identifier, returns the standardised URL where the OAuth20 server metadata can be retrieved.</p> <p>The returned URL is built as specified in RFC8414.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>an OAuth20 Authentication Server <code>issuer</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>the standardised discovery document URL. Note that no attempt to fetch this document is</p> <code>str</code> <p>made.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def oauth2_discovery_document_url(issuer: str) -&gt; str:\n    \"\"\"Construct the standardised OAuth 2.0 discovery document url for a given `issuer`.\n\n    Based an `issuer` identifier, returns the standardised URL where the OAuth20 server metadata can\n    be retrieved.\n\n    The returned URL is built as specified in\n    [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414).\n\n    Args:\n        issuer: an OAuth20 Authentication Server `issuer`\n\n    Returns:\n        the standardised discovery document URL. Note that no attempt to fetch this document is\n        made.\n\n    \"\"\"\n    return well_known_uri(issuer, \"oauth-authorization-server\", at_root=True)\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions","title":"<code>exceptions</code>","text":"<p>This module contains all exception classes from <code>requests_oauth2client</code>.</p>"},{"location":"api/#requests_oauth2client.exceptions.OAuth2Error","title":"<code>OAuth2Error</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for Exceptions raised when a backend endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the HTTP response containing the error</p> required <code>client</code> <p>the OAuth2Client used to send the request</p> required Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class OAuth2Error(Exception):\n    \"\"\"Base class for Exceptions raised when a backend endpoint returns an error.\n\n    Args:\n        response: the HTTP response containing the error\n        client : the OAuth2Client used to send the request\n\n    \"\"\"\n\n    def __init__(self, response: requests.Response, client: OAuth2Client) -&gt; None:\n        super().__init__(\"The remote endpoint returned an error\")\n        self.response = response\n        self.client = client\n\n    @property\n    def request(self) -&gt; requests.PreparedRequest:\n        \"\"\"The request leading to the error.\"\"\"\n        return self.response.request\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.OAuth2Error.request","title":"<code>request: requests.PreparedRequest</code>  <code>property</code>","text":"<p>The request leading to the error.</p>"},{"location":"api/#requests_oauth2client.exceptions.EndpointError","title":"<code>EndpointError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Base class for exceptions raised from backend endpoint errors.</p> <p>This contains the error message, description and uri that are returned by the AS in the OAuth 2.0 standardised way.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the raw response containing the error.</p> required <code>error</code> <code>str</code> <p>the <code>error</code> identifier as returned by the AS.</p> required <code>description</code> <code>str | None</code> <p>the <code>error_description</code> as returned by the AS.</p> <code>None</code> <code>uri</code> <code>str | None</code> <p>the <code>error_uri</code> as returned by the AS.</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class EndpointError(OAuth2Error):\n    \"\"\"Base class for exceptions raised from backend endpoint errors.\n\n    This contains the error message, description and uri that are returned\n    by the AS in the OAuth 2.0 standardised way.\n\n    Args:\n        response: the raw response containing the error.\n        error: the `error` identifier as returned by the AS.\n        description: the `error_description` as returned by the AS.\n        uri: the `error_uri` as returned by the AS.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        response: requests.Response,\n        client: OAuth2Client,\n        error: str,\n        description: str | None = None,\n        uri: str | None = None,\n    ) -&gt; None:\n        super().__init__(response=response, client=client)\n        self.error = error\n        self.description = description\n        self.uri = uri\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidTokenResponse","title":"<code>InvalidTokenResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Token Endpoint returns a non-standard response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidTokenResponse(OAuth2Error):\n    \"\"\"Raised when the Token Endpoint returns a non-standard response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnknownTokenEndpointError","title":"<code>UnknownTokenEndpointError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when an otherwise unknown error is returned by the token endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnknownTokenEndpointError(EndpointError):\n    \"\"\"Raised when an otherwise unknown error is returned by the token endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ServerError","title":"<code>ServerError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when the token endpoint returns <code>error = server_error</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ServerError(EndpointError):\n    \"\"\"Raised when the token endpoint returns `error = server_error`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.TokenEndpointError","title":"<code>TokenEndpointError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for errors that are specific to the token endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class TokenEndpointError(EndpointError):\n    \"\"\"Base class for errors that are specific to the token endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidRequest","title":"<code>InvalidRequest</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_request</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidRequest(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_request`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidClient","title":"<code>InvalidClient</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_client</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidClient(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_client`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidScope","title":"<code>InvalidScope</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_scope</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidScope(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_scope`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidTarget","title":"<code>InvalidTarget</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_target</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidTarget(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_target`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidGrant","title":"<code>InvalidGrant</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_grant</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidGrant(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_grant`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AccessDenied","title":"<code>AccessDenied</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when the Authorization Server returns <code>error = access_denied</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AccessDenied(EndpointError):\n    \"\"\"Raised when the Authorization Server returns `error = access_denied`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnauthorizedClient","title":"<code>UnauthorizedClient</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Raised when the Authorization Server returns <code>error = unauthorized_client</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnauthorizedClient(EndpointError):\n    \"\"\"Raised when the Authorization Server returns `error = unauthorized_client`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.RevocationError","title":"<code>RevocationError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for Revocation Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class RevocationError(EndpointError):\n    \"\"\"Base class for Revocation Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnsupportedTokenType","title":"<code>UnsupportedTokenType</code>","text":"<p>               Bases: <code>RevocationError</code></p> <p>Raised when the Revocation endpoint returns <code>error = unsupported_token_type</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnsupportedTokenType(RevocationError):\n    \"\"\"Raised when the Revocation endpoint returns `error = unsupported_token_type`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.IntrospectionError","title":"<code>IntrospectionError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for Introspection Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class IntrospectionError(EndpointError):\n    \"\"\"Base class for Introspection Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnknownIntrospectionError","title":"<code>UnknownIntrospectionError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Introspection Endpoint returns a non-standard error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnknownIntrospectionError(OAuth2Error):\n    \"\"\"Raised when the Introspection Endpoint returns a non-standard error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.DeviceAuthorizationError","title":"<code>DeviceAuthorizationError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for Device Authorization Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class DeviceAuthorizationError(EndpointError):\n    \"\"\"Base class for Device Authorization Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AuthorizationPending","title":"<code>AuthorizationPending</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = authorization_pending</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AuthorizationPending(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = authorization_pending`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.SlowDown","title":"<code>SlowDown</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = slow_down</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class SlowDown(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = slow_down`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ExpiredToken","title":"<code>ExpiredToken</code>","text":"<p>               Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = expired_token</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ExpiredToken(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = expired_token`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidDeviceAuthorizationResponse","title":"<code>InvalidDeviceAuthorizationResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Device Authorization Endpoint returns a non-standard error response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidDeviceAuthorizationResponse(OAuth2Error):\n    \"\"\"Raised when the Device Authorization Endpoint returns a non-standard error response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AuthorizationResponseError","title":"<code>AuthorizationResponseError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for error responses returned by the Authorization endpoint.</p> <p>An <code>AuthorizationResponseError</code> contains the error message, description and uri that are returned by the AS.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>str</code> <p>the <code>error</code> identifier as returned by the AS</p> required <code>description</code> <code>str | None</code> <p>the <code>error_description</code> as returned by the AS</p> <code>None</code> <code>uri</code> <code>str | None</code> <p>the <code>error_uri</code> as returned by the AS</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AuthorizationResponseError(Exception):\n    \"\"\"Base class for error responses returned by the Authorization endpoint.\n\n    An `AuthorizationResponseError` contains the error message, description and uri that are\n    returned by the AS.\n\n    Args:\n        error: the `error` identifier as returned by the AS\n        description: the `error_description` as returned by the AS\n        uri: the `error_uri` as returned by the AS\n\n    \"\"\"\n\n    def __init__(\n        self,\n        request: AuthorizationRequest,\n        response: str,\n        error: str,\n        description: str | None = None,\n        uri: str | None = None,\n    ) -&gt; None:\n        self.error = error\n        self.description = description\n        self.uri = uri\n        self.request = request\n        self.response = response\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InteractionRequired","title":"<code>InteractionRequired</code>","text":"<p>               Bases: <code>AuthorizationResponseError</code></p> <p>Raised when the Authorization Endpoint returns <code>error = interaction_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InteractionRequired(AuthorizationResponseError):\n    \"\"\"Raised when the Authorization Endpoint returns `error = interaction_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.LoginRequired","title":"<code>LoginRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = login_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class LoginRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = login_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AccountSelectionRequired","title":"<code>AccountSelectionRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = account_selection_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AccountSelectionRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = account_selection_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.SessionSelectionRequired","title":"<code>SessionSelectionRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = session_selection_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class SessionSelectionRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = session_selection_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ConsentRequired","title":"<code>ConsentRequired</code>","text":"<p>               Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = consent_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ConsentRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = consent_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidAuthResponse","title":"<code>InvalidAuthResponse</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when the Authorization Endpoint returns an invalid response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidAuthResponse(ValueError):\n    \"\"\"Raised when the Authorization Endpoint returns an invalid response.\"\"\"\n\n    def __init__(self, message: str, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(f\"The Authorization Response is invalid: {message}\")\n        self.request = request\n        self.response = response\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MissingAuthCode","title":"<code>MissingAuthCode</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return the mandatory <code>code</code>.</p> <p>This happens when the Authorization Endpoint does not return an error, but does not return an authorization <code>code</code> either.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingAuthCode(InvalidAuthResponse):\n    \"\"\"Raised when the Authorization Endpoint does not return the mandatory `code`.\n\n    This happens when the Authorization Endpoint does not return an error, but does not return an\n    authorization `code` either.\n\n    \"\"\"\n\n    def __init__(self, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(\"missing `code` query parameter in response\", request, response)\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MissingIssuer","title":"<code>MissingIssuer</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return an <code>iss</code> parameter as expected.</p> <p>The Authorization Server advertises its support with a flag <code>authorization_response_iss_parameter_supported</code> in its discovery document. If it is set to <code>true</code>, it must include an <code>iss</code> parameter in its authorization responses, containing its issuer identifier.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingIssuer(InvalidAuthResponse):\n    \"\"\"Raised when the Authorization Endpoint does not return an `iss` parameter as expected.\n\n    The Authorization Server advertises its support with a flag\n    `authorization_response_iss_parameter_supported` in its discovery document. If it is set to\n    `true`, it must include an `iss` parameter in its authorization responses, containing its issuer\n    identifier.\n\n    \"\"\"\n\n    def __init__(self, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(\"missing `iss` query parameter in response\", request, response)\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingState","title":"<code>MismatchingState</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised on mismatching <code>state</code> value.</p> <p>This happens when the Authorization Endpoints returns a 'state' parameter that doesn't match the value passed in the Authorization Request.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingState(InvalidAuthResponse):\n    \"\"\"Raised on mismatching `state` value.\n\n    This happens when the Authorization Endpoints returns a 'state' parameter that doesn't match the\n    value passed in the Authorization Request.\n\n    \"\"\"\n\n    def __init__(self, received: str, expected: str, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(f\"mismatching `state` (received '{received}', expected '{expected}')\", request, response)\n        self.received = received\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingIssuer","title":"<code>MismatchingIssuer</code>","text":"<p>               Bases: <code>InvalidAuthResponse</code></p> <p>Raised on mismatching <code>iss</code> value.</p> <p>This happens when the Authorization Endpoints returns an 'iss' that doesn't match the expected value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingIssuer(InvalidAuthResponse):\n    \"\"\"Raised on mismatching `iss` value.\n\n    This happens when the Authorization Endpoints returns an 'iss' that doesn't match the expected\n    value.\n\n    \"\"\"\n\n    def __init__(self, received: str, expected: str, request: AuthorizationRequest, response: str) -&gt; None:\n        super().__init__(f\"mismatching `iss` (received '{received}', expected '{expected}')\", request, response)\n        self.received = received\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.BackChannelAuthenticationError","title":"<code>BackChannelAuthenticationError</code>","text":"<p>               Bases: <code>EndpointError</code></p> <p>Base class for errors returned by the BackChannel Authentication endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class BackChannelAuthenticationError(EndpointError):\n    \"\"\"Base class for errors returned by the BackChannel Authentication endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidBackChannelAuthenticationResponse","title":"<code>InvalidBackChannelAuthenticationResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the BackChannel Authentication endpoint returns a non-standard response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidBackChannelAuthenticationResponse(OAuth2Error):\n    \"\"\"Raised when the BackChannel Authentication endpoint returns a non-standard response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidPushedAuthorizationResponse","title":"<code>InvalidPushedAuthorizationResponse</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Raised when the Pushed Authorization Endpoint returns an error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidPushedAuthorizationResponse(OAuth2Error):\n    \"\"\"Raised when the Pushed Authorization Endpoint returns an error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.flask","title":"<code>flask</code>","text":"<p>This module contains helper classes for the Flask Framework.</p> <p>See Flask framework.</p>"},{"location":"api/#requests_oauth2client.flask.FlaskOAuth2ClientCredentialsAuth","title":"<code>FlaskOAuth2ClientCredentialsAuth</code>","text":"<p>               Bases: <code>FlaskSessionAuthMixin</code>, <code>OAuth2ClientCredentialsAuth</code></p> <p>A <code>requests</code> Auth handler for CC grant that stores its token in Flask session.</p> <p>It will automatically get Access Tokens from an OAuth 2.x AS with the Client Credentials grant (and can get a new one once the first one is expired), and stores the retrieved token, serialized in Flask <code>session</code>, so that each user has a different access token.</p> Source code in <code>requests_oauth2client/flask/auth.py</code> <pre><code>class FlaskOAuth2ClientCredentialsAuth(FlaskSessionAuthMixin, OAuth2ClientCredentialsAuth):  # type: ignore[misc]\n    \"\"\"A `requests` Auth handler for CC grant that stores its token in Flask session.\n\n    It will automatically get Access Tokens from an OAuth 2.x AS with the Client Credentials grant\n    (and can get a new one once the first one is expired), and stores the retrieved token,\n    serialized in Flask `session`, so that each user has a different access token.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.flask.auth","title":"<code>auth</code>","text":"<p>Helper classes for the Flask framework.</p>"},{"location":"api/#requests_oauth2client.flask.auth.FlaskSessionAuthMixin","title":"<code>FlaskSessionAuthMixin</code>","text":"<p>A Mixin for auth handlers to store their tokens in Flask session.</p> <p>Storing tokens in Flask session does ensure that each user of a Flask application has a different access token, and that tokens used for backend API access will be persisted between multiple requests to the front-end Flask app.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>the key that will be used to store the access token in session.</p> required <code>serializer</code> <code>BearerTokenSerializer | None</code> <p>the serializer that will be used to store the access token in session.</p> <code>None</code> Source code in <code>requests_oauth2client/flask/auth.py</code> <pre><code>class FlaskSessionAuthMixin:\n    \"\"\"A Mixin for auth handlers to store their tokens in Flask session.\n\n    Storing tokens in Flask session does ensure that each user of a Flask application has a\n    different access token, and that tokens used for backend API access will be persisted between\n    multiple requests to the front-end Flask app.\n\n    Args:\n        session_key: the key that will be used to store the access token in session.\n        serializer: the serializer that will be used to store the access token in session.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        session_key: str,\n        serializer: BearerTokenSerializer | None = None,\n        *args: Any,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        super().__init__(*args, **token_kwargs)\n        self.serializer = serializer or BearerTokenSerializer()\n        self.session_key = session_key\n\n    @property\n    def token(self) -&gt; BearerToken | None:\n        \"\"\"Return the Access Token stored in session.\n\n        Returns:\n            The current `BearerToken` for this session, if any.\n\n        \"\"\"\n        serialized_token = session.get(self.session_key)\n        if serialized_token is None:\n            return None\n        return self.serializer.loads(serialized_token)\n\n    @token.setter\n    def token(self, token: BearerToken | str | None) -&gt; None:\n        \"\"\"Store an Access Token in session.\n\n        Args:\n            token: the token to store\n\n        \"\"\"\n        if isinstance(token, str):\n            token = BearerToken(token)  # pragma: no cover\n        if token:\n            serialized_token = self.serializer.dumps(token)\n            session[self.session_key] = serialized_token\n        elif session and self.session_key in session:\n            session.pop(self.session_key, None)\n</code></pre>"},{"location":"api/#requests_oauth2client.flask.auth.FlaskSessionAuthMixin.token","title":"<code>token: BearerToken | None</code>  <code>property</code> <code>writable</code>","text":"<p>Return the Access Token stored in session.</p> <p>Returns:</p> Type Description <code>BearerToken | None</code> <p>The current <code>BearerToken</code> for this session, if any.</p>"},{"location":"api/#requests_oauth2client.flask.auth.FlaskOAuth2ClientCredentialsAuth","title":"<code>FlaskOAuth2ClientCredentialsAuth</code>","text":"<p>               Bases: <code>FlaskSessionAuthMixin</code>, <code>OAuth2ClientCredentialsAuth</code></p> <p>A <code>requests</code> Auth handler for CC grant that stores its token in Flask session.</p> <p>It will automatically get Access Tokens from an OAuth 2.x AS with the Client Credentials grant (and can get a new one once the first one is expired), and stores the retrieved token, serialized in Flask <code>session</code>, so that each user has a different access token.</p> Source code in <code>requests_oauth2client/flask/auth.py</code> <pre><code>class FlaskOAuth2ClientCredentialsAuth(FlaskSessionAuthMixin, OAuth2ClientCredentialsAuth):  # type: ignore[misc]\n    \"\"\"A `requests` Auth handler for CC grant that stores its token in Flask session.\n\n    It will automatically get Access Tokens from an OAuth 2.x AS with the Client Credentials grant\n    (and can get a new one once the first one is expired), and stores the retrieved token,\n    serialized in Flask `session`, so that each user has a different access token.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.pooling","title":"<code>pooling</code>","text":"<p>Contains base classes for pooling jobs.</p>"},{"location":"api/#requests_oauth2client.pooling.BaseTokenEndpointPoolingJob","title":"<code>BaseTokenEndpointPoolingJob</code>","text":"<p>Base class for Token Endpoint pooling jobs.</p> <p>This is used for decoupled flows like CIBA or Device Authorization.</p> <p>This class must be subclassed to implement actual BackChannel flows. This needs an OAuth2Client that will be used to pool the token endpoint. The initial pooling <code>interval</code> is configurable.</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>@define\nclass BaseTokenEndpointPoolingJob:\n    \"\"\"Base class for Token Endpoint pooling jobs.\n\n    This is used for decoupled flows like CIBA or Device Authorization.\n\n    This class must be subclassed to implement actual BackChannel flows. This needs an\n    [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token\n    endpoint. The initial pooling `interval` is configurable.\n\n    \"\"\"\n\n    client: OAuth2Client\n    requests_kwargs: dict[str, Any]\n    token_kwargs: dict[str, Any]\n    interval: int\n    slow_down_interval: int\n\n    def __call__(self) -&gt; BearerToken | None:\n        \"\"\"Wrap the actual Token Endpoint call with a pooling interval.\n\n        Everytime this method is called, it will wait for the entire duration of the pooling\n        interval before calling\n        [token_request()][requests_oauth2client.pooling.TokenEndpointPoolingJob.token_request]. So\n        you can call it immediately after initiating the BackChannel flow, and it will wait before\n        initiating the first call.\n\n        This implements the logic to handle\n        [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] or\n        [SlowDown][requests_oauth2client.exceptions.SlowDown] requests by the AS.\n\n        Returns:\n            a `BearerToken` if the AS returns one, or `None` if the Authorization is still pending.\n\n        \"\"\"\n        self.sleep()\n        try:\n            return self.token_request()\n        except SlowDown:\n            self.slow_down()\n        except AuthorizationPending:\n            self.authorization_pending()\n        return None\n\n    def sleep(self) -&gt; None:\n        \"\"\"Implement the wait between two requests of the token endpoint.\n\n        By default, relies on time.sleep().\n\n        \"\"\"\n        time.sleep(self.interval)\n\n    def slow_down(self) -&gt; None:\n        \"\"\"Implement the behavior when receiving a 'slow_down' response from the AS.\n\n        By default, it increases the pooling interval by the slow down interval.\n\n        \"\"\"\n        self.interval += self.slow_down_interval\n\n    def authorization_pending(self) -&gt; None:\n        \"\"\"Implement the behavior when receiving an 'authorization_pending' response from the AS.\n\n        By default, it does nothing.\n\n        \"\"\"\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Abstract method for the token endpoint call.\n\n        Subclasses must implement this. This method must raise\n        [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after\n        the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase\n        the pooling interval by `slow_down_interval` seconds.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.pooling.BaseTokenEndpointPoolingJob.sleep","title":"<code>sleep()</code>","text":"<p>Implement the wait between two requests of the token endpoint.</p> <p>By default, relies on time.sleep().</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def sleep(self) -&gt; None:\n    \"\"\"Implement the wait between two requests of the token endpoint.\n\n    By default, relies on time.sleep().\n\n    \"\"\"\n    time.sleep(self.interval)\n</code></pre>"},{"location":"api/#requests_oauth2client.pooling.BaseTokenEndpointPoolingJob.slow_down","title":"<code>slow_down()</code>","text":"<p>Implement the behavior when receiving a 'slow_down' response from the AS.</p> <p>By default, it increases the pooling interval by the slow down interval.</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def slow_down(self) -&gt; None:\n    \"\"\"Implement the behavior when receiving a 'slow_down' response from the AS.\n\n    By default, it increases the pooling interval by the slow down interval.\n\n    \"\"\"\n    self.interval += self.slow_down_interval\n</code></pre>"},{"location":"api/#requests_oauth2client.pooling.BaseTokenEndpointPoolingJob.authorization_pending","title":"<code>authorization_pending()</code>","text":"<p>Implement the behavior when receiving an 'authorization_pending' response from the AS.</p> <p>By default, it does nothing.</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def authorization_pending(self) -&gt; None:\n    \"\"\"Implement the behavior when receiving an 'authorization_pending' response from the AS.\n\n    By default, it does nothing.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.pooling.BaseTokenEndpointPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Abstract method for the token endpoint call.</p> <p>Subclasses must implement this. This method must raise AuthorizationPending to retry after the pooling interval, or SlowDown to increase the pooling interval by <code>slow_down_interval</code> seconds.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Abstract method for the token endpoint call.\n\n    Subclasses must implement this. This method must raise\n    [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after\n    the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase\n    the pooling interval by `slow_down_interval` seconds.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens","title":"<code>tokens</code>","text":"<p>This module contains classes that represent Tokens used in OAuth2.0 / OIDC.</p>"},{"location":"api/#requests_oauth2client.tokens.TokenType","title":"<code>TokenType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum of standardised <code>token_type</code> values.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class TokenType(str, Enum):\n    \"\"\"An enum of standardised `token_type` values.\"\"\"\n\n    ACCESS_TOKEN = \"access_token\"\n    REFRESH_TOKEN = \"refresh_token\"\n    ID_TOKEN = \"id_token\"\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.AccessTokenType","title":"<code>AccessTokenType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum of standardised <code>access_token</code> types.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class AccessTokenType(str, Enum):\n    \"\"\"An enum of standardised `access_token` types.\"\"\"\n\n    BEARER = \"Bearer\"\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.UnsupportedTokenType","title":"<code>UnsupportedTokenType</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an unsupported token_type is provided.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class UnsupportedTokenType(ValueError):\n    \"\"\"Raised when an unsupported token_type is provided.\"\"\"\n\n    def __init__(self, token_type: str) -&gt; None:\n        super().__init__(f\"Unsupported token_type: {token_type}\")\n        self.token_type = token_type\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.IdToken","title":"<code>IdToken</code>","text":"<p>               Bases: <code>SignedJwt</code></p> <p>Represent an ID Token.</p> <p>An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be decoded beforehand.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class IdToken(jwskate.SignedJwt):\n    \"\"\"Represent an ID Token.\n\n    An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be decoded\n    beforehand.\n\n    \"\"\"\n\n    @property\n    def authorized_party(self) -&gt; str | None:\n        \"\"\"The Authorized Party (azp).\"\"\"\n        azp = self.claims.get(\"azp\")\n        if azp is None or isinstance(azp, str):\n            return azp\n        msg = \"`azp` attribute must be a string.\"\n        raise AttributeError(msg)\n\n    @property\n    def auth_datetime(self) -&gt; datetime | None:\n        \"\"\"The last user authentication time (auth_time).\"\"\"\n        auth_time = self.claims.get(\"auth_time\")\n        if auth_time is None:\n            return None\n        if isinstance(auth_time, int) and auth_time &gt; 0:\n            return self.timestamp_to_datetime(auth_time)\n        msg = \"`auth_time` must be a positive integer\"\n        raise AttributeError(msg)\n\n    @classmethod\n    def hash_method(cls, key: jwskate.Jwk, alg: str | None = None) -&gt; Callable[[str], str]:\n        \"\"\"Returns a callable that generates valid OIDC hashes, such as `at_hash`, `c_hash`, etc.\n\n        Args:\n            key: the ID token signature verification public key\n            alg: the ID token signature algorithm\n\n        Returns:\n            a callable that takes a string as input and produces a valid hash as a str output\n\n        \"\"\"\n        alg_class = jwskate.select_alg_class(key.SIGNATURE_ALGORITHMS, jwk_alg=key.alg, alg=alg)\n        if alg_class == jwskate.EdDsa:\n            if key.crv == \"Ed25519\":\n\n                def hash_method(token: str) -&gt; str:\n                    return BinaPy(token).to(\"sha512\")[:32].to(\"b64u\").decode()\n\n            elif key.crv == \"Ed448\":\n\n                def hash_method(token: str) -&gt; str:\n                    return BinaPy(token).to(\"shake256\", 456).to(\"b64u\").decode()\n\n        else:\n            hash_alg = alg_class.hashing_alg.name\n            hash_size = alg_class.hashing_alg.digest_size\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(hash_alg)[: hash_size // 2].to(\"b64u\").decode()\n\n        return hash_method\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.IdToken.authorized_party","title":"<code>authorized_party: str | None</code>  <code>property</code>","text":"<p>The Authorized Party (azp).</p>"},{"location":"api/#requests_oauth2client.tokens.IdToken.auth_datetime","title":"<code>auth_datetime: datetime | None</code>  <code>property</code>","text":"<p>The last user authentication time (auth_time).</p>"},{"location":"api/#requests_oauth2client.tokens.IdToken.hash_method","title":"<code>hash_method(key, alg=None)</code>  <code>classmethod</code>","text":"<p>Returns a callable that generates valid OIDC hashes, such as <code>at_hash</code>, <code>c_hash</code>, etc.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Jwk</code> <p>the ID token signature verification public key</p> required <code>alg</code> <code>str | None</code> <p>the ID token signature algorithm</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[str], str]</code> <p>a callable that takes a string as input and produces a valid hash as a str output</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@classmethod\ndef hash_method(cls, key: jwskate.Jwk, alg: str | None = None) -&gt; Callable[[str], str]:\n    \"\"\"Returns a callable that generates valid OIDC hashes, such as `at_hash`, `c_hash`, etc.\n\n    Args:\n        key: the ID token signature verification public key\n        alg: the ID token signature algorithm\n\n    Returns:\n        a callable that takes a string as input and produces a valid hash as a str output\n\n    \"\"\"\n    alg_class = jwskate.select_alg_class(key.SIGNATURE_ALGORITHMS, jwk_alg=key.alg, alg=alg)\n    if alg_class == jwskate.EdDsa:\n        if key.crv == \"Ed25519\":\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(\"sha512\")[:32].to(\"b64u\").decode()\n\n        elif key.crv == \"Ed448\":\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(\"shake256\", 456).to(\"b64u\").decode()\n\n    else:\n        hash_alg = alg_class.hashing_alg.name\n        hash_size = alg_class.hashing_alg.digest_size\n\n        def hash_method(token: str) -&gt; str:\n            return BinaPy(token).to(hash_alg)[: hash_size // 2].to(\"b64u\").decode()\n\n    return hash_method\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.InvalidIdToken","title":"<code>InvalidIdToken</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when trying to validate an invalid ID Token value.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class InvalidIdToken(ValueError):\n    \"\"\"Raised when trying to validate an invalid ID Token value.\"\"\"\n\n    def __init__(self, message: str, token: TokenResponse, id_token: IdToken | None = None) -&gt; None:\n        super().__init__(f\"Invalid ID Token: {message}\")\n        self.token = token\n        self.id_token = id_token\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.MissingIdToken","title":"<code>MissingIdToken</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the Authorization Endpoint does not return a mandatory ID Token.</p> <p>This happens when the Authorization Endpoint does not return an error, but does not return an ID Token either.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MissingIdToken(InvalidIdToken):\n    \"\"\"Raised when the Authorization Endpoint does not return a mandatory ID Token.\n\n    This happens when the Authorization Endpoint does not return an error, but does not return an ID\n    Token either.\n\n    \"\"\"\n\n    def __init__(self, token: TokenResponse) -&gt; None:\n        super().__init__(\"An expected `id_token` is missing in the response.\", token, None)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.MismatchingIdTokenIssuer","title":"<code>MismatchingIdTokenIssuer</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised on mismatching <code>iss</code> value in an ID Token.</p> <p>This happens when the expected <code>issuer</code> value is different from the <code>iss</code> value in an obtained ID Token.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenIssuer(InvalidIdToken):\n    \"\"\"Raised on mismatching `iss` value in an ID Token.\n\n    This happens when the expected `issuer` value is different from the `iss` value in an obtained ID Token.\n\n    \"\"\"\n\n    def __init__(self, iss: str | None, expected: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"`iss` from token '{iss}' does not match expected value '{expected}'\", token, id_token)\n        self.received = iss\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.MismatchingIdTokenNonce","title":"<code>MismatchingIdTokenNonce</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised on mismatching <code>nonce</code> value in an ID Token.</p> <p>This happens when the authorization request includes a <code>nonce</code> but the returned ID Token include a different value.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenNonce(InvalidIdToken):\n    \"\"\"Raised on mismatching `nonce` value in an ID Token.\n\n    This happens when the authorization request includes a `nonce` but the returned ID Token include\n    a different value.\n\n    \"\"\"\n\n    def __init__(self, nonce: str, expected: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"nonce from token '{nonce}' does not match expected value '{expected}'\", token, id_token)\n        self.received = nonce\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.MismatchingIdTokenAcr","title":"<code>MismatchingIdTokenAcr</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token doesn't contain one of the requested ACR Values.</p> <p>This happens when the authorization request includes an <code>acr_values</code> parameter but the returned ID Token includes a different value.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAcr(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token doesn't contain one of the requested ACR Values.\n\n    This happens when the authorization request includes an `acr_values` parameter but the returned\n    ID Token includes a different value.\n\n    \"\"\"\n\n    def __init__(self, acr: str, expected: Sequence[str], token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"token contains acr '{acr}' while client expects one of '{expected}'\", token, id_token)\n        self.received = acr\n        self.expected = expected\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.MismatchingIdTokenAudience","title":"<code>MismatchingIdTokenAudience</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the ID Token audience does not include the requesting Client ID.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAudience(InvalidIdToken):\n    \"\"\"Raised when the ID Token audience does not include the requesting Client ID.\"\"\"\n\n    def __init__(self, audiences: Sequence[str], client_id: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(\n            f\"token audience (`aud`) '{audiences}' does not match client_id '{client_id}'\", token, id_token\n        )\n        self.received = audiences\n        self.expected = client_id\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.MismatchingIdTokenAzp","title":"<code>MismatchingIdTokenAzp</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the ID Token Authorized Presenter (azp) claim is not the Client ID.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAzp(InvalidIdToken):\n    \"\"\"Raised when the ID Token Authorized Presenter (azp) claim is not the Client ID.\"\"\"\n\n    def __init__(self, azp: str, client_id: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(\n            f\"token Authorized Presenter (`azp`) claim '{azp}' does not match client_id '{client_id}'\", token, id_token\n        )\n        self.received = azp\n        self.expected = client_id\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.MismatchingIdTokenAlg","title":"<code>MismatchingIdTokenAlg</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token is signed with an unexpected alg.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class MismatchingIdTokenAlg(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token is signed with an unexpected alg.\"\"\"\n\n    def __init__(self, token_alg: str, client_alg: str, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(f\"token is signed with alg {token_alg}, client expects {client_alg}\", token, id_token)\n        self.received = token_alg\n        self.expected = client_alg\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.ExpiredIdToken","title":"<code>ExpiredIdToken</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token is expired.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class ExpiredIdToken(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token is expired.\"\"\"\n\n    def __init__(self, token: TokenResponse, id_token: IdToken) -&gt; None:\n        super().__init__(\"token is expired\", token, id_token)\n        self.received = id_token.expires_at\n        self.expected = datetime.now(tz=timezone.utc)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.UnsupportedIdTokenAlg","title":"<code>UnsupportedIdTokenAlg</code>","text":"<p>               Bases: <code>InvalidIdToken</code></p> <p>Raised when the return ID Token is signed with an unsupported alg.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class UnsupportedIdTokenAlg(InvalidIdToken):\n    \"\"\"Raised when the return ID Token is signed with an unsupported alg.\"\"\"\n\n    def __init__(self, token: TokenResponse, id_token: IdToken, alg: str) -&gt; None:\n        super().__init__(f\"token is signed with an unsupported alg {alg}\", token, id_token)\n        self.alg = alg\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.TokenResponse","title":"<code>TokenResponse</code>","text":"<p>Base class for Token Endpoint Responses.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class TokenResponse:\n    \"\"\"Base class for Token Endpoint Responses.\"\"\"\n\n    TOKEN_TYPE: ClassVar[str]\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.ExpiredAccessToken","title":"<code>ExpiredAccessToken</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Raised when an expired access token is used.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class ExpiredAccessToken(RuntimeError):\n    \"\"\"Raised when an expired access token is used.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken","title":"<code>BearerToken</code>","text":"<p>               Bases: <code>TokenResponse</code>, <code>AuthBase</code></p> <p>Represents a Bearer Token as returned by a Token Endpoint.</p> <p>This is a wrapper around a Bearer Token and associated parameters, such as expiration date and refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint.</p> <p>All parameters are as returned by a Token Endpoint. The token expiration date can be passed as datetime in the <code>expires_at</code> parameter, or an <code>expires_in</code> parameter, as number of seconds in the future, can be passed instead.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>str</code> <p>an <code>access_token</code>, as returned by the AS.</p> required <code>expires_at</code> <code>datetime | None</code> <p>an expiration date. This method also accepts an <code>expires_in</code> hint as returned by the AS, if any.</p> <code>None</code> <code>scope</code> <code>str | None</code> <p>a <code>scope</code>, as returned by the AS, if any.</p> <code>None</code> <code>refresh_token</code> <code>str | None</code> <p>a <code>refresh_token</code>, as returned by the AS, if any.</p> <code>None</code> <code>token_type</code> <code>str</code> <p>a <code>token_type</code>, as returned by the AS.</p> <code>TOKEN_TYPE</code> <code>id_token</code> <code>str | bytes | IdToken | JweCompact | None</code> <p>an <code>id_token</code>, as returned by the AS, if any.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters as returned by the AS, if any.</p> <code>{}</code> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@frozen(init=False)\nclass BearerToken(TokenResponse, requests.auth.AuthBase):\n    \"\"\"Represents a Bearer Token as returned by a Token Endpoint.\n\n    This is a wrapper around a Bearer Token and associated parameters, such as expiration date and\n    refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint.\n\n    All parameters are as returned by a Token Endpoint. The token expiration date can be passed as\n    datetime in the `expires_at` parameter, or an `expires_in` parameter, as number of seconds in\n    the future, can be passed instead.\n\n    Args:\n        access_token: an `access_token`, as returned by the AS.\n        expires_at: an expiration date. This method also accepts an `expires_in` hint as\n            returned by the AS, if any.\n        scope: a `scope`, as returned by the AS, if any.\n        refresh_token: a `refresh_token`, as returned by the AS, if any.\n        token_type: a `token_type`, as returned by the AS.\n        id_token: an `id_token`, as returned by the AS, if any.\n        **kwargs: additional parameters as returned by the AS, if any.\n\n    \"\"\"\n\n    TOKEN_TYPE: ClassVar[str] = AccessTokenType.BEARER.value\n    AUTHORIZATION_HEADER: ClassVar[str] = \"Authorization\"\n\n    access_token: str\n    expires_at: datetime | None = None\n    scope: str | None = None\n    refresh_token: str | None = None\n    token_type: str = TOKEN_TYPE\n    id_token: IdToken | jwskate.JweCompact | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        access_token: str,\n        *,\n        expires_at: datetime | None = None,\n        scope: str | None = None,\n        refresh_token: str | None = None,\n        token_type: str = TOKEN_TYPE,\n        id_token: str | bytes | IdToken | jwskate.JweCompact | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        if token_type.title() != self.TOKEN_TYPE.title():\n            raise UnsupportedTokenType(token_type)\n        id_token_jwt: IdToken | jwskate.JweCompact | None\n        if isinstance(id_token, (str, bytes)):\n            try:\n                id_token_jwt = IdToken(id_token)\n            except jwskate.InvalidJwt:\n                try:\n                    id_token_jwt = jwskate.JweCompact(id_token)\n                except jwskate.InvalidJwe:\n                    msg = \"token is neither a JWT or a JWE.\"\n                    raise InvalidIdToken(msg, self) from None\n        else:\n            id_token_jwt = id_token\n        self.__attrs_init__(\n            access_token=access_token,\n            expires_at=expires_at,\n            scope=scope,\n            refresh_token=refresh_token,\n            token_type=token_type,\n            id_token=id_token_jwt,\n            kwargs=kwargs,\n        )\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Check if the access token is expired.\n\n        Args:\n            leeway: If the token expires in the next given number of seconds,\n                then consider it expired already.\n\n        Returns:\n            One of:\n\n            - `True` if the access token is expired\n            - `False` if it is still valid\n            - `None` if there is no expires_in hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) + timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n\n    def authorization_header(self) -&gt; str:\n        \"\"\"Return the appropriate Authorization Header value for this token.\n\n        The value is formatted correctly according to RFC6750.\n\n        Returns:\n            the value to use in an HTTP Authorization Header\n\n        \"\"\"\n        return f\"Bearer {self.access_token}\"\n\n    def validate_id_token(  # noqa: PLR0915, C901\n        self, client: OAuth2Client, azr: AuthorizationResponse, exp_leeway: int = 0, auth_time_leeway: int = 10\n    ) -&gt; Self:\n        \"\"\"Validate the ID Token, and return a new instance with the decrypted ID Token.\n\n        If the ID Token was not encrypted, the returned instance will contain the same ID Token.\n\n        This will validate the id_token as described in [OIDC 1.0\n        $3.1.3.7](https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation).\n\n        Args:\n            client: the `OAuth2Client` that was used to obtain this token\n            azr: the `AuthorizationResponse`, as obtained by a call to `AuthorizationRequest.validate()`\n            exp_leeway: a leeway, in seconds, applied to the ID Token expiration date\n            auth_time_leeway: a leeway, in seconds, applied to the `auth_time` validation\n\n        Raises:\n            MissingIdToken: if the ID Token is missing\n            InvalidIdToken: this is a base exception class, which is raised:\n\n                - if the ID Token is not a JWT\n                - or is encrypted while a clear-text token is expected\n                - or is clear-text while an encrypted token is expected\n                - if token is encrypted but client does not have a decryption key\n                - if the token does not contain an `alg` header\n            MismatchingIdTokenAlg: if the `alg` header from the ID Token does not match\n                the expected `client.id_token_signed_response_alg`.\n            MismatchingIdTokenIssuer: if the `iss` claim from the ID Token does not match\n                the expected `azr.issuer`.\n            MismatchingIdTokenAcr: if the `acr` claim from the ID Token does not match\n                on of the expected `azr.acr_values`.\n            MismatchingIdTokenAudience: if the `aud` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenAzp: if the `azp` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenNonce: if the `nonce` claim from the ID Token does not match\n                the expected `azr.nonce`.\n            ExpiredIdToken: if the ID Token is expired at the time of the check.\n            UnsupportedIdTokenAlg: if the signature alg for the ID Token is not supported.\n\n        \"\"\"\n        if not self.id_token:\n            raise MissingIdToken(self)\n\n        raw_id_token = self.id_token\n\n        if isinstance(raw_id_token, jwskate.JweCompact) and client.id_token_encrypted_response_alg is None:\n            msg = \"token is encrypted while it should be clear-text\"\n            raise InvalidIdToken(msg, self)\n        if isinstance(raw_id_token, IdToken) and client.id_token_encrypted_response_alg is not None:\n            msg = \"token is clear-text while it should be encrypted\"\n            raise InvalidIdToken(msg, self)\n\n        if isinstance(raw_id_token, jwskate.JweCompact):\n            enc_jwk = client.id_token_decryption_key\n            if enc_jwk is None:\n                msg = \"token is encrypted but client does not have a decryption key\"\n                raise InvalidIdToken(msg, self)\n            nested_id_token = raw_id_token.decrypt(enc_jwk)\n            id_token = IdToken(nested_id_token)\n        else:\n            id_token = raw_id_token\n\n        id_token_alg = id_token.get_header(\"alg\")\n        if id_token_alg is None:\n            id_token_alg = client.id_token_signed_response_alg\n        if id_token_alg is None:\n            msg = \"\"\"\ntoken does not contain an `alg` parameter to specify the signature algorithm,\nand no algorithm has been configured for the client (using param `id_token_signed_response_alg`).\n\"\"\"\n            raise InvalidIdToken(msg, self, id_token)\n        if client.id_token_signed_response_alg is not None and id_token_alg != client.id_token_signed_response_alg:\n            raise MismatchingIdTokenAlg(id_token.alg, client.id_token_signed_response_alg, self, id_token)\n\n        verification_jwk: jwskate.Jwk\n\n        if id_token_alg in jwskate.SignatureAlgs.ALL_SYMMETRIC:\n            if not client.client_secret:\n                msg = \"token is symmetrically signed but this client does not have a Client Secret.\"\n                raise InvalidIdToken(msg, self, id_token)\n            verification_jwk = jwskate.SymmetricJwk.from_bytes(client.client_secret, alg=id_token_alg)\n            id_token.verify_signature(verification_jwk, alg=id_token_alg)\n        elif id_token_alg in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n            if not client.authorization_server_jwks:\n                msg = \"token is asymmetrically signed but the Authorization Server JWKS is not available.\"\n                raise InvalidIdToken(msg, self, id_token)\n\n            if id_token.get_header(\"kid\") is None:\n                msg = \"\"\"\ntoken does not contain a Key ID (kid) to specify the asymmetric key\nto use for signature verification.\"\"\"\n                raise InvalidIdToken(msg, self, id_token)\n            try:\n                verification_jwk = client.authorization_server_jwks.get_jwk_by_kid(id_token.kid)\n            except KeyError:\n                msg = f\"\"\"\\\ntoken is asymmetrically signed but there is no key\nwith kid='{id_token.kid}' in the Authorization Server JWKS.\"\"\"\n                raise InvalidIdToken(msg, self, id_token) from None\n\n            if id_token_alg not in verification_jwk.supported_signing_algorithms():\n                msg = \"token is asymmetrically signed but its algorithm is not supported by the verification key.\"\n                raise InvalidIdToken(msg, self, id_token)\n        else:\n            raise UnsupportedIdTokenAlg(self, id_token, id_token_alg)\n\n        id_token.verify(verification_jwk, alg=id_token_alg)\n\n        if azr.issuer and id_token.issuer != azr.issuer:\n            raise MismatchingIdTokenIssuer(id_token.issuer, azr.issuer, self, id_token)\n\n        if id_token.audiences and client.client_id not in id_token.audiences:\n            raise MismatchingIdTokenAudience(id_token.audiences, client.client_id, self, id_token)\n\n        if id_token.authorized_party is not None and id_token.authorized_party != client.client_id:\n            raise MismatchingIdTokenAzp(id_token.azp, client.client_id, self, id_token)\n\n        if id_token.is_expired(leeway=exp_leeway):\n            raise ExpiredIdToken(self, id_token)\n\n        if azr.nonce and id_token.nonce != azr.nonce:\n            raise MismatchingIdTokenNonce(id_token.nonce, azr.nonce, self, id_token)\n\n        if azr.acr_values and id_token.acr not in azr.acr_values:\n            raise MismatchingIdTokenAcr(id_token.acr, azr.acr_values, self, id_token)\n\n        hash_function = IdToken.hash_method(verification_jwk, id_token_alg)\n\n        at_hash = id_token.get_claim(\"at_hash\")\n        if at_hash is not None:\n            expected_at_hash = hash_function(self.access_token)\n            if expected_at_hash != at_hash:\n                msg = f\"mismatching 'at_hash' value (expected '{expected_at_hash}', got '{at_hash}')\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        c_hash = id_token.get_claim(\"c_hash\")\n        if c_hash is not None:\n            expected_c_hash = hash_function(azr.code)\n            if expected_c_hash != c_hash:\n                msg = f\"mismatching 'c_hash' value (expected '{expected_c_hash}', got '{c_hash}')\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        s_hash = id_token.get_claim(\"s_hash\")\n        if s_hash is not None:\n            if azr.state is None:\n                msg = \"token has a 's_hash' claim but no state was included in the request.\"\n                raise InvalidIdToken(msg, self, id_token)\n            expected_s_hash = hash_function(azr.state)\n            if expected_s_hash != s_hash:\n                msg = f\"mismatching 's_hash' value (expected '{expected_s_hash}', got '{s_hash}')\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        if azr.max_age is not None:\n            auth_time = id_token.auth_datetime\n            if auth_time is None:\n                msg = \"\"\"\na `max_age` parameter was included in the authorization request,\nbut the ID Token does not contain an `auth_time` claim.\n\"\"\"\n                raise InvalidIdToken(msg, self, id_token) from None\n            auth_age = datetime.now(tz=timezone.utc) - auth_time\n            if auth_age.total_seconds() &gt; azr.max_age + auth_time_leeway:\n                msg = f\"\"\"\nuser authentication happened too far in the past.\nThe `auth_time` parameter from the ID Token indicate that\nthe last Authentication Time was at {auth_time} ({auth_age.total_seconds()} sec ago),\nbut the authorization request `max_age` parameter specified that it must\nbe a maximum of {azr.max_age} sec ago.\n\"\"\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        return self.__class__(\n            access_token=self.access_token,\n            expires_at=self.expires_at,\n            scope=self.scope,\n            refresh_token=self.refresh_token,\n            token_type=self.token_type,\n            id_token=id_token,\n            **self.kwargs,\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the access token value, as a string.\n\n        Returns:\n            the access token string\n\n        \"\"\"\n        return self.access_token\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dict of parameters.\n\n        That is suitable for serialization or to init another BearerToken.\n\n        \"\"\"\n        d = asdict(self)\n        d.pop(\"expires_at\")\n        d[\"expires_in\"] = self.expires_in\n        d.update(**d.pop(\"kwargs\", {}))\n        return {key: val for key, val in d.items() if val is not None}\n\n    @property\n    def expires_in(self) -&gt; int | None:\n        \"\"\"Number of seconds until expiration.\"\"\"\n        if self.expires_at:\n            return ceil((self.expires_at - datetime.now(tz=timezone.utc)).total_seconds())\n        return None\n\n    def __getattr__(self, key: str) -&gt; Any:\n        \"\"\"Return custom attributes from this BearerToken.\n\n        Args:\n            key: a key\n\n        Returns:\n            the associated value in this token response\n\n        Raises:\n            AttributeError: if the attribute is not found in this response.\n\n        \"\"\"\n        return self.kwargs.get(key) or super().__getattribute__(key)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the usage of Bearer Tokens in requests.\n\n        This will add a properly formatted `Authorization: Bearer &lt;token&gt;` header in the request.\n\n        If the configured token is an instance of BearerToken with an expires_at attribute, raises\n        [ExpiredAccessToken][requests_oauth2client.exceptions.ExpiredAccessToken] once the access\n        token is expired.\n\n        Args:\n            request: the request\n\n        Returns:\n            the same request with an Access Token added in `Authorization` Header\n\n        Raises:\n            ExpiredAccessToken: if the token is expired\n\n        \"\"\"\n        if self.access_token is None:\n            return request  # pragma: no cover\n        if self.is_expired():\n            raise ExpiredAccessToken(self)\n        request.headers[self.AUTHORIZATION_HEADER] = self.authorization_header()\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.expires_in","title":"<code>expires_in: int | None</code>  <code>property</code>","text":"<p>Number of seconds until expiration.</p>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Check if the access token is expired.</p> <p>Parameters:</p> Name Type Description Default <code>leeway</code> <code>int</code> <p>If the token expires in the next given number of seconds, then consider it expired already.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>One of:</p> <code>bool | None</code> <ul> <li><code>True</code> if the access token is expired</li> </ul> <code>bool | None</code> <ul> <li><code>False</code> if it is still valid</li> </ul> <code>bool | None</code> <ul> <li><code>None</code> if there is no expires_in hint.</li> </ul> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Check if the access token is expired.\n\n    Args:\n        leeway: If the token expires in the next given number of seconds,\n            then consider it expired already.\n\n    Returns:\n        One of:\n\n        - `True` if the access token is expired\n        - `False` if it is still valid\n        - `None` if there is no expires_in hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) + timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.authorization_header","title":"<code>authorization_header()</code>","text":"<p>Return the appropriate Authorization Header value for this token.</p> <p>The value is formatted correctly according to RFC6750.</p> <p>Returns:</p> Type Description <code>str</code> <p>the value to use in an HTTP Authorization Header</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def authorization_header(self) -&gt; str:\n    \"\"\"Return the appropriate Authorization Header value for this token.\n\n    The value is formatted correctly according to RFC6750.\n\n    Returns:\n        the value to use in an HTTP Authorization Header\n\n    \"\"\"\n    return f\"Bearer {self.access_token}\"\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.validate_id_token","title":"<code>validate_id_token(client, azr, exp_leeway=0, auth_time_leeway=10)</code>","text":"<p>Validate the ID Token, and return a new instance with the decrypted ID Token.</p> <p>If the ID Token was not encrypted, the returned instance will contain the same ID Token.</p> <p>This will validate the id_token as described in OIDC 1.0 $3.1.3.7.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the <code>OAuth2Client</code> that was used to obtain this token</p> required <code>azr</code> <code>AuthorizationResponse</code> <p>the <code>AuthorizationResponse</code>, as obtained by a call to <code>AuthorizationRequest.validate()</code></p> required <code>exp_leeway</code> <code>int</code> <p>a leeway, in seconds, applied to the ID Token expiration date</p> <code>0</code> <code>auth_time_leeway</code> <code>int</code> <p>a leeway, in seconds, applied to the <code>auth_time</code> validation</p> <code>10</code> <p>Raises:</p> Type Description <code>MissingIdToken</code> <p>if the ID Token is missing</p> <code>InvalidIdToken</code> <p>this is a base exception class, which is raised:</p> <ul> <li>if the ID Token is not a JWT</li> <li>or is encrypted while a clear-text token is expected</li> <li>or is clear-text while an encrypted token is expected</li> <li>if token is encrypted but client does not have a decryption key</li> <li>if the token does not contain an <code>alg</code> header</li> </ul> <code>MismatchingIdTokenAlg</code> <p>if the <code>alg</code> header from the ID Token does not match the expected <code>client.id_token_signed_response_alg</code>.</p> <code>MismatchingIdTokenIssuer</code> <p>if the <code>iss</code> claim from the ID Token does not match the expected <code>azr.issuer</code>.</p> <code>MismatchingIdTokenAcr</code> <p>if the <code>acr</code> claim from the ID Token does not match on of the expected <code>azr.acr_values</code>.</p> <code>MismatchingIdTokenAudience</code> <p>if the <code>aud</code> claim from the ID Token does not match the expected <code>client.client_id</code>.</p> <code>MismatchingIdTokenAzp</code> <p>if the <code>azp</code> claim from the ID Token does not match the expected <code>client.client_id</code>.</p> <code>MismatchingIdTokenNonce</code> <p>if the <code>nonce</code> claim from the ID Token does not match the expected <code>azr.nonce</code>.</p> <code>ExpiredIdToken</code> <p>if the ID Token is expired at the time of the check.</p> <code>UnsupportedIdTokenAlg</code> <p>if the signature alg for the ID Token is not supported.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>    def validate_id_token(  # noqa: PLR0915, C901\n        self, client: OAuth2Client, azr: AuthorizationResponse, exp_leeway: int = 0, auth_time_leeway: int = 10\n    ) -&gt; Self:\n        \"\"\"Validate the ID Token, and return a new instance with the decrypted ID Token.\n\n        If the ID Token was not encrypted, the returned instance will contain the same ID Token.\n\n        This will validate the id_token as described in [OIDC 1.0\n        $3.1.3.7](https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation).\n\n        Args:\n            client: the `OAuth2Client` that was used to obtain this token\n            azr: the `AuthorizationResponse`, as obtained by a call to `AuthorizationRequest.validate()`\n            exp_leeway: a leeway, in seconds, applied to the ID Token expiration date\n            auth_time_leeway: a leeway, in seconds, applied to the `auth_time` validation\n\n        Raises:\n            MissingIdToken: if the ID Token is missing\n            InvalidIdToken: this is a base exception class, which is raised:\n\n                - if the ID Token is not a JWT\n                - or is encrypted while a clear-text token is expected\n                - or is clear-text while an encrypted token is expected\n                - if token is encrypted but client does not have a decryption key\n                - if the token does not contain an `alg` header\n            MismatchingIdTokenAlg: if the `alg` header from the ID Token does not match\n                the expected `client.id_token_signed_response_alg`.\n            MismatchingIdTokenIssuer: if the `iss` claim from the ID Token does not match\n                the expected `azr.issuer`.\n            MismatchingIdTokenAcr: if the `acr` claim from the ID Token does not match\n                on of the expected `azr.acr_values`.\n            MismatchingIdTokenAudience: if the `aud` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenAzp: if the `azp` claim from the ID Token does not match\n                the expected `client.client_id`.\n            MismatchingIdTokenNonce: if the `nonce` claim from the ID Token does not match\n                the expected `azr.nonce`.\n            ExpiredIdToken: if the ID Token is expired at the time of the check.\n            UnsupportedIdTokenAlg: if the signature alg for the ID Token is not supported.\n\n        \"\"\"\n        if not self.id_token:\n            raise MissingIdToken(self)\n\n        raw_id_token = self.id_token\n\n        if isinstance(raw_id_token, jwskate.JweCompact) and client.id_token_encrypted_response_alg is None:\n            msg = \"token is encrypted while it should be clear-text\"\n            raise InvalidIdToken(msg, self)\n        if isinstance(raw_id_token, IdToken) and client.id_token_encrypted_response_alg is not None:\n            msg = \"token is clear-text while it should be encrypted\"\n            raise InvalidIdToken(msg, self)\n\n        if isinstance(raw_id_token, jwskate.JweCompact):\n            enc_jwk = client.id_token_decryption_key\n            if enc_jwk is None:\n                msg = \"token is encrypted but client does not have a decryption key\"\n                raise InvalidIdToken(msg, self)\n            nested_id_token = raw_id_token.decrypt(enc_jwk)\n            id_token = IdToken(nested_id_token)\n        else:\n            id_token = raw_id_token\n\n        id_token_alg = id_token.get_header(\"alg\")\n        if id_token_alg is None:\n            id_token_alg = client.id_token_signed_response_alg\n        if id_token_alg is None:\n            msg = \"\"\"\ntoken does not contain an `alg` parameter to specify the signature algorithm,\nand no algorithm has been configured for the client (using param `id_token_signed_response_alg`).\n\"\"\"\n            raise InvalidIdToken(msg, self, id_token)\n        if client.id_token_signed_response_alg is not None and id_token_alg != client.id_token_signed_response_alg:\n            raise MismatchingIdTokenAlg(id_token.alg, client.id_token_signed_response_alg, self, id_token)\n\n        verification_jwk: jwskate.Jwk\n\n        if id_token_alg in jwskate.SignatureAlgs.ALL_SYMMETRIC:\n            if not client.client_secret:\n                msg = \"token is symmetrically signed but this client does not have a Client Secret.\"\n                raise InvalidIdToken(msg, self, id_token)\n            verification_jwk = jwskate.SymmetricJwk.from_bytes(client.client_secret, alg=id_token_alg)\n            id_token.verify_signature(verification_jwk, alg=id_token_alg)\n        elif id_token_alg in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n            if not client.authorization_server_jwks:\n                msg = \"token is asymmetrically signed but the Authorization Server JWKS is not available.\"\n                raise InvalidIdToken(msg, self, id_token)\n\n            if id_token.get_header(\"kid\") is None:\n                msg = \"\"\"\ntoken does not contain a Key ID (kid) to specify the asymmetric key\nto use for signature verification.\"\"\"\n                raise InvalidIdToken(msg, self, id_token)\n            try:\n                verification_jwk = client.authorization_server_jwks.get_jwk_by_kid(id_token.kid)\n            except KeyError:\n                msg = f\"\"\"\\\ntoken is asymmetrically signed but there is no key\nwith kid='{id_token.kid}' in the Authorization Server JWKS.\"\"\"\n                raise InvalidIdToken(msg, self, id_token) from None\n\n            if id_token_alg not in verification_jwk.supported_signing_algorithms():\n                msg = \"token is asymmetrically signed but its algorithm is not supported by the verification key.\"\n                raise InvalidIdToken(msg, self, id_token)\n        else:\n            raise UnsupportedIdTokenAlg(self, id_token, id_token_alg)\n\n        id_token.verify(verification_jwk, alg=id_token_alg)\n\n        if azr.issuer and id_token.issuer != azr.issuer:\n            raise MismatchingIdTokenIssuer(id_token.issuer, azr.issuer, self, id_token)\n\n        if id_token.audiences and client.client_id not in id_token.audiences:\n            raise MismatchingIdTokenAudience(id_token.audiences, client.client_id, self, id_token)\n\n        if id_token.authorized_party is not None and id_token.authorized_party != client.client_id:\n            raise MismatchingIdTokenAzp(id_token.azp, client.client_id, self, id_token)\n\n        if id_token.is_expired(leeway=exp_leeway):\n            raise ExpiredIdToken(self, id_token)\n\n        if azr.nonce and id_token.nonce != azr.nonce:\n            raise MismatchingIdTokenNonce(id_token.nonce, azr.nonce, self, id_token)\n\n        if azr.acr_values and id_token.acr not in azr.acr_values:\n            raise MismatchingIdTokenAcr(id_token.acr, azr.acr_values, self, id_token)\n\n        hash_function = IdToken.hash_method(verification_jwk, id_token_alg)\n\n        at_hash = id_token.get_claim(\"at_hash\")\n        if at_hash is not None:\n            expected_at_hash = hash_function(self.access_token)\n            if expected_at_hash != at_hash:\n                msg = f\"mismatching 'at_hash' value (expected '{expected_at_hash}', got '{at_hash}')\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        c_hash = id_token.get_claim(\"c_hash\")\n        if c_hash is not None:\n            expected_c_hash = hash_function(azr.code)\n            if expected_c_hash != c_hash:\n                msg = f\"mismatching 'c_hash' value (expected '{expected_c_hash}', got '{c_hash}')\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        s_hash = id_token.get_claim(\"s_hash\")\n        if s_hash is not None:\n            if azr.state is None:\n                msg = \"token has a 's_hash' claim but no state was included in the request.\"\n                raise InvalidIdToken(msg, self, id_token)\n            expected_s_hash = hash_function(azr.state)\n            if expected_s_hash != s_hash:\n                msg = f\"mismatching 's_hash' value (expected '{expected_s_hash}', got '{s_hash}')\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        if azr.max_age is not None:\n            auth_time = id_token.auth_datetime\n            if auth_time is None:\n                msg = \"\"\"\na `max_age` parameter was included in the authorization request,\nbut the ID Token does not contain an `auth_time` claim.\n\"\"\"\n                raise InvalidIdToken(msg, self, id_token) from None\n            auth_age = datetime.now(tz=timezone.utc) - auth_time\n            if auth_age.total_seconds() &gt; azr.max_age + auth_time_leeway:\n                msg = f\"\"\"\nuser authentication happened too far in the past.\nThe `auth_time` parameter from the ID Token indicate that\nthe last Authentication Time was at {auth_time} ({auth_age.total_seconds()} sec ago),\nbut the authorization request `max_age` parameter specified that it must\nbe a maximum of {azr.max_age} sec ago.\n\"\"\"\n                raise InvalidIdToken(msg, self, id_token)\n\n        return self.__class__(\n            access_token=self.access_token,\n            expires_at=self.expires_at,\n            scope=self.scope,\n            refresh_token=self.refresh_token,\n            token_type=self.token_type,\n            id_token=id_token,\n            **self.kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.as_dict","title":"<code>as_dict()</code>","text":"<p>Return a dict of parameters.</p> <p>That is suitable for serialization or to init another BearerToken.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return a dict of parameters.\n\n    That is suitable for serialization or to init another BearerToken.\n\n    \"\"\"\n    d = asdict(self)\n    d.pop(\"expires_at\")\n    d[\"expires_in\"] = self.expires_in\n    d.update(**d.pop(\"kwargs\", {}))\n    return {key: val for key, val in d.items() if val is not None}\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer","title":"<code>BearerTokenSerializer</code>","text":"<p>A helper class to serialize Token Response returned by an AS.</p> <p>This may be used to store BearerTokens in session or cookies.</p> <p>It needs a <code>dumper</code> and a <code>loader</code> functions that will respectively serialize and deserialize BearerTokens. Default implementations are provided with use gzip and base64url on the serialized JSON representation.</p> <p>Parameters:</p> Name Type Description Default <code>dumper</code> <code>Callable[[BearerToken], str] | None</code> <p>a function to serialize a token into a <code>str</code>.</p> <code>None</code> <code>loader</code> <code>Callable[[str], BearerToken] | None</code> <p>a function to deserialize a serialized token representation.</p> <code>None</code> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class BearerTokenSerializer:\n    \"\"\"A helper class to serialize Token Response returned by an AS.\n\n    This may be used to store BearerTokens in session or cookies.\n\n    It needs a `dumper` and a `loader` functions that will respectively serialize and deserialize\n    BearerTokens. Default implementations are provided with use gzip and base64url on the serialized\n    JSON representation.\n\n    Args:\n        dumper: a function to serialize a token into a `str`.\n        loader: a function to deserialize a serialized token representation.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        dumper: Callable[[BearerToken], str] | None = None,\n        loader: Callable[[str], BearerToken] | None = None,\n    ) -&gt; None:\n        self.dumper = dumper or self.default_dumper\n        self.loader = loader or self.default_loader\n\n    @staticmethod\n    def default_dumper(token: BearerToken) -&gt; str:\n        \"\"\"Serialize a token as JSON, then compress with deflate, then encodes as base64url.\n\n        Args:\n            token: the `BearerToken` to serialize\n\n        Returns:\n            the serialized value\n\n        \"\"\"\n        d = asdict(token)\n        d.update(**d.pop(\"kwargs\", {}))\n        return (\n            BinaPy.serialize_to(\"json\", {k: w for k, w in d.items() if w is not None}).to(\"deflate\").to(\"b64u\").ascii()\n        )\n\n    def default_loader(self, serialized: str, token_class: type[BearerToken] = BearerToken) -&gt; BearerToken:\n        \"\"\"Deserialize a BearerToken.\n\n        This does the opposite operations than `default_dumper`.\n\n        Args:\n            serialized: the serialized token\n            token_class: class to use to deserialize the Token\n\n        Returns:\n            a BearerToken\n\n        \"\"\"\n        attrs = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n        expires_at = attrs.get(\"expires_at\")\n        if expires_at:\n            attrs[\"expires_at\"] = datetime.fromtimestamp(expires_at, tz=timezone.utc)\n        return token_class(**attrs)\n\n    def dumps(self, token: BearerToken) -&gt; str:\n        \"\"\"Serialize and compress a given token for easier storage.\n\n        Args:\n            token: a BearerToken to serialize\n\n        Returns:\n            the serialized token, as a str\n\n        \"\"\"\n        return self.dumper(token)\n\n    def loads(self, serialized: str) -&gt; BearerToken:\n        \"\"\"Deserialize a serialized token.\n\n        Args:\n            serialized: the serialized token\n\n        Returns:\n            the deserialized token\n\n        \"\"\"\n        return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.default_dumper","title":"<code>default_dumper(token)</code>  <code>staticmethod</code>","text":"<p>Serialize a token as JSON, then compress with deflate, then encodes as base64url.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BearerToken</code> <p>the <code>BearerToken</code> to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized value</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@staticmethod\ndef default_dumper(token: BearerToken) -&gt; str:\n    \"\"\"Serialize a token as JSON, then compress with deflate, then encodes as base64url.\n\n    Args:\n        token: the `BearerToken` to serialize\n\n    Returns:\n        the serialized value\n\n    \"\"\"\n    d = asdict(token)\n    d.update(**d.pop(\"kwargs\", {}))\n    return (\n        BinaPy.serialize_to(\"json\", {k: w for k, w in d.items() if w is not None}).to(\"deflate\").to(\"b64u\").ascii()\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.default_loader","title":"<code>default_loader(serialized, token_class=BearerToken)</code>","text":"<p>Deserialize a BearerToken.</p> <p>This does the opposite operations than <code>default_dumper</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized token</p> required <code>token_class</code> <code>type[BearerToken]</code> <p>class to use to deserialize the Token</p> <code>BearerToken</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def default_loader(self, serialized: str, token_class: type[BearerToken] = BearerToken) -&gt; BearerToken:\n    \"\"\"Deserialize a BearerToken.\n\n    This does the opposite operations than `default_dumper`.\n\n    Args:\n        serialized: the serialized token\n        token_class: class to use to deserialize the Token\n\n    Returns:\n        a BearerToken\n\n    \"\"\"\n    attrs = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n    expires_at = attrs.get(\"expires_at\")\n    if expires_at:\n        attrs[\"expires_at\"] = datetime.fromtimestamp(expires_at, tz=timezone.utc)\n    return token_class(**attrs)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.dumps","title":"<code>dumps(token)</code>","text":"<p>Serialize and compress a given token for easier storage.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BearerToken</code> <p>a BearerToken to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized token, as a str</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def dumps(self, token: BearerToken) -&gt; str:\n    \"\"\"Serialize and compress a given token for easier storage.\n\n    Args:\n        token: a BearerToken to serialize\n\n    Returns:\n        the serialized token, as a str\n\n    \"\"\"\n    return self.dumper(token)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.loads","title":"<code>loads(serialized)</code>","text":"<p>Deserialize a serialized token.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized token</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>the deserialized token</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def loads(self, serialized: str) -&gt; BearerToken:\n    \"\"\"Deserialize a serialized token.\n\n    Args:\n        serialized: the serialized token\n\n    Returns:\n        the deserialized token\n\n    \"\"\"\n    return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific","title":"<code>vendor_specific</code>","text":"<p>Vendor-specific utilities.</p> <p>This module contains vendor-specific subclasses of [requests_oauth2client] classes, that make it easier to work with specific OAuth 2.x providers and/or fix compatibility issues.</p>"},{"location":"api/#requests_oauth2client.vendor_specific.Auth0","title":"<code>Auth0</code>","text":"<p>Auth0-related utilities.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>class Auth0:\n    \"\"\"Auth0-related utilities.\"\"\"\n\n    @classmethod\n    def tenant(cls, tenant: str) -&gt; str:\n        \"\"\"Given a short tenant name, returns the full tenant FQDN.\"\"\"\n        if not tenant:\n            msg = \"You must specify a tenant name.\"\n            raise ValueError(msg)\n        if \".\" not in tenant or tenant.endswith((\".eu\", \".us\", \".au\", \".jp\")):\n            tenant = f\"{tenant}.auth0.com\"\n        if \"://\" in tenant:\n            if tenant.startswith(\"https://\"):\n                return tenant[8:]\n            msg = (\n                \"Invalid tenant name. \"\n                \"It must be a tenant name like 'mytenant.myregion' \"\n                \"or a full FQDN like 'mytenant.myregion.auth0.com'.\"\n                \"or an issuer like 'https://mytenant.myregion.auth0.com'\"\n            )\n            raise ValueError(msg)\n        return tenant\n\n    @classmethod\n    def client(\n        cls,\n        tenant: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any | None = None,\n        session: requests.Session | None = None,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialise an OAuth2Client for an Auth0 tenant.\"\"\"\n        tenant = cls.tenant(tenant)\n        issuer = f\"https://{tenant}\"\n        token_endpoint = f\"{issuer}/oauth/token\"\n        authorization_endpoint = f\"{issuer}/authorize\"\n        revocation_endpoint = f\"{issuer}/oauth/revoke\"\n        userinfo_endpoint = f\"{issuer}/userinfo\"\n        jwks_uri = f\"{issuer}/.well-known/jwks.json\"\n\n        return OAuth2Client(\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            issuer=issuer,\n            jwks_uri=jwks_uri,\n            **kwargs,\n        )\n\n    @classmethod\n    def management_api_client(\n        cls,\n        tenant: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any | None = None,\n        session: requests.Session | None = None,\n        **kwargs: Any,\n    ) -&gt; ApiClient:\n        \"\"\"Initialize a client for the Auth0 Management API.\n\n        See [Auth0 Management API v2](https://auth0.com/docs/api/management/v2). You must provide the\n        target tenant name and the credentials for a client that is allowed access to the Management\n        API.\n\n        Args:\n            tenant: the tenant name.\n                Same definition as for [Auth0.client][requests_oauth2client.vendor_specific.auth0.Auth0.client]\n            auth: client credentials.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            client_id: the Client ID.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            client_secret: the Client Secret.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            private_jwk: the private key to use for client authentication.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            session: requests session.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            **kwargs: additional kwargs to pass to the ApiClient base class\n\n        Example:\n            ```python\n            from requests_oauth2client.vendor_specific import Auth0\n\n            a0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\n            users = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n            ```\n\n        \"\"\"\n        tenant = cls.tenant(tenant)\n        client = cls.client(\n            tenant,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n        )\n        audience = f\"https://{tenant}/api/v2/\"\n        api_auth = OAuth2ClientCredentialsAuth(client, audience=audience)\n        return ApiClient(\n            base_url=audience,\n            auth=api_auth,\n            session=session,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.Auth0.tenant","title":"<code>tenant(tenant)</code>  <code>classmethod</code>","text":"<p>Given a short tenant name, returns the full tenant FQDN.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef tenant(cls, tenant: str) -&gt; str:\n    \"\"\"Given a short tenant name, returns the full tenant FQDN.\"\"\"\n    if not tenant:\n        msg = \"You must specify a tenant name.\"\n        raise ValueError(msg)\n    if \".\" not in tenant or tenant.endswith((\".eu\", \".us\", \".au\", \".jp\")):\n        tenant = f\"{tenant}.auth0.com\"\n    if \"://\" in tenant:\n        if tenant.startswith(\"https://\"):\n            return tenant[8:]\n        msg = (\n            \"Invalid tenant name. \"\n            \"It must be a tenant name like 'mytenant.myregion' \"\n            \"or a full FQDN like 'mytenant.myregion.auth0.com'.\"\n            \"or an issuer like 'https://mytenant.myregion.auth0.com'\"\n        )\n        raise ValueError(msg)\n    return tenant\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.Auth0.client","title":"<code>client(tenant, auth=None, *, client_id=None, client_secret=None, private_jwk=None, session=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialise an OAuth2Client for an Auth0 tenant.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef client(\n    cls,\n    tenant: str,\n    auth: (\n        requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n    ) = None,\n    *,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any | None = None,\n    session: requests.Session | None = None,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n    \"\"\"Initialise an OAuth2Client for an Auth0 tenant.\"\"\"\n    tenant = cls.tenant(tenant)\n    issuer = f\"https://{tenant}\"\n    token_endpoint = f\"{issuer}/oauth/token\"\n    authorization_endpoint = f\"{issuer}/authorize\"\n    revocation_endpoint = f\"{issuer}/oauth/revoke\"\n    userinfo_endpoint = f\"{issuer}/userinfo\"\n    jwks_uri = f\"{issuer}/.well-known/jwks.json\"\n\n    return OAuth2Client(\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n        token_endpoint=token_endpoint,\n        authorization_endpoint=authorization_endpoint,\n        revocation_endpoint=revocation_endpoint,\n        userinfo_endpoint=userinfo_endpoint,\n        issuer=issuer,\n        jwks_uri=jwks_uri,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.Auth0.management_api_client","title":"<code>management_api_client(tenant, auth=None, *, client_id=None, client_secret=None, private_jwk=None, session=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize a client for the Auth0 Management API.</p> <p>See Auth0 Management API v2. You must provide the target tenant name and the credentials for a client that is allowed access to the Management API.</p> <p>Parameters:</p> Name Type Description Default <code>tenant</code> <code>str</code> <p>the tenant name. Same definition as for Auth0.client</p> required <code>auth</code> <code>AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None</code> <p>client credentials. Same definition as for OAuth2Client</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>the Client ID. Same definition as for OAuth2Client</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>the Client Secret. Same definition as for OAuth2Client</p> <code>None</code> <code>private_jwk</code> <code>Any | None</code> <p>the private key to use for client authentication. Same definition as for OAuth2Client</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>requests session. Same definition as for OAuth2Client</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs to pass to the ApiClient base class</p> <code>{}</code> Example <pre><code>from requests_oauth2client.vendor_specific import Auth0\n\na0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\nusers = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n</code></pre> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef management_api_client(\n    cls,\n    tenant: str,\n    auth: (\n        requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n    ) = None,\n    *,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any | None = None,\n    session: requests.Session | None = None,\n    **kwargs: Any,\n) -&gt; ApiClient:\n    \"\"\"Initialize a client for the Auth0 Management API.\n\n    See [Auth0 Management API v2](https://auth0.com/docs/api/management/v2). You must provide the\n    target tenant name and the credentials for a client that is allowed access to the Management\n    API.\n\n    Args:\n        tenant: the tenant name.\n            Same definition as for [Auth0.client][requests_oauth2client.vendor_specific.auth0.Auth0.client]\n        auth: client credentials.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        client_id: the Client ID.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        client_secret: the Client Secret.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        private_jwk: the private key to use for client authentication.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        session: requests session.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        **kwargs: additional kwargs to pass to the ApiClient base class\n\n    Example:\n        ```python\n        from requests_oauth2client.vendor_specific import Auth0\n\n        a0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\n        users = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n        ```\n\n    \"\"\"\n    tenant = cls.tenant(tenant)\n    client = cls.client(\n        tenant,\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n    )\n    audience = f\"https://{tenant}/api/v2/\"\n    api_auth = OAuth2ClientCredentialsAuth(client, audience=audience)\n    return ApiClient(\n        base_url=audience,\n        auth=api_auth,\n        session=session,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.Ping","title":"<code>Ping</code>","text":"<p>Ping Identity related utilities.</p> Source code in <code>requests_oauth2client/vendor_specific/ping.py</code> <pre><code>class Ping:\n    \"\"\"Ping Identity related utilities.\"\"\"\n\n    @classmethod\n    def client(\n        cls,\n        issuer: str,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any = None,\n        session: requests.Session | None = None,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an OAuth2Client for PingFederate.\n\n        This will configure all endpoints with PingID specific urls, without using the metadata.\n        Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage\n        over using `OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")`.\n\n        \"\"\"\n        if not issuer.startswith(\"https://\"):\n            if \"://\" in issuer:\n                msg = \"Invalid issuer. It must be an https:// url or a domain name without a scheme.\"\n                raise ValueError(msg)\n            issuer = f\"https://{issuer}\"\n        if \".\" not in issuer:\n            msg = \"Invalid issuer. It must contain at least a dot in the domain name.\"\n            raise ValueError(msg)\n\n        return OAuth2Client(\n            authorization_endpoint=f\"{issuer}/as/authorization.oauth2\",\n            token_endpoint=f\"{issuer}/as/token.oauth2\",\n            revocation_endpoint=f\"{issuer}/as/revoke_token.oauth2\",\n            userinfo_endpoint=f\"{issuer}/idp/userinfo.openid\",\n            introspection_endpoint=f\"{issuer}/as/introspect.oauth2\",\n            jwks_uri=f\"{issuer}/pf/JWKS\",\n            registration_endpoint=f\"{issuer}/as/clients.oauth2\",\n            ping_revoked_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/revokedSris\",\n            ping_session_management_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/sessions\",\n            ping_session_management_users_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/users\",\n            ping_end_session_endpoint=f\"{issuer}/idp/startSLO.ping\",\n            device_authorization_endpoint=f\"{issuer}/as/device_authz.oauth2\",\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.Ping.client","title":"<code>client(issuer, auth=None, client_id=None, client_secret=None, private_jwk=None, session=None)</code>  <code>classmethod</code>","text":"<p>Initialize an OAuth2Client for PingFederate.</p> <p>This will configure all endpoints with PingID specific urls, without using the metadata. Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage over using <code>OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")</code>.</p> Source code in <code>requests_oauth2client/vendor_specific/ping.py</code> <pre><code>@classmethod\ndef client(\n    cls,\n    issuer: str,\n    auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any = None,\n    session: requests.Session | None = None,\n) -&gt; OAuth2Client:\n    \"\"\"Initialize an OAuth2Client for PingFederate.\n\n    This will configure all endpoints with PingID specific urls, without using the metadata.\n    Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage\n    over using `OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")`.\n\n    \"\"\"\n    if not issuer.startswith(\"https://\"):\n        if \"://\" in issuer:\n            msg = \"Invalid issuer. It must be an https:// url or a domain name without a scheme.\"\n            raise ValueError(msg)\n        issuer = f\"https://{issuer}\"\n    if \".\" not in issuer:\n        msg = \"Invalid issuer. It must contain at least a dot in the domain name.\"\n        raise ValueError(msg)\n\n    return OAuth2Client(\n        authorization_endpoint=f\"{issuer}/as/authorization.oauth2\",\n        token_endpoint=f\"{issuer}/as/token.oauth2\",\n        revocation_endpoint=f\"{issuer}/as/revoke_token.oauth2\",\n        userinfo_endpoint=f\"{issuer}/idp/userinfo.openid\",\n        introspection_endpoint=f\"{issuer}/as/introspect.oauth2\",\n        jwks_uri=f\"{issuer}/pf/JWKS\",\n        registration_endpoint=f\"{issuer}/as/clients.oauth2\",\n        ping_revoked_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/revokedSris\",\n        ping_session_management_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/sessions\",\n        ping_session_management_users_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/users\",\n        ping_end_session_endpoint=f\"{issuer}/idp/startSLO.ping\",\n        device_authorization_endpoint=f\"{issuer}/as/device_authz.oauth2\",\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0","title":"<code>auth0</code>","text":"<p>Implements subclasses for Auth0.</p>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0","title":"<code>Auth0</code>","text":"<p>Auth0-related utilities.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>class Auth0:\n    \"\"\"Auth0-related utilities.\"\"\"\n\n    @classmethod\n    def tenant(cls, tenant: str) -&gt; str:\n        \"\"\"Given a short tenant name, returns the full tenant FQDN.\"\"\"\n        if not tenant:\n            msg = \"You must specify a tenant name.\"\n            raise ValueError(msg)\n        if \".\" not in tenant or tenant.endswith((\".eu\", \".us\", \".au\", \".jp\")):\n            tenant = f\"{tenant}.auth0.com\"\n        if \"://\" in tenant:\n            if tenant.startswith(\"https://\"):\n                return tenant[8:]\n            msg = (\n                \"Invalid tenant name. \"\n                \"It must be a tenant name like 'mytenant.myregion' \"\n                \"or a full FQDN like 'mytenant.myregion.auth0.com'.\"\n                \"or an issuer like 'https://mytenant.myregion.auth0.com'\"\n            )\n            raise ValueError(msg)\n        return tenant\n\n    @classmethod\n    def client(\n        cls,\n        tenant: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any | None = None,\n        session: requests.Session | None = None,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialise an OAuth2Client for an Auth0 tenant.\"\"\"\n        tenant = cls.tenant(tenant)\n        issuer = f\"https://{tenant}\"\n        token_endpoint = f\"{issuer}/oauth/token\"\n        authorization_endpoint = f\"{issuer}/authorize\"\n        revocation_endpoint = f\"{issuer}/oauth/revoke\"\n        userinfo_endpoint = f\"{issuer}/userinfo\"\n        jwks_uri = f\"{issuer}/.well-known/jwks.json\"\n\n        return OAuth2Client(\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            issuer=issuer,\n            jwks_uri=jwks_uri,\n            **kwargs,\n        )\n\n    @classmethod\n    def management_api_client(\n        cls,\n        tenant: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any | None = None,\n        session: requests.Session | None = None,\n        **kwargs: Any,\n    ) -&gt; ApiClient:\n        \"\"\"Initialize a client for the Auth0 Management API.\n\n        See [Auth0 Management API v2](https://auth0.com/docs/api/management/v2). You must provide the\n        target tenant name and the credentials for a client that is allowed access to the Management\n        API.\n\n        Args:\n            tenant: the tenant name.\n                Same definition as for [Auth0.client][requests_oauth2client.vendor_specific.auth0.Auth0.client]\n            auth: client credentials.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            client_id: the Client ID.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            client_secret: the Client Secret.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            private_jwk: the private key to use for client authentication.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            session: requests session.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            **kwargs: additional kwargs to pass to the ApiClient base class\n\n        Example:\n            ```python\n            from requests_oauth2client.vendor_specific import Auth0\n\n            a0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\n            users = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n            ```\n\n        \"\"\"\n        tenant = cls.tenant(tenant)\n        client = cls.client(\n            tenant,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n        )\n        audience = f\"https://{tenant}/api/v2/\"\n        api_auth = OAuth2ClientCredentialsAuth(client, audience=audience)\n        return ApiClient(\n            base_url=audience,\n            auth=api_auth,\n            session=session,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0.tenant","title":"<code>tenant(tenant)</code>  <code>classmethod</code>","text":"<p>Given a short tenant name, returns the full tenant FQDN.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef tenant(cls, tenant: str) -&gt; str:\n    \"\"\"Given a short tenant name, returns the full tenant FQDN.\"\"\"\n    if not tenant:\n        msg = \"You must specify a tenant name.\"\n        raise ValueError(msg)\n    if \".\" not in tenant or tenant.endswith((\".eu\", \".us\", \".au\", \".jp\")):\n        tenant = f\"{tenant}.auth0.com\"\n    if \"://\" in tenant:\n        if tenant.startswith(\"https://\"):\n            return tenant[8:]\n        msg = (\n            \"Invalid tenant name. \"\n            \"It must be a tenant name like 'mytenant.myregion' \"\n            \"or a full FQDN like 'mytenant.myregion.auth0.com'.\"\n            \"or an issuer like 'https://mytenant.myregion.auth0.com'\"\n        )\n        raise ValueError(msg)\n    return tenant\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0.client","title":"<code>client(tenant, auth=None, *, client_id=None, client_secret=None, private_jwk=None, session=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialise an OAuth2Client for an Auth0 tenant.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef client(\n    cls,\n    tenant: str,\n    auth: (\n        requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n    ) = None,\n    *,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any | None = None,\n    session: requests.Session | None = None,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n    \"\"\"Initialise an OAuth2Client for an Auth0 tenant.\"\"\"\n    tenant = cls.tenant(tenant)\n    issuer = f\"https://{tenant}\"\n    token_endpoint = f\"{issuer}/oauth/token\"\n    authorization_endpoint = f\"{issuer}/authorize\"\n    revocation_endpoint = f\"{issuer}/oauth/revoke\"\n    userinfo_endpoint = f\"{issuer}/userinfo\"\n    jwks_uri = f\"{issuer}/.well-known/jwks.json\"\n\n    return OAuth2Client(\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n        token_endpoint=token_endpoint,\n        authorization_endpoint=authorization_endpoint,\n        revocation_endpoint=revocation_endpoint,\n        userinfo_endpoint=userinfo_endpoint,\n        issuer=issuer,\n        jwks_uri=jwks_uri,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0.management_api_client","title":"<code>management_api_client(tenant, auth=None, *, client_id=None, client_secret=None, private_jwk=None, session=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize a client for the Auth0 Management API.</p> <p>See Auth0 Management API v2. You must provide the target tenant name and the credentials for a client that is allowed access to the Management API.</p> <p>Parameters:</p> Name Type Description Default <code>tenant</code> <code>str</code> <p>the tenant name. Same definition as for Auth0.client</p> required <code>auth</code> <code>AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None</code> <p>client credentials. Same definition as for OAuth2Client</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>the Client ID. Same definition as for OAuth2Client</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>the Client Secret. Same definition as for OAuth2Client</p> <code>None</code> <code>private_jwk</code> <code>Any | None</code> <p>the private key to use for client authentication. Same definition as for OAuth2Client</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>requests session. Same definition as for OAuth2Client</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs to pass to the ApiClient base class</p> <code>{}</code> Example <pre><code>from requests_oauth2client.vendor_specific import Auth0\n\na0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\nusers = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n</code></pre> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef management_api_client(\n    cls,\n    tenant: str,\n    auth: (\n        requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n    ) = None,\n    *,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any | None = None,\n    session: requests.Session | None = None,\n    **kwargs: Any,\n) -&gt; ApiClient:\n    \"\"\"Initialize a client for the Auth0 Management API.\n\n    See [Auth0 Management API v2](https://auth0.com/docs/api/management/v2). You must provide the\n    target tenant name and the credentials for a client that is allowed access to the Management\n    API.\n\n    Args:\n        tenant: the tenant name.\n            Same definition as for [Auth0.client][requests_oauth2client.vendor_specific.auth0.Auth0.client]\n        auth: client credentials.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        client_id: the Client ID.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        client_secret: the Client Secret.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        private_jwk: the private key to use for client authentication.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        session: requests session.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        **kwargs: additional kwargs to pass to the ApiClient base class\n\n    Example:\n        ```python\n        from requests_oauth2client.vendor_specific import Auth0\n\n        a0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\n        users = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n        ```\n\n    \"\"\"\n    tenant = cls.tenant(tenant)\n    client = cls.client(\n        tenant,\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n    )\n    audience = f\"https://{tenant}/api/v2/\"\n    api_auth = OAuth2ClientCredentialsAuth(client, audience=audience)\n    return ApiClient(\n        base_url=audience,\n        auth=api_auth,\n        session=session,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.ping","title":"<code>ping</code>","text":"<p>PingID specific client.</p>"},{"location":"api/#requests_oauth2client.vendor_specific.ping.Ping","title":"<code>Ping</code>","text":"<p>Ping Identity related utilities.</p> Source code in <code>requests_oauth2client/vendor_specific/ping.py</code> <pre><code>class Ping:\n    \"\"\"Ping Identity related utilities.\"\"\"\n\n    @classmethod\n    def client(\n        cls,\n        issuer: str,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any = None,\n        session: requests.Session | None = None,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an OAuth2Client for PingFederate.\n\n        This will configure all endpoints with PingID specific urls, without using the metadata.\n        Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage\n        over using `OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")`.\n\n        \"\"\"\n        if not issuer.startswith(\"https://\"):\n            if \"://\" in issuer:\n                msg = \"Invalid issuer. It must be an https:// url or a domain name without a scheme.\"\n                raise ValueError(msg)\n            issuer = f\"https://{issuer}\"\n        if \".\" not in issuer:\n            msg = \"Invalid issuer. It must contain at least a dot in the domain name.\"\n            raise ValueError(msg)\n\n        return OAuth2Client(\n            authorization_endpoint=f\"{issuer}/as/authorization.oauth2\",\n            token_endpoint=f\"{issuer}/as/token.oauth2\",\n            revocation_endpoint=f\"{issuer}/as/revoke_token.oauth2\",\n            userinfo_endpoint=f\"{issuer}/idp/userinfo.openid\",\n            introspection_endpoint=f\"{issuer}/as/introspect.oauth2\",\n            jwks_uri=f\"{issuer}/pf/JWKS\",\n            registration_endpoint=f\"{issuer}/as/clients.oauth2\",\n            ping_revoked_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/revokedSris\",\n            ping_session_management_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/sessions\",\n            ping_session_management_users_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/users\",\n            ping_end_session_endpoint=f\"{issuer}/idp/startSLO.ping\",\n            device_authorization_endpoint=f\"{issuer}/as/device_authz.oauth2\",\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.ping.Ping.client","title":"<code>client(issuer, auth=None, client_id=None, client_secret=None, private_jwk=None, session=None)</code>  <code>classmethod</code>","text":"<p>Initialize an OAuth2Client for PingFederate.</p> <p>This will configure all endpoints with PingID specific urls, without using the metadata. Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage over using <code>OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")</code>.</p> Source code in <code>requests_oauth2client/vendor_specific/ping.py</code> <pre><code>@classmethod\ndef client(\n    cls,\n    issuer: str,\n    auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any = None,\n    session: requests.Session | None = None,\n) -&gt; OAuth2Client:\n    \"\"\"Initialize an OAuth2Client for PingFederate.\n\n    This will configure all endpoints with PingID specific urls, without using the metadata.\n    Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage\n    over using `OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")`.\n\n    \"\"\"\n    if not issuer.startswith(\"https://\"):\n        if \"://\" in issuer:\n            msg = \"Invalid issuer. It must be an https:// url or a domain name without a scheme.\"\n            raise ValueError(msg)\n        issuer = f\"https://{issuer}\"\n    if \".\" not in issuer:\n        msg = \"Invalid issuer. It must contain at least a dot in the domain name.\"\n        raise ValueError(msg)\n\n    return OAuth2Client(\n        authorization_endpoint=f\"{issuer}/as/authorization.oauth2\",\n        token_endpoint=f\"{issuer}/as/token.oauth2\",\n        revocation_endpoint=f\"{issuer}/as/revoke_token.oauth2\",\n        userinfo_endpoint=f\"{issuer}/idp/userinfo.openid\",\n        introspection_endpoint=f\"{issuer}/as/introspect.oauth2\",\n        jwks_uri=f\"{issuer}/pf/JWKS\",\n        registration_endpoint=f\"{issuer}/as/clients.oauth2\",\n        ping_revoked_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/revokedSris\",\n        ping_session_management_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/sessions\",\n        ping_session_management_users_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/users\",\n        ping_end_session_endpoint=f\"{issuer}/idp/startSLO.ping\",\n        device_authorization_endpoint=f\"{issuer}/as/device_authz.oauth2\",\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n    )\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/guillp/requests_oauth2client/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Detailed steps to reproduce the bug.</li> <li>Full error message whenever there is one</li> <li>Your Python version, operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p><code>requests_oauth2client</code> could always use more documentation, whether as part of the official requests_oauth2client docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/guillp/requests_oauth2client/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>requests_oauth2client</code> for local development.</p> <ol> <li>Fork the <code>requests_oauth2client</code> repo on GitHub.</li> <li>Clone your fork locally</li> </ol> <pre><code>$ git clone git@github.com:your_name_here/requests_oauth2client.git\n</code></pre> <ol> <li>Ensure poetry is installed.</li> <li>Install dependencies and start your virtualenv:</li> </ol> <pre><code>$ poetry install -E test -E doc -E dev\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</li> </ol> <pre><code>$ tox\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check    https://github.com/guillp/requests_oauth2client/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<pre><code>$ pytest tests.test_client_credentials\n</code></pre> <p>To run a subset of tests.</p>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run:</p> <pre><code>$ poetry patch # possible: major / minor / patch\n$ git push\n$ git push --tags\n</code></pre> <p>Travis will then deploy to PyPI if tests pass.</p>"},{"location":"history/","title":"History","text":""},{"location":"history/#history","title":"History","text":""},{"location":"history/#12","title":"1.2","text":"<ul> <li><code>OAuth2AuthorizationCodeAuth</code> now accepts an AuthorizationResponse</li> <li><code>AuthorizationRequest</code> now handles <code>nonce</code> and <code>acr_values</code></li> <li><code>OAuth2Client</code> accepts <code>authorization_endpoint</code> and <code>redirect_uri</code> at init time, and has a <code>authorization_request()</code> method to generate AuthorizationRequests</li> <li><code>BearerToken</code> has a <code>validate_id_token()</code> method to handle ID Token validation has specified in OIDC</li> <li>Added <code>PingClient</code> for PingFederate by PingID</li> </ul>"},{"location":"history/#11","title":"1.1","text":"<ul> <li>ApiClient now has <code>allow_redirects=False</code> by default</li> <li>OAuth2Client now has <code>extra_metadata</code></li> <li>bugfixes, optimizations, introduce methods for easier subclassing</li> </ul>"},{"location":"history/#100","title":"1.0.0","text":"<ul> <li>First properly documented version.</li> <li>Migrated from pipenv to poetry</li> <li>Added pre-commit checks</li> <li><code>requests</code> is now automatically imported with <code>from requests_oauth2client import *</code></li> <li>ApiClient is now a wrapper around <code>requests.Session</code> instead of a subclass</li> <li><code>ApiClient.__init__()</code> now accepts extra kwargs which will be used to configure the <code>Session</code>.</li> <li>Add <code>__getitem__</code> and <code>__getattr_</code> to ApiClient</li> <li><code>AuthorizationRequest.validate_callback()</code> now returns an <code>AuthorizationResponse</code> which contains all returned   response attributes instead of just a code. To access the authorization code, get the <code>code</code> attribute from that response.</li> <li><code>OAuth2Client.authorization_code()</code> now accepts an <code>AuthorizationResponse</code> as parameter, and will   use it to include all necessary parameters for the Authorization Code Grant.</li> <li>removed <code>OAuth2Client.authorization_code_pkce()</code></li> <li>Renamed <code>ClientSecretJWT</code> and <code>PrivateKeyJWT</code> to <code>ClientSecretJwt</code> and <code>PrivateKeyJwt</code>, for consistency with <code>jwskate</code>.</li> <li>Methods from <code>requests_oauth2client.utils</code> are no longer exposed in top-level module.</li> <li>Renamed base class <code>ClientAuthenticationMethod</code> to <code>BaseClientAuthenticationMethod</code>.</li> <li>Introduced a default timeout in <code>ApiClient</code></li> <li>Splitted <code>jwskate</code> into its own independant module</li> <li>Use <code>BinaPy</code> for binary data manipulation</li> <li>Add support for Pushed Authorization Requests</li> </ul>"},{"location":"history/#-018","title":"\\&lt;= 0.18","text":"<ul> <li>Draft versions</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install requests_oauth2client, run this command in your terminal:</p> <pre><code>$ pip install requests_oauth2client\n</code></pre> <p>This is the preferred method to install requests_oauth2client, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for requests_oauth2client can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>$ git clone git://github.com/guillp/requests_oauth2client\n</code></pre> <p>Or download the tarball:</p> <pre><code>$ curl -OJL https://github.com/guillp/requests_oauth2client/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>$ pip install .\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#usage","title":"Usage","text":"<p>To use requests_oauth2client in a project</p> <pre><code>from requests_oauth2client import *\n</code></pre>"}]}